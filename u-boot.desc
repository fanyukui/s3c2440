
u-boot:     file format elf32-littlearm


Disassembly of section .text:

33d00000 <_start>:
 *************************************************************************
 */


.globl _start
_start:	b       reset
33d00000:	ea000016 	b	33d00060 <reset>
	ldr	pc, _undefined_instruction
33d00004:	e59ff014 	ldr	pc, [pc, #20]	; 33d00020 <_undefined_instruction>
	ldr	pc, _software_interrupt
33d00008:	e59ff014 	ldr	pc, [pc, #20]	; 33d00024 <_software_interrupt>
	ldr	pc, _prefetch_abort
33d0000c:	e59ff014 	ldr	pc, [pc, #20]	; 33d00028 <_prefetch_abort>
	ldr	pc, _data_abort
33d00010:	e59ff014 	ldr	pc, [pc, #20]	; 33d0002c <_data_abort>
	ldr	pc, _not_used
33d00014:	e59ff014 	ldr	pc, [pc, #20]	; 33d00030 <_not_used>
	ldr	pc, _irq
33d00018:	e59ff014 	ldr	pc, [pc, #20]	; 33d00034 <_irq>
	ldr	pc, _fiq
33d0001c:	e59ff014 	ldr	pc, [pc, #20]	; 33d00038 <_fiq>

33d00020 <_undefined_instruction>:
33d00020:	33d00140 	.word	0x33d00140

33d00024 <_software_interrupt>:
33d00024:	33d001a0 	.word	0x33d001a0

33d00028 <_prefetch_abort>:
33d00028:	33d00200 	.word	0x33d00200

33d0002c <_data_abort>:
33d0002c:	33d00260 	.word	0x33d00260

33d00030 <_not_used>:
33d00030:	33d002c0 	.word	0x33d002c0

33d00034 <_irq>:
33d00034:	33d003e0 	.word	0x33d003e0

33d00038 <_fiq>:
33d00038:	33d00400 	.word	0x33d00400
33d0003c:	deadbeef 	.word	0xdeadbeef

33d00040 <_TEXT_BASE>:
33d00040:	33d00000 	.word	0x33d00000

33d00044 <_armboot_start>:
33d00044:	33d00000 	.word	0x33d00000

33d00048 <_bss_start>:
33d00048:	33d37178 	.word	0x33d37178

33d0004c <_bss_end>:
33d0004c:	33d62f58 	.word	0x33d62f58

33d00050 <FREE_RAM_END>:
33d00050:	0badc0de 	.word	0x0badc0de

33d00054 <FREE_RAM_SIZE>:
33d00054:	0badc0de 	.word	0x0badc0de

33d00058 <IRQ_STACK_START>:
33d00058:	0badc0de 	.word	0x0badc0de

33d0005c <FIQ_STACK_START>:
33d0005c:	0badc0de 	.word	0x0badc0de

33d00060 <reset>:

reset:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
33d00060:	e10f0000 	mrs	r0, CPSR
	bic	r0,r0,#0x1f
33d00064:	e3c0001f 	bic	r0, r0, #31	; 0x1f
	orr	r0,r0,#0xd3
33d00068:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
33d0006c:	e129f000 	msr	CPSR_fc, r0
# define INTSUBMSK	0x4A00001C
# define CLKDIVN	0x4C000014	/* clock divisor register */
#endif

#if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
	ldr     r0, =pWTCON
33d00070:	e3a00453 	mov	r0, #1392508928	; 0x53000000
	mov     r1, #0x0
33d00074:	e3a01000 	mov	r1, #0	; 0x0
	str     r1, [r0]
33d00078:	e5801000 	str	r1, [r0]

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
33d0007c:	e3e01000 	mvn	r1, #0	; 0x0
	ldr	r0, =INTMSK
33d00080:	e59f03b8 	ldr	r0, [pc, #952]	; 33d00440 <fiq+0x40>
	str	r1, [r0]
33d00084:	e5801000 	str	r1, [r0]
# if defined(CONFIG_S3C2410)
	ldr	r1, =0x3ff
	ldr	r0, =INTSUBMSK
	str	r1, [r0]
# elif defined(CONFIG_S3C2440)
	ldr	r1, =0x7fff
33d00088:	e59f13b4 	ldr	r1, [pc, #948]	; 33d00444 <fiq+0x44>
	ldr	r0, =INTSUBMSK
33d0008c:	e59f03b4 	ldr	r0, [pc, #948]	; 33d00448 <fiq+0x48>
	str	r1, [r0]
33d00090:	e5801000 	str	r1, [r0]
	/*
	 * we do sys-critical inits only at reboot,
	 * not when booting from ram!
	 */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_crit
33d00094:	eb000016 	bl	33d000f4 <cpu_init_crit>

33d00098 <stack_setup>:
#endif

	/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
33d00098:	e51f0060 	ldr	r0, [pc, #-96]	; 33d00040 <_TEXT_BASE>
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
33d0009c:	e2400701 	sub	r0, r0, #262144	; 0x40000
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
33d000a0:	e2400080 	sub	r0, r0, #128	; 0x80

#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
33d000a4:	e2400a02 	sub	r0, r0, #8192	; 0x2000
#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
33d000a8:	e240d00c 	sub	sp, r0, #12	; 0xc

	bl clock_init
33d000ac:	eb000237 	bl	33d00990 <clock_init>

33d000b0 <relocate>:

#ifndef CONFIG_SKIP_RELOCATE_UBOOT
relocate:				/* relocate U-Boot to RAM	    */
	adr	r0, _start		/* r0 <- current position of code   */
33d000b0:	e24f00b8 	sub	r0, pc, #184	; 0xb8
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
33d000b4:	e51f107c 	ldr	r1, [pc, #-124]	; 33d00040 <_TEXT_BASE>
	cmp     r0, r1                  /* don't reloc during debug         */
33d000b8:	e1500001 	cmp	r0, r1
	beq     clear_bss
33d000bc:	0a000003 	beq	33d000d0 <clear_bss>

	ldr	r2, _armboot_start
33d000c0:	e51f2084 	ldr	r2, [pc, #-132]	; 33d00044 <_armboot_start>
	ldr	r3, _bss_start
33d000c4:	e51f3084 	ldr	r3, [pc, #-132]	; 33d00048 <_bss_start>
	sub	r2, r3, r2		/* r2 <- size of armboot            */
33d000c8:	e0432002 	sub	r2, r3, r2
#if 1
	bl  CopyCode2Ram		/* r0: source, r1: dest, r2: size */
33d000cc:	eb00020a 	bl	33d008fc <CopyCode2Ram>

33d000d0 <clear_bss>:
	ble	copy_loop
#endif
#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */

clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment        */
33d000d0:	e51f0090 	ldr	r0, [pc, #-144]	; 33d00048 <_bss_start>
	ldr	r1, _bss_end		/* stop here                        */
33d000d4:	e51f1090 	ldr	r1, [pc, #-144]	; 33d0004c <_bss_end>
	mov 	r2, #0x00000000		/* clear                            */
33d000d8:	e3a02000 	mov	r2, #0	; 0x0

33d000dc <clbss_l>:

clbss_l:str	r2, [r0]		/* clear loop...                    */
33d000dc:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
33d000e0:	e2800004 	add	r0, r0, #4	; 0x4
	cmp	r0, r1
33d000e4:	e1500001 	cmp	r0, r1
	ble	clbss_l
33d000e8:	dafffffb 	ble	33d000dc <clbss_l>
	mov	r1, #3
	str	r1, [r0]
	/* END stuff after relocation */
#endif

	ldr	pc, _start_armboot
33d000ec:	e51ff004 	ldr	pc, [pc, #-4]	; 33d000f0 <_start_armboot>

33d000f0 <_start_armboot>:
33d000f0:	33d01534 	.word	0x33d01534

33d000f4 <cpu_init_crit>:
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
cpu_init_crit:
	/*
	 * flush v4 I/D caches
	 */
	mov	r0, #0
33d000f4:	e3a00000 	mov	r0, #0	; 0x0
	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
33d000f8:	ee070f17 	mcr	15, 0, r0, cr7, cr7, {0}
	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
33d000fc:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
33d00100:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
33d00104:	e3c00c23 	bic	r0, r0, #8960	; 0x2300
	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
33d00108:	e3c00087 	bic	r0, r0, #135	; 0x87
	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
33d0010c:	e3800002 	orr	r0, r0, #2	; 0x2
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
33d00110:	e3800a01 	orr	r0, r0, #4096	; 0x1000
	mcr	p15, 0, r0, c1, c0, 0
33d00114:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	/*
	 * before relocating, we have to setup RAM timing
	 * because memory timing is board-dependend, you will
	 * find a lowlevel_init.S in your board directory.
	 */
	mov	ip, lr
33d00118:	e1a0c00e 	mov	ip, lr
	bl	lowlevel_init
33d0011c:	eb000231 	bl	33d009e8 <lowlevel_init>
	mov	lr, ip
33d00120:	e1a0e00c 	mov	lr, ip
	mov	pc, lr
33d00124:	e1a0f00e 	mov	pc, lr
	...

33d00140 <undefined_instruction>:
/*
 * exception handlers
 */
	.align  5
undefined_instruction:
	get_bad_stack
33d00140:	e51fd104 	ldr	sp, [pc, #-260]	; 33d00044 <_armboot_start>
33d00144:	e24dd806 	sub	sp, sp, #393216	; 0x60000
33d00148:	e24dd088 	sub	sp, sp, #136	; 0x88
33d0014c:	e58de000 	str	lr, [sp]
33d00150:	e14fe000 	mrs	lr, SPSR
33d00154:	e58de004 	str	lr, [sp, #4]
33d00158:	e3a0d013 	mov	sp, #19	; 0x13
33d0015c:	e169f00d 	msr	SPSR_fc, sp
33d00160:	e1a0e00f 	mov	lr, pc
33d00164:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
33d00168:	e24dd048 	sub	sp, sp, #72	; 0x48
33d0016c:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
33d00170:	e51f2134 	ldr	r2, [pc, #-308]	; 33d00044 <_armboot_start>
33d00174:	e2422806 	sub	r2, r2, #393216	; 0x60000
33d00178:	e2422088 	sub	r2, r2, #136	; 0x88
33d0017c:	e892000c 	ldm	r2, {r2, r3}
33d00180:	e28d0048 	add	r0, sp, #72	; 0x48
33d00184:	e28d5034 	add	r5, sp, #52	; 0x34
33d00188:	e1a0100e 	mov	r1, lr
33d0018c:	e885000f 	stm	r5, {r0, r1, r2, r3}
33d00190:	e1a0000d 	mov	r0, sp
	bl 	do_undefined_instruction
33d00194:	eb00028c 	bl	33d00bcc <do_undefined_instruction>
	...

33d001a0 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack
33d001a0:	e51fd164 	ldr	sp, [pc, #-356]	; 33d00044 <_armboot_start>
33d001a4:	e24dd806 	sub	sp, sp, #393216	; 0x60000
33d001a8:	e24dd088 	sub	sp, sp, #136	; 0x88
33d001ac:	e58de000 	str	lr, [sp]
33d001b0:	e14fe000 	mrs	lr, SPSR
33d001b4:	e58de004 	str	lr, [sp, #4]
33d001b8:	e3a0d013 	mov	sp, #19	; 0x13
33d001bc:	e169f00d 	msr	SPSR_fc, sp
33d001c0:	e1a0e00f 	mov	lr, pc
33d001c4:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
33d001c8:	e24dd048 	sub	sp, sp, #72	; 0x48
33d001cc:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
33d001d0:	e51f2194 	ldr	r2, [pc, #-404]	; 33d00044 <_armboot_start>
33d001d4:	e2422806 	sub	r2, r2, #393216	; 0x60000
33d001d8:	e2422088 	sub	r2, r2, #136	; 0x88
33d001dc:	e892000c 	ldm	r2, {r2, r3}
33d001e0:	e28d0048 	add	r0, sp, #72	; 0x48
33d001e4:	e28d5034 	add	r5, sp, #52	; 0x34
33d001e8:	e1a0100e 	mov	r1, lr
33d001ec:	e885000f 	stm	r5, {r0, r1, r2, r3}
33d001f0:	e1a0000d 	mov	r0, sp
	bl 	do_software_interrupt
33d001f4:	eb00027d 	bl	33d00bf0 <do_software_interrupt>
	...

33d00200 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
33d00200:	e51fd1c4 	ldr	sp, [pc, #-452]	; 33d00044 <_armboot_start>
33d00204:	e24dd806 	sub	sp, sp, #393216	; 0x60000
33d00208:	e24dd088 	sub	sp, sp, #136	; 0x88
33d0020c:	e58de000 	str	lr, [sp]
33d00210:	e14fe000 	mrs	lr, SPSR
33d00214:	e58de004 	str	lr, [sp, #4]
33d00218:	e3a0d013 	mov	sp, #19	; 0x13
33d0021c:	e169f00d 	msr	SPSR_fc, sp
33d00220:	e1a0e00f 	mov	lr, pc
33d00224:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
33d00228:	e24dd048 	sub	sp, sp, #72	; 0x48
33d0022c:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
33d00230:	e51f21f4 	ldr	r2, [pc, #-500]	; 33d00044 <_armboot_start>
33d00234:	e2422806 	sub	r2, r2, #393216	; 0x60000
33d00238:	e2422088 	sub	r2, r2, #136	; 0x88
33d0023c:	e892000c 	ldm	r2, {r2, r3}
33d00240:	e28d0048 	add	r0, sp, #72	; 0x48
33d00244:	e28d5034 	add	r5, sp, #52	; 0x34
33d00248:	e1a0100e 	mov	r1, lr
33d0024c:	e885000f 	stm	r5, {r0, r1, r2, r3}
33d00250:	e1a0000d 	mov	r0, sp
	bl 	do_prefetch_abort
33d00254:	eb00026e 	bl	33d00c14 <do_prefetch_abort>
	...

33d00260 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
33d00260:	e51fd224 	ldr	sp, [pc, #-548]	; 33d00044 <_armboot_start>
33d00264:	e24dd806 	sub	sp, sp, #393216	; 0x60000
33d00268:	e24dd088 	sub	sp, sp, #136	; 0x88
33d0026c:	e58de000 	str	lr, [sp]
33d00270:	e14fe000 	mrs	lr, SPSR
33d00274:	e58de004 	str	lr, [sp, #4]
33d00278:	e3a0d013 	mov	sp, #19	; 0x13
33d0027c:	e169f00d 	msr	SPSR_fc, sp
33d00280:	e1a0e00f 	mov	lr, pc
33d00284:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
33d00288:	e24dd048 	sub	sp, sp, #72	; 0x48
33d0028c:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
33d00290:	e51f2254 	ldr	r2, [pc, #-596]	; 33d00044 <_armboot_start>
33d00294:	e2422806 	sub	r2, r2, #393216	; 0x60000
33d00298:	e2422088 	sub	r2, r2, #136	; 0x88
33d0029c:	e892000c 	ldm	r2, {r2, r3}
33d002a0:	e28d0048 	add	r0, sp, #72	; 0x48
33d002a4:	e28d5034 	add	r5, sp, #52	; 0x34
33d002a8:	e1a0100e 	mov	r1, lr
33d002ac:	e885000f 	stm	r5, {r0, r1, r2, r3}
33d002b0:	e1a0000d 	mov	r0, sp
	bl 	do_data_abort
33d002b4:	eb00025f 	bl	33d00c38 <do_data_abort>
	...

33d002c0 <not_used>:

	.align	5
not_used:
	get_bad_stack
33d002c0:	e51fd284 	ldr	sp, [pc, #-644]	; 33d00044 <_armboot_start>
33d002c4:	e24dd806 	sub	sp, sp, #393216	; 0x60000
33d002c8:	e24dd088 	sub	sp, sp, #136	; 0x88
33d002cc:	e58de000 	str	lr, [sp]
33d002d0:	e14fe000 	mrs	lr, SPSR
33d002d4:	e58de004 	str	lr, [sp, #4]
33d002d8:	e3a0d013 	mov	sp, #19	; 0x13
33d002dc:	e169f00d 	msr	SPSR_fc, sp
33d002e0:	e1a0e00f 	mov	lr, pc
33d002e4:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
33d002e8:	e24dd048 	sub	sp, sp, #72	; 0x48
33d002ec:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
33d002f0:	e51f22b4 	ldr	r2, [pc, #-692]	; 33d00044 <_armboot_start>
33d002f4:	e2422806 	sub	r2, r2, #393216	; 0x60000
33d002f8:	e2422088 	sub	r2, r2, #136	; 0x88
33d002fc:	e892000c 	ldm	r2, {r2, r3}
33d00300:	e28d0048 	add	r0, sp, #72	; 0x48
33d00304:	e28d5034 	add	r5, sp, #52	; 0x34
33d00308:	e1a0100e 	mov	r1, lr
33d0030c:	e885000f 	stm	r5, {r0, r1, r2, r3}
33d00310:	e1a0000d 	mov	r0, sp
	bl 	do_not_used
33d00314:	eb000250 	bl	33d00c5c <do_not_used>
	...

33d00320 <Launch>:

@ HJ
.globl Launch
    .align	4
Launch:    
    mov r7, r0
33d00320:	e1a07000 	mov	r7, r0
    @ diable interrupt
	@ disable watch dog timer
	mov	r1, #0x53000000
33d00324:	e3a01453 	mov	r1, #1392508928	; 0x53000000
	mov	r2, #0x0
33d00328:	e3a02000 	mov	r2, #0	; 0x0
	str	r2, [r1]
33d0032c:	e5812000 	str	r2, [r1]

    ldr r1,=INTMSK
33d00330:	e59f1108 	ldr	r1, [pc, #264]	; 33d00440 <fiq+0x40>
    ldr r2,=0xffffffff  @ all interrupt disable
33d00334:	e3e02000 	mvn	r2, #0	; 0x0
    str r2,[r1]
33d00338:	e5812000 	str	r2, [r1]

    ldr r1,=INTSUBMSK
33d0033c:	e59f1104 	ldr	r1, [pc, #260]	; 33d00448 <fiq+0x48>
    ldr r2,=0x7ff       @ all sub interrupt disable
33d00340:	e59f2104 	ldr	r2, [pc, #260]	; 33d0044c <fiq+0x4c>
    str r2,[r1]
33d00344:	e5812000 	str	r2, [r1]

    ldr     r1, = INTMOD
33d00348:	e59f1100 	ldr	r1, [pc, #256]	; 33d00450 <fiq+0x50>
    mov r2, #0x0        @ set all interrupt as IRQ (not FIQ)
33d0034c:	e3a02000 	mov	r2, #0	; 0x0
    str     r2, [r1]
33d00350:	e5812000 	str	r2, [r1]

    @ 
	mov	ip, #0
33d00354:	e3a0c000 	mov	ip, #0	; 0x0
	mcr	p15, 0, ip, c13, c0, 0      @	/* zero PID */
33d00358:	ee0dcf10 	mcr	15, 0, ip, cr13, cr0, {0}
	mcr	p15, 0, ip, c7, c7, 0       @	/* invalidate I,D caches */
33d0035c:	ee07cf17 	mcr	15, 0, ip, cr7, cr7, {0}
	mcr	p15, 0, ip, c7, c10, 4      @	/* drain write buffer */
33d00360:	ee07cf9a 	mcr	15, 0, ip, cr7, cr10, {4}
	mcr	p15, 0, ip, c8, c7, 0       @	/* invalidate I,D TLBs */
33d00364:	ee08cf17 	mcr	15, 0, ip, cr8, cr7, {0}
	mrc	p15, 0, ip, c1, c0, 0       @	/* get control register */
33d00368:	ee11cf10 	mrc	15, 0, ip, cr1, cr0, {0}
	bic	ip, ip, #0x0001             @	/* disable MMU */
33d0036c:	e3ccc001 	bic	ip, ip, #1	; 0x1
	mcr	p15, 0, ip, c1, c0, 0       @	/* write control register */
33d00370:	ee01cf10 	mcr	15, 0, ip, cr1, cr0, {0}
#ifdef CONFIG_SURPORT_WINCE
    bl Wince_Port_Init
#endif

    @ clear SDRAM: the end of free mem(has wince on it now) to the end of SDRAM
    ldr     r3, FREE_RAM_END
33d00374:	e51f332c 	ldr	r3, [pc, #-812]	; 33d00050 <FREE_RAM_END>
    ldr     r4, =PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE    @ must clear all the memory unused to zero
33d00378:	e3a0430d 	mov	r4, #872415232	; 0x34000000
    mov     r5, #0
33d0037c:	e3a05000 	mov	r5, #0	; 0x0

    ldr     r1, _armboot_start
33d00380:	e51f1344 	ldr	r1, [pc, #-836]	; 33d00044 <_armboot_start>
    ldr     r2, =On_Steppingstone
33d00384:	e59f20c8 	ldr	r2, [pc, #200]	; 33d00454 <fiq+0x54>
    sub     r2, r2, r1
33d00388:	e0422001 	sub	r2, r2, r1
    mov     pc, r2
33d0038c:	e1a0f002 	mov	pc, r2

33d00390 <On_Steppingstone>:
On_Steppingstone:
2:  stmia   r3!, {r5}
33d00390:	e8a30020 	stmia	r3!, {r5}
    cmp     r3, r4
33d00394:	e1530004 	cmp	r3, r4
    bne     2b
33d00398:	1afffffc 	bne	33d00390 <On_Steppingstone>

    @ set sp = 0 on sys mode
    mov sp, #0
33d0039c:	e3a0d000 	mov	sp, #0	; 0x0

    @ add by HJ, switch to SVC mode
	msr	cpsr_c,	#0xdf	@ set the I-bit = 1, diable the IRQ interrupt
33d003a0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
	msr	cpsr_c,	#0xd3	@ set the I-bit = 1, diable the IRQ interrupt
33d003a4:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    ldr sp, =0x31ff5800	
33d003a8:	e59fd0a8 	ldr	sp, [pc, #168]	; 33d00458 <fiq+0x58>
    
    nop
33d003ac:	e1a00000 	nop			(mov r0,r0)
	nop
33d003b0:	e1a00000 	nop			(mov r0,r0)
    nop
33d003b4:	e1a00000 	nop			(mov r0,r0)
	nop
33d003b8:	e1a00000 	nop			(mov r0,r0)

	mov     pc, r7  @ Jump to PhysicalAddress
33d003bc:	e1a0f007 	mov	pc, r7
	nop
33d003c0:	e1a00000 	nop			(mov r0,r0)
    mov pc, lr
33d003c4:	e1a0f00e 	mov	pc, lr
	...

33d003e0 <irq>:
#ifdef CONFIG_USE_IRQ

	.align	5
irq:
/* add by www.embedsky.net to use IRQ for USB and DMA */
	sub	lr, lr, #4			        @ the return address
33d003e0:	e24ee004 	sub	lr, lr, #4	; 0x4
	ldr	sp, IRQ_STACK_START	        @ the stack for irq
33d003e4:	e51fd394 	ldr	sp, [pc, #-916]	; 33d00058 <IRQ_STACK_START>
	stmdb	sp!, 	{ r0-r12,lr }	@ save registers
33d003e8:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	
	ldr	lr,	=int_return		        @ set the return addr
33d003ec:	e59fe068 	ldr	lr, [pc, #104]	; 33d0045c <fiq+0x5c>
	ldr	pc, =IRQ_Handle		        @ call the isr
33d003f0:	e59ff068 	ldr	pc, [pc, #104]	; 33d00460 <fiq+0x60>

33d003f4 <int_return>:
int_return:
	ldmia	sp!, 	{ r0-r12,pc }^	@ return from interrupt
33d003f4:	e8fd9fff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^
	...

33d00400 <fiq>:

	.align	5
fiq:
	get_fiq_stack
33d00400:	e51fd3ac 	ldr	sp, [pc, #-940]	; 33d0005c <FIQ_STACK_START>
	/* someone ought to write a more effiction fiq_save_user_regs */
	irq_save_user_regs
33d00404:	e24dd048 	sub	sp, sp, #72	; 0x48
33d00408:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
33d0040c:	e28d803c 	add	r8, sp, #60	; 0x3c
33d00410:	e9486000 	stmdb	r8, {sp, lr}^
33d00414:	e588e000 	str	lr, [r8]
33d00418:	e14f6000 	mrs	r6, SPSR
33d0041c:	e5886004 	str	r6, [r8, #4]
33d00420:	e5880008 	str	r0, [r8, #8]
33d00424:	e1a0000d 	mov	r0, sp
	bl 	do_fiq
33d00428:	eb000214 	bl	33d00c80 <do_fiq>
	irq_restore_user_regs
33d0042c:	e8dd7fff 	ldm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
33d00430:	e1a00000 	nop			(mov r0,r0)
33d00434:	e59de03c 	ldr	lr, [sp, #60]
33d00438:	e28dd048 	add	sp, sp, #72	; 0x48
33d0043c:	e25ef004 	subs	pc, lr, #4	; 0x4
33d00440:	4a000008 	.word	0x4a000008
33d00444:	00007fff 	.word	0x00007fff
33d00448:	4a00001c 	.word	0x4a00001c
33d0044c:	000007ff 	.word	0x000007ff
33d00450:	4a000004 	.word	0x4a000004
33d00454:	33d00390 	.word	0x33d00390
33d00458:	31ff5800 	.word	0x31ff5800
33d0045c:	33d003f4 	.word	0x33d003f4
33d00460:	33d01184 	.word	0x33d01184
33d00464:	e1a00000 	.word	0xe1a00000
33d00468:	e1a00000 	.word	0xe1a00000
33d0046c:	e1a00000 	.word	0xe1a00000
33d00470:	e1a00000 	.word	0xe1a00000
33d00474:	e1a00000 	.word	0xe1a00000
33d00478:	e1a00000 	.word	0xe1a00000
33d0047c:	e1a00000 	.word	0xe1a00000

33d00480 <s3c2440_nand_select_chip>:
/* 发出片选信号 */
static void s3c2440_nand_select_chip(void)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

33d00480:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
	s3c2440nand->NFCONT &= ~(1<<1);
	for(i=0; i<10; i++);    
33d00484:	e5923004 	ldr	r3, [r2, #4]
33d00488:	e3c33002 	bic	r3, r3, #2	; 0x2
33d0048c:	e5823004 	str	r3, [r2, #4]
}

/* 发出片选信号 */
static void s3c2440_nand_select_chip(void)
{
	int i;
33d00490:	e3a03009 	mov	r3, #9	; 0x9
33d00494:	e2533001 	subs	r3, r3, #1	; 0x1
33d00498:	5afffffd 	bpl	33d00494 <s3c2440_nand_select_chip+0x14>
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

	s3c2440nand->NFCONT &= ~(1<<1);
	for(i=0; i<10; i++);    
}
33d0049c:	e1a0f00e 	mov	pc, lr

33d004a0 <s3c2440_write_cmd>:
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
	*p = cmd;
}
33d004a0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d004a4:	e5c30008 	strb	r0, [r3, #8]
33d004a8:	e1a0f00e 	mov	pc, lr

33d004ac <s3c2440_wait_idle>:
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;

	while(!(*p & BUSY))
        for(i=0; i<10; i++);
}
33d004ac:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d004b0:	e5d33020 	ldrb	r3, [r3, #32]
33d004b4:	e3130001 	tst	r3, #1	; 0x1
static void s3c2440_wait_idle(void)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;

33d004b8:	e59f201c 	ldr	r2, [pc, #28]	; 33d004dc <s3c2440_wait_idle+0x30>
	while(!(*p & BUSY))
        for(i=0; i<10; i++);
}
33d004bc:	11a0f00e 	movne	pc, lr
33d004c0:	e3a03009 	mov	r3, #9	; 0x9
33d004c4:	e2533001 	subs	r3, r3, #1	; 0x1
33d004c8:	5afffffd 	bpl	33d004c4 <s3c2440_wait_idle+0x18>
33d004cc:	e5d23000 	ldrb	r3, [r2]
33d004d0:	e3130001 	tst	r3, #1	; 0x1
33d004d4:	0afffff9 	beq	33d004c0 <s3c2440_wait_idle+0x14>
33d004d8:	e1a0f00e 	mov	pc, lr
33d004dc:	4e000020 	.word	0x4e000020

33d004e0 <s3c2440_nand_deselect_chip>:

/* 取消片选信号 */
static void s3c2440_nand_deselect_chip(void)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

33d004e0:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
	s3c2440nand->NFCONT |= (1<<1);
}
33d004e4:	e5923004 	ldr	r3, [r2, #4]
33d004e8:	e3833002 	orr	r3, r3, #2	; 0x2
33d004ec:	e5823004 	str	r3, [r2, #4]
33d004f0:	e1a0f00e 	mov	pc, lr

33d004f4 <wait_idle>:
}

static void wait_idle(void)
{
	s3c2440_wait_idle();
}
33d004f4:	eaffffec 	b	33d004ac <s3c2440_wait_idle>

33d004f8 <nand_select_chip>:

static void nand_select_chip(void)
{
	int i;
33d004f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	
	s3c2440_nand_select_chip();
	
33d004fc:	ebffffdf 	bl	33d00480 <s3c2440_nand_select_chip>
33d00500:	e3a03009 	mov	r3, #9	; 0x9
33d00504:	e2533001 	subs	r3, r3, #1	; 0x1
33d00508:	5afffffd 	bpl	33d00504 <nand_select_chip+0xc>
	for(i=0; i<10; i++);
}
33d0050c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d00510 <nand_deselect_chip>:

static void nand_deselect_chip(void)
{
	s3c2440_nand_deselect_chip();
}
33d00510:	eafffff2 	b	33d004e0 <s3c2440_nand_deselect_chip>

33d00514 <write_cmd>:

static void write_cmd(int cmd)
{
	s3c2440_write_cmd(cmd);
}
33d00514:	eaffffe1 	b	33d004a0 <s3c2440_write_cmd>

33d00518 <read_data>:
/* 读取数据 */
static unsigned char s3c2440_read_data(void)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFDATA;
	return *p;
33d00518:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d0051c:	e5d30010 	ldrb	r0, [r3, #16]

static unsigned char read_data(void)
{
	return s3c2440_read_data();
}

33d00520:	e1a0f00e 	mov	pc, lr

33d00524 <nand_init_ll>:
/* 初始化NAND Flash */
void nand_init_ll(void)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

33d00524:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
	#define TWRPH0  3
	#define TWRPH1  0

	/* 设置时序 */
	s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
	/* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
33d00528:	e3a02c03 	mov	r2, #768	; 0x300
}

/* 初始化NAND Flash */
void nand_init_ll(void)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
33d0052c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	#define TWRPH0  3
	#define TWRPH1  0

	/* 设置时序 */
	s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
	/* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
33d00530:	e5832000 	str	r2, [r3]
	s3c2440nand->NFCONT = (1<<4)|(1<<1)|(1<<0);

33d00534:	e3a02013 	mov	r2, #19	; 0x13
33d00538:	e5832004 	str	r2, [r3, #4]

/* 复位 */
static void s3c2440_nand_reset(void)
{
	s3c2440_nand_select_chip();
	s3c2440_write_cmd(0xff);  // 复位命令
33d0053c:	ebffffcf 	bl	33d00480 <s3c2440_nand_select_chip>
	s3c2440_wait_idle();
33d00540:	e3a000ff 	mov	r0, #255	; 0xff
33d00544:	ebffffd5 	bl	33d004a0 <s3c2440_write_cmd>
	s3c2440_nand_deselect_chip();
33d00548:	ebffffd7 	bl	33d004ac <s3c2440_wait_idle>
}
33d0054c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d00550:	eaffffe2 	b	33d004e0 <s3c2440_nand_deselect_chip>

33d00554 <NF_ReadID>:
	nand_reset();
}
#if 1
int NF_ReadID(void)
{
	char pMID;
33d00554:	e92d4030 	push	{r4, r5, lr}
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

	b128MB = 1;
	n4thcycle = nBuff = 0;
33d00558:	e59f5058 	ldr	r5, [pc, #88]	; 33d005b8 <NF_ReadID+0x64>
33d0055c:	e3a03001 	mov	r3, #1	; 0x1
33d00560:	e5c53000 	strb	r3, [r5]

	nand_init_ll();
	nand_select_chip();
33d00564:	ebffffee 	bl	33d00524 <nand_init_ll>
	write_cmd(0x90);	// read id command
33d00568:	ebffffe2 	bl	33d004f8 <nand_select_chip>
	*p=0x00 & 0xff;
33d0056c:	e3a00090 	mov	r0, #144	; 0x90
33d00570:	ebffffe7 	bl	33d00514 <write_cmd>
	for ( i = 0; i < 100; i++ );
33d00574:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d00578:	e3a02000 	mov	r2, #0	; 0x0
33d0057c:	e5c3200c 	strb	r2, [r3, #12]
33d00580:	e3a03063 	mov	r3, #99	; 0x63
33d00584:	e2533001 	subs	r3, r3, #1	; 0x1
33d00588:	5afffffd 	bpl	33d00584 <NF_ReadID+0x30>

	pMID = read_data();
	pDID =  read_data();
33d0058c:	ebffffe1 	bl	33d00518 <read_data>
	nBuff =  read_data();
33d00590:	ebffffe0 	bl	33d00518 <read_data>
33d00594:	e20040ff 	and	r4, r0, #255	; 0xff
	n4thcycle = read_data();
33d00598:	ebffffde 	bl	33d00518 <read_data>

33d0059c:	ebffffdd 	bl	33d00518 <read_data>
	nand_deselect_chip();
	
33d005a0:	ebffffda 	bl	33d00510 <nand_deselect_chip>
	if (pDID >= 0xA0)
	{
33d005a4:	e354009f 	cmp	r4, #159	; 0x9f
		b128MB = 0;
	}
33d005a8:	83a03000 	movhi	r3, #0	; 0x0

	return (pDID);
}
#endif
33d005ac:	e1a00004 	mov	r0, r4
	nand_deselect_chip();
	
	if (pDID >= 0xA0)
	{
		b128MB = 0;
	}
33d005b0:	85c53000 	strbhi	r3, [r5]

	return (pDID);
}
#endif
33d005b4:	e8bd8030 	pop	{r4, r5, pc}
33d005b8:	33d37179 	.word	0x33d37179

33d005bc <nand_read_ll>:
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

    
	if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK))
	{
33d005bc:	e1a03b81 	lsl	r3, r1, #23
33d005c0:	e1a03ba3 	lsr	r3, r3, #23
33d005c4:	e3530000 	cmp	r3, #0	; 0x0
#endif

/* 读函数 */
int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
{
	int i, j;
33d005c8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d005cc:	e1a0a000 	mov	sl, r0
	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

33d005d0:	e59f6138 	ldr	r6, [pc, #312]	; 33d00710 <nand_read_ll+0x154>
    
	if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK))
	{
33d005d4:	1a000003 	bne	33d005e8 <nand_read_ll+0x2c>
33d005d8:	e1a03b82 	lsl	r3, r2, #23
33d005dc:	e1a03ba3 	lsr	r3, r3, #23
33d005e0:	e3530000 	cmp	r3, #0	; 0x0
33d005e4:	0a000001 	beq	33d005f0 <nand_read_ll+0x34>
		return -1;    /* 地址或长度不对齐 */
	}
33d005e8:	e3e00000 	mvn	r0, #0	; 0x0
33d005ec:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	/* 选中芯片 */
	nand_select_chip();

	for(i=start_addr; i < (start_addr + size);)
	{
33d005f0:	e1a05001 	mov	r5, r1
33d005f4:	e0817002 	add	r7, r1, r2
		return -1;    /* 地址或长度不对齐 */
	}

	/* 选中芯片 */
	nand_select_chip();

33d005f8:	ebffffbe 	bl	33d004f8 <nand_select_chip>
	for(i=start_addr; i < (start_addr + size);)
	{
33d005fc:	e1550007 	cmp	r5, r7
33d00600:	2a00003f 	bcs	33d00704 <nand_read_ll+0x148>
/* Check Bad Block */
if(1){
		/* 发出READ0命令 */
		write_cmd(0x50);

33d00604:	e3a00050 	mov	r0, #80	; 0x50
33d00608:	ebffffc1 	bl	33d00514 <write_cmd>
		*p = 5;
		for(j=0; j<10; j++);
33d0060c:	e3a03005 	mov	r3, #5	; 0x5
33d00610:	e5c63000 	strb	r3, [r6]
33d00614:	e3a04009 	mov	r4, #9	; 0x9
33d00618:	e2544001 	subs	r4, r4, #1	; 0x1
33d0061c:	5afffffd 	bpl	33d00618 <nand_read_ll+0x5c>
		*p = (i >> 9) & 0xff;
		for(j=0; j<10; j++);
33d00620:	e1a034c5 	asr	r3, r5, #9
33d00624:	e5c63000 	strb	r3, [r6]
33d00628:	e3a04009 	mov	r4, #9	; 0x9
33d0062c:	e2544001 	subs	r4, r4, #1	; 0x1
33d00630:	5afffffd 	bpl	33d0062c <nand_read_ll+0x70>
		*p = (i >> 17) & 0xff;
		for(j=0; j<10; j++);
33d00634:	e1a038c5 	asr	r3, r5, #17
33d00638:	e5c63000 	strb	r3, [r6]
33d0063c:	e3a04009 	mov	r4, #9	; 0x9
33d00640:	e2544001 	subs	r4, r4, #1	; 0x1
33d00644:	5afffffd 	bpl	33d00640 <nand_read_ll+0x84>
		*p = (i >> 25) & 0xff;
		for(j=0; j<10; j++);
33d00648:	e1a03cc5 	asr	r3, r5, #25
33d0064c:	e5c63000 	strb	r3, [r6]
33d00650:	e3a04009 	mov	r4, #9	; 0x9
33d00654:	e2544001 	subs	r4, r4, #1	; 0x1
33d00658:	5afffffd 	bpl	33d00654 <nand_read_ll+0x98>
		wait_idle();

33d0065c:	ebffffa4 	bl	33d004f4 <wait_idle>
		dat = read_data();
		write_cmd(0);
33d00660:	ebffffac 	bl	33d00518 <read_data>
33d00664:	e1a04000 	mov	r4, r0
33d00668:	e20440ff 	and	r4, r4, #255	; 0xff
		
33d0066c:	e3a00000 	mov	r0, #0	; 0x0
33d00670:	ebffffa7 	bl	33d00514 <write_cmd>
		/* 取消片选信号 */
		nand_deselect_chip();
		if(dat != 0xff)
33d00674:	ebffffa5 	bl	33d00510 <nand_deselect_chip>
			i += 16384;		// 1 Block = 512*32= 16384
33d00678:	e35400ff 	cmp	r4, #255	; 0xff
/* Read Page */
33d0067c:	12855901 	addne	r5, r5, #16384	; 0x4000
		/* 选中芯片 */
		nand_select_chip();
}
33d00680:	ebffff9c 	bl	33d004f8 <nand_select_chip>
		/* 发出READ0命令 */
		write_cmd(0);

33d00684:	e3a00000 	mov	r0, #0	; 0x0
33d00688:	ebffffa1 	bl	33d00514 <write_cmd>
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
    
	*p = addr & 0xff;
	for(i=0; i<10; i++);
33d0068c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
static void s3c2440_write_addr(unsigned int addr)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
    
33d00690:	e59f2078 	ldr	r2, [pc, #120]	; 33d00710 <nand_read_ll+0x154>
	*p = addr & 0xff;
	for(i=0; i<10; i++);
33d00694:	e5c3500c 	strb	r5, [r3, #12]
33d00698:	e3a03009 	mov	r3, #9	; 0x9
33d0069c:	e2533001 	subs	r3, r3, #1	; 0x1
33d006a0:	5afffffd 	bpl	33d0069c <nand_read_ll+0xe0>
	*p = (addr >> 9) & 0xff;
	for(i=0; i<10; i++);
33d006a4:	e1a034a5 	lsr	r3, r5, #9
33d006a8:	e5c23000 	strb	r3, [r2]
33d006ac:	e3a03009 	mov	r3, #9	; 0x9
33d006b0:	e2533001 	subs	r3, r3, #1	; 0x1
33d006b4:	5afffffd 	bpl	33d006b0 <nand_read_ll+0xf4>
	*p = (addr >> 17) & 0xff;
	for(i=0; i<10; i++);
33d006b8:	e1a038a5 	lsr	r3, r5, #17
33d006bc:	e5c23000 	strb	r3, [r2]
33d006c0:	e3a03009 	mov	r3, #9	; 0x9
33d006c4:	e2533001 	subs	r3, r3, #1	; 0x1
33d006c8:	5afffffd 	bpl	33d006c4 <nand_read_ll+0x108>
	*p = (addr >> 25) & 0xff;
	for(i=0; i<10; i++);
33d006cc:	e1a03ca5 	lsr	r3, r5, #25
33d006d0:	e5c23000 	strb	r3, [r2]
33d006d4:	e3a03009 	mov	r3, #9	; 0x9
33d006d8:	e2533001 	subs	r3, r3, #1	; 0x1
33d006dc:	5afffffd 	bpl	33d006d8 <nand_read_ll+0x11c>
		write_cmd(0);

		/* Write Address */
		write_addr(i);
		wait_idle();

33d006e0:	ebffff83 	bl	33d004f4 <wait_idle>
		for(j=0; j < NAND_SECTOR_SIZE; j++, i++)
		{
33d006e4:	e3a04000 	mov	r4, #0	; 0x0
			*buf = read_data();
			buf++;
33d006e8:	ebffff8a 	bl	33d00518 <read_data>
		/* Write Address */
		write_addr(i);
		wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE; j++, i++)
		{
33d006ec:	e2844001 	add	r4, r4, #1	; 0x1
33d006f0:	e3540c02 	cmp	r4, #512	; 0x200
			*buf = read_data();
			buf++;
33d006f4:	e4ca0001 	strb	r0, [sl], #1
		/* Write Address */
		write_addr(i);
		wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE; j++, i++)
		{
33d006f8:	e2855001 	add	r5, r5, #1	; 0x1
33d006fc:	bafffff9 	blt	33d006e8 <nand_read_ll+0x12c>
33d00700:	eaffffbd 	b	33d005fc <nand_read_ll+0x40>
		}
	}

	/* 取消片选信号 */
	nand_deselect_chip();

33d00704:	ebffff81 	bl	33d00510 <nand_deselect_chip>
	return 0;
}
33d00708:	e3a00000 	mov	r0, #0	; 0x0

33d0070c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d00710:	4e00000c 	.word	0x4e00000c

33d00714 <nand_read_ll_lp>:
	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

	if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP))
	{
33d00714:	e1a03a81 	lsl	r3, r1, #21
33d00718:	e1a03aa3 	lsr	r3, r3, #21
33d0071c:	e3530000 	cmp	r3, #0	; 0x0
/* 读函数 
  * Large Page
  */
int nand_read_ll_lp(unsigned char *buf, unsigned long start_addr, int size)
{
	int i, j;
33d00720:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d00724:	e1a0b000 	mov	fp, r0
	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

33d00728:	e59f7198 	ldr	r7, [pc, #408]	; 33d008c8 <nand_read_ll_lp+0x1b4>
	if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP))
	{
33d0072c:	1a000003 	bne	33d00740 <nand_read_ll_lp+0x2c>
33d00730:	e1a03a82 	lsl	r3, r2, #21
33d00734:	e1a03aa3 	lsr	r3, r3, #21
33d00738:	e3530000 	cmp	r3, #0	; 0x0
33d0073c:	0a000001 	beq	33d00748 <nand_read_ll_lp+0x34>
		return -1;    /* 地址或长度不对齐 */
	}
33d00740:	e3e00000 	mvn	r0, #0	; 0x0
33d00744:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	/* 选中芯片 */
	nand_select_chip();

	for(i=start_addr; i < (start_addr + size);)
	{
33d00748:	e1a05001 	mov	r5, r1
33d0074c:	e0819002 	add	r9, r1, r2
		return -1;    /* 地址或长度不对齐 */
	}

	/* 选中芯片 */
	nand_select_chip();

33d00750:	ebffff68 	bl	33d004f8 <nand_select_chip>
	for(i=start_addr; i < (start_addr + size);)
	{
33d00754:	e1550009 	cmp	r5, r9
33d00758:	2a000057 	bcs	33d008bc <nand_read_ll_lp+0x1a8>
if(1){
		int col, page;

		col = i & NAND_BLOCK_MASK_LP;
		page = i / NAND_SECTOR_SIZE_LP;
		/* 发出READ0命令 */
33d0075c:	e1a03fc5 	asr	r3, r5, #31
33d00760:	e0853aa3 	add	r3, r5, r3, lsr #21
		write_cmd(0x00);

33d00764:	e3a00000 	mov	r0, #0	; 0x0
if(1){
		int col, page;

		col = i & NAND_BLOCK_MASK_LP;
		page = i / NAND_SECTOR_SIZE_LP;
		/* 发出READ0命令 */
33d00768:	e1a065c3 	asr	r6, r3, #11
		write_cmd(0x00);

33d0076c:	ebffff68 	bl	33d00514 <write_cmd>
		*p = 5;
		for(j=0; j<10; j++);
33d00770:	e3a03005 	mov	r3, #5	; 0x5
33d00774:	e5c73000 	strb	r3, [r7]
33d00778:	e3a04009 	mov	r4, #9	; 0x9
33d0077c:	e2544001 	subs	r4, r4, #1	; 0x1
33d00780:	5afffffd 	bpl	33d0077c <nand_read_ll_lp+0x68>
		*p = 8;
		for(j=0; j<10; j++);
33d00784:	e3a03008 	mov	r3, #8	; 0x8
33d00788:	e5c73000 	strb	r3, [r7]
33d0078c:	e3a04009 	mov	r4, #9	; 0x9
33d00790:	e2544001 	subs	r4, r4, #1	; 0x1
33d00794:	5afffffd 	bpl	33d00790 <nand_read_ll_lp+0x7c>
		*p = page & 0xff;		/* Row Address A12~A19 */
		for(j=0; j<10; j++);
33d00798:	e5c76000 	strb	r6, [r7]
33d0079c:	e3a04009 	mov	r4, #9	; 0x9
33d007a0:	e2544001 	subs	r4, r4, #1	; 0x1
33d007a4:	5afffffd 	bpl	33d007a0 <nand_read_ll_lp+0x8c>
		*p = (page >> 8) & 0xff;		/* Row Address A20~A27 */
		for(j=0; j<10; j++);
33d007a8:	e1a03446 	asr	r3, r6, #8
33d007ac:	e5c73000 	strb	r3, [r7]
33d007b0:	e3a04009 	mov	r4, #9	; 0x9
33d007b4:	e2544001 	subs	r4, r4, #1	; 0x1
33d007b8:	5afffffd 	bpl	33d007b4 <nand_read_ll_lp+0xa0>
if (b128MB == 0)
		*p = (page >> 16) & 0x03;		/* Row Address A28~A29 */
33d007bc:	e59fa108 	ldr	sl, [pc, #264]	; 33d008cc <nand_read_ll_lp+0x1b8>
33d007c0:	e5da3000 	ldrb	r3, [sl]
33d007c4:	e3530000 	cmp	r3, #0	; 0x0
		for(j=0; j<10; j++);
33d007c8:	01a03846 	asreq	r3, r6, #16
33d007cc:	02033003 	andeq	r3, r3, #3	; 0x3
33d007d0:	05c73000 	strbeq	r3, [r7]
33d007d4:	e3a04009 	mov	r4, #9	; 0x9
33d007d8:	e2544001 	subs	r4, r4, #1	; 0x1
33d007dc:	5afffffd 	bpl	33d007d8 <nand_read_ll_lp+0xc4>

		write_cmd(0x30);
		wait_idle();
33d007e0:	e3a00030 	mov	r0, #48	; 0x30
33d007e4:	ebffff4a 	bl	33d00514 <write_cmd>

33d007e8:	ebffff41 	bl	33d004f4 <wait_idle>
		dat = read_data();
		
33d007ec:	ebffff49 	bl	33d00518 <read_data>
33d007f0:	e1a04000 	mov	r4, r0
33d007f4:	e20440ff 	and	r4, r4, #255	; 0xff
		/* 取消片选信号 */
		nand_deselect_chip();
		if(dat != 0xff)
33d007f8:	ebffff44 	bl	33d00510 <nand_deselect_chip>
			i += 131072;		// 1 Block = 2048*64= 131072
33d007fc:	e35400ff 	cmp	r4, #255	; 0xff
/* Read Page */
33d00800:	12855802 	addne	r5, r5, #131072	; 0x20000
		/* 选中芯片 */
		nand_select_chip();
}
33d00804:	ebffff3b 	bl	33d004f8 <nand_select_chip>
		/* 发出READ0命令 */
		write_cmd(0);

33d00808:	e3a00000 	mov	r0, #0	; 0x0
33d0080c:	ebffff40 	bl	33d00514 <write_cmd>
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
	int col, page;

	col = addr & NAND_BLOCK_MASK_LP;
	page = addr / NAND_SECTOR_SIZE_LP;
33d00810:	e1a01a85 	lsl	r1, r5, #21
33d00814:	e1a01aa1 	lsr	r1, r1, #21
	
	*p = col & 0xff;			/* Column Address A0~A7 */
	for(i=0; i<10; i++);		
33d00818:	e3c12000 	bic	r2, r1, #0	; 0x0
33d0081c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
static void s3c2440_write_addr_lp(unsigned int addr)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
	int col, page;
33d00820:	e59f00a0 	ldr	r0, [pc, #160]	; 33d008c8 <nand_read_ll_lp+0x1b4>

	col = addr & NAND_BLOCK_MASK_LP;
	page = addr / NAND_SECTOR_SIZE_LP;
	
	*p = col & 0xff;			/* Column Address A0~A7 */
	for(i=0; i<10; i++);		
33d00824:	e5c3200c 	strb	r2, [r3, #12]
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
	int col, page;

	col = addr & NAND_BLOCK_MASK_LP;
	page = addr / NAND_SECTOR_SIZE_LP;
	
33d00828:	e1a025a5 	lsr	r2, r5, #11
33d0082c:	e3a03009 	mov	r3, #9	; 0x9
33d00830:	e2533001 	subs	r3, r3, #1	; 0x1
33d00834:	5afffffd 	bpl	33d00830 <nand_read_ll_lp+0x11c>
	*p = col & 0xff;			/* Column Address A0~A7 */
	for(i=0; i<10; i++);		
	*p = (col >> 8) & 0x0f;		/* Column Address A8~A11 */
	for(i=0; i<10; i++);
33d00838:	e1a03421 	lsr	r3, r1, #8
33d0083c:	e5c03000 	strb	r3, [r0]
33d00840:	e3a03009 	mov	r3, #9	; 0x9
33d00844:	e2533001 	subs	r3, r3, #1	; 0x1
33d00848:	5afffffd 	bpl	33d00844 <nand_read_ll_lp+0x130>
	*p = page & 0xff;			/* Row Address A12~A19 */
	for(i=0; i<10; i++);
33d0084c:	e5c02000 	strb	r2, [r0]
33d00850:	e3a03009 	mov	r3, #9	; 0x9
33d00854:	e2533001 	subs	r3, r3, #1	; 0x1
33d00858:	5afffffd 	bpl	33d00854 <nand_read_ll_lp+0x140>
	*p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
	for(i=0; i<10; i++);
33d0085c:	e1a03442 	asr	r3, r2, #8
33d00860:	e5c03000 	strb	r3, [r0]
33d00864:	e3a03009 	mov	r3, #9	; 0x9
33d00868:	e2533001 	subs	r3, r3, #1	; 0x1
33d0086c:	5afffffd 	bpl	33d00868 <nand_read_ll_lp+0x154>
if (b128MB == 0)
	*p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
33d00870:	e5da3000 	ldrb	r3, [sl]
33d00874:	e3530000 	cmp	r3, #0	; 0x0
	for(i=0; i<10; i++);
33d00878:	01a03842 	asreq	r3, r2, #16
33d0087c:	02033003 	andeq	r3, r3, #3	; 0x3
33d00880:	05c03000 	strbeq	r3, [r0]
33d00884:	e3a03009 	mov	r3, #9	; 0x9
33d00888:	e2533001 	subs	r3, r3, #1	; 0x1
33d0088c:	5afffffd 	bpl	33d00888 <nand_read_ll_lp+0x174>
		write_cmd(0);

		/* Write Address */
		write_addr_lp(i);
		write_cmd(0x30);
		wait_idle();
33d00890:	e3a00030 	mov	r0, #48	; 0x30
33d00894:	ebffff1e 	bl	33d00514 <write_cmd>

33d00898:	ebffff15 	bl	33d004f4 <wait_idle>
		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
		{
33d0089c:	e3a04000 	mov	r4, #0	; 0x0
			*buf = read_data();
			buf++;
33d008a0:	ebffff1c 	bl	33d00518 <read_data>
		write_addr_lp(i);
		write_cmd(0x30);
		wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
		{
33d008a4:	e2844001 	add	r4, r4, #1	; 0x1
33d008a8:	e3540b02 	cmp	r4, #2048	; 0x800
			*buf = read_data();
			buf++;
33d008ac:	e4cb0001 	strb	r0, [fp], #1
		write_addr_lp(i);
		write_cmd(0x30);
		wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
		{
33d008b0:	e2855001 	add	r5, r5, #1	; 0x1
33d008b4:	bafffff9 	blt	33d008a0 <nand_read_ll_lp+0x18c>
33d008b8:	eaffffa5 	b	33d00754 <nand_read_ll_lp+0x40>
		}
	}

	/* 取消片选信号 */
	nand_deselect_chip();

33d008bc:	ebffff13 	bl	33d00510 <nand_deselect_chip>
	return 0;
}
33d008c0:	e3a00000 	mov	r0, #0	; 0x0

33d008c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d008c8:	4e00000c 	.word	0x4e00000c
33d008cc:	33d37179 	.word	0x33d37179

33d008d0 <bBootFrmNORFlash>:
	 * 向地址0写入一个数据，然后读出来，如果没有改变的话就是NOR Flash
	 */

	dwVal = *pdw;       
	*pdw = 0x12345678;
	if (*pdw != 0x12345678)
33d008d0:	e59f2020 	ldr	r2, [pc, #32]	; 33d008f8 <bBootFrmNORFlash+0x28>
}

int bBootFrmNORFlash(void)
{
	volatile unsigned int *pdw = (volatile unsigned int *)0;
	unsigned int dwVal;
33d008d4:	e3a01000 	mov	r1, #0	; 0x0
	 * 所以可以根据这点差别来分辨是从NAND Flash还是NOR Flash启动:
	 * 向地址0写入一个数据，然后读出来，如果没有改变的话就是NOR Flash
	 */

	dwVal = *pdw;       
	*pdw = 0x12345678;
33d008d8:	e591c000 	ldr	ip, [r1]
	if (*pdw != 0x12345678)
33d008dc:	e5812000 	str	r2, [r1]
	{
33d008e0:	e5913000 	ldr	r3, [r1]
33d008e4:	e1530002 	cmp	r3, r2
		return 1;
	}
33d008e8:	e3a00001 	mov	r0, #1	; 0x1
	else
	{
		*pdw = dwVal;
		return 0;
	}
33d008ec:	01a00001 	moveq	r0, r1
		return 1;
	}
	else
	{
		*pdw = dwVal;
		return 0;
33d008f0:	0581c000 	streq	ip, [r1]
	}
}

33d008f4:	e1a0f00e 	mov	pc, lr
33d008f8:	12345678 	.word	0x12345678

33d008fc <CopyCode2Ram>:
int CopyCode2Ram(unsigned long start_addr, unsigned char *buf, int size)
{
	unsigned int *pdwDest;
33d008fc:	e92d4070 	push	{r4, r5, r6, lr}
33d00900:	e1a06000 	mov	r6, r0
33d00904:	e1a05001 	mov	r5, r1
33d00908:	e1a04002 	mov	r4, r2
	unsigned int *pdwSrc;
	int i;

	if (bBootFrmNORFlash())
	{
33d0090c:	ebffffef 	bl	33d008d0 <bBootFrmNORFlash>
33d00910:	e3500000 	cmp	r0, #0	; 0x0
33d00914:	0a000008 	beq	33d0093c <CopyCode2Ram+0x40>
		pdwDest = (unsigned int *)buf;
		pdwSrc  = (unsigned int *)start_addr;
		/* 从 NOR Flash启动 */
		for (i = 0; i < size / 4; i++)
		{
33d00918:	e1a03fc4 	asr	r3, r4, #31
33d0091c:	e0842f23 	add	r2, r4, r3, lsr #30
33d00920:	e3a01000 	mov	r1, #0	; 0x0
33d00924:	e1510142 	cmp	r1, r2, asr #2
33d00928:	aa000016 	bge	33d00988 <CopyCode2Ram+0x8c>
			pdwDest[i] = pdwSrc[i];
		}
33d0092c:	e7963101 	ldr	r3, [r6, r1, lsl #2]
33d00930:	e7853101 	str	r3, [r5, r1, lsl #2]
	{
		pdwDest = (unsigned int *)buf;
		pdwSrc  = (unsigned int *)start_addr;
		/* 从 NOR Flash启动 */
		for (i = 0; i < size / 4; i++)
		{
33d00934:	e2811001 	add	r1, r1, #1	; 0x1
33d00938:	eafffff9 	b	33d00924 <CopyCode2Ram+0x28>
	}
	else
	{
		/* 初始化NAND Flash */
		nand_init_ll();

33d0093c:	ebfffef8 	bl	33d00524 <nand_init_ll>
		/* 从 NAND Flash启动 */
		if (NF_ReadID() == 0x76 )
			nand_read_ll(buf, start_addr, (size + NAND_BLOCK_MASK)&~(NAND_BLOCK_MASK));
33d00940:	ebffff03 	bl	33d00554 <NF_ReadID>
33d00944:	e3500076 	cmp	r0, #118	; 0x76
33d00948:	1a000007 	bne	33d0096c <CopyCode2Ram+0x70>
		else
33d0094c:	e2842f7f 	add	r2, r4, #508	; 0x1fc
33d00950:	e2822003 	add	r2, r2, #3	; 0x3
33d00954:	e3c22f7f 	bic	r2, r2, #508	; 0x1fc
33d00958:	e1a00005 	mov	r0, r5
33d0095c:	e1a01006 	mov	r1, r6
33d00960:	e3c22003 	bic	r2, r2, #3	; 0x3
33d00964:	ebffff14 	bl	33d005bc <nand_read_ll>
33d00968:	ea000006 	b	33d00988 <CopyCode2Ram+0x8c>
			nand_read_ll_lp(buf, start_addr, (size + NAND_BLOCK_MASK_LP)&~(NAND_BLOCK_MASK_LP));
		return 0;
33d0096c:	e2842e7f 	add	r2, r4, #2032	; 0x7f0
33d00970:	e282200f 	add	r2, r2, #15	; 0xf
33d00974:	e3c22e7f 	bic	r2, r2, #2032	; 0x7f0
33d00978:	e1a00005 	mov	r0, r5
33d0097c:	e1a01006 	mov	r1, r6
33d00980:	e3c2200f 	bic	r2, r2, #15	; 0xf
33d00984:	ebffff62 	bl	33d00714 <nand_read_ll_lp>
	}
}

33d00988:	e3a00000 	mov	r0, #0	; 0x0
33d0098c:	e8bd8070 	pop	{r4, r5, r6, pc}

33d00990 <clock_init>:
#define S3C2440_UPLL_48MHZ_Fin16MHz		((60<<12)|(4<<4)|(2))

void clock_init(void)
{
	S3C24X0_CLOCK_POWER *clk_power = (S3C24X0_CLOCK_POWER *)0x4C000000;

33d00990:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
	/* FCLK:HCLK:PCLK = ?:?:? */
#if CONFIG_133MHZ_SDRAM
	clk_power->CLKDIVN = S3C2440_CLKDIV136;			//HJ 1:3:6
#else
	clk_power->CLKDIVN = S3C2440_CLKDIV;				//HJ 1:4:8
#endif
33d00994:	e3a03005 	mov	r3, #5	; 0x5
33d00998:	e5823014 	str	r3, [r2, #20]
	/* change to asynchronous bus mod */
	__asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
33d0099c:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
33d009a0:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
33d009a4:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
                    :::"r1"
                    );

	/* to reduce PLL lock time, adjust the LOCKTIME register */
	clk_power->LOCKTIME = 0xFFFFFF;

33d009a8:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
33d009ac:	e5823000 	str	r3, [r2]
	/* configure UPLL */
	clk_power->UPLLCON = S3C2440_UPLL_48MHZ;		//fin=12.000MHz
//	clk_power->UPLLCON = S3C2440_UPLL_48MHZ_Fin16MHz;	//fin=16.934MHz
33d009b0:	e59f3024 	ldr	r3, [pc, #36]	; 33d009dc <clock_init+0x4c>
33d009b4:	e5823008 	str	r3, [r2, #8]
	}
}

static inline void delay (unsigned long loops)
{
	__asm__ volatile ("1:\n"
33d009b8:	e3a03efa 	mov	r3, #4000	; 0xfa0
			"subs %0, %1, #1\n"
33d009bc:	e2533001 	subs	r3, r3, #1	; 0x1
33d009c0:	1afffffd 	bne	33d009bc <clock_init+0x2c>
	/* some delay between MPLL and UPLL */
	delay (4000);

	/* configure MPLL */
	clk_power->MPLLCON = S3C2440_MPLL_400MHZ;		//fin=12.000MHz
//	clk_power->MPLLCON = S3C2440_MPLL_405MHZ;				//HJ 405MHz
33d009c4:	e59f3014 	ldr	r3, [pc, #20]	; 33d009e0 <clock_init+0x50>
33d009c8:	e5823004 	str	r3, [r2, #4]
	}
}

static inline void delay (unsigned long loops)
{
	__asm__ volatile ("1:\n"
33d009cc:	e3a03d7d 	mov	r3, #8000	; 0x1f40
			"subs %0, %1, #1\n"
33d009d0:	e2533001 	subs	r3, r3, #1	; 0x1
33d009d4:	1afffffd 	bne	33d009d0 <clock_init+0x40>
33d009d8:	e1a0f00e 	mov	pc, lr
33d009dc:	00038022 	.word	0x00038022
33d009e0:	0005c011 	.word	0x0005c011

33d009e4 <_TEXT_BASE>:
33d009e4:	33d00000 	.word	0x33d00000

33d009e8 <lowlevel_init>:
.globl lowlevel_init
lowlevel_init:
	/* memory control configuration */
	/* make r0 relative the current location so that it */
	/* reads SMRDATA out of FLASH rather than memory ! */
	ldr     r0, =SMRDATA
33d009e8:	e59f0020 	ldr	r0, [pc, #32]	; 33d00a10 <lowlevel_init+0x28>
	ldr	r1, _TEXT_BASE
33d009ec:	e51f1010 	ldr	r1, [pc, #-16]	; 33d009e4 <_TEXT_BASE>
	sub	r0, r0, r1
33d009f0:	e0400001 	sub	r0, r0, r1
	ldr	r1, =BWSCON	/* Bus Width Status Controller */
33d009f4:	e3a01312 	mov	r1, #1207959552	; 0x48000000
	add     r2, r0, #13*4
33d009f8:	e2802034 	add	r2, r0, #52	; 0x34
0:
	ldr     r3, [r0], #4
33d009fc:	e4903004 	ldr	r3, [r0], #4
	str     r3, [r1], #4
33d00a00:	e4813004 	str	r3, [r1], #4
	cmp     r2, r0
33d00a04:	e1520000 	cmp	r2, r0
	bne     0b
33d00a08:	1afffffb 	bne	33d009fc <lowlevel_init+0x14>

	/* everything is fine now */
	mov	pc, lr
33d00a0c:	e1a0f00e 	mov	pc, lr
33d00a10:	33d00a14 	.word	0x33d00a14

33d00a14 <SMRDATA>:
33d00a14:	2201d110 	.word	0x2201d110
33d00a18:	00000700 	.word	0x00000700
33d00a1c:	00000700 	.word	0x00000700
33d00a20:	00000700 	.word	0x00000700
33d00a24:	00001f4c 	.word	0x00001f4c
33d00a28:	00000700 	.word	0x00000700
33d00a2c:	00000700 	.word	0x00000700
33d00a30:	00018005 	.word	0x00018005
33d00a34:	00018005 	.word	0x00018005
33d00a38:	008e04f4 	.word	0x008e04f4
33d00a3c:	00000032 	.word	0x00000032
33d00a40:	00000030 	.word	0x00000030
33d00a44:	00000030 	.word	0x00000030

33d00a48 <enable_interrupts>:
#ifdef CONFIG_USE_IRQ
/* enable IRQ interrupts */
void enable_interrupts (void)
{
	unsigned long temp;
	__asm__ __volatile__("mrs %0, cpsr\n"
33d00a48:	e10f3000 	mrs	r3, CPSR
33d00a4c:	e3c33080 	bic	r3, r3, #128	; 0x80
33d00a50:	e121f003 	msr	CPSR_c, r3
33d00a54:	e1a0f00e 	mov	pc, lr

33d00a58 <disable_interrupts>:
 * returns true if interrupts had been enabled before we disabled them
 */
int disable_interrupts (void)
{
	unsigned long old,temp;
	__asm__ __volatile__("mrs %0, cpsr\n"
33d00a58:	e10f0000 	mrs	r0, CPSR
33d00a5c:	e38030c0 	orr	r3, r0, #192	; 0xc0
33d00a60:	e121f003 	msr	CPSR_c, r3
			     "orr %1, %0, #0xc0\n"
			     "msr cpsr_c, %1"
			     : "=r" (old), "=r" (temp)
			     :
			     : "memory");
	return (old & 0x80) == 0;
33d00a64:	e1a003a0 	lsr	r0, r0, #7
33d00a68:	e2200001 	eor	r0, r0, #1	; 0x1
}
33d00a6c:	e2000001 	and	r0, r0, #1	; 0x1
33d00a70:	e1a0f00e 	mov	pc, lr

33d00a74 <bad_mode>:
}
#endif


void bad_mode (void)
{
33d00a74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	panic ("Resetting CPU ...\n");
33d00a78:	e59f000c 	ldr	r0, [pc, #12]	; 33d00a8c <bad_mode+0x18>
33d00a7c:	eb0068a4 	bl	33d1ad14 <panic>
	reset_cpu (0);
33d00a80:	e3a00000 	mov	r0, #0	; 0x0
33d00a84:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d00a88:	ea00011d 	b	33d00f04 <reset_cpu>
33d00a8c:	33d25200 	.word	0x33d25200

33d00a90 <show_regs>:
}

void show_regs (struct pt_regs *regs)
{
33d00a90:	e92d4030 	push	{r4, r5, lr}
33d00a94:	e24dd088 	sub	sp, sp, #136	; 0x88
33d00a98:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
33d00a9c:	e59f1100 	ldr	r1, [pc, #256]	; 33d00ba4 <show_regs+0x114>
33d00aa0:	e3a02080 	mov	r2, #128	; 0x80
33d00aa4:	e28d0008 	add	r0, sp, #8	; 0x8
33d00aa8:	eb00664d 	bl	33d1a3e4 <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]    lr : [<%08lx>]\n"
33d00aac:	e594e02c 	ldr	lr, [r4, #44]
33d00ab0:	e594c030 	ldr	ip, [r4, #48]
33d00ab4:	e594103c 	ldr	r1, [r4, #60]
33d00ab8:	e5942038 	ldr	r2, [r4, #56]
33d00abc:	e5943034 	ldr	r3, [r4, #52]
33d00ac0:	e88d5000 	stm	sp, {ip, lr}
33d00ac4:	e59f00dc 	ldr	r0, [pc, #220]	; 33d00ba8 <show_regs+0x118>
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
33d00ac8:	e5945040 	ldr	r5, [r4, #64]

	printf ("pc : [<%08lx>]    lr : [<%08lx>]\n"
33d00acc:	eb00593d 	bl	33d16fc8 <printf>
		"sp : %08lx  ip : %08lx  fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
33d00ad0:	e5941028 	ldr	r1, [r4, #40]
33d00ad4:	e5942024 	ldr	r2, [r4, #36]
33d00ad8:	e5943020 	ldr	r3, [r4, #32]
33d00adc:	e59f00c8 	ldr	r0, [pc, #200]	; 33d00bac <show_regs+0x11c>
33d00ae0:	eb005938 	bl	33d16fc8 <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
33d00ae4:	e594c010 	ldr	ip, [r4, #16]
33d00ae8:	e594101c 	ldr	r1, [r4, #28]
33d00aec:	e5942018 	ldr	r2, [r4, #24]
33d00af0:	e5943014 	ldr	r3, [r4, #20]
33d00af4:	e59f00b4 	ldr	r0, [pc, #180]	; 33d00bb0 <show_regs+0x120>
33d00af8:	e58dc000 	str	ip, [sp]
33d00afc:	eb005931 	bl	33d16fc8 <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
33d00b00:	e594c000 	ldr	ip, [r4]
33d00b04:	e594100c 	ldr	r1, [r4, #12]
33d00b08:	e5942008 	ldr	r2, [r4, #8]
33d00b0c:	e5943004 	ldr	r3, [r4, #4]
33d00b10:	e59f009c 	ldr	r0, [pc, #156]	; 33d00bb4 <show_regs+0x124>
33d00b14:	e58dc000 	str	ip, [sp]
33d00b18:	eb00592a 	bl	33d16fc8 <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
33d00b1c:	e3150101 	tst	r5, #1073741824	; 0x40000000
33d00b20:	03a0207a 	moveq	r2, #122	; 0x7a
33d00b24:	13a0205a 	movne	r2, #90	; 0x5a
33d00b28:	e3150202 	tst	r5, #536870912	; 0x20000000
33d00b2c:	03a03063 	moveq	r3, #99	; 0x63
33d00b30:	13a03043 	movne	r3, #67	; 0x43
33d00b34:	e3150201 	tst	r5, #268435456	; 0x10000000
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
33d00b38:	e205520f 	and	r5, r5, #-268435456	; 0xf0000000
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
33d00b3c:	03a0c076 	moveq	ip, #118	; 0x76
33d00b40:	13a0c056 	movne	ip, #86	; 0x56
33d00b44:	e3550000 	cmp	r5, #0	; 0x0
33d00b48:	a3a0106e 	movge	r1, #110	; 0x6e
33d00b4c:	b3a0104e 	movlt	r1, #78	; 0x4e
33d00b50:	e59f0060 	ldr	r0, [pc, #96]	; 33d00bb8 <show_regs+0x128>
33d00b54:	e58dc000 	str	ip, [sp]
33d00b58:	eb00591a 	bl	33d16fc8 <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
33d00b5c:	e5940040 	ldr	r0, [r4, #64]
33d00b60:	e28d2088 	add	r2, sp, #136	; 0x88
33d00b64:	e200301f 	and	r3, r0, #31	; 0x1f
33d00b68:	e59fc04c 	ldr	ip, [pc, #76]	; 33d00bbc <show_regs+0x12c>
33d00b6c:	e0823103 	add	r3, r2, r3, lsl #2
33d00b70:	e59f2048 	ldr	r2, [pc, #72]	; 33d00bc0 <show_regs+0x130>
33d00b74:	e3100080 	tst	r0, #128	; 0x80
33d00b78:	11a0100c 	movne	r1, ip
33d00b7c:	01a01002 	moveq	r1, r2
33d00b80:	e3100040 	tst	r0, #64	; 0x40
33d00b84:	11a0200c 	movne	r2, ip
33d00b88:	e59fc034 	ldr	ip, [pc, #52]	; 33d00bc4 <show_regs+0x134>
33d00b8c:	e5133080 	ldr	r3, [r3, #-128]
33d00b90:	e59f0030 	ldr	r0, [pc, #48]	; 33d00bc8 <show_regs+0x138>
33d00b94:	e58dc000 	str	ip, [sp]
33d00b98:	eb00590a 	bl	33d16fc8 <printf>
33d00b9c:	e28dd088 	add	sp, sp, #136	; 0x88
33d00ba0:	e8bd8030 	pop	{r4, r5, pc}
33d00ba4:	33d24770 	.word	0x33d24770
33d00ba8:	33d25314 	.word	0x33d25314
33d00bac:	33d2535c 	.word	0x33d2535c
33d00bb0:	33d25380 	.word	0x33d25380
33d00bb4:	33d253b0 	.word	0x33d253b0
33d00bb8:	33d253e0 	.word	0x33d253e0
33d00bbc:	33d253f0 	.word	0x33d253f0
33d00bc0:	33d27af0 	.word	0x33d27af0
33d00bc4:	33d2a490 	.word	0x33d2a490
33d00bc8:	33d251e0 	.word	0x33d251e0

33d00bcc <do_undefined_instruction>:
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
33d00bcc:	e92d4010 	push	{r4, lr}
33d00bd0:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
33d00bd4:	e59f0010 	ldr	r0, [pc, #16]	; 33d00bec <do_undefined_instruction+0x20>
33d00bd8:	eb0058fa 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00bdc:	e1a00004 	mov	r0, r4
33d00be0:	ebffffaa 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00be4:	e8bd4010 	pop	{r4, lr}
33d00be8:	eaffffa1 	b	33d00a74 <bad_mode>
33d00bec:	33d253f4 	.word	0x33d253f4

33d00bf0 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
33d00bf0:	e92d4010 	push	{r4, lr}
33d00bf4:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
33d00bf8:	e59f0010 	ldr	r0, [pc, #16]	; 33d00c10 <do_software_interrupt+0x20>
33d00bfc:	eb0058f1 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00c00:	e1a00004 	mov	r0, r4
33d00c04:	ebffffa1 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00c08:	e8bd4010 	pop	{r4, lr}
33d00c0c:	eaffff98 	b	33d00a74 <bad_mode>
33d00c10:	33d2540c 	.word	0x33d2540c

33d00c14 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
33d00c14:	e92d4010 	push	{r4, lr}
33d00c18:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
33d00c1c:	e59f0010 	ldr	r0, [pc, #16]	; 33d00c34 <do_prefetch_abort+0x20>
33d00c20:	eb0058e8 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00c24:	e1a00004 	mov	r0, r4
33d00c28:	ebffff98 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00c2c:	e8bd4010 	pop	{r4, lr}
33d00c30:	eaffff8f 	b	33d00a74 <bad_mode>
33d00c34:	33d25420 	.word	0x33d25420

33d00c38 <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
33d00c38:	e92d4010 	push	{r4, lr}
33d00c3c:	e1a04000 	mov	r4, r0
	printf ("data abort\n");
33d00c40:	e59f0010 	ldr	r0, [pc, #16]	; 33d00c58 <do_data_abort+0x20>
33d00c44:	eb0058df 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00c48:	e1a00004 	mov	r0, r4
33d00c4c:	ebffff8f 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00c50:	e8bd4010 	pop	{r4, lr}
33d00c54:	eaffff86 	b	33d00a74 <bad_mode>
33d00c58:	33d25430 	.word	0x33d25430

33d00c5c <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
33d00c5c:	e92d4010 	push	{r4, lr}
33d00c60:	e1a04000 	mov	r4, r0
	printf ("not used\n");
33d00c64:	e59f0010 	ldr	r0, [pc, #16]	; 33d00c7c <do_not_used+0x20>
33d00c68:	eb0058d6 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00c6c:	e1a00004 	mov	r0, r4
33d00c70:	ebffff86 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00c74:	e8bd4010 	pop	{r4, lr}
33d00c78:	eaffff7d 	b	33d00a74 <bad_mode>
33d00c7c:	33d2543c 	.word	0x33d2543c

33d00c80 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
33d00c80:	e92d4010 	push	{r4, lr}
33d00c84:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
33d00c88:	e59f0010 	ldr	r0, [pc, #16]	; 33d00ca0 <do_fiq+0x20>
33d00c8c:	eb0058cd 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00c90:	e1a00004 	mov	r0, r4
33d00c94:	ebffff7d 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00c98:	e8bd4010 	pop	{r4, lr}
33d00c9c:	eaffff74 	b	33d00a74 <bad_mode>
33d00ca0:	33d25448 	.word	0x33d25448

33d00ca4 <do_irq>:
}

void do_irq (struct pt_regs *pt_regs)
{
33d00ca4:	e92d4010 	push	{r4, lr}
33d00ca8:	e1a04000 	mov	r4, r0
	/* ASSUMED to be a timer interrupt  */
	/* Just clear it - count handled in */
	/* integratorap.c                   */
	*(volatile ulong *)(CFG_TIMERBASE + 0x0C) = 0;
#else
	printf ("interrupt request\n");
33d00cac:	e59f0010 	ldr	r0, [pc, #16]	; 33d00cc4 <do_irq+0x20>
33d00cb0:	eb0058c4 	bl	33d16fc8 <printf>
	show_regs (pt_regs);
33d00cb4:	e1a00004 	mov	r0, r4
33d00cb8:	ebffff74 	bl	33d00a90 <show_regs>
	bad_mode ();
33d00cbc:	e8bd4010 	pop	{r4, lr}
33d00cc0:	eaffff6b 	b	33d00a74 <bad_mode>
33d00cc4:	33d25460 	.word	0x33d25460

33d00cc8 <interrupt_init>:
static ulong timestamp;
static ulong lastdec;


int interrupt_init (void)
{
33d00cc8:	e92d4030 	push	{r4, r5, lr}
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();

	/* use PWM Timer 4 because it has no output */
	/* prescaler for Timer 4 is 16 */
	timers->TCFG0 = 0x0f00;
	if (timer_load_val == 0)
33d00ccc:	e59f5068 	ldr	r5, [pc, #104]	; 33d00d3c <interrupt_init+0x74>
33d00cd0:	e5953000 	ldr	r3, [r5]
{
    return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
}
static inline S3C24X0_TIMERS * const S3C24X0_GetBase_TIMERS(void)
{
    return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
33d00cd4:	e3a04451 	mov	r4, #1358954496	; 0x51000000
33d00cd8:	e3530000 	cmp	r3, #0	; 0x0
{
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();

	/* use PWM Timer 4 because it has no output */
	/* prescaler for Timer 4 is 16 */
	timers->TCFG0 = 0x0f00;
33d00cdc:	e3a03c0f 	mov	r3, #3840	; 0xf00
33d00ce0:	e5843000 	str	r3, [r4]
	if (timer_load_val == 0)
33d00ce4:	1a000003 	bne	33d00cf8 <interrupt_init+0x30>
		/*
		 * for 10 ms clock period @ PCLK with 4 bit divider = 1/2
		 * (default) and prescaler = 16. Should be 10390
		 * @33.25MHz and 15625 @ 50 MHz
		 */
		timer_load_val = get_PCLK()/(2 * 16 * 100);
33d00ce8:	eb00018d 	bl	33d01324 <get_PCLK>
33d00cec:	e3a01d32 	mov	r1, #3200	; 0xc80
33d00cf0:	eb0001ba 	bl	33d013e0 <__udivsi3>
33d00cf4:	e5850000 	str	r0, [r5]
	}
	/* load value for 10 ms timeout */
	lastdec = timers->TCNTB4 = timer_load_val;
33d00cf8:	e5953000 	ldr	r3, [r5]
33d00cfc:	e584303c 	str	r3, [r4, #60]
33d00d00:	e594103c 	ldr	r1, [r4, #60]
	/* auto load, manual update of Timer 4 */
	timers->TCON = (timers->TCON & ~0x0700000) | 0x600000;
33d00d04:	e5943008 	ldr	r3, [r4, #8]
33d00d08:	e3c33607 	bic	r3, r3, #7340032	; 0x700000
33d00d0c:	e3833606 	orr	r3, r3, #6291456	; 0x600000
33d00d10:	e5843008 	str	r3, [r4, #8]
	/* auto load, start Timer 4 */
	timers->TCON = (timers->TCON & ~0x0700000) | 0x500000;
33d00d14:	e5943008 	ldr	r3, [r4, #8]
		 * @33.25MHz and 15625 @ 50 MHz
		 */
		timer_load_val = get_PCLK()/(2 * 16 * 100);
	}
	/* load value for 10 ms timeout */
	lastdec = timers->TCNTB4 = timer_load_val;
33d00d18:	e59f2020 	ldr	r2, [pc, #32]	; 33d00d40 <interrupt_init+0x78>
	/* auto load, manual update of Timer 4 */
	timers->TCON = (timers->TCON & ~0x0700000) | 0x600000;
	/* auto load, start Timer 4 */
	timers->TCON = (timers->TCON & ~0x0700000) | 0x500000;
33d00d1c:	e3c33607 	bic	r3, r3, #7340032	; 0x700000
33d00d20:	e3833605 	orr	r3, r3, #5242880	; 0x500000
		 * @33.25MHz and 15625 @ 50 MHz
		 */
		timer_load_val = get_PCLK()/(2 * 16 * 100);
	}
	/* load value for 10 ms timeout */
	lastdec = timers->TCNTB4 = timer_load_val;
33d00d24:	e5821000 	str	r1, [r2]
	/* auto load, manual update of Timer 4 */
	timers->TCON = (timers->TCON & ~0x0700000) | 0x600000;
	/* auto load, start Timer 4 */
	timers->TCON = (timers->TCON & ~0x0700000) | 0x500000;
33d00d28:	e5843008 	str	r3, [r4, #8]
	timestamp = 0;
33d00d2c:	e59f3010 	ldr	r3, [pc, #16]	; 33d00d44 <interrupt_init+0x7c>
33d00d30:	e3a00000 	mov	r0, #0	; 0x0
33d00d34:	e5830000 	str	r0, [r3]

	return (0);
}
33d00d38:	e8bd8030 	pop	{r4, r5, pc}
33d00d3c:	33d3717c 	.word	0x33d3717c
33d00d40:	33d37254 	.word	0x33d37254
33d00d44:	33d37250 	.word	0x33d37250

33d00d48 <reset_timer_masked>:
int timer_load_val = 0;

/* macro to read the 16 bit timer */
static inline ulong READ_TIMER(void)
{
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();
33d00d48:	e3a03451 	mov	r3, #1358954496	; 0x51000000
33d00d4c:	e5933040 	ldr	r3, [r3, #64]

int timer_load_val = 0;

/* macro to read the 16 bit timer */
static inline ulong READ_TIMER(void)
{
33d00d50:	e59f2018 	ldr	r2, [pc, #24]	; 33d00d70 <reset_timer_masked+0x28>
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();
33d00d54:	e1a03803 	lsl	r3, r3, #16
33d00d58:	e1a03823 	lsr	r3, r3, #16

int timer_load_val = 0;

/* macro to read the 16 bit timer */
static inline ulong READ_TIMER(void)
{
33d00d5c:	e5823000 	str	r3, [r2]

void reset_timer_masked (void)
{
	/* reset time */
	lastdec = READ_TIMER();
	timestamp = 0;
33d00d60:	e59f300c 	ldr	r3, [pc, #12]	; 33d00d74 <reset_timer_masked+0x2c>
33d00d64:	e3a02000 	mov	r2, #0	; 0x0
33d00d68:	e5832000 	str	r2, [r3]
33d00d6c:	e1a0f00e 	mov	pc, lr
33d00d70:	33d37254 	.word	0x33d37254
33d00d74:	33d37250 	.word	0x33d37250

33d00d78 <reset_timer>:
 * timer without interrupts
 */

void reset_timer (void)
{
	reset_timer_masked ();
33d00d78:	eafffff2 	b	33d00d48 <reset_timer_masked>

33d00d7c <get_timer_masked>:
	lastdec = READ_TIMER();
	timestamp = 0;
}

ulong get_timer_masked (void)
{
33d00d7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
int timer_load_val = 0;

/* macro to read the 16 bit timer */
static inline ulong READ_TIMER(void)
{
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();
33d00d80:	e3a03451 	mov	r3, #1358954496	; 0x51000000
33d00d84:	e5933040 	ldr	r3, [r3, #64]

ulong get_timer_masked (void)
{
	ulong now = READ_TIMER();

	if (lastdec >= now)
33d00d88:	e59fe04c 	ldr	lr, [pc, #76]	; 33d00ddc <get_timer_masked+0x60>
int timer_load_val = 0;

/* macro to read the 16 bit timer */
static inline ulong READ_TIMER(void)
{
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();
33d00d8c:	e1a01803 	lsl	r1, r3, #16

ulong get_timer_masked (void)
{
	ulong now = READ_TIMER();

	if (lastdec >= now)
33d00d90:	e59e2000 	ldr	r2, [lr]
int timer_load_val = 0;

/* macro to read the 16 bit timer */
static inline ulong READ_TIMER(void)
{
	S3C24X0_TIMERS * const timers = S3C24X0_GetBase_TIMERS();
33d00d94:	e1a01821 	lsr	r1, r1, #16

ulong get_timer_masked (void)
{
	ulong now = READ_TIMER();

	if (lastdec >= now)
33d00d98:	e1520001 	cmp	r2, r1
		timestamp += lastdec - now;
	}
	else
	{
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
33d00d9c:	359f303c 	ldrcc	r3, [pc, #60]	; 33d00de0 <get_timer_masked+0x64>
33d00da0:	e59f003c 	ldr	r0, [pc, #60]	; 33d00de4 <get_timer_masked+0x68>
33d00da4:	35933000 	ldrcc	r3, [r3]
	ulong now = READ_TIMER();

	if (lastdec >= now)
	{
		/* normal mode */
		timestamp += lastdec - now;
33d00da8:	25903000 	ldrcs	r3, [r0]
	}
	else
	{
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
33d00dac:	30823003 	addcc	r3, r2, r3
	ulong now = READ_TIMER();

	if (lastdec >= now)
	{
		/* normal mode */
		timestamp += lastdec - now;
33d00db0:	e061c002 	rsb	ip, r1, r2
	}
	else
	{
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
33d00db4:	35902000 	ldrcc	r2, [r0]
33d00db8:	30613003 	rsbcc	r3, r1, r3
	ulong now = READ_TIMER();

	if (lastdec >= now)
	{
		/* normal mode */
		timestamp += lastdec - now;
33d00dbc:	2083300c 	addcs	r3, r3, ip
	}
	else
	{
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
33d00dc0:	30822003 	addcc	r2, r2, r3
	ulong now = READ_TIMER();

	if (lastdec >= now)
	{
		/* normal mode */
		timestamp += lastdec - now;
33d00dc4:	25803000 	strcs	r3, [r0]
	}
	else
	{
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
33d00dc8:	35802000 	strcc	r2, [r0]
	}
	lastdec = now;

	return timestamp;
}
33d00dcc:	e59f3010 	ldr	r3, [pc, #16]	; 33d00de4 <get_timer_masked+0x68>
33d00dd0:	e5930000 	ldr	r0, [r3]
	else
	{
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
	}
	lastdec = now;
33d00dd4:	e58e1000 	str	r1, [lr]

	return timestamp;
}
33d00dd8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d00ddc:	33d37254 	.word	0x33d37254
33d00de0:	33d3717c 	.word	0x33d3717c
33d00de4:	33d37250 	.word	0x33d37250

33d00de8 <get_timer>:
{
	reset_timer_masked ();
}

ulong get_timer (ulong base)
{
33d00de8:	e92d4010 	push	{r4, lr}
33d00dec:	e1a04000 	mov	r4, r0
	return get_timer_masked () - base;
33d00df0:	ebffffe1 	bl	33d00d7c <get_timer_masked>
}
33d00df4:	e0640000 	rsb	r0, r4, r0
33d00df8:	e8bd8010 	pop	{r4, pc}

33d00dfc <set_timer>:

void set_timer (ulong t)
{
	timestamp = t;
33d00dfc:	e59f3004 	ldr	r3, [pc, #4]	; 33d00e08 <set_timer+0xc>
33d00e00:	e5830000 	str	r0, [r3]
33d00e04:	e1a0f00e 	mov	pc, lr
33d00e08:	33d37250 	.word	0x33d37250

33d00e0c <udelay>:
}

void udelay (unsigned long usec)
{
33d00e0c:	e92d4030 	push	{r4, r5, lr}
33d00e10:	e1a04000 	mov	r4, r0
	ulong tmo;
	ulong start = get_timer(0);
33d00e14:	e3a00000 	mov	r0, #0	; 0x0
33d00e18:	ebfffff2 	bl	33d00de8 <get_timer>

	tmo = usec / 1000;
33d00e1c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
}

void udelay (unsigned long usec)
{
	ulong tmo;
	ulong start = get_timer(0);
33d00e20:	e1a05000 	mov	r5, r0

	tmo = usec / 1000;
33d00e24:	e1a00004 	mov	r0, r4
33d00e28:	eb00016c 	bl	33d013e0 <__udivsi3>
	tmo *= (timer_load_val * 100);
33d00e2c:	e59f3030 	ldr	r3, [pc, #48]	; 33d00e64 <udelay+0x58>
33d00e30:	e5933000 	ldr	r3, [r3]
33d00e34:	e0000093 	mul	r0, r3, r0
33d00e38:	e0800100 	add	r0, r0, r0, lsl #2
33d00e3c:	e0800100 	add	r0, r0, r0, lsl #2
	tmo /= 1000;
33d00e40:	e1a00100 	lsl	r0, r0, #2
33d00e44:	e3a01ffa 	mov	r1, #1000	; 0x3e8
33d00e48:	eb000164 	bl	33d013e0 <__udivsi3>
33d00e4c:	e1a04000 	mov	r4, r0

	while ((ulong)(get_timer_masked () - start) < tmo)
33d00e50:	ebffffc9 	bl	33d00d7c <get_timer_masked>
33d00e54:	e0650000 	rsb	r0, r5, r0
33d00e58:	e1500004 	cmp	r0, r4
33d00e5c:	3afffffb 	bcc	33d00e50 <udelay+0x44>
33d00e60:	e8bd8030 	pop	{r4, r5, pc}
33d00e64:	33d3717c 	.word	0x33d3717c

33d00e68 <udelay_masked>:
{
	ulong tmo;
	ulong endtime;
	signed long diff;

	if (usec >= 1000)
33d00e68:	e3500ffa 	cmp	r0, #1000	; 0x3e8

	return timestamp;
}

void udelay_masked (unsigned long usec)
{
33d00e6c:	e92d4010 	push	{r4, lr}
33d00e70:	e1a02000 	mov	r2, r0
33d00e74:	e59f4060 	ldr	r4, [pc, #96]	; 33d00edc <udelay_masked+0x74>
	ulong tmo;
	ulong endtime;
	signed long diff;

	if (usec >= 1000)
33d00e78:	3a000008 	bcc	33d00ea0 <udelay_masked+0x38>
	{
		tmo = usec / 1000;
33d00e7c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
33d00e80:	eb000156 	bl	33d013e0 <__udivsi3>
		tmo *= (timer_load_val * 100);
33d00e84:	e5943000 	ldr	r3, [r4]
33d00e88:	e0000093 	mul	r0, r3, r0
33d00e8c:	e0800100 	add	r0, r0, r0, lsl #2
33d00e90:	e0800100 	add	r0, r0, r0, lsl #2
		tmo /= 1000;
33d00e94:	e1a00100 	lsl	r0, r0, #2
33d00e98:	e3a01ffa 	mov	r1, #1000	; 0x3e8
33d00e9c:	ea000005 	b	33d00eb8 <udelay_masked+0x50>
	}
	else
	{
		tmo = usec * (timer_load_val * 100);
33d00ea0:	e5943000 	ldr	r3, [r4]
33d00ea4:	e0000293 	mul	r0, r3, r2
33d00ea8:	e0800100 	add	r0, r0, r0, lsl #2
33d00eac:	e0800100 	add	r0, r0, r0, lsl #2
		tmo /= (1000*1000);
33d00eb0:	e59f1028 	ldr	r1, [pc, #40]	; 33d00ee0 <udelay_masked+0x78>
33d00eb4:	e1a00100 	lsl	r0, r0, #2
33d00eb8:	eb000148 	bl	33d013e0 <__udivsi3>
33d00ebc:	e1a04000 	mov	r4, r0
	}

	endtime = get_timer_masked () + tmo;
33d00ec0:	ebffffad 	bl	33d00d7c <get_timer_masked>
33d00ec4:	e0804004 	add	r4, r0, r4

	do
	{
		ulong now = get_timer_masked ();
33d00ec8:	ebffffab 	bl	33d00d7c <get_timer_masked>
		diff = endtime - now;
33d00ecc:	e0600004 	rsb	r0, r0, r4
	} while (diff >= 0);
33d00ed0:	e3500000 	cmp	r0, #0	; 0x0
33d00ed4:	aafffffb 	bge	33d00ec8 <udelay_masked+0x60>
33d00ed8:	e8bd8010 	pop	{r4, pc}
33d00edc:	33d3717c 	.word	0x33d3717c
33d00ee0:	000f4240 	.word	0x000f4240

33d00ee4 <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
33d00ee4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return get_timer(0);
33d00ee8:	e3a00000 	mov	r0, #0	; 0x0
33d00eec:	ebffffbd 	bl	33d00de8 <get_timer>
}
33d00ef0:	e3a01000 	mov	r1, #0	; 0x0
33d00ef4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d00ef8 <get_tbclk>:
#else
#	error "tbclk not configured"
#endif

	return tbclk;
}
33d00ef8:	e59f0000 	ldr	r0, [pc, #0]	; 33d00f00 <get_tbclk+0x8>
33d00efc:	e1a0f00e 	mov	pc, lr
33d00f00:	0017d784 	.word	0x0017d784

33d00f04 <reset_cpu>:
{
    return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
}
static inline S3C24X0_WATCHDOG * const S3C24X0_GetBase_WATCHDOG(void)
{
    return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
33d00f04:	e3a02453 	mov	r2, #1392508928	; 0x53000000
#endif

	watchdog = S3C24X0_GetBase_WATCHDOG();

	/* Disable watchdog */
	watchdog->WTCON = 0x0000;
33d00f08:	e3a03000 	mov	r3, #0	; 0x0
33d00f0c:	e5823000 	str	r3, [r2]

	/* Initialize watchdog timer count register */
	watchdog->WTCNT = 0x0001;
33d00f10:	e2833001 	add	r3, r3, #1	; 0x1
33d00f14:	e5823008 	str	r3, [r2, #8]

	/* Enable watchdog timer; assert reset at timer timeout */
	watchdog->WTCON = 0x0021;
33d00f18:	e2833020 	add	r3, r3, #32	; 0x20
33d00f1c:	e5823000 	str	r3, [r2]

	/* loop forever and wait for reset to happen */
	while(1);
33d00f20:	eafffffe 	b	33d00f20 <reset_cpu+0x1c>

33d00f24 <ClearPending>:

void IsrWatchdog(void);

void ClearPending(int bit)
{
	intregs->SRCPND = bit;
33d00f24:	e59f2010 	ldr	r2, [pc, #16]	; 33d00f3c <ClearPending+0x18>
33d00f28:	e5923000 	ldr	r3, [r2]
33d00f2c:	e5830000 	str	r0, [r3]
	intregs->INTPND = bit;
33d00f30:	e5923000 	ldr	r3, [r2]
33d00f34:	e5830010 	str	r0, [r3, #16]
33d00f38:	e1a0f00e 	mov	pc, lr
33d00f3c:	33d37248 	.word	0x33d37248

33d00f40 <Timer_InitEx>:
}

void Timer_InitEx(void)
{
33d00f40:	e92d4010 	push	{r4, lr}
	intCount=0;
	intregs->SUBSRCPND= (1<<13);
33d00f44:	e59f4040 	ldr	r4, [pc, #64]	; 33d00f8c <Timer_InitEx+0x4c>
	intregs->INTPND = bit;
}

void Timer_InitEx(void)
{
	intCount=0;
33d00f48:	e59f3040 	ldr	r3, [pc, #64]	; 33d00f90 <Timer_InitEx+0x50>
33d00f4c:	e3a02000 	mov	r2, #0	; 0x0
	intregs->SUBSRCPND= (1<<13);
33d00f50:	e5941000 	ldr	r1, [r4]
	intregs->INTPND = bit;
}

void Timer_InitEx(void)
{
	intCount=0;
33d00f54:	e5832000 	str	r2, [r3]
	intregs->SUBSRCPND= (1<<13);
33d00f58:	e3a03a02 	mov	r3, #8192	; 0x2000
33d00f5c:	e5813018 	str	r3, [r1, #24]
	ClearPending(BIT_WDT_AC97);				/*BIT_WDT*/
33d00f60:	e3a00c02 	mov	r0, #512	; 0x200
33d00f64:	ebffffee 	bl	33d00f24 <ClearPending>
	intregs->INTMSK&=~(BIT_WDT_AC97);			/*BIT_WDT*/
33d00f68:	e5942000 	ldr	r2, [r4]
33d00f6c:	e5923008 	ldr	r3, [r2, #8]
33d00f70:	e3c33c02 	bic	r3, r3, #512	; 0x200
33d00f74:	e5823008 	str	r3, [r2, #8]
	intregs->INTSUBMSK &= ~(1<<13);
33d00f78:	e5942000 	ldr	r2, [r4]
33d00f7c:	e592301c 	ldr	r3, [r2, #28]
33d00f80:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
33d00f84:	e582301c 	str	r3, [r2, #28]
33d00f88:	e8bd8010 	pop	{r4, pc}
33d00f8c:	33d37248 	.word	0x33d37248
33d00f90:	33d37258 	.word	0x33d37258

33d00f94 <Timer_StartEx>:
}


void Timer_StartEx(void)
{
33d00f94:	e92d4030 	push	{r4, r5, lr}
	S3C24X0_WATCHDOG * const wdtregs = S3C24X0_GetBase_WATCHDOG();

	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2);	// 16us
33d00f98:	e59f5048 	ldr	r5, [pc, #72]	; 33d00fe8 <Timer_StartEx+0x54>
33d00f9c:	eb0000e0 	bl	33d01324 <get_PCLK>
33d00fa0:	e1a01005 	mov	r1, r5
33d00fa4:	eb00010d 	bl	33d013e0 <__udivsi3>
33d00fa8:	e2400001 	sub	r0, r0, #1	; 0x1
	wdtregs->WTDAT=0xffff;
33d00fac:	e59f3038 	ldr	r3, [pc, #56]	; 33d00fec <Timer_StartEx+0x58>

void Timer_StartEx(void)
{
	S3C24X0_WATCHDOG * const wdtregs = S3C24X0_GetBase_WATCHDOG();

	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2);	// 16us
33d00fb0:	e1a00400 	lsl	r0, r0, #8
33d00fb4:	e3a04453 	mov	r4, #1392508928	; 0x53000000
33d00fb8:	e3800004 	orr	r0, r0, #4	; 0x4
33d00fbc:	e5840000 	str	r0, [r4]
	wdtregs->WTDAT=0xffff;
33d00fc0:	e5843004 	str	r3, [r4, #4]
	wdtregs->WTCNT=0xffff;
33d00fc4:	e5843008 	str	r3, [r4, #8]

	// 1/16/(65+1),interrupt enable,reset disable,watchdog enable
	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2)|(0<<0)|(1<<5);
33d00fc8:	eb0000d5 	bl	33d01324 <get_PCLK>
33d00fcc:	e1a01005 	mov	r1, r5
33d00fd0:	eb000102 	bl	33d013e0 <__udivsi3>
33d00fd4:	e2400001 	sub	r0, r0, #1	; 0x1
33d00fd8:	e1a00400 	lsl	r0, r0, #8
33d00fdc:	e3800024 	orr	r0, r0, #36	; 0x24
33d00fe0:	e5840000 	str	r0, [r4]
33d00fe4:	e8bd8030 	pop	{r4, r5, pc}
33d00fe8:	000f4240 	.word	0x000f4240
33d00fec:	0000ffff 	.word	0x0000ffff

33d00ff0 <Timer_StopEx>:
}

unsigned int Timer_StopEx(void)
{
33d00ff0:	e92d4010 	push	{r4, lr}
	int count;
	S3C24X0_WATCHDOG * const wdtregs = S3C24X0_GetBase_WATCHDOG();

	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8);
33d00ff4:	e59f4068 	ldr	r4, [pc, #104]	; 33d01064 <Timer_StopEx+0x74>
33d00ff8:	eb0000c9 	bl	33d01324 <get_PCLK>
33d00ffc:	e1a01004 	mov	r1, r4
33d01000:	eb0000f6 	bl	33d013e0 <__udivsi3>
33d01004:	e2400001 	sub	r0, r0, #1	; 0x1
33d01008:	e3a0c453 	mov	ip, #1392508928	; 0x53000000
33d0100c:	e1a00400 	lsl	r0, r0, #8
33d01010:	e58c0000 	str	r0, [ip]
	intregs->INTMSK|=BIT_WDT_AC97;				//BIT_WDT;
33d01014:	e59f104c 	ldr	r1, [pc, #76]	; 33d01068 <Timer_StopEx+0x78>
33d01018:	e5912000 	ldr	r2, [r1]
33d0101c:	e5923008 	ldr	r3, [r2, #8]
33d01020:	e3833c02 	orr	r3, r3, #512	; 0x200
33d01024:	e5823008 	str	r3, [r2, #8]
	intregs->INTSUBMSK |= (1<<13);
33d01028:	e5912000 	ldr	r2, [r1]
33d0102c:	e592301c 	ldr	r3, [r2, #28]
33d01030:	e3833a02 	orr	r3, r3, #8192	; 0x2000
33d01034:	e582301c 	str	r3, [r2, #28]

	count=(0xffff-wdtregs->WTCNT)+(intCount*0xffff);
33d01038:	e59f302c 	ldr	r3, [pc, #44]	; 33d0106c <Timer_StopEx+0x7c>
33d0103c:	e5930000 	ldr	r0, [r3]
33d01040:	e59c3008 	ldr	r3, [ip, #8]
33d01044:	e0600800 	rsb	r0, r0, r0, lsl #16
33d01048:	e0630000 	rsb	r0, r3, r0
33d0104c:	e2800cff 	add	r0, r0, #65280	; 0xff00
33d01050:	e28000ff 	add	r0, r0, #255	; 0xff
	return ((unsigned int)count*16/1000000);
33d01054:	e1a01004 	mov	r1, r4
33d01058:	e1a00200 	lsl	r0, r0, #4
33d0105c:	eb0000df 	bl	33d013e0 <__udivsi3>
}
33d01060:	e8bd8010 	pop	{r4, pc}
33d01064:	000f4240 	.word	0x000f4240
33d01068:	33d37248 	.word	0x33d37248
33d0106c:	33d37258 	.word	0x33d37258

33d01070 <IsrWatchdog>:


void  IsrWatchdog(void)
{
33d01070:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	intregs->SUBSRCPND	= (1<<13);
33d01074:	e59f3024 	ldr	r3, [pc, #36]	; 33d010a0 <IsrWatchdog+0x30>
33d01078:	e5932000 	ldr	r2, [r3]
33d0107c:	e3a03a02 	mov	r3, #8192	; 0x2000
33d01080:	e5823018 	str	r3, [r2, #24]
	ClearPending(BIT_WDT_AC97 /* BIT_WDT */);
33d01084:	e3a00c02 	mov	r0, #512	; 0x200
33d01088:	ebffffa5 	bl	33d00f24 <ClearPending>
	intCount++;
33d0108c:	e59f2010 	ldr	r2, [pc, #16]	; 33d010a4 <IsrWatchdog+0x34>
33d01090:	e5923000 	ldr	r3, [r2]
33d01094:	e2833001 	add	r3, r3, #1	; 0x1
33d01098:	e5823000 	str	r3, [r2]
33d0109c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d010a0:	33d37248 	.word	0x33d37248
33d010a4:	33d37258 	.word	0x33d37258

33d010a8 <IsrTimer4>:
}

int g_TimerIntHappen;
void  IsrTimer4(void)
{
33d010a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	ClearPending(BIT_TIMER4);
33d010ac:	e3a00901 	mov	r0, #16384	; 0x4000
33d010b0:	ebffff9b 	bl	33d00f24 <ClearPending>
	*(volatile int *)&g_TimerIntHappen = 1;
33d010b4:	e59f3008 	ldr	r3, [pc, #8]	; 33d010c4 <IsrTimer4+0x1c>
33d010b8:	e3a02001 	mov	r2, #1	; 0x1
33d010bc:	e5832000 	str	r2, [r3]
33d010c0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d010c4:	33d3724c 	.word	0x33d3724c

33d010c8 <Dummy_isr>:
}


void Dummy_isr(void)
{
33d010c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	printf("Dummy_isr error, interrupt number: %d, INTMSK = 0x%x\n", intregs->INTOFFSET, intregs->INTMSK);
33d010cc:	e59f3014 	ldr	r3, [pc, #20]	; 33d010e8 <Dummy_isr+0x20>
33d010d0:	e5933000 	ldr	r3, [r3]
33d010d4:	e59f0010 	ldr	r0, [pc, #16]	; 33d010ec <Dummy_isr+0x24>
33d010d8:	e5931014 	ldr	r1, [r3, #20]
33d010dc:	e5932008 	ldr	r2, [r3, #8]
33d010e0:	eb0057b8 	bl	33d16fc8 <printf>
	while(1);
33d010e4:	eafffffe 	b	33d010e4 <Dummy_isr+0x1c>
33d010e8:	33d37248 	.word	0x33d37248
33d010ec:	33d25474 	.word	0x33d25474

33d010f0 <Isr_Init>:
}

void Isr_Init(void)
{
	int i = 0;
	intregs = S3C24X0_GetBase_INTERRUPT();
33d010f0:	e59f1070 	ldr	r1, [pc, #112]	; 33d01168 <Isr_Init+0x78>
static inline S3C24X0_USB_HOST * const S3C24X0_GetBase_USB_HOST(void)
{
    return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
}
static inline S3C24X0_INTERRUPT * const S3C24X0_GetBase_INTERRUPT(void)
{
33d010f4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
	printf("Dummy_isr error, interrupt number: %d, INTMSK = 0x%x\n", intregs->INTOFFSET, intregs->INTMSK);
	while(1);
}

void Isr_Init(void)
{
33d010f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d010fc:	e5813000 	str	r3, [r1]
	int i = 0;
33d01100:	e3a02000 	mov	r2, #0	; 0x0
	intregs = S3C24X0_GetBase_INTERRUPT();

	for (i = 0; i < sizeof(isr_handle_array) / sizeof(isr_handle_array[0]); i++ )
	{
		isr_handle_array[i] = Dummy_isr;
33d01104:	e59fc060 	ldr	ip, [pc, #96]	; 33d0116c <Isr_Init+0x7c>
33d01108:	e59f3060 	ldr	r3, [pc, #96]	; 33d01170 <Isr_Init+0x80>
33d0110c:	e78c3102 	str	r3, [ip, r2, lsl #2]
void Isr_Init(void)
{
	int i = 0;
	intregs = S3C24X0_GetBase_INTERRUPT();

	for (i = 0; i < sizeof(isr_handle_array) / sizeof(isr_handle_array[0]); i++ )
33d01110:	e2822001 	add	r2, r2, #1	; 0x1
33d01114:	e3520031 	cmp	r2, #49	; 0x31
33d01118:	9afffff9 	bls	33d01104 <Isr_Init+0x14>
	{
		isr_handle_array[i] = Dummy_isr;
	}

	intregs->INTMOD=0x0;				// All=IRQ mode
33d0111c:	e5912000 	ldr	r2, [r1]
33d01120:	e3a03000 	mov	r3, #0	; 0x0
33d01124:	e5823004 	str	r3, [r2, #4]
	intregs->INTMSK=BIT_ALLMSK;			// All interrupt is masked.
33d01128:	e5912000 	ldr	r2, [r1]
33d0112c:	e2433001 	sub	r3, r3, #1	; 0x1
33d01130:	e5823008 	str	r3, [r2, #8]
	isr_handle_array[ISR_TIMER4_OFT] = IsrTimer4;
	isr_handle_array[ISR_WDT_OFT]  = IsrWatchdog;

#ifdef CONFIG_USB_DEVICE
	isr_handle_array[ISR_USBD_OFT] = IsrUsbd;
	isr_handle_array[ISR_DMA2_OFT] = IsrDma2;
33d01134:	e59f3038 	ldr	r3, [pc, #56]	; 33d01174 <Isr_Init+0x84>
33d01138:	e58c304c 	str	r3, [ip, #76]
	intregs->INTMSK=BIT_ALLMSK;			// All interrupt is masked.

	//pISR_URXD0=(unsigned)Uart0_RxInt;
	//rINTMSK=~(BIT_URXD0);				//enable UART0 RX Default value=0xffffffff

	isr_handle_array[ISR_TIMER4_OFT] = IsrTimer4;
33d0113c:	e59f3034 	ldr	r3, [pc, #52]	; 33d01178 <Isr_Init+0x88>
33d01140:	e58c3038 	str	r3, [ip, #56]
	isr_handle_array[ISR_WDT_OFT]  = IsrWatchdog;
33d01144:	e59f3030 	ldr	r3, [pc, #48]	; 33d0117c <Isr_Init+0x8c>
33d01148:	e58c3024 	str	r3, [ip, #36]

#ifdef CONFIG_USB_DEVICE
	isr_handle_array[ISR_USBD_OFT] = IsrUsbd;
33d0114c:	e59f302c 	ldr	r3, [pc, #44]	; 33d01180 <Isr_Init+0x90>
	isr_handle_array[ISR_DMA2_OFT] = IsrDma2;
	ClearPending(BIT_DMA2);
33d01150:	e3a00702 	mov	r0, #524288	; 0x80000

	isr_handle_array[ISR_TIMER4_OFT] = IsrTimer4;
	isr_handle_array[ISR_WDT_OFT]  = IsrWatchdog;

#ifdef CONFIG_USB_DEVICE
	isr_handle_array[ISR_USBD_OFT] = IsrUsbd;
33d01154:	e58c3064 	str	r3, [ip, #100]
	isr_handle_array[ISR_DMA2_OFT] = IsrDma2;
	ClearPending(BIT_DMA2);
33d01158:	ebffff71 	bl	33d00f24 <ClearPending>
	ClearPending(BIT_USBD);
33d0115c:	e3a00402 	mov	r0, #33554432	; 0x2000000
33d01160:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d01164:	eaffff6e 	b	33d00f24 <ClearPending>
33d01168:	33d37248 	.word	0x33d37248
33d0116c:	33d37180 	.word	0x33d37180
33d01170:	33d010c8 	.word	0x33d010c8
33d01174:	33d09b14 	.word	0x33d09b14
33d01178:	33d010a8 	.word	0x33d010a8
33d0117c:	33d01070 	.word	0x33d01070
33d01180:	33d09818 	.word	0x33d09818

33d01184 <IRQ_Handle>:
#endif
}


void IRQ_Handle(void)
{
33d01184:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	unsigned long oft = intregs->INTOFFSET;
33d01188:	e59fe03c 	ldr	lr, [pc, #60]	; 33d011cc <IRQ_Handle+0x48>
33d0118c:	e59e0000 	ldr	r0, [lr]
33d01190:	e5901014 	ldr	r1, [r0, #20]

//	printk("IRQ_Handle: %d\n", oft);

	//ж
	if( oft == 4 ) gpio->EINTPEND = 1<<7;		//EINT4-7IRQ4עEINTPEND[3:0]δãЩλд1ܵδ֪
	intregs->SRCPND = 1<<oft;
33d01194:	e3a03001 	mov	r3, #1	; 0x1
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

//	printk("IRQ_Handle: %d\n", oft);

	//ж
	if( oft == 4 ) gpio->EINTPEND = 1<<7;		//EINT4-7IRQ4עEINTPEND[3:0]δãЩλд1ܵδ֪
33d01198:	e3510004 	cmp	r1, #4	; 0x4
	intregs->SRCPND = 1<<oft;
33d0119c:	e1a0c113 	lsl	ip, r3, r1
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

//	printk("IRQ_Handle: %d\n", oft);

	//ж
	if( oft == 4 ) gpio->EINTPEND = 1<<7;		//EINT4-7IRQ4עEINTPEND[3:0]δãЩλд1ܵδ֪
33d011a0:	03a02080 	moveq	r2, #128	; 0x80
33d011a4:	03a03456 	moveq	r3, #1442840576	; 0x56000000
33d011a8:	058320a8 	streq	r2, [r3, #168]
	intregs->SRCPND = 1<<oft;
33d011ac:	e580c000 	str	ip, [r0]
	intregs->INTPND	= intregs->INTPND;
33d011b0:	e59e3000 	ldr	r3, [lr]
33d011b4:	e5932010 	ldr	r2, [r3, #16]
33d011b8:	e5832010 	str	r2, [r3, #16]

	/* run the isr */
	isr_handle_array[oft]();
33d011bc:	e59f300c 	ldr	r3, [pc, #12]	; 33d011d0 <IRQ_Handle+0x4c>
33d011c0:	e1a0e00f 	mov	lr, pc
33d011c4:	e793f101 	ldr	pc, [r3, r1, lsl #2]
33d011c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d011cc:	33d37248 	.word	0x33d37248
33d011d0:	33d37180 	.word	0x33d37180

33d011d4 <get_PLLCLK>:
 * the specified bus in HZ.
 */
/* ------------------------------------------------------------------------- */

static ulong get_PLLCLK(int pllreg)
{
33d011d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
    ulong r, m, p, s;

    if (pllreg == MPLL)
33d011d8:	e3500000 	cmp	r0, #0	; 0x0
{
    return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
}
static inline S3C24X0_CLOCK_POWER * const S3C24X0_GetBase_CLOCK_POWER(void)
{
    return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
33d011dc:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
    r = clk_power->MPLLCON;
33d011e0:	05920004 	ldreq	r0, [r2, #4]
static ulong get_PLLCLK(int pllreg)
{
    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
    ulong r, m, p, s;

    if (pllreg == MPLL)
33d011e4:	0a000002 	beq	33d011f4 <get_PLLCLK+0x20>
    r = clk_power->MPLLCON;
    else if (pllreg == UPLL)
33d011e8:	e3500001 	cmp	r0, #1	; 0x1
    r = clk_power->UPLLCON;
33d011ec:	05920008 	ldreq	r0, [r2, #8]
    else
    hang();
33d011f0:	1b0000cb 	blne	33d01524 <hang>

    m = ((r & 0xFF000) >> 12) + 8;
33d011f4:	e2003aff 	and	r3, r0, #1044480	; 0xff000
    p = ((r & 0x003F0) >> 4) + 2;
33d011f8:	e2002e3f 	and	r2, r0, #1008	; 0x3f0
    else if (pllreg == UPLL)
    r = clk_power->UPLLCON;
    else
    hang();

    m = ((r & 0xFF000) >> 12) + 8;
33d011fc:	e1a03623 	lsr	r3, r3, #12
    p = ((r & 0x003F0) >> 4) + 2;
33d01200:	e1a02222 	lsr	r2, r2, #4
    else if (pllreg == UPLL)
    r = clk_power->UPLLCON;
    else
    hang();

    m = ((r & 0xFF000) >> 12) + 8;
33d01204:	e2833008 	add	r3, r3, #8	; 0x8
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;
33d01208:	e2000003 	and	r0, r0, #3	; 0x3
    r = clk_power->UPLLCON;
    else
    hang();

    m = ((r & 0xFF000) >> 12) + 8;
    p = ((r & 0x003F0) >> 4) + 2;
33d0120c:	e2822002 	add	r2, r2, #2	; 0x2
33d01210:	e1a0c012 	lsl	ip, r2, r0
33d01214:	e1a02283 	lsl	r2, r3, #5
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
33d01218:	e0630002 	rsb	r0, r3, r2
    m = ((r & 0xFF000) >> 12) + 8;
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d0121c:	e5981000 	ldr	r1, [r8]
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
33d01220:	e0830100 	add	r0, r3, r0, lsl #2
    else
        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
33d01224:	e0632002 	rsb	r2, r3, r2
    m = ((r & 0xFF000) >> 12) + 8;
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d01228:	e5911014 	ldr	r1, [r1, #20]
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
    else
        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
33d0122c:	e0833102 	add	r3, r3, r2, lsl #2
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
33d01230:	e0800100 	add	r0, r0, r0, lsl #2
33d01234:	e0800100 	add	r0, r0, r0, lsl #2
    else
        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
33d01238:	e0833103 	add	r3, r3, r3, lsl #2
    m = ((r & 0xFF000) >> 12) + 8;
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d0123c:	e35100c1 	cmp	r1, #193	; 0xc1
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
33d01240:	e0600200 	rsb	r0, r0, r0, lsl #4
    else
        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
33d01244:	e0833103 	add	r3, r3, r3, lsl #2
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
33d01248:	e1a0100c 	mov	r1, ip
33d0124c:	e1a00400 	lsl	r0, r0, #8
    else
        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
33d01250:	e0633203 	rsb	r3, r3, r3, lsl #4
    m = ((r & 0xFF000) >> 12) + 8;
    p = ((r & 0x003F0) >> 4) + 2;
    s = r & 0x3;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d01254:	1a000001 	bne	33d01260 <get_PLLCLK+0x8c>
        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
33d01258:	eb000060 	bl	33d013e0 <__udivsi3>
33d0125c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    else
        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
33d01260:	e1a00483 	lsl	r0, r3, #9
33d01264:	e1a0100c 	mov	r1, ip
33d01268:	eb00005c 	bl	33d013e0 <__udivsi3>
}
33d0126c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d01270 <get_FCLK>:

/* return FCLK frequency */
ulong get_FCLK(void)
{
    return(get_PLLCLK(MPLL));
33d01270:	e3a00000 	mov	r0, #0	; 0x0
33d01274:	eaffffd6 	b	33d011d4 <get_PLLCLK>

33d01278 <get_HCLK>:
#define S3C2440_CAMDIVN_HCLK4_HALF   (1<<9)
#define S3C2440_CAMDIVN_DVSEN        (1<<12)

/* return HCLK frequency */
ulong get_HCLK(void)
{
33d01278:	e92d4010 	push	{r4, lr}
    unsigned long clkdiv;
    unsigned long camdiv;
    int hdiv = 1;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d0127c:	e5983000 	ldr	r3, [r8]
33d01280:	e5933014 	ldr	r3, [r3, #20]
33d01284:	e35300c1 	cmp	r3, #193	; 0xc1
33d01288:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
ulong get_HCLK(void)
{
    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
    unsigned long clkdiv;
    unsigned long camdiv;
    int hdiv = 1;
33d0128c:	e3a04001 	mov	r4, #1	; 0x1

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d01290:	1a000007 	bne	33d012b4 <get_HCLK+0x3c>
        return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
33d01294:	e5923014 	ldr	r3, [r2, #20]
33d01298:	e3130002 	tst	r3, #2	; 0x2
33d0129c:	0a000002 	beq	33d012ac <get_HCLK+0x34>
33d012a0:	ebfffff2 	bl	33d01270 <get_FCLK>
33d012a4:	e1a00430 	lsr	r0, r0, r4
33d012a8:	e8bd8010 	pop	{r4, pc}
            break;
        }

        return get_FCLK() / hdiv;
    }
}
33d012ac:	e8bd4010 	pop	{r4, lr}
    unsigned long camdiv;
    int hdiv = 1;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
33d012b0:	eaffffee 	b	33d01270 <get_FCLK>
    else
    {
        clkdiv = clk_power->CLKDIVN;
33d012b4:	e5923014 	ldr	r3, [r2, #20]
        camdiv = clk_power->CAMDIVN;

        /* work out clock scalings */

        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
33d012b8:	e2033006 	and	r3, r3, #6	; 0x6
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
    else
    {
        clkdiv = clk_power->CLKDIVN;
        camdiv = clk_power->CAMDIVN;
33d012bc:	e5922018 	ldr	r2, [r2, #24]

        /* work out clock scalings */

        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
33d012c0:	e3530006 	cmp	r3, #6	; 0x6
33d012c4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d012c8:	ea000011 	b	33d01314 <get_HCLK+0x9c>
33d012cc:	33d012e8 	.word	0x33d012e8
33d012d0:	33d01314 	.word	0x33d01314
33d012d4:	33d012f0 	.word	0x33d012f0
33d012d8:	33d01314 	.word	0x33d01314
33d012dc:	33d012f8 	.word	0x33d012f8
33d012e0:	33d01314 	.word	0x33d01314
33d012e4:	33d01308 	.word	0x33d01308
        case S3C2440_CLKDIVN_HDIVN_1:
            hdiv = 1;
33d012e8:	e3a04001 	mov	r4, #1	; 0x1
            break;
33d012ec:	ea000008 	b	33d01314 <get_HCLK+0x9c>

        case S3C2440_CLKDIVN_HDIVN_2:
            hdiv = 2;
33d012f0:	e3a04002 	mov	r4, #2	; 0x2
            break;
33d012f4:	ea000006 	b	33d01314 <get_HCLK+0x9c>

        case S3C2440_CLKDIVN_HDIVN_4_8:
            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
33d012f8:	e3120c02 	tst	r2, #512	; 0x200
33d012fc:	03a04004 	moveq	r4, #4	; 0x4
33d01300:	13a04008 	movne	r4, #8	; 0x8
            break;
33d01304:	ea000002 	b	33d01314 <get_HCLK+0x9c>

        case S3C2440_CLKDIVN_HDIVN_3_6:
            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
33d01308:	e3120c01 	tst	r2, #256	; 0x100
33d0130c:	03a04003 	moveq	r4, #3	; 0x3
33d01310:	13a04006 	movne	r4, #6	; 0x6
            break;
        }

        return get_FCLK() / hdiv;
33d01314:	ebffffd5 	bl	33d01270 <get_FCLK>
33d01318:	e1a01004 	mov	r1, r4
33d0131c:	eb00002f 	bl	33d013e0 <__udivsi3>
    }
}
33d01320:	e8bd8010 	pop	{r4, pc}

33d01324 <get_PCLK>:

/* return PCLK frequency */
ulong get_PCLK(void)
{
33d01324:	e92d4030 	push	{r4, r5, lr}
    unsigned long clkdiv;
    unsigned long camdiv;
    int hdiv = 1;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d01328:	e5983000 	ldr	r3, [r8]
33d0132c:	e5933014 	ldr	r3, [r3, #20]
33d01330:	e35300c1 	cmp	r3, #193	; 0xc1
33d01334:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
ulong get_PCLK(void)
{
    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
    unsigned long clkdiv;
    unsigned long camdiv;
    int hdiv = 1;
33d01338:	e3a04001 	mov	r4, #1	; 0x1

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d0133c:	1a000007 	bne	33d01360 <get_PCLK+0x3c>
        return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
33d01340:	e5923014 	ldr	r3, [r2, #20]
33d01344:	e3130001 	tst	r3, #1	; 0x1
33d01348:	0a000002 	beq	33d01358 <get_PCLK+0x34>
33d0134c:	ebffffc9 	bl	33d01278 <get_HCLK>
33d01350:	e1a00430 	lsr	r0, r0, r4
33d01354:	e8bd8030 	pop	{r4, r5, pc}
            break;
        }

        return get_FCLK() / hdiv / ((clkdiv & S3C2440_CLKDIVN_PDIVN)? 2:1);
    }        
}
33d01358:	e8bd4030 	pop	{r4, r5, lr}
    unsigned long camdiv;
    int hdiv = 1;

    /* support both of S3C2410 and S3C2440, by www.embedsky.net */
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
33d0135c:	eaffffc5 	b	33d01278 <get_HCLK>
    else
    {   
        clkdiv = clk_power->CLKDIVN;
33d01360:	e5925014 	ldr	r5, [r2, #20]
        camdiv = clk_power->CAMDIVN;

        /* work out clock scalings */

        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
33d01364:	e2053006 	and	r3, r5, #6	; 0x6
    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
        return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
    else
    {   
        clkdiv = clk_power->CLKDIVN;
        camdiv = clk_power->CAMDIVN;
33d01368:	e5922018 	ldr	r2, [r2, #24]

        /* work out clock scalings */

        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
33d0136c:	e3530006 	cmp	r3, #6	; 0x6
33d01370:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d01374:	ea000011 	b	33d013c0 <get_PCLK+0x9c>
33d01378:	33d01394 	.word	0x33d01394
33d0137c:	33d013c0 	.word	0x33d013c0
33d01380:	33d0139c 	.word	0x33d0139c
33d01384:	33d013c0 	.word	0x33d013c0
33d01388:	33d013a4 	.word	0x33d013a4
33d0138c:	33d013c0 	.word	0x33d013c0
33d01390:	33d013b4 	.word	0x33d013b4
        case S3C2440_CLKDIVN_HDIVN_1:
            hdiv = 1;
33d01394:	e3a04001 	mov	r4, #1	; 0x1
            break;
33d01398:	ea000008 	b	33d013c0 <get_PCLK+0x9c>

        case S3C2440_CLKDIVN_HDIVN_2:
            hdiv = 2;
33d0139c:	e3a04002 	mov	r4, #2	; 0x2
            break;
33d013a0:	ea000006 	b	33d013c0 <get_PCLK+0x9c>

        case S3C2440_CLKDIVN_HDIVN_4_8:
            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
33d013a4:	e3120c02 	tst	r2, #512	; 0x200
33d013a8:	03a04004 	moveq	r4, #4	; 0x4
33d013ac:	13a04008 	movne	r4, #8	; 0x8
            break;
33d013b0:	ea000002 	b	33d013c0 <get_PCLK+0x9c>

        case S3C2440_CLKDIVN_HDIVN_3_6:
            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
33d013b4:	e3120c01 	tst	r2, #256	; 0x100
33d013b8:	03a04003 	moveq	r4, #3	; 0x3
33d013bc:	13a04006 	movne	r4, #6	; 0x6
            break;
        }

        return get_FCLK() / hdiv / ((clkdiv & S3C2440_CLKDIVN_PDIVN)? 2:1);
33d013c0:	ebffffaa 	bl	33d01270 <get_FCLK>
33d013c4:	e1a01004 	mov	r1, r4
33d013c8:	eb000004 	bl	33d013e0 <__udivsi3>
33d013cc:	e3150001 	tst	r5, #1	; 0x1
33d013d0:	11a000a0 	lsrne	r0, r0, #1
33d013d4:	e8bd8030 	pop	{r4, r5, pc}

33d013d8 <get_UCLK>:
}

/* return UCLK frequency */
ulong get_UCLK(void)
{
    return(get_PLLCLK(UPLL));
33d013d8:	e3a00001 	mov	r0, #1	; 0x1
33d013dc:	eaffff7c 	b	33d011d4 <get_PLLCLK>

33d013e0 <__udivsi3>:
	.text
	.globl	 __udivsi3
	.type  __udivsi3       ,function
	.align	0
 __udivsi3      :
	cmp	divisor, #0
33d013e0:	e3510000 	cmp	r1, #0	; 0x0
	beq	Ldiv0
33d013e4:	0a00001f 	beq	33d01468 <Ldiv0>
	mov	curbit, #1
33d013e8:	e3a03001 	mov	r3, #1	; 0x1
	mov	result, #0
33d013ec:	e3a02000 	mov	r2, #0	; 0x0
	cmp	dividend, divisor
33d013f0:	e1500001 	cmp	r0, r1
	bcc	Lgot_result
33d013f4:	3a000019 	bcc	33d01460 <Lgot_result>

33d013f8 <Loop1>:
Loop1:
	@ Unless the divisor is very big, shift it up in multiples of
	@ four bits, since this is the amount of unwinding in the main
	@ division loop.  Continue shifting until the divisor is
	@ larger than the dividend.
	cmp	divisor, #0x10000000
33d013f8:	e3510201 	cmp	r1, #268435456	; 0x10000000
	cmpcc	divisor, dividend
33d013fc:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #4
33d01400:	31a01201 	lslcc	r1, r1, #4
	movcc	curbit, curbit, lsl #4
33d01404:	31a03203 	lslcc	r3, r3, #4
	bcc	Loop1
33d01408:	3afffffa 	bcc	33d013f8 <Loop1>

33d0140c <Lbignum>:
Lbignum:
	@ For very big divisors, we must shift it a bit at a time, or
	@ we will be in danger of overflowing.
	cmp	divisor, #0x80000000
33d0140c:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
	cmpcc	divisor, dividend
33d01410:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #1
33d01414:	31a01081 	lslcc	r1, r1, #1
	movcc	curbit, curbit, lsl #1
33d01418:	31a03083 	lslcc	r3, r3, #1
	bcc	Lbignum
33d0141c:	3afffffa 	bcc	33d0140c <Lbignum>

33d01420 <Loop3>:
Loop3:
	@ Test for possible subtractions, and note which bits
	@ are done in the result.  On the final pass, this may subtract
	@ too much from the dividend, but the result will be ok, since the
	@ "bit" will have been shifted out at the bottom.
	cmp	dividend, divisor
33d01420:	e1500001 	cmp	r0, r1
	subcs	dividend, dividend, divisor
33d01424:	20400001 	subcs	r0, r0, r1
	orrcs	result, result, curbit
33d01428:	21822003 	orrcs	r2, r2, r3
	cmp	dividend, divisor, lsr #1
33d0142c:	e15000a1 	cmp	r0, r1, lsr #1
	subcs	dividend, dividend, divisor, lsr #1
33d01430:	204000a1 	subcs	r0, r0, r1, lsr #1
	orrcs	result, result, curbit, lsr #1
33d01434:	218220a3 	orrcs	r2, r2, r3, lsr #1
	cmp	dividend, divisor, lsr #2
33d01438:	e1500121 	cmp	r0, r1, lsr #2
	subcs	dividend, dividend, divisor, lsr #2
33d0143c:	20400121 	subcs	r0, r0, r1, lsr #2
	orrcs	result, result, curbit, lsr #2
33d01440:	21822123 	orrcs	r2, r2, r3, lsr #2
	cmp	dividend, divisor, lsr #3
33d01444:	e15001a1 	cmp	r0, r1, lsr #3
	subcs	dividend, dividend, divisor, lsr #3
33d01448:	204001a1 	subcs	r0, r0, r1, lsr #3
	orrcs	result, result, curbit, lsr #3
33d0144c:	218221a3 	orrcs	r2, r2, r3, lsr #3
	cmp	dividend, #0			@ Early termination?
33d01450:	e3500000 	cmp	r0, #0	; 0x0
	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
33d01454:	11b03223 	lsrsne	r3, r3, #4
	movne	divisor, divisor, lsr #4
33d01458:	11a01221 	lsrne	r1, r1, #4
	bne	Loop3
33d0145c:	1affffef 	bne	33d01420 <Loop3>

33d01460 <Lgot_result>:
Lgot_result:
	mov	r0, result
33d01460:	e1a00002 	mov	r0, r2
	mov 	pc, lr
33d01464:	e1a0f00e 	mov	pc, lr

33d01468 <Ldiv0>:
Ldiv0:
	str	lr, [sp, #-4]!
33d01468:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	bl	 __div0       (PLT)
33d0146c:	eb0001a4 	bl	33d01b04 <__div0>
	mov	r0, #0			@ about as wrong as it could be
33d01470:	e3a00000 	mov	r0, #0	; 0x0
	ldmia	sp!, {pc}
33d01474:	e8bd8000 	pop	{pc}

33d01478 <sbrk>:
			mem_malloc_end - mem_malloc_start);
}

void *sbrk (ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
33d01478:	e59fc030 	ldr	ip, [pc, #48]	; 33d014b0 <sbrk+0x38>
	ulong new = old + increment;

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
33d0147c:	e59f3030 	ldr	r3, [pc, #48]	; 33d014b4 <sbrk+0x3c>
			mem_malloc_end - mem_malloc_start);
}

void *sbrk (ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
33d01480:	e59c1000 	ldr	r1, [ip]
	ulong new = old + increment;

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
33d01484:	e5933000 	ldr	r3, [r3]
}

void *sbrk (ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
	ulong new = old + increment;
33d01488:	e0812000 	add	r2, r1, r0

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
33d0148c:	e1520003 	cmp	r2, r3
		return (NULL);
33d01490:	e3a00000 	mov	r0, #0	; 0x0
void *sbrk (ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
	ulong new = old + increment;

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
33d01494:	31a0f00e 	movcc	pc, lr
33d01498:	e59f3018 	ldr	r3, [pc, #24]	; 33d014b8 <sbrk+0x40>
33d0149c:	e5933000 	ldr	r3, [r3]
33d014a0:	e1520003 	cmp	r2, r3
		return (NULL);
	}
	mem_malloc_brk = new;

	return ((void *) old);
33d014a4:	91a00001 	movls	r0, r1
	ulong new = old + increment;

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
		return (NULL);
	}
	mem_malloc_brk = new;
33d014a8:	958c2000 	strls	r2, [ip]

	return ((void *) old);
}
33d014ac:	e1a0f00e 	mov	pc, lr
33d014b0:	33d37260 	.word	0x33d37260
33d014b4:	33d37268 	.word	0x33d37268
33d014b8:	33d37264 	.word	0x33d37264

33d014bc <init_baudrate>:
 * or dropped completely,
 * but let's get it working (again) first...
 */

static int init_baudrate (void)
{
33d014bc:	e92d4010 	push	{r4, lr}
33d014c0:	e24dd040 	sub	sp, sp, #64	; 0x40
	char tmp[64];	/* long enough for environment variables */
	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
33d014c4:	e1a0100d 	mov	r1, sp
33d014c8:	e3a02040 	mov	r2, #64	; 0x40
33d014cc:	e59f0034 	ldr	r0, [pc, #52]	; 33d01508 <init_baudrate+0x4c>
33d014d0:	eb0050fd 	bl	33d158cc <getenv_r>
	gd->bd->bi_baudrate = gd->baudrate = (i > 0)
33d014d4:	e3a01000 	mov	r1, #0	; 0x0
33d014d8:	e1500001 	cmp	r0, r1
33d014dc:	e3a0200a 	mov	r2, #10	; 0xa
33d014e0:	e1a0000d 	mov	r0, sp
33d014e4:	e5984000 	ldr	r4, [r8]
33d014e8:	d59f001c 	ldrle	r0, [pc, #28]	; 33d0150c <init_baudrate+0x50>
33d014ec:	cb00641a 	blgt	33d1a55c <simple_strtoul>
33d014f0:	e5880008 	str	r0, [r8, #8]
33d014f4:	e5983008 	ldr	r3, [r8, #8]
			? (int) simple_strtoul (tmp, NULL, 10)
			: CONFIG_BAUDRATE;

	return (0);
}
33d014f8:	e3a00000 	mov	r0, #0	; 0x0

static int init_baudrate (void)
{
	char tmp[64];	/* long enough for environment variables */
	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
	gd->bd->bi_baudrate = gd->baudrate = (i > 0)
33d014fc:	e5843000 	str	r3, [r4]
			? (int) simple_strtoul (tmp, NULL, 10)
			: CONFIG_BAUDRATE;

	return (0);
}
33d01500:	e28dd040 	add	sp, sp, #64	; 0x40
33d01504:	e8bd8010 	pop	{r4, pc}
33d01508:	33d254ac 	.word	0x33d254ac
33d0150c:	0001c200 	.word	0x0001c200

33d01510 <display_banner>:
	debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
}
33d01510:	e3a00000 	mov	r0, #0	; 0x0
33d01514:	e1a0f00e 	mov	pc, lr

33d01518 <display_dram_config>:
	}
#else
	ulong size = 0;

	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
		size += gd->bd->bi_dram[i].size;
33d01518:	e5983000 	ldr	r3, [r8]
//	puts("DRAM:  ");				//HJ
//	print_size(size, "\n");			//HJ
#endif

	return (0);
}
33d0151c:	e3a00000 	mov	r0, #0	; 0x0
33d01520:	e1a0f00e 	mov	pc, lr

33d01524 <hang>:
	/* NOTREACHED - no way out of command loop except booting */
}

void hang (void)
{
	puts ("### ERROR ### Please RESET the board ###\n");
33d01524:	e59f0004 	ldr	r0, [pc, #4]	; 33d01530 <hang+0xc>
33d01528:	eb00569f 	bl	33d16fac <puts>
	for (;;);
33d0152c:	eafffffe 	b	33d0152c <hang+0x8>
33d01530:	33d254b8 	.word	0x33d254b8

33d01534 <start_armboot>:
	display_dram_config,
	NULL,
};

void start_armboot (void)
{
33d01534:	e92d4070 	push	{r4, r5, r6, lr}
	init_fnc_t **init_fnc_ptr;
	char *s;
	char buf1[10];
	char buf2[15];
	buf1[0] = 'E';
33d01538:	e3a03045 	mov	r3, #69	; 0x45
	display_dram_config,
	NULL,
};

void start_armboot (void)
{
33d0153c:	e24dd060 	sub	sp, sp, #96	; 0x60
	init_fnc_t **init_fnc_ptr;
	char *s;
	char buf1[10];
	char buf2[15];
	buf1[0] = 'E';
33d01540:	e5cd3054 	strb	r3, [sp, #84]
	buf1[1] = 'm';
33d01544:	e2833028 	add	r3, r3, #40	; 0x28
33d01548:	e5cd3055 	strb	r3, [sp, #85]
	buf1[2] = 'b';
33d0154c:	e243300b 	sub	r3, r3, #11	; 0xb
33d01550:	e5cd3056 	strb	r3, [sp, #86]
	buf1[3] = 'e';
33d01554:	e2833003 	add	r3, r3, #3	; 0x3
33d01558:	e5cd3057 	strb	r3, [sp, #87]
	buf1[4] = 'd';
33d0155c:	e2433001 	sub	r3, r3, #1	; 0x1
33d01560:	e5cd3058 	strb	r3, [sp, #88]
	buf1[5] = 'S';
	buf1[6] = 'k';
33d01564:	e2833007 	add	r3, r3, #7	; 0x7
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
33d01568:	e59f5224 	ldr	r5, [pc, #548]	; 33d01794 <start_armboot+0x260>
	buf1[1] = 'm';
	buf1[2] = 'b';
	buf1[3] = 'e';
	buf1[4] = 'd';
	buf1[5] = 'S';
	buf1[6] = 'k';
33d0156c:	e5cd305a 	strb	r3, [sp, #90]
	buf1[7] = 'y';
33d01570:	e283300e 	add	r3, r3, #14	; 0xe
33d01574:	e5cd305b 	strb	r3, [sp, #91]
	buf1[8] = '\0';
    
	buf2[0] = 'S';
	buf2[1] = 'K';
33d01578:	e243302e 	sub	r3, r3, #46	; 0x2e
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
33d0157c:	e5952000 	ldr	r2, [r5]
	buf1[6] = 'k';
	buf1[7] = 'y';
	buf1[8] = '\0';
    
	buf2[0] = 'S';
	buf2[1] = 'K';
33d01580:	e5cd3045 	strb	r3, [sp, #69]
	buf2[2] = 'Y';
33d01584:	e283300e 	add	r3, r3, #14	; 0xe
33d01588:	e5cd3046 	strb	r3, [sp, #70]
	buf2[3] = '2';
	buf2[4] = '4';
	buf2[5] = '4';
	buf2[6] = '0';
	buf2[7] = '/';
33d0158c:	e243302a 	sub	r3, r3, #42	; 0x2a
33d01590:	e5cd304b 	strb	r3, [sp, #75]
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
33d01594:	e2422701 	sub	r2, r2, #262144	; 0x40000
	buf2[3] = '2';
	buf2[4] = '4';
	buf2[5] = '4';
	buf2[6] = '0';
	buf2[7] = '/';
	buf2[8] = 'T';
33d01598:	e2833025 	add	r3, r3, #37	; 0x25
    
	buf2[0] = 'S';
	buf2[1] = 'K';
	buf2[2] = 'Y';
	buf2[3] = '2';
	buf2[4] = '4';
33d0159c:	e3a01034 	mov	r1, #52	; 0x34
	buf1[0] = 'E';
	buf1[1] = 'm';
	buf1[2] = 'b';
	buf1[3] = 'e';
	buf1[4] = 'd';
	buf1[5] = 'S';
33d015a0:	e3a0c053 	mov	ip, #83	; 0x53
	buf1[6] = 'k';
	buf1[7] = 'y';
	buf1[8] = '\0';
33d015a4:	e3a04000 	mov	r4, #0	; 0x0
    
	buf2[0] = 'S';
	buf2[1] = 'K';
	buf2[2] = 'Y';
	buf2[3] = '2';
33d015a8:	e3a00032 	mov	r0, #50	; 0x32
	buf2[4] = '4';
	buf2[5] = '4';
	buf2[6] = '0';
33d015ac:	e3a0e030 	mov	lr, #48	; 0x30
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
33d015b0:	e2422024 	sub	r2, r2, #36	; 0x24
	buf2[3] = '2';
	buf2[4] = '4';
	buf2[5] = '4';
	buf2[6] = '0';
	buf2[7] = '/';
	buf2[8] = 'T';
33d015b4:	e5cd304c 	strb	r3, [sp, #76]
	buf2[9] = 'Q';
33d015b8:	e2433003 	sub	r3, r3, #3	; 0x3
	buf1[5] = 'S';
	buf1[6] = 'k';
	buf1[7] = 'y';
	buf1[8] = '\0';
    
	buf2[0] = 'S';
33d015bc:	e5cdc044 	strb	ip, [sp, #68]
	buf2[4] = '4';
	buf2[5] = '4';
	buf2[6] = '0';
	buf2[7] = '/';
	buf2[8] = 'T';
	buf2[9] = 'Q';
33d015c0:	e5cd304d 	strb	r3, [sp, #77]
	buf2[10] = '2';
33d015c4:	e5cd004e 	strb	r0, [sp, #78]
	buf2[11] = '4';
	buf2[12] = '4';
33d015c8:	e5cd1050 	strb	r1, [sp, #80]
	buf2[13] = '0';
33d015cc:	e5cde051 	strb	lr, [sp, #81]
	buf1[0] = 'E';
	buf1[1] = 'm';
	buf1[2] = 'b';
	buf1[3] = 'e';
	buf1[4] = 'd';
	buf1[5] = 'S';
33d015d0:	e5cdc059 	strb	ip, [sp, #89]
	buf1[8] = '\0';
    
	buf2[0] = 'S';
	buf2[1] = 'K';
	buf2[2] = 'Y';
	buf2[3] = '2';
33d015d4:	e5cd0047 	strb	r0, [sp, #71]
	buf2[4] = '4';
33d015d8:	e5cd1048 	strb	r1, [sp, #72]
	buf2[5] = '4';
33d015dc:	e5cd1049 	strb	r1, [sp, #73]
	buf2[6] = '0';
33d015e0:	e5cde04a 	strb	lr, [sp, #74]
	buf2[7] = '/';
	buf2[8] = 'T';
	buf2[9] = 'Q';
	buf2[10] = '2';
	buf2[11] = '4';
33d015e4:	e5cd104f 	strb	r1, [sp, #79]
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
33d015e8:	e1a08002 	mov	r8, r2
	buf1[3] = 'e';
	buf1[4] = 'd';
	buf1[5] = 'S';
	buf1[6] = 'k';
	buf1[7] = 'y';
	buf1[8] = '\0';
33d015ec:	e5cd405c 	strb	r4, [sp, #92]
	buf2[9] = 'Q';
	buf2[10] = '2';
	buf2[11] = '4';
	buf2[12] = '4';
	buf2[13] = '0';
	buf2[14] = '\0';
33d015f0:	e5cd4052 	strb	r4, [sp, #82]
	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset ((void*)gd, 0, sizeof (gd_t));
33d015f4:	e3a02024 	mov	r2, #36	; 0x24
33d015f8:	e1a01004 	mov	r1, r4
33d015fc:	e1a00008 	mov	r0, r8
33d01600:	eb006363 	bl	33d1a394 <memset>
	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
33d01604:	e2483024 	sub	r3, r8, #36	; 0x24
33d01608:	e5883000 	str	r3, [r8]
	memset (gd->bd, 0, sizeof (bd_t));
33d0160c:	e1a01004 	mov	r1, r4
33d01610:	e3a02024 	mov	r2, #36	; 0x24
33d01614:	e5980000 	ldr	r0, [r8]
33d01618:	eb00635d 	bl	33d1a394 <memset>

	monitor_flash_len = _bss_start - _armboot_start;
33d0161c:	e59f3174 	ldr	r3, [pc, #372]	; 33d01798 <start_armboot+0x264>
33d01620:	e5932000 	ldr	r2, [r3]
33d01624:	e5953000 	ldr	r3, [r5]

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
33d01628:	e59f416c 	ldr	r4, [pc, #364]	; 33d0179c <start_armboot+0x268>

	memset ((void*)gd, 0, sizeof (gd_t));
	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
	memset (gd->bd, 0, sizeof (bd_t));

	monitor_flash_len = _bss_start - _armboot_start;
33d0162c:	e0632002 	rsb	r2, r3, r2
33d01630:	e59f3168 	ldr	r3, [pc, #360]	; 33d017a0 <start_armboot+0x26c>

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
33d01634:	e5941000 	ldr	r1, [r4]

	memset ((void*)gd, 0, sizeof (gd_t));
	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
	memset (gd->bd, 0, sizeof (bd_t));

	monitor_flash_len = _bss_start - _armboot_start;
33d01638:	e5832000 	str	r2, [r3]

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
33d0163c:	e3510000 	cmp	r1, #0	; 0x0
33d01640:	0a000006 	beq	33d01660 <start_armboot+0x12c>
		if ((*init_fnc_ptr)() != 0) {
33d01644:	e1a0e00f 	mov	lr, pc
33d01648:	e594f000 	ldr	pc, [r4]
33d0164c:	e3500000 	cmp	r0, #0	; 0x0
			hang ();
33d01650:	1bffffb3 	blne	33d01524 <hang>
	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
	memset (gd->bd, 0, sizeof (bd_t));

	monitor_flash_len = _bss_start - _armboot_start;

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
33d01654:	e5b43004 	ldr	r3, [r4, #4]!
33d01658:	e3530000 	cmp	r3, #0	; 0x0
33d0165c:	eafffff7 	b	33d01640 <start_armboot+0x10c>
		}
	}

#ifndef CFG_NO_FLASH
	/* configure available FLASH banks */
	size = flash_init ();
33d01660:	eb0070f6 	bl	33d1da40 <flash_init>
static ulong mem_malloc_end = 0;
static ulong mem_malloc_brk = 0;

static
void mem_malloc_init (ulong dest_addr)
{
33d01664:	e595c000 	ldr	ip, [r5]
	mem_malloc_start = dest_addr;
33d01668:	e59f3134 	ldr	r3, [pc, #308]	; 33d017a4 <start_armboot+0x270>
static ulong mem_malloc_end = 0;
static ulong mem_malloc_brk = 0;

static
void mem_malloc_init (ulong dest_addr)
{
33d0166c:	e24ce701 	sub	lr, ip, #262144	; 0x40000
	mem_malloc_start = dest_addr;
33d01670:	e583e000 	str	lr, [r3]
	mem_malloc_end = dest_addr + CFG_MALLOC_LEN;
33d01674:	e59f312c 	ldr	r3, [pc, #300]	; 33d017a8 <start_armboot+0x274>
33d01678:	e583c000 	str	ip, [r3]
	mem_malloc_brk = mem_malloc_start;
33d0167c:	e59f3128 	ldr	r3, [pc, #296]	; 33d017ac <start_armboot+0x278>

	memset ((void *) mem_malloc_start, 0,
33d01680:	e06e200c 	rsb	r2, lr, ip
33d01684:	e1a0000e 	mov	r0, lr
33d01688:	e3a01000 	mov	r1, #0	; 0x0
static
void mem_malloc_init (ulong dest_addr)
{
	mem_malloc_start = dest_addr;
	mem_malloc_end = dest_addr + CFG_MALLOC_LEN;
	mem_malloc_brk = mem_malloc_start;
33d0168c:	e583e000 	str	lr, [r3]

	memset ((void *) mem_malloc_start, 0,
33d01690:	eb00633f 	bl	33d1a394 <memset>
	/* armboot_start is defined in the board-specific linker script */
	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);

#if (CONFIG_COMMANDS & CFG_CMD_NAND)
//	puts ("NAND:  ");						//HJ
	nand_init();		/* go init the NAND */
33d01694:	eb000c3e 	bl	33d04794 <nand_init>
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	env_relocate ();
33d01698:	eb005b72 	bl	33d18468 <env_relocate>
	/* must do this after the framebuffer is allocated */
	drv_vfd_init();
#endif /* CONFIG_VFD */

	/* IP Address */
	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
33d0169c:	e59f010c 	ldr	r0, [pc, #268]	; 33d017b0 <start_armboot+0x27c>
33d016a0:	e5984000 	ldr	r4, [r8]
33d016a4:	eb00052e 	bl	33d02b64 <getenv_IPaddr>
		int i;
		ulong reg;
		char *s, *e;
		char tmp[64];

		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
33d016a8:	e28d5004 	add	r5, sp, #4	; 0x4
	/* must do this after the framebuffer is allocated */
	drv_vfd_init();
#endif /* CONFIG_VFD */

	/* IP Address */
	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
33d016ac:	e5840004 	str	r0, [r4, #4]
		int i;
		ulong reg;
		char *s, *e;
		char tmp[64];

		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
33d016b0:	e1a01005 	mov	r1, r5
33d016b4:	e59f00f8 	ldr	r0, [pc, #248]	; 33d017b4 <start_armboot+0x280>
33d016b8:	e3a02040 	mov	r2, #64	; 0x40
33d016bc:	eb005082 	bl	33d158cc <getenv_r>
		s = (i > 0) ? tmp : NULL;
33d016c0:	e3500000 	cmp	r0, #0	; 0x0
33d016c4:	c1a04005 	movgt	r4, r5
33d016c8:	d3a04000 	movle	r4, #0	; 0x0

		for (reg = 0; reg < 6; ++reg) {
33d016cc:	e3a06000 	mov	r6, #0	; 0x0
			gd->bd->bi_enetaddr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
33d016d0:	e5983000 	ldr	r3, [r8]
33d016d4:	e3540000 	cmp	r4, #0	; 0x0
33d016d8:	e0863003 	add	r3, r6, r3
33d016dc:	e1a00004 	mov	r0, r4
33d016e0:	e1a0100d 	mov	r1, sp
33d016e4:	e3a02010 	mov	r2, #16	; 0x10
33d016e8:	e2835008 	add	r5, r3, #8	; 0x8
33d016ec:	01a00004 	moveq	r0, r4
33d016f0:	1b006399 	blne	33d1a55c <simple_strtoul>
			if (s)
33d016f4:	e3540000 	cmp	r4, #0	; 0x0
		char tmp[64];

		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
		s = (i > 0) ? tmp : NULL;

		for (reg = 0; reg < 6; ++reg) {
33d016f8:	e2866001 	add	r6, r6, #1	; 0x1
			gd->bd->bi_enetaddr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
33d016fc:	e5c50000 	strb	r0, [r5]
			if (s)
33d01700:	0a000004 	beq	33d01718 <start_armboot+0x1e4>
				s = (*e) ? e + 1 : e;
33d01704:	e59d2000 	ldr	r2, [sp]
33d01708:	e5d23000 	ldrb	r3, [r2]
33d0170c:	e3530000 	cmp	r3, #0	; 0x0
33d01710:	01a04002 	moveq	r4, r2
33d01714:	12824001 	addne	r4, r2, #1	; 0x1
		char tmp[64];

		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
		s = (i > 0) ? tmp : NULL;

		for (reg = 0; reg < 6; ++reg) {
33d01718:	e3560005 	cmp	r6, #5	; 0x5
33d0171c:	9affffeb 	bls	33d016d0 <start_armboot+0x19c>
				s = (*e) ? e + 1 : e;
		}
#endif
	}

	devices_init ();	/* get the devices list going. */
33d01720:	eb0056d5 	bl	33d1727c <devices_init>

#ifdef CONFIG_CMC_PU2
	load_sernum_ethaddr ();
#endif /* CONFIG_CMC_PU2 */

	jumptable_init ();
33d01724:	eb005bf7 	bl	33d18708 <jumptable_init>

	console_init_r ();	/* fully init console as a device */
33d01728:	eb00568f 	bl	33d1716c <console_init_r>
	/* miscellaneous platform dependent initialisations */
	misc_init_r ();
#endif

	/* enable exceptions */
	enable_interrupts ();
33d0172c:	ebfffcc5 	bl	33d00a48 <enable_interrupts>

	/* add by www.embedsky.net */
	printf("\n\r\n##### %s BIOS for %s #####\r\n", buf1, buf2);
33d01730:	e59f0080 	ldr	r0, [pc, #128]	; 33d017b8 <start_armboot+0x284>
33d01734:	e28d1054 	add	r1, sp, #84	; 0x54
33d01738:	e28d2044 	add	r2, sp, #68	; 0x44
33d0173c:	eb005621 	bl	33d16fc8 <printf>
	usb_init();
33d01740:	eb0024bb 	bl	33d0aa34 <usb_init>
		smc_set_mac_addr(gd->bd->bi_enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	if ((s = getenv ("loadaddr")) != NULL) {
33d01744:	e59f0070 	ldr	r0, [pc, #112]	; 33d017bc <start_armboot+0x288>
33d01748:	eb005040 	bl	33d15850 <getenv>
33d0174c:	e3500000 	cmp	r0, #0	; 0x0
33d01750:	0a000004 	beq	33d01768 <start_armboot+0x234>
		load_addr = simple_strtoul (s, NULL, 16);
33d01754:	e3a01000 	mov	r1, #0	; 0x0
33d01758:	e3a02010 	mov	r2, #16	; 0x10
33d0175c:	eb00637e 	bl	33d1a55c <simple_strtoul>
33d01760:	e59f3058 	ldr	r3, [pc, #88]	; 33d017c0 <start_armboot+0x28c>
33d01764:	e5830000 	str	r0, [r3]
	}
#if (CONFIG_COMMANDS & CFG_CMD_NET)
	if ((s = getenv ("bootfile")) != NULL) {
33d01768:	e59f0054 	ldr	r0, [pc, #84]	; 33d017c4 <start_armboot+0x290>
33d0176c:	eb005037 	bl	33d15850 <getenv>
33d01770:	e3500000 	cmp	r0, #0	; 0x0
		copy_filename (BootFile, s, sizeof (BootFile));
33d01774:	11a01000 	movne	r1, r0
33d01778:	13a02080 	movne	r2, #128	; 0x80
33d0177c:	159f0044 	ldrne	r0, [pc, #68]	; 33d017c8 <start_armboot+0x294>
33d01780:	1b00030e 	blne	33d023c0 <copy_filename>
#endif
#if (CONFIG_COMMANDS & CFG_CMD_NET)
#if defined(CONFIG_NET_MULTI)
	puts ("Net:   ");
#endif
	eth_initialize(gd->bd);
33d01784:	e5980000 	ldr	r0, [r8]
33d01788:	eb000a25 	bl	33d04024 <eth_initialize>
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;)
	{
		main_loop ();
33d0178c:	eb002e27 	bl	33d0d030 <main_loop>
#endif
	eth_initialize(gd->bd);
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;)
33d01790:	eafffffd 	b	33d0178c <start_armboot+0x258>
33d01794:	33d00044 	.word	0x33d00044
33d01798:	33d00048 	.word	0x33d00048
33d0179c:	33d2dd7c 	.word	0x33d2dd7c
33d017a0:	33d3725c 	.word	0x33d3725c
33d017a4:	33d37268 	.word	0x33d37268
33d017a8:	33d37264 	.word	0x33d37264
33d017ac:	33d37260 	.word	0x33d37260
33d017b0:	33d254e4 	.word	0x33d254e4
33d017b4:	33d254ec 	.word	0x33d254ec
33d017b8:	33d254f4 	.word	0x33d254f4
33d017bc:	33d25514 	.word	0x33d25514
33d017c0:	33d35fec 	.word	0x33d35fec
33d017c4:	33d25520 	.word	0x33d25520
33d017c8:	33d37340 	.word	0x33d37340

33d017cc <cache_clean_invalidate>:
	: "memory", "cc");					\
	})

static inline void cpu_arm920_cache_clean_invalidate_all(void)
{
__asm__(
33d017cc:	e3a01000 	mov	r1, #0	; 0x0
33d017d0:	e3a010e0 	mov	r1, #224	; 0xe0
33d017d4:	e381333f 	orr	r3, r1, #-67108864	; 0xfc000000
33d017d8:	ee073f5e 	mcr	15, 0, r3, cr7, cr14, {2}
33d017dc:	e2533301 	subs	r3, r3, #67108864	; 0x4000000
33d017e0:	2afffffc 	bcs	33d017d8 <cache_clean_invalidate+0xc>
33d017e4:	e2511020 	subs	r1, r1, #32	; 0x20
33d017e8:	2afffff9 	bcs	33d017d4 <cache_clean_invalidate+0x8>
33d017ec:	ee071f15 	mcr	15, 0, r1, cr7, cr5, {0}
33d017f0:	ee071f9a 	mcr	15, 0, r1, cr7, cr10, {4}
33d017f4:	e1a0f00e 	mov	pc, lr

33d017f8 <tlb_invalidate>:
	cpu_arm920_cache_clean_invalidate_all();
}

static inline void cpu_arm920_tlb_invalidate_all(void)
{
	__asm__(
33d017f8:	e3a00000 	mov	r0, #0	; 0x0
33d017fc:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
33d01800:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
33d01804:	e1a0f00e 	mov	pc, lr

33d01808 <call_linux>:
	cpu_arm920_tlb_invalidate_all();
}


void  call_linux(long a0, long a1, long a2)
{
33d01808:	e92d4070 	push	{r4, r5, r6, lr}
33d0180c:	e1a06000 	mov	r6, r0
33d01810:	e1a05001 	mov	r5, r1
33d01814:	e1a04002 	mov	r4, r2
 	local_irq_disable();
33d01818:	e10f3000 	mrs	r3, CPSR
33d0181c:	e3833080 	orr	r3, r3, #128	; 0x80
33d01820:	e121f003 	msr	CPSR_c, r3
	cache_clean_invalidate();
33d01824:	ebffffe8 	bl	33d017cc <cache_clean_invalidate>
	tlb_invalidate();
33d01828:	ebfffff2 	bl	33d017f8 <tlb_invalidate>

__asm__(
33d0182c:	e1a00006 	mov	r0, r6
33d01830:	e1a01005 	mov	r1, r5
33d01834:	e1a02004 	mov	r2, r4
33d01838:	e3a0c000 	mov	ip, #0	; 0x0
33d0183c:	ee0dcf10 	mcr	15, 0, ip, cr13, cr0, {0}
33d01840:	ee07cf17 	mcr	15, 0, ip, cr7, cr7, {0}
33d01844:	ee07cf9a 	mcr	15, 0, ip, cr7, cr10, {4}
33d01848:	ee08cf17 	mcr	15, 0, ip, cr8, cr7, {0}
33d0184c:	ee11cf10 	mrc	15, 0, ip, cr1, cr0, {0}
33d01850:	e3ccc001 	bic	ip, ip, #1	; 0x1
33d01854:	ee01cf10 	mcr	15, 0, ip, cr1, cr0, {0}
33d01858:	e1a0f002 	mov	pc, r2
33d0185c:	e1a00000 	nop			(mov r0,r0)
33d01860:	e1a00000 	nop			(mov r0,r0)
33d01864:	e8bd8070 	pop	{r4, r5, r6, pc}

33d01868 <setup_linux_param>:

/*
 * pram_base: base address of linux paramter
 */
static void setup_linux_param(ulong param_base)
{
33d01868:	e92d4030 	push	{r4, r5, lr}
	struct param_struct *params = (struct param_struct *)param_base; 
	char *linux_cmd;

//	printf("Setup linux parameters at 0x%08lx\n", param_base);
	memset(params, 0, sizeof(struct param_struct));
33d0186c:	e3a01000 	mov	r1, #0	; 0x0
33d01870:	e3a02c09 	mov	r2, #2304	; 0x900

/*
 * pram_base: base address of linux paramter
 */
static void setup_linux_param(ulong param_base)
{
33d01874:	e1a04000 	mov	r4, r0
	struct param_struct *params = (struct param_struct *)param_base; 
	char *linux_cmd;

//	printf("Setup linux parameters at 0x%08lx\n", param_base);
	memset(params, 0, sizeof(struct param_struct));
33d01878:	eb0062c5 	bl	33d1a394 <memset>

	params->u1.s.page_size = LINUX_PAGE_SIZE;
33d0187c:	e3a03a01 	mov	r3, #4096	; 0x1000
33d01880:	e5843000 	str	r3, [r4]
	params->u1.s.nr_pages = (DRAM_SIZE >> LINUX_PAGE_SHIFT);
33d01884:	e2833a03 	add	r3, r3, #12288	; 0x3000
33d01888:	e5843004 	str	r3, [r4, #4]

	/* set linux command line */
	linux_cmd = getenv ("bootargs");
33d0188c:	e59f0030 	ldr	r0, [pc, #48]	; 33d018c4 <setup_linux_param+0x5c>
33d01890:	eb004fee 	bl	33d15850 <getenv>
	if (linux_cmd == NULL) {
		printf("Wrong magic: could not found linux command line\n");
	} else {
		memcpy(params->commandline, linux_cmd, strlen(linux_cmd) + 1);
33d01894:	e2845c05 	add	r5, r4, #1280	; 0x500
	params->u1.s.page_size = LINUX_PAGE_SIZE;
	params->u1.s.nr_pages = (DRAM_SIZE >> LINUX_PAGE_SHIFT);

	/* set linux command line */
	linux_cmd = getenv ("bootargs");
	if (linux_cmd == NULL) {
33d01898:	e2504000 	subs	r4, r0, #0	; 0x0
33d0189c:	1a000002 	bne	33d018ac <setup_linux_param+0x44>
		printf("Wrong magic: could not found linux command line\n");
33d018a0:	e59f0020 	ldr	r0, [pc, #32]	; 33d018c8 <setup_linux_param+0x60>
	} else {
		memcpy(params->commandline, linux_cmd, strlen(linux_cmd) + 1);
//		printf("linux command line is: \"%s\"\n", linux_cmd);
	}
}
33d018a4:	e8bd4030 	pop	{r4, r5, lr}
	params->u1.s.nr_pages = (DRAM_SIZE >> LINUX_PAGE_SHIFT);

	/* set linux command line */
	linux_cmd = getenv ("bootargs");
	if (linux_cmd == NULL) {
		printf("Wrong magic: could not found linux command line\n");
33d018a8:	ea0055c6 	b	33d16fc8 <printf>
	} else {
		memcpy(params->commandline, linux_cmd, strlen(linux_cmd) + 1);
33d018ac:	eb006217 	bl	33d1a110 <strlen>
33d018b0:	e1a01004 	mov	r1, r4
33d018b4:	e2802001 	add	r2, r0, #1	; 0x1
33d018b8:	e1a00005 	mov	r0, r5
//		printf("linux command line is: \"%s\"\n", linux_cmd);
	}
}
33d018bc:	e8bd4030 	pop	{r4, r5, lr}
	/* set linux command line */
	linux_cmd = getenv ("bootargs");
	if (linux_cmd == NULL) {
		printf("Wrong magic: could not found linux command line\n");
	} else {
		memcpy(params->commandline, linux_cmd, strlen(linux_cmd) + 1);
33d018c0:	ea0062c7 	b	33d1a3e4 <memcpy>
33d018c4:	33d255f4 	.word	0x33d255f4
33d018c8:	33d25600 	.word	0x33d25600

33d018cc <boot_zImage>:
	return ret;
}


int boot_zImage(ulong from, size_t size)
{
33d018cc:	e92d4070 	push	{r4, r5, r6, lr}
	ulong mach_type;

	boot_mem_base = 0x30000000;

	/* copy kerne image */
	to = boot_mem_base + LINUX_KERNEL_OFFSET;
33d018d0:	e59f60b8 	ldr	r6, [pc, #184]	; 33d01990 <boot_zImage+0xc4>
	printf("Copy linux kernel from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
33d018d4:	e1a03001 	mov	r3, r1
33d018d8:	e1a02006 	mov	r2, r6
	return ret;
}


int boot_zImage(ulong from, size_t size)
{
33d018dc:	e1a04000 	mov	r4, r0
33d018e0:	e1a05001 	mov	r5, r1

	boot_mem_base = 0x30000000;

	/* copy kerne image */
	to = boot_mem_base + LINUX_KERNEL_OFFSET;
	printf("Copy linux kernel from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
33d018e4:	e1a01000 	mov	r1, r0
33d018e8:	e59f00a4 	ldr	r0, [pc, #164]	; 33d01994 <boot_zImage+0xc8>
33d018ec:	eb0055b5 	bl	33d16fc8 <printf>
 * mt: type of storage device
 */
static inline int copy_kernel_img(ulong dst, const char *src, size_t size)
{
	int ret = 0;
if (NF_ReadID() == 0x76)
33d018f0:	ebfffb17 	bl	33d00554 <NF_ReadID>
33d018f4:	e3500076 	cmp	r0, #118	; 0x76
{
#ifdef CONFIG_EMBEDSKY_LOGO
	ret = nand_read_ll_lcd((unsigned char *)dst, 
33d018f8:	e1a01004 	mov	r1, r4
33d018fc:	e1a02005 	mov	r2, r5
33d01900:	e1a00006 	mov	r0, r6
 * mt: type of storage device
 */
static inline int copy_kernel_img(ulong dst, const char *src, size_t size)
{
	int ret = 0;
if (NF_ReadID() == 0x76)
33d01904:	1a000001 	bne	33d01910 <boot_zImage+0x44>
{
#ifdef CONFIG_EMBEDSKY_LOGO
	ret = nand_read_ll_lcd((unsigned char *)dst, 
33d01908:	eb001ee3 	bl	33d0949c <nand_read_ll_lcd>
33d0190c:	ea000003 	b	33d01920 <boot_zImage+0x54>
#endif
}
else
{
#ifdef CONFIG_EMBEDSKY_LOGO
	ret = nand_read_ll_lp_lcd((unsigned char *)dst, 
33d01910:	e1a01004 	mov	r1, r4
33d01914:	e1a02005 	mov	r2, r5
33d01918:	e1a00006 	mov	r0, r6
33d0191c:	eb001f3e 	bl	33d0961c <nand_read_ll_lp_lcd>
33d01920:	e1a04000 	mov	r4, r0
	/* copy kerne image */
	to = boot_mem_base + LINUX_KERNEL_OFFSET;
	printf("Copy linux kernel from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
		from, to, size);
	ret = copy_kernel_img(to, (char *)from, size);
	if (ret) {
33d01924:	e3540000 	cmp	r4, #0	; 0x0
		printf("failed\n");
33d01928:	e59f0068 	ldr	r0, [pc, #104]	; 33d01998 <boot_zImage+0xcc>
	/* copy kerne image */
	to = boot_mem_base + LINUX_KERNEL_OFFSET;
	printf("Copy linux kernel from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
		from, to, size);
	ret = copy_kernel_img(to, (char *)from, size);
	if (ret) {
33d0192c:	0a000002 	beq	33d0193c <boot_zImage+0x70>
		printf("failed\n");
33d01930:	eb0055a4 	bl	33d16fc8 <printf>
		return -1;
33d01934:	e3e00000 	mvn	r0, #0	; 0x0
33d01938:	e8bd8070 	pop	{r4, r5, r6, pc}
	} else {
		printf("Copy Kernel to SDRAM done,");
33d0193c:	e59f0058 	ldr	r0, [pc, #88]	; 33d0199c <boot_zImage+0xd0>
33d01940:	eb0055a0 	bl	33d16fc8 <printf>
	}

	if (*(ulong *)(to + 9*4) != LINUX_ZIMAGE_MAGIC) {
33d01944:	e5962024 	ldr	r2, [r6, #36]
33d01948:	e59f3050 	ldr	r3, [pc, #80]	; 33d019a0 <boot_zImage+0xd4>
33d0194c:	e1520003 	cmp	r2, r3
		printf("Warning: this binary is not compressed linux kernel image\n");
33d01950:	e59f004c 	ldr	r0, [pc, #76]	; 33d019a4 <boot_zImage+0xd8>
		return -1;
	} else {
		printf("Copy Kernel to SDRAM done,");
	}

	if (*(ulong *)(to + 9*4) != LINUX_ZIMAGE_MAGIC) {
33d01954:	0a000003 	beq	33d01968 <boot_zImage+0x9c>
		printf("Warning: this binary is not compressed linux kernel image\n");
33d01958:	eb00559a 	bl	33d16fc8 <printf>
		printf("zImage magic = 0x%08lx\n", *(ulong *)(to + 9*4));
33d0195c:	e5961024 	ldr	r1, [r6, #36]
33d01960:	e59f0040 	ldr	r0, [pc, #64]	; 33d019a8 <boot_zImage+0xdc>
33d01964:	eb005597 	bl	33d16fc8 <printf>
//		printf("zImage magic = 0x%08lx\n", *(ulong *)(to + 9*4));
		;
	}

	/* Setup linux parameters and linux command line */
	setup_linux_param(boot_mem_base + LINUX_PARAM_OFFSET);
33d01968:	e59f003c 	ldr	r0, [pc, #60]	; 33d019ac <boot_zImage+0xe0>
33d0196c:	ebffffbd 	bl	33d01868 <setup_linux_param>
	/* Get machine type */
	mach_type = MACH_TYPE_S3C2440;
//	printf("MACH_TYPE = %d\n", mach_type);

	/* Go Go Go */
	printf("NOW, Booting Linux......\n");	
33d01970:	e59f0038 	ldr	r0, [pc, #56]	; 33d019b0 <boot_zImage+0xe4>
33d01974:	eb005593 	bl	33d16fc8 <printf>
	call_linux(0, mach_type, to);
33d01978:	e1a00004 	mov	r0, r4
33d0197c:	e3a010a8 	mov	r1, #168	; 0xa8
33d01980:	e59f2008 	ldr	r2, [pc, #8]	; 33d01990 <boot_zImage+0xc4>
33d01984:	ebffff9f 	bl	33d01808 <call_linux>

	return 0;	
33d01988:	e1a00004 	mov	r0, r4
}
33d0198c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d01990:	30008000 	.word	0x30008000
33d01994:	33d25634 	.word	0x33d25634
33d01998:	33d2dab0 	.word	0x33d2dab0
33d0199c:	33d25674 	.word	0x33d25674
33d019a0:	016f2818 	.word	0x016f2818
33d019a4:	33d25690 	.word	0x33d25690
33d019a8:	33d256cc 	.word	0x33d256cc
33d019ac:	30000100 	.word	0x30000100
33d019b0:	33d256e4 	.word	0x33d256e4

33d019b4 <do_boot_zImage>:

int do_boot_zImage (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d019b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
#if( LCD_TFT == VGA1024768 )
	boot_zImage(0x280000,0x300000);
#else
	boot_zImage(0x200000,0x300000);
33d019b8:	e3a01603 	mov	r1, #3145728	; 0x300000
33d019bc:	e3a00602 	mov	r0, #2097152	; 0x200000
33d019c0:	ebffffc1 	bl	33d018cc <boot_zImage>
#endif
	return 0;
}
33d019c4:	e3a00000 	mov	r0, #0	; 0x0
33d019c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d019cc <test_zImage>:
	"boot_zImage - boot Linux 's zImage\n",
	" - boot Linux 's zImage"
);

int test_zImage(void)
{
33d019cc:	e92d4010 	push	{r4, lr}
	ulong to;
	ulong mach_type;

	boot_mem_base = 0x30000000;

	to = boot_mem_base + LINUX_KERNEL_OFFSET;
33d019d0:	e59f4048 	ldr	r4, [pc, #72]	; 33d01a20 <test_zImage+0x54>

	if (*(ulong *)(to + 9*4) != LINUX_ZIMAGE_MAGIC) {
33d019d4:	e59f3048 	ldr	r3, [pc, #72]	; 33d01a24 <test_zImage+0x58>
33d019d8:	e5942024 	ldr	r2, [r4, #36]
33d019dc:	e1520003 	cmp	r2, r3
		printf("Warning: this binary is not compressed linux kernel image\n");
33d019e0:	e59f0040 	ldr	r0, [pc, #64]	; 33d01a28 <test_zImage+0x5c>

	boot_mem_base = 0x30000000;

	to = boot_mem_base + LINUX_KERNEL_OFFSET;

	if (*(ulong *)(to + 9*4) != LINUX_ZIMAGE_MAGIC) {
33d019e4:	0a000003 	beq	33d019f8 <test_zImage+0x2c>
		printf("Warning: this binary is not compressed linux kernel image\n");
33d019e8:	eb005576 	bl	33d16fc8 <printf>
		printf("zImage magic = 0x%08lx\n", *(ulong *)(to + 9*4));
33d019ec:	e5941024 	ldr	r1, [r4, #36]
33d019f0:	e59f0034 	ldr	r0, [pc, #52]	; 33d01a2c <test_zImage+0x60>
33d019f4:	eb005573 	bl	33d16fc8 <printf>
//		printf("zImage magic = 0x%08lx\n", *(ulong *)(to + 9*4));
		;
	}

	/* Setup linux parameters and linux command line */
	setup_linux_param(boot_mem_base + LINUX_PARAM_OFFSET);
33d019f8:	e59f0030 	ldr	r0, [pc, #48]	; 33d01a30 <test_zImage+0x64>
33d019fc:	ebffff99 	bl	33d01868 <setup_linux_param>
	/* Get machine type */
	mach_type = MACH_TYPE_S3C2440;
//	printf("MACH_TYPE = %d\n", mach_type);

	/* Go Go Go */
	printf("NOW, Booting Linux......\n");	
33d01a00:	e59f002c 	ldr	r0, [pc, #44]	; 33d01a34 <test_zImage+0x68>
33d01a04:	eb00556f 	bl	33d16fc8 <printf>
	call_linux(0, mach_type, to);
33d01a08:	e1a02004 	mov	r2, r4
33d01a0c:	e3a00000 	mov	r0, #0	; 0x0
33d01a10:	e3a010a8 	mov	r1, #168	; 0xa8
33d01a14:	ebffff7b 	bl	33d01808 <call_linux>

	return 0;	
}
33d01a18:	e3a00000 	mov	r0, #0	; 0x0
33d01a1c:	e8bd8010 	pop	{r4, pc}
33d01a20:	30008000 	.word	0x30008000
33d01a24:	016f2818 	.word	0x016f2818
33d01a28:	33d25690 	.word	0x33d25690
33d01a2c:	33d256cc 	.word	0x33d256cc
33d01a30:	30000100 	.word	0x30000100
33d01a34:	33d256e4 	.word	0x33d256e4

33d01a38 <do_test_zImage>:

int do_test_zImage (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d01a38:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	test_zImage( );
33d01a3c:	ebffffe2 	bl	33d019cc <test_zImage>
	return 0;
}
33d01a40:	e3a00000 	mov	r0, #0	; 0x0
33d01a44:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d01a48 <boot_noos>:
	"test_zImage - test Linux 's zImage\n",
	" - test Linux 's zImage"
);

int boot_noos(ulong from, size_t size)
{
33d01a48:	e92d4030 	push	{r4, r5, lr}

	boot_mem_base = 0x30000000;

	/* copy kerne image */
	to = boot_mem_base;
	printf("Copy code from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
33d01a4c:	e1a03001 	mov	r3, r1
33d01a50:	e3a02203 	mov	r2, #805306368	; 0x30000000
	"test_zImage - test Linux 's zImage\n",
	" - test Linux 's zImage"
);

int boot_noos(ulong from, size_t size)
{
33d01a54:	e1a04000 	mov	r4, r0
33d01a58:	e1a05001 	mov	r5, r1

	boot_mem_base = 0x30000000;

	/* copy kerne image */
	to = boot_mem_base;
	printf("Copy code from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
33d01a5c:	e1a01000 	mov	r1, r0
33d01a60:	e59f0070 	ldr	r0, [pc, #112]	; 33d01ad8 <boot_noos+0x90>
33d01a64:	eb005557 	bl	33d16fc8 <printf>
 * mt: type of storage device
 */
static inline int copy_kernel_img(ulong dst, const char *src, size_t size)
{
	int ret = 0;
if (NF_ReadID() == 0x76)
33d01a68:	ebfffab9 	bl	33d00554 <NF_ReadID>
33d01a6c:	e3500076 	cmp	r0, #118	; 0x76
{
#ifdef CONFIG_EMBEDSKY_LOGO
	ret = nand_read_ll_lcd((unsigned char *)dst, 
33d01a70:	e1a01004 	mov	r1, r4
33d01a74:	e1a02005 	mov	r2, r5
33d01a78:	e3a00203 	mov	r0, #805306368	; 0x30000000
 * mt: type of storage device
 */
static inline int copy_kernel_img(ulong dst, const char *src, size_t size)
{
	int ret = 0;
if (NF_ReadID() == 0x76)
33d01a7c:	1a000001 	bne	33d01a88 <boot_noos+0x40>
{
#ifdef CONFIG_EMBEDSKY_LOGO
	ret = nand_read_ll_lcd((unsigned char *)dst, 
33d01a80:	eb001e85 	bl	33d0949c <nand_read_ll_lcd>
33d01a84:	ea000003 	b	33d01a98 <boot_noos+0x50>
#endif
}
else
{
#ifdef CONFIG_EMBEDSKY_LOGO
	ret = nand_read_ll_lp_lcd((unsigned char *)dst, 
33d01a88:	e1a01004 	mov	r1, r4
33d01a8c:	e1a02005 	mov	r2, r5
33d01a90:	e3a00203 	mov	r0, #805306368	; 0x30000000
33d01a94:	eb001ee0 	bl	33d0961c <nand_read_ll_lp_lcd>
33d01a98:	e1a04000 	mov	r4, r0
	/* copy kerne image */
	to = boot_mem_base;
	printf("Copy code from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
		from, to, size);
	ret = copy_kernel_img(to, (char *)from, size);
	if (ret) {
33d01a9c:	e3540000 	cmp	r4, #0	; 0x0
		printf("failed\n");
33d01aa0:	e59f0034 	ldr	r0, [pc, #52]	; 33d01adc <boot_noos+0x94>
	/* copy kerne image */
	to = boot_mem_base;
	printf("Copy code from 0x%08lx to 0x%08lx, size = 0x%08lx ... ",
		from, to, size);
	ret = copy_kernel_img(to, (char *)from, size);
	if (ret) {
33d01aa4:	0a000002 	beq	33d01ab4 <boot_noos+0x6c>
		printf("failed\n");
33d01aa8:	eb005546 	bl	33d16fc8 <printf>
		return -1;
33d01aac:	e3e00000 	mvn	r0, #0	; 0x0
33d01ab0:	e8bd8030 	pop	{r4, r5, pc}
	} else {
		printf("Copy code to SDRAM done,");
33d01ab4:	e59f0024 	ldr	r0, [pc, #36]	; 33d01ae0 <boot_noos+0x98>
33d01ab8:	eb005542 	bl	33d16fc8 <printf>
	}

	/* Go Go Go */
	printf("NOW, Booting code......\n");	
33d01abc:	e59f0020 	ldr	r0, [pc, #32]	; 33d01ae4 <boot_noos+0x9c>
33d01ac0:	eb005540 	bl	33d16fc8 <printf>
	run_command("go 0x30000000", 0);
33d01ac4:	e1a01004 	mov	r1, r4
33d01ac8:	e59f0018 	ldr	r0, [pc, #24]	; 33d01ae8 <boot_noos+0xa0>
33d01acc:	eb002c43 	bl	33d0cbe0 <run_command>

	return 0;	
33d01ad0:	e1a00004 	mov	r0, r4
}
33d01ad4:	e8bd8030 	pop	{r4, r5, pc}
33d01ad8:	33d25700 	.word	0x33d25700
33d01adc:	33d2dab0 	.word	0x33d2dab0
33d01ae0:	33d25738 	.word	0x33d25738
33d01ae4:	33d25754 	.word	0x33d25754
33d01ae8:	33d25770 	.word	0x33d25770

33d01aec <do_boot_noos>:

int do_boot_noos (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d01aec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
#if( LCD_TFT == VGA1024768 )
	boot_noos(0x280000,0x300000);
#else
	boot_noos(0x200000,0x300000);
33d01af0:	e3a01603 	mov	r1, #3145728	; 0x300000
33d01af4:	e3a00602 	mov	r0, #2097152	; 0x200000
33d01af8:	ebffffd2 	bl	33d01a48 <boot_noos>
#endif
	return 0;
}
33d01afc:	e3a00000 	mov	r0, #0	; 0x0
33d01b00:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d01b04 <__div0>:
/* Replacement (=dummy) for GNU/Linux division-by zero handler */
void __div0 (void)
{
	extern void hang (void);

	hang();
33d01b04:	eafffe86 	b	33d01524 <hang>

33d01b08 <NetSetEther>:
	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE : VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(volatile uchar * xet, uchar * addr, uint prot)
{
33d01b08:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	Ethernet_t *et = (Ethernet_t *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
33d01b0c:	e59f30a8 	ldr	r3, [pc, #168]	; 33d01bbc <NetSetEther+0xb4>
33d01b10:	e1d330b0 	ldrh	r3, [r3]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
33d01b14:	e1a04423 	lsr	r4, r3, #8
33d01b18:	e1a04804 	lsl	r4, r4, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01b1c:	e1844c03 	orr	r4, r4, r3, lsl #24
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
33d01b20:	e59f6098 	ldr	r6, [pc, #152]	; 33d01bc0 <NetSetEther+0xb8>
	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE : VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(volatile uchar * xet, uchar * addr, uint prot)
{
33d01b24:	e1a07000 	mov	r7, r0
	Ethernet_t *et = (Ethernet_t *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
33d01b28:	e3740801 	cmn	r4, #65536	; 0x10000
	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE : VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(volatile uchar * xet, uchar * addr, uint prot)
{
33d01b2c:	e1a05002 	mov	r5, r2

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy (et->et_dest, addr, 6);
33d01b30:	e3a02006 	mov	r2, #6	; 0x6
	Ethernet_t *et = (Ethernet_t *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
33d01b34:	01a04006 	moveq	r4, r6
33d01b38:	11a04824 	lsrne	r4, r4, #16

	memcpy (et->et_dest, addr, 6);
33d01b3c:	eb006228 	bl	33d1a3e4 <memcpy>
	memcpy (et->et_src, NetOurEther, 6);
33d01b40:	e2870006 	add	r0, r7, #6	; 0x6
33d01b44:	e59f1078 	ldr	r1, [pc, #120]	; 33d01bc4 <NetSetEther+0xbc>
33d01b48:	e3a02006 	mov	r2, #6	; 0x6
33d01b4c:	eb006224 	bl	33d1a3e4 <memcpy>
	} else {
		VLAN_Ethernet_t *vet = (VLAN_Ethernet_t *)xet;

		vet->vet_vlan_type = htons(PROT_VLAN);
		vet->vet_tag = htons((0 << 5) | (myvlanid & VLAN_IDMASK));
		vet->vet_type = htons(prot);
33d01b50:	e1a03805 	lsl	r3, r5, #16
33d01b54:	e1a03823 	lsr	r3, r3, #16
33d01b58:	e2042c0f 	and	r2, r4, #3840	; 0xf00
	return __arch__swab16(x);
33d01b5c:	e1a01423 	lsr	r1, r3, #8
		myvlanid = VLAN_NONE;

	memcpy (et->et_dest, addr, 6);
	memcpy (et->et_src, NetOurEther, 6);
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
	et->et_protlen = htons(prot);
33d01b60:	e1a05805 	lsl	r5, r5, #16
33d01b64:	e1a05825 	lsr	r5, r5, #16
33d01b68:	e1a02402 	lsl	r2, r2, #8
33d01b6c:	e1a01801 	lsl	r1, r1, #16
33d01b70:	e1822c04 	orr	r2, r2, r4, lsl #24
33d01b74:	e1811c03 	orr	r1, r1, r3, lsl #24
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy (et->et_dest, addr, 6);
	memcpy (et->et_src, NetOurEther, 6);
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
33d01b78:	e1a04a04 	lsl	r4, r4, #20
33d01b7c:	e1a03425 	lsr	r3, r5, #8
33d01b80:	e1a04a24 	lsr	r4, r4, #20
33d01b84:	e1a03803 	lsl	r3, r3, #16
33d01b88:	e1540006 	cmp	r4, r6
33d01b8c:	e1833c05 	orr	r3, r3, r5, lsl #24
33d01b90:	e1a03823 	lsr	r3, r3, #16
33d01b94:	e1a02822 	lsr	r2, r2, #16
33d01b98:	e1a01821 	lsr	r1, r1, #16
	et->et_protlen = htons(prot);
		return ETHER_HDR_SIZE;
33d01b9c:	e3a0000e 	mov	r0, #14	; 0xe
	} else {
		VLAN_Ethernet_t *vet = (VLAN_Ethernet_t *)xet;

		vet->vet_vlan_type = htons(PROT_VLAN);
33d01ba0:	13a03081 	movne	r3, #129	; 0x81
		vet->vet_tag = htons((0 << 5) | (myvlanid & VLAN_IDMASK));
		vet->vet_type = htons(prot);
		return VLAN_ETHER_HDR_SIZE;
33d01ba4:	13a00012 	movne	r0, #18	; 0x12
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01ba8:	01c730bc 	strheq	r3, [r7, #12]
33d01bac:	11c711b0 	strhne	r1, [r7, #16]
33d01bb0:	11c720be 	strhne	r2, [r7, #14]
	et->et_protlen = htons(prot);
		return ETHER_HDR_SIZE;
	} else {
		VLAN_Ethernet_t *vet = (VLAN_Ethernet_t *)xet;

		vet->vet_vlan_type = htons(PROT_VLAN);
33d01bb4:	11c730bc 	strhne	r3, [r7, #12]
		vet->vet_tag = htons((0 << 5) | (myvlanid & VLAN_IDMASK));
		vet->vet_type = htons(prot);
		return VLAN_ETHER_HDR_SIZE;
	}
}
33d01bb8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d01bbc:	33d2ddaa 	.word	0x33d2ddaa
33d01bc0:	00000fff 	.word	0x00000fff
33d01bc4:	33d37310 	.word	0x33d37310

33d01bc8 <ArpRequest>:
uchar 		NetArpWaitPacketBuf[PKTSIZE_ALIGN + PKTALIGN];
ulong		NetArpWaitTimerStart;
int		NetArpWaitTry;

void ArpRequest (void)
{
33d01bc8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ARP_t *arp;

#ifdef ET_DEBUG
	printf ("ARP broadcast %d\n", NetArpWaitTry);
#endif
	pkt = NetTxPacket;
33d01bcc:	e59fa10c 	ldr	sl, [pc, #268]	; 33d01ce0 <ArpRequest+0x118>
33d01bd0:	e59a5000 	ldr	r5, [sl]
uchar 		NetArpWaitPacketBuf[PKTSIZE_ALIGN + PKTALIGN];
ulong		NetArpWaitTimerStart;
int		NetArpWaitTry;

void ArpRequest (void)
{
33d01bd4:	e24dd008 	sub	sp, sp, #8	; 0x8
#ifdef ET_DEBUG
	printf ("ARP broadcast %d\n", NetArpWaitTry);
#endif
	pkt = NetTxPacket;

	pkt += NetSetEther (pkt, NetBcastAddr, PROT_ARP);
33d01bd8:	e59f1104 	ldr	r1, [pc, #260]	; 33d01ce4 <ArpRequest+0x11c>
33d01bdc:	e1a00005 	mov	r0, r5
33d01be0:	e59f2100 	ldr	r2, [pc, #256]	; 33d01ce8 <ArpRequest+0x120>
33d01be4:	ebffffc7 	bl	33d01b08 <NetSetEther>

	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
	arp->ar_pro = htons (PROT_IP);
	arp->ar_hln = 6;
33d01be8:	e3a03006 	mov	r3, #6	; 0x6
#ifdef ET_DEBUG
	printf ("ARP broadcast %d\n", NetArpWaitTry);
#endif
	pkt = NetTxPacket;

	pkt += NetSetEther (pkt, NetBcastAddr, PROT_ARP);
33d01bec:	e0855000 	add	r5, r5, r0

	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
33d01bf0:	e3a01c01 	mov	r1, #256	; 0x100
	arp->ar_pro = htons (PROT_IP);
	arp->ar_hln = 6;
	arp->ar_pln = 4;
	arp->ar_op = htons (ARPOP_REQUEST);

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
33d01bf4:	e1a02003 	mov	r2, r3
	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
	arp->ar_pro = htons (PROT_IP);
	arp->ar_hln = 6;
	arp->ar_pln = 4;
33d01bf8:	e3a04004 	mov	r4, #4	; 0x4

	pkt += NetSetEther (pkt, NetBcastAddr, PROT_ARP);

	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
33d01bfc:	e1c510b0 	strh	r1, [r5]
	arp->ar_pro = htons (PROT_IP);
	arp->ar_hln = 6;
33d01c00:	e5c53004 	strb	r3, [r5, #4]
	pkt += NetSetEther (pkt, NetBcastAddr, PROT_ARP);

	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
	arp->ar_pro = htons (PROT_IP);
33d01c04:	e3a01008 	mov	r1, #8	; 0x8
	arp->ar_hln = 6;
	arp->ar_pln = 4;
	arp->ar_op = htons (ARPOP_REQUEST);
33d01c08:	e3a03c01 	mov	r3, #256	; 0x100
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d01c0c:	e59f70d8 	ldr	r7, [pc, #216]	; 33d01cec <ArpRequest+0x124>
	pkt += NetSetEther (pkt, NetBcastAddr, PROT_ARP);

	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
	arp->ar_pro = htons (PROT_IP);
33d01c10:	e1c510b2 	strh	r1, [r5, #2]
	arp->ar_hln = 6;
	arp->ar_pln = 4;
	arp->ar_op = htons (ARPOP_REQUEST);
33d01c14:	e1c530b6 	strh	r3, [r5, #6]

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
33d01c18:	e59f10d0 	ldr	r1, [pc, #208]	; 33d01cf0 <ArpRequest+0x128>
	arp = (ARP_t *) pkt;

	arp->ar_hrd = htons (ARP_ETHER);
	arp->ar_pro = htons (PROT_IP);
	arp->ar_hln = 6;
	arp->ar_pln = 4;
33d01c1c:	e5c54005 	strb	r4, [r5, #5]
	arp->ar_op = htons (ARPOP_REQUEST);

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
33d01c20:	e2850008 	add	r0, r5, #8	; 0x8
33d01c24:	eb0061ee 	bl	33d1a3e4 <memcpy>
33d01c28:	e5973000 	ldr	r3, [r7]
33d01c2c:	e28d1008 	add	r1, sp, #8	; 0x8
33d01c30:	e5213004 	str	r3, [r1, #-4]!
	memcpy(to, (void*)&ip, sizeof(ip));
33d01c34:	e1a02004 	mov	r2, r4
33d01c38:	e285000e 	add	r0, r5, #14	; 0xe
33d01c3c:	eb0061e8 	bl	33d1a3e4 <memcpy>
	NetWriteIP ((uchar *) & arp->ar_data[6], NetOurIP);	/* source IP addr	*/
	for (i = 10; i < 16; ++i) {
33d01c40:	e3a0100a 	mov	r1, #10	; 0xa
		arp->ar_data[i] = 0;				/* dest ET addr = 0     */
33d01c44:	e0812005 	add	r2, r1, r5
	arp->ar_pln = 4;
	arp->ar_op = htons (ARPOP_REQUEST);

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
	NetWriteIP ((uchar *) & arp->ar_data[6], NetOurIP);	/* source IP addr	*/
	for (i = 10; i < 16; ++i) {
33d01c48:	e2811001 	add	r1, r1, #1	; 0x1
		arp->ar_data[i] = 0;				/* dest ET addr = 0     */
33d01c4c:	e3a03000 	mov	r3, #0	; 0x0
	arp->ar_pln = 4;
	arp->ar_op = htons (ARPOP_REQUEST);

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
	NetWriteIP ((uchar *) & arp->ar_data[6], NetOurIP);	/* source IP addr	*/
	for (i = 10; i < 16; ++i) {
33d01c50:	e351000f 	cmp	r1, #15	; 0xf
		arp->ar_data[i] = 0;				/* dest ET addr = 0     */
33d01c54:	e5c23008 	strb	r3, [r2, #8]
	arp->ar_pln = 4;
	arp->ar_op = htons (ARPOP_REQUEST);

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
	NetWriteIP ((uchar *) & arp->ar_data[6], NetOurIP);	/* source IP addr	*/
	for (i = 10; i < 16; ++i) {
33d01c58:	dafffff9 	ble	33d01c44 <ArpRequest+0x7c>
		arp->ar_data[i] = 0;				/* dest ET addr = 0     */
	}

	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
33d01c5c:	e59f6090 	ldr	r6, [pc, #144]	; 33d01cf4 <ArpRequest+0x12c>
33d01c60:	e59f3090 	ldr	r3, [pc, #144]	; 33d01cf8 <ArpRequest+0x130>
33d01c64:	e5961000 	ldr	r1, [r6]
33d01c68:	e5933000 	ldr	r3, [r3]
33d01c6c:	e5972000 	ldr	r2, [r7]
33d01c70:	e0022003 	and	r2, r2, r3
33d01c74:	e0013003 	and	r3, r1, r3
33d01c78:	e1530002 	cmp	r3, r2
			NetArpWaitReplyIP = NetArpWaitPacketIP;
		} else {
			NetArpWaitReplyIP = NetOurGatewayIP;
		}
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
33d01c7c:	059f3078 	ldreq	r3, [pc, #120]	; 33d01cfc <ArpRequest+0x134>
33d01c80:	05831000 	streq	r1, [r3]
	NetWriteIP ((uchar *) & arp->ar_data[6], NetOurIP);	/* source IP addr	*/
	for (i = 10; i < 16; ++i) {
		arp->ar_data[i] = 0;				/* dest ET addr = 0     */
	}

	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
33d01c84:	0a000008 	beq	33d01cac <ArpRequest+0xe4>
	    (NetOurIP & NetOurSubnetMask)) {
		if (NetOurGatewayIP == 0) {
33d01c88:	e59f3070 	ldr	r3, [pc, #112]	; 33d01d00 <ArpRequest+0x138>
33d01c8c:	e5933000 	ldr	r3, [r3]
33d01c90:	e3530000 	cmp	r3, #0	; 0x0
33d01c94:	e59f4060 	ldr	r4, [pc, #96]	; 33d01cfc <ArpRequest+0x134>
33d01c98:	1a000002 	bne	33d01ca8 <ArpRequest+0xe0>
			puts ("## Warning: gatewayip needed but not set\n");
33d01c9c:	e59f0060 	ldr	r0, [pc, #96]	; 33d01d04 <ArpRequest+0x13c>
33d01ca0:	eb0054c1 	bl	33d16fac <puts>
			NetArpWaitReplyIP = NetArpWaitPacketIP;
33d01ca4:	e5963000 	ldr	r3, [r6]
		} else {
			NetArpWaitReplyIP = NetOurGatewayIP;
33d01ca8:	e5843000 	str	r3, [r4]
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d01cac:	e59f3048 	ldr	r3, [pc, #72]	; 33d01cfc <ArpRequest+0x134>
33d01cb0:	e5933000 	ldr	r3, [r3]
	memcpy(to, (void*)&ip, sizeof(ip));
33d01cb4:	e1a0100d 	mov	r1, sp
33d01cb8:	e2850018 	add	r0, r5, #24	; 0x18
33d01cbc:	e3a02004 	mov	r2, #4	; 0x4
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d01cc0:	e58d3000 	str	r3, [sp]
	memcpy(to, (void*)&ip, sizeof(ip));
33d01cc4:	eb0061c6 	bl	33d1a3e4 <memcpy>
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
	}

	NetWriteIP ((uchar *) & arp->ar_data[16], NetArpWaitReplyIP);
	(void) eth_send (NetTxPacket, (pkt - NetTxPacket) + ARP_HDR_SIZE);
33d01cc8:	e59a0000 	ldr	r0, [sl]
33d01ccc:	e0601005 	rsb	r1, r0, r5
33d01cd0:	e281101c 	add	r1, r1, #28	; 0x1c
33d01cd4:	eb000a1e 	bl	33d04554 <eth_send>
33d01cd8:	e28dd008 	add	sp, sp, #8	; 0x8
33d01cdc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d01ce0:	33d3726c 	.word	0x33d3726c
33d01ce4:	33d2ddac 	.word	0x33d2ddac
33d01ce8:	00000806 	.word	0x00000806
33d01cec:	33d37318 	.word	0x33d37318
33d01cf0:	33d37310 	.word	0x33d37310
33d01cf4:	33d391e4 	.word	0x33d391e4
33d01cf8:	33d37308 	.word	0x33d37308
33d01cfc:	33d391e8 	.word	0x33d391e8
33d01d00:	33d37304 	.word	0x33d37304
33d01d04:	33d25780 	.word	0x33d25780

33d01d08 <startAgainTimeout>:
/**********************************************************************/

static void
startAgainTimeout(void)
{
	NetState = NETLOOP_RESTART;
33d01d08:	e59f3008 	ldr	r3, [pc, #8]	; 33d01d18 <startAgainTimeout+0x10>
33d01d0c:	e3a02002 	mov	r2, #2	; 0x2
33d01d10:	e5832000 	str	r2, [r3]
33d01d14:	e1a0f00e 	mov	pc, lr
33d01d18:	33d3733c 	.word	0x33d3733c

33d01d1c <startAgainHandler>:
}

static void
startAgainHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
33d01d1c:	e1a0f00e 	mov	pc, lr

33d01d20 <NetSetTimeout>:
}


void
NetSetTimeout(ulong iv, thand_f * f)
{
33d01d20:	e92d4010 	push	{r4, lr}
	if (iv == 0) {
33d01d24:	e2504000 	subs	r4, r0, #0	; 0x0
33d01d28:	e59f3020 	ldr	r3, [pc, #32]	; 33d01d50 <NetSetTimeout+0x30>
		timeHandler = (thand_f *)0;
	} else {
		timeHandler = f;
		timeStart = get_timer(0);
33d01d2c:	e3a00000 	mov	r0, #0	; 0x0


void
NetSetTimeout(ulong iv, thand_f * f)
{
	if (iv == 0) {
33d01d30:	0a000004 	beq	33d01d48 <NetSetTimeout+0x28>
		timeHandler = (thand_f *)0;
	} else {
		timeHandler = f;
33d01d34:	e5831000 	str	r1, [r3]
		timeStart = get_timer(0);
33d01d38:	ebfffc2a 	bl	33d00de8 <get_timer>
33d01d3c:	e59f3010 	ldr	r3, [pc, #16]	; 33d01d54 <NetSetTimeout+0x34>
33d01d40:	e5830000 	str	r0, [r3]
		timeDelta = iv;
33d01d44:	e59f300c 	ldr	r3, [pc, #12]	; 33d01d58 <NetSetTimeout+0x38>
33d01d48:	e5834000 	str	r4, [r3]
33d01d4c:	e8bd8010 	pop	{r4, pc}
33d01d50:	33d3982c 	.word	0x33d3982c
33d01d54:	33d39830 	.word	0x33d39830
33d01d58:	33d39834 	.word	0x33d39834

33d01d5c <NetSetHandler>:
 */

void
NetSetHandler(rxhand_f * f)
{
	packetHandler = f;
33d01d5c:	e59f3004 	ldr	r3, [pc, #4]	; 33d01d68 <NetSetHandler+0xc>
33d01d60:	e5830000 	str	r0, [r3]
33d01d64:	e1a0f00e 	mov	pc, lr
33d01d68:	33d39828 	.word	0x33d39828

33d01d6c <NetStartAgain>:
{
	/* Totally ignore the packet */
}

void NetStartAgain (void)
{
33d01d6c:	e92d4030 	push	{r4, r5, lr}
	char *nretry;
	int noretry = 0, once = 0;

	if ((nretry = getenv ("netretry")) != NULL) {
33d01d70:	e59f0058 	ldr	r0, [pc, #88]	; 33d01dd0 <NetStartAgain+0x64>
33d01d74:	eb004eb5 	bl	33d15850 <getenv>
33d01d78:	e2505000 	subs	r5, r0, #0	; 0x0
		noretry = (strcmp (nretry, "no") == 0);
33d01d7c:	e59f1050 	ldr	r1, [pc, #80]	; 33d01dd4 <NetStartAgain+0x68>
void NetStartAgain (void)
{
	char *nretry;
	int noretry = 0, once = 0;

	if ((nretry = getenv ("netretry")) != NULL) {
33d01d80:	0a00000c 	beq	33d01db8 <NetStartAgain+0x4c>
		noretry = (strcmp (nretry, "no") == 0);
33d01d84:	eb0060b7 	bl	33d1a068 <strcmp>
		once = (strcmp (nretry, "once") == 0);
33d01d88:	e59f1048 	ldr	r1, [pc, #72]	; 33d01dd8 <NetStartAgain+0x6c>
{
	char *nretry;
	int noretry = 0, once = 0;

	if ((nretry = getenv ("netretry")) != NULL) {
		noretry = (strcmp (nretry, "no") == 0);
33d01d8c:	e2704001 	rsbs	r4, r0, #1	; 0x1
33d01d90:	33a04000 	movcc	r4, #0	; 0x0
		once = (strcmp (nretry, "once") == 0);
33d01d94:	e1a00005 	mov	r0, r5
33d01d98:	eb0060b2 	bl	33d1a068 <strcmp>
	}
	if (noretry) {
33d01d9c:	e3540000 	cmp	r4, #0	; 0x0
33d01da0:	0a000004 	beq	33d01db8 <NetStartAgain+0x4c>
		eth_halt ();
33d01da4:	eb000a20 	bl	33d0462c <eth_halt>
		NetState = NETLOOP_FAIL;
33d01da8:	e59f302c 	ldr	r3, [pc, #44]	; 33d01ddc <NetStartAgain+0x70>
33d01dac:	e3a02004 	mov	r2, #4	; 0x4
33d01db0:	e5832000 	str	r2, [r3]
		return;
33d01db4:	e8bd8030 	pop	{r4, r5, pc}
	}
#ifndef CONFIG_NET_MULTI
	NetSetTimeout (10 * CFG_HZ, startAgainTimeout);
33d01db8:	e59f0020 	ldr	r0, [pc, #32]	; 33d01de0 <NetStartAgain+0x74>
33d01dbc:	e59f1020 	ldr	r1, [pc, #32]	; 33d01de4 <NetStartAgain+0x78>
33d01dc0:	ebffffd6 	bl	33d01d20 <NetSetTimeout>
	NetSetHandler (startAgainHandler);
33d01dc4:	e59f001c 	ldr	r0, [pc, #28]	; 33d01de8 <NetStartAgain+0x7c>
		}
	} else {
		NetState = NETLOOP_RESTART;
	}
#endif	/* CONFIG_NET_MULTI */
}
33d01dc8:	e8bd4030 	pop	{r4, r5, lr}
		NetState = NETLOOP_FAIL;
		return;
	}
#ifndef CONFIG_NET_MULTI
	NetSetTimeout (10 * CFG_HZ, startAgainTimeout);
	NetSetHandler (startAgainHandler);
33d01dcc:	eaffffe2 	b	33d01d5c <NetSetHandler>
33d01dd0:	33d257ac 	.word	0x33d257ac
33d01dd4:	33d257b8 	.word	0x33d257b8
33d01dd8:	33d257bc 	.word	0x33d257bc
33d01ddc:	33d3733c 	.word	0x33d3733c
33d01de0:	00ee6b28 	.word	0x00ee6b28
33d01de4:	33d01d08 	.word	0x33d01d08
33d01de8:	33d01d1c 	.word	0x33d01d1c

33d01dec <ArpTimeoutCheck>:
	NetWriteIP ((uchar *) & arp->ar_data[16], NetArpWaitReplyIP);
	(void) eth_send (NetTxPacket, (pkt - NetTxPacket) + ARP_HDR_SIZE);
}

void ArpTimeoutCheck(void)
{
33d01dec:	e92d4010 	push	{r4, lr}
	ulong t;

	if (!NetArpWaitPacketIP)
33d01df0:	e59f3068 	ldr	r3, [pc, #104]	; 33d01e60 <ArpTimeoutCheck+0x74>
33d01df4:	e5933000 	ldr	r3, [r3]
		return;

	t = get_timer(0);
33d01df8:	e3a00000 	mov	r0, #0	; 0x0

void ArpTimeoutCheck(void)
{
	ulong t;

	if (!NetArpWaitPacketIP)
33d01dfc:	e1530000 	cmp	r3, r0
33d01e00:	08bd8010 	popeq	{r4, pc}
		return;

	t = get_timer(0);
33d01e04:	ebfffbf7 	bl	33d00de8 <get_timer>

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT * CFG_HZ) {
33d01e08:	e59fc054 	ldr	ip, [pc, #84]	; 33d01e64 <ArpTimeoutCheck+0x78>
33d01e0c:	e59c3000 	ldr	r3, [ip]
33d01e10:	e59f2050 	ldr	r2, [pc, #80]	; 33d01e68 <ArpTimeoutCheck+0x7c>
33d01e14:	e0633000 	rsb	r3, r3, r0
33d01e18:	e1530002 	cmp	r3, r2
	ulong t;

	if (!NetArpWaitPacketIP)
		return;

	t = get_timer(0);
33d01e1c:	e1a01000 	mov	r1, r0

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT * CFG_HZ) {
		NetArpWaitTry++;
33d01e20:	e59f4044 	ldr	r4, [pc, #68]	; 33d01e6c <ArpTimeoutCheck+0x80>
		return;

	t = get_timer(0);

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT * CFG_HZ) {
33d01e24:	98bd8010 	popls	{r4, pc}
		NetArpWaitTry++;
33d01e28:	e5943000 	ldr	r3, [r4]
33d01e2c:	e2833001 	add	r3, r3, #1	; 0x1

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
33d01e30:	e3530004 	cmp	r3, #4	; 0x4
			puts ("\nARP Retry count exceeded; starting again\n");
33d01e34:	e59f0034 	ldr	r0, [pc, #52]	; 33d01e70 <ArpTimeoutCheck+0x84>

	t = get_timer(0);

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT * CFG_HZ) {
		NetArpWaitTry++;
33d01e38:	e5843000 	str	r3, [r4]

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
33d01e3c:	da000004 	ble	33d01e54 <ArpTimeoutCheck+0x68>
			puts ("\nARP Retry count exceeded; starting again\n");
33d01e40:	eb005459 	bl	33d16fac <puts>
			NetArpWaitTry = 0;
33d01e44:	e3a03000 	mov	r3, #0	; 0x0
33d01e48:	e5843000 	str	r3, [r4]
		} else {
			NetArpWaitTimerStart = t;
			ArpRequest();
		}
	}
}
33d01e4c:	e8bd4010 	pop	{r4, lr}
		NetArpWaitTry++;

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
			puts ("\nARP Retry count exceeded; starting again\n");
			NetArpWaitTry = 0;
			NetStartAgain();
33d01e50:	eaffffc5 	b	33d01d6c <NetStartAgain>
		} else {
			NetArpWaitTimerStart = t;
33d01e54:	e58c1000 	str	r1, [ip]
			ArpRequest();
		}
	}
}
33d01e58:	e8bd4010 	pop	{r4, lr}
			puts ("\nARP Retry count exceeded; starting again\n");
			NetArpWaitTry = 0;
			NetStartAgain();
		} else {
			NetArpWaitTimerStart = t;
			ArpRequest();
33d01e5c:	eaffff59 	b	33d01bc8 <ArpRequest>
33d01e60:	33d391e4 	.word	0x33d391e4
33d01e64:	33d39818 	.word	0x33d39818
33d01e68:	00773594 	.word	0x00773594
33d01e6c:	33d3981c 	.word	0x33d3981c
33d01e70:	33d257c4 	.word	0x33d257c4

33d01e74 <NetSendPacket>:


void
NetSendPacket(volatile uchar * pkt, int len)
{
	(void) eth_send(pkt, len);
33d01e74:	ea0009b6 	b	33d04554 <eth_send>

33d01e78 <NetCksum>:
	ulong	xsum;
	ushort *p = (ushort *)ptr;

	xsum = 0;
	while (len-- > 0)
		xsum += *p++;
33d01e78:	e3510000 	cmp	r1, #0	; 0x0

unsigned
NetCksum(uchar * ptr, int len)
{
	ulong	xsum;
	ushort *p = (ushort *)ptr;
33d01e7c:	e1a0c000 	mov	ip, r0

	xsum = 0;
	while (len-- > 0)
		xsum += *p++;
33d01e80:	e2411001 	sub	r1, r1, #1	; 0x1
NetCksum(uchar * ptr, int len)
{
	ulong	xsum;
	ushort *p = (ushort *)ptr;

	xsum = 0;
33d01e84:	e3a00000 	mov	r0, #0	; 0x0
	while (len-- > 0)
		xsum += *p++;
33d01e88:	da000004 	ble	33d01ea0 <NetCksum+0x28>
33d01e8c:	e0dc20b2 	ldrh	r2, [ip], #2
33d01e90:	e3510000 	cmp	r1, #0	; 0x0
33d01e94:	e0800002 	add	r0, r0, r2
33d01e98:	e2411001 	sub	r1, r1, #1	; 0x1
33d01e9c:	eafffff9 	b	33d01e88 <NetCksum+0x10>
	xsum = (xsum & 0xffff) + (xsum >> 16);
33d01ea0:	e1a03800 	lsl	r3, r0, #16
33d01ea4:	e1a03823 	lsr	r3, r3, #16
33d01ea8:	e0830820 	add	r0, r3, r0, lsr #16
	xsum = (xsum & 0xffff) + (xsum >> 16);
33d01eac:	e1a03800 	lsl	r3, r0, #16
33d01eb0:	e1a03823 	lsr	r3, r3, #16
33d01eb4:	e0830820 	add	r0, r3, r0, lsr #16
	return (xsum & 0xffff);
33d01eb8:	e1a00800 	lsl	r0, r0, #16
33d01ebc:	e1a00820 	lsr	r0, r0, #16
}
33d01ec0:	e1a0f00e 	mov	pc, lr

33d01ec4 <NetSetIP>:
	}
}

void
NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
{
33d01ec4:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d01ec8:	e24dd004 	sub	sp, sp, #4	; 0x4
33d01ecc:	e59d5020 	ldr	r5, [sp, #32]
	 *	Construct an IP and UDP header.
	 *	(need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE + len);
33d01ed0:	e285e01c 	add	lr, r5, #28	; 0x1c
33d01ed4:	e1a0e80e 	lsl	lr, lr, #16
33d01ed8:	e1a0e82e 	lsr	lr, lr, #16
	return __arch__swab16(x);
33d01edc:	e1a0c42e 	lsr	ip, lr, #8
	}
}

void
NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
{
33d01ee0:	e1a04000 	mov	r4, r0
	/*
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
33d01ee4:	e3150001 	tst	r5, #1	; 0x1
	/*
	 *	Construct an IP and UDP header.
	 *	(need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_tos   = 0;
33d01ee8:	e3a09000 	mov	r9, #0	; 0x0
33d01eec:	e1a0c80c 	lsl	ip, ip, #16
	}
}

void
NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
{
33d01ef0:	e1a0a003 	mov	sl, r3
33d01ef4:	e18ccc0e 	orr	ip, ip, lr, lsl #24
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
		xip[IP_HDR_SIZE + len] = 0;
33d01ef8:	11a03009 	movne	r3, r9
33d01efc:	e084e005 	add	lr, r4, r5
	}
}

void
NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
{
33d01f00:	e58d1000 	str	r1, [sp]
33d01f04:	e1a0c82c 	lsr	ip, ip, #16
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
		xip[IP_HDR_SIZE + len] = 0;
33d01f08:	15ce301c 	strbne	r3, [lr, #28]

	/*
	 *	Construct an IP and UDP header.
	 *	(need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
33d01f0c:	e3a03045 	mov	r3, #69	; 0x45
33d01f10:	e5c43000 	strb	r3, [r4]
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01f14:	e59f60e0 	ldr	r6, [pc, #224]	; 33d01ffc <NetSetIP+0x138>
	ip->ip_tos   = 0;
33d01f18:	e5c49001 	strb	r9, [r4, #1]
33d01f1c:	e1c4c0b2 	strh	ip, [r4, #2]
33d01f20:	e1d6e0b0 	ldrh	lr, [r6]
	return __arch__swab16(x);
33d01f24:	e1a0342e 	lsr	r3, lr, #8
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01f28:	e596c000 	ldr	ip, [r6]
	return __arch__swab16(x);
33d01f2c:	e1a03803 	lsl	r3, r3, #16
33d01f30:	e1833c0e 	orr	r3, r3, lr, lsl #24
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01f34:	e28cc001 	add	ip, ip, #1	; 0x1
	return __arch__swab16(x);
33d01f38:	e1a03823 	lsr	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01f3c:	e586c000 	str	ip, [r6]
33d01f40:	e1c430b4 	strh	r3, [r4, #4]
	ip->ip_len   = htons(IP_HDR_SIZE + len);
	ip->ip_id    = htons(NetIPID++);
	ip->ip_off   = htons(0x4000);	/* No fragmentation */
33d01f44:	e3a03040 	mov	r3, #64	; 0x40
33d01f48:	e1c430b6 	strh	r3, [r4, #6]
	ip->ip_ttl   = 255;
33d01f4c:	e3e03000 	mvn	r3, #0	; 0x0
33d01f50:	e5c43008 	strb	r3, [r4, #8]
	ip->ip_p     = 17;		/* UDP */
33d01f54:	e2833012 	add	r3, r3, #18	; 0x12
33d01f58:	e5c43009 	strb	r3, [r4, #9]
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy(to, from, sizeof(IPaddr_t));
33d01f5c:	e59f109c 	ldr	r1, [pc, #156]	; 33d02000 <NetSetIP+0x13c>
	}
}

void
NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
{
33d01f60:	e1a07002 	mov	r7, r2
33d01f64:	e280000c 	add	r0, r0, #12	; 0xc
33d01f68:	e3a02004 	mov	r2, #4	; 0x4
	ip->ip_len   = htons(IP_HDR_SIZE + len);
	ip->ip_id    = htons(NetIPID++);
	ip->ip_off   = htons(0x4000);	/* No fragmentation */
	ip->ip_ttl   = 255;
	ip->ip_p     = 17;		/* UDP */
	ip->ip_sum   = 0;
33d01f6c:	e1c490ba 	strh	r9, [r4, #10]
33d01f70:	eb00611b 	bl	33d1a3e4 <memcpy>
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &dest);	   /* - "" - */
	ip->udp_src  = htons(sport);
	ip->udp_dst  = htons(dport);
	ip->udp_len  = htons(8 + len);
33d01f74:	e1a0100d 	mov	r1, sp
33d01f78:	e3a02004 	mov	r2, #4	; 0x4
33d01f7c:	e2840010 	add	r0, r4, #16	; 0x10
33d01f80:	eb006117 	bl	33d1a3e4 <memcpy>
33d01f84:	e2850008 	add	r0, r5, #8	; 0x8
33d01f88:	e1a00800 	lsl	r0, r0, #16
	ip->ip_ttl   = 255;
	ip->ip_p     = 17;		/* UDP */
	ip->ip_sum   = 0;
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &dest);	   /* - "" - */
	ip->udp_src  = htons(sport);
33d01f8c:	e1a0c80a 	lsl	ip, sl, #16
	ip->udp_dst  = htons(dport);
33d01f90:	e1a0e807 	lsl	lr, r7, #16
	ip->ip_ttl   = 255;
	ip->ip_p     = 17;		/* UDP */
	ip->ip_sum   = 0;
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &dest);	   /* - "" - */
	ip->udp_src  = htons(sport);
33d01f94:	e1a0c82c 	lsr	ip, ip, #16
	ip->udp_dst  = htons(dport);
33d01f98:	e1a0e82e 	lsr	lr, lr, #16
	ip->udp_len  = htons(8 + len);
33d01f9c:	e1a00820 	lsr	r0, r0, #16
	return __arch__swab16(x);
33d01fa0:	e1a0342c 	lsr	r3, ip, #8
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01fa4:	e1a0242e 	lsr	r2, lr, #8
33d01fa8:	e1a01420 	lsr	r1, r0, #8
	return __arch__swab16(x);
33d01fac:	e1a03803 	lsl	r3, r3, #16
33d01fb0:	e1a02802 	lsl	r2, r2, #16
33d01fb4:	e1a01801 	lsl	r1, r1, #16
33d01fb8:	e1833c0c 	orr	r3, r3, ip, lsl #24
33d01fbc:	e1822c0e 	orr	r2, r2, lr, lsl #24
33d01fc0:	e1811c00 	orr	r1, r1, r0, lsl #24
33d01fc4:	e1a03823 	lsr	r3, r3, #16
33d01fc8:	e1a02822 	lsr	r2, r2, #16
33d01fcc:	e1a01821 	lsr	r1, r1, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d01fd0:	e1c431b4 	strh	r3, [r4, #20]
	ip->udp_xsum = 0;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
33d01fd4:	e1a00004 	mov	r0, r4
33d01fd8:	e1c421b6 	strh	r2, [r4, #22]
33d01fdc:	e1c411b8 	strh	r1, [r4, #24]
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &dest);	   /* - "" - */
	ip->udp_src  = htons(sport);
	ip->udp_dst  = htons(dport);
	ip->udp_len  = htons(8 + len);
	ip->udp_xsum = 0;
33d01fe0:	e1c491ba 	strh	r9, [r4, #26]
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
33d01fe4:	e3a0100a 	mov	r1, #10	; 0xa
33d01fe8:	ebffffa2 	bl	33d01e78 <NetCksum>
33d01fec:	e1e00000 	mvn	r0, r0
33d01ff0:	e1c400ba 	strh	r0, [r4, #10]
33d01ff4:	e28dd004 	add	sp, sp, #4	; 0x4
33d01ff8:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d01ffc:	33d37338 	.word	0x33d37338
33d02000:	33d37318 	.word	0x33d37318

33d02004 <NetSendUDPPacket>:
	(void) eth_send(pkt, len);
}

int
NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport, int len)
{
33d02004:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	uchar *pkt;

	/* convert to new style broadcast */
	if (dest == 0)
33d02008:	e2516000 	subs	r6, r1, #0	; 0x0
	(void) eth_send(pkt, len);
}

int
NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport, int len)
{
33d0200c:	e24dd00c 	sub	sp, sp, #12	; 0xc
33d02010:	e1a05000 	mov	r5, r0
33d02014:	e58d3008 	str	r3, [sp, #8]
33d02018:	e1a0b002 	mov	fp, r2
33d0201c:	e59d902c 	ldr	r9, [sp, #44]
	uchar *pkt;

	/* convert to new style broadcast */
	if (dest == 0)
		dest = 0xFFFFFFFF;
33d02020:	03e06000 	mvneq	r6, #0	; 0x0
NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport, int len)
{
	uchar *pkt;

	/* convert to new style broadcast */
	if (dest == 0)
33d02024:	0a000001 	beq	33d02030 <NetSendUDPPacket+0x2c>
		dest = 0xFFFFFFFF;

	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
33d02028:	e3760001 	cmn	r6, #1	; 0x1
33d0202c:	1a000000 	bne	33d02034 <NetSendUDPPacket+0x30>
		ether = NetBcastAddr;
33d02030:	e59f5110 	ldr	r5, [pc, #272]	; 33d02148 <NetSendUDPPacket+0x144>

	/* if MAC address was not discovered yet, save the packet and do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
33d02034:	e59f1110 	ldr	r1, [pc, #272]	; 33d0214c <NetSendUDPPacket+0x148>
33d02038:	e3a02006 	mov	r2, #6	; 0x6
33d0203c:	e1a00005 	mov	r0, r5
33d02040:	eb006109 	bl	33d1a46c <memcmp>
33d02044:	e3500000 	cmp	r0, #0	; 0x0
		printf("sending ARP for %08lx\n", dest);
#endif
		NetArpWaitPacketIP = dest;
		NetArpWaitPacketMAC = ether;

		pkt = NetArpWaitTxPacket;
33d02048:	e59fa100 	ldr	sl, [pc, #256]	; 33d02150 <NetSendUDPPacket+0x14c>
		pkt += NetSetEther (pkt, NetArpWaitPacketMAC, PROT_IP);
33d0204c:	e1a01005 	mov	r1, r5
33d02050:	e3a02b02 	mov	r2, #2048	; 0x800
	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
		ether = NetBcastAddr;

	/* if MAC address was not discovered yet, save the packet and do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
33d02054:	e58d0004 	str	r0, [sp, #4]
33d02058:	e59f70f4 	ldr	r7, [pc, #244]	; 33d02154 <NetSendUDPPacket+0x150>
33d0205c:	1a000025 	bne	33d020f8 <NetSendUDPPacket+0xf4>

#ifdef ET_DEBUG
		printf("sending ARP for %08lx\n", dest);
#endif
		NetArpWaitPacketIP = dest;
33d02060:	e59f30f0 	ldr	r3, [pc, #240]	; 33d02158 <NetSendUDPPacket+0x154>
		NetArpWaitPacketMAC = ether;

		pkt = NetArpWaitTxPacket;
33d02064:	e59a4000 	ldr	r4, [sl]
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {

#ifdef ET_DEBUG
		printf("sending ARP for %08lx\n", dest);
#endif
		NetArpWaitPacketIP = dest;
33d02068:	e5836000 	str	r6, [r3]
		NetArpWaitPacketMAC = ether;
33d0206c:	e59f30e8 	ldr	r3, [pc, #232]	; 33d0215c <NetSendUDPPacket+0x158>

		pkt = NetArpWaitTxPacket;
		pkt += NetSetEther (pkt, NetArpWaitPacketMAC, PROT_IP);
33d02070:	e1a00004 	mov	r0, r4

#ifdef ET_DEBUG
		printf("sending ARP for %08lx\n", dest);
#endif
		NetArpWaitPacketIP = dest;
		NetArpWaitPacketMAC = ether;
33d02074:	e5835000 	str	r5, [r3]

		pkt = NetArpWaitTxPacket;
		pkt += NetSetEther (pkt, NetArpWaitPacketMAC, PROT_IP);
33d02078:	ebfffea2 	bl	33d01b08 <NetSetEther>
33d0207c:	e0844000 	add	r4, r4, r0

		NetSetIP (pkt, dest, dport, sport, len);
33d02080:	e59d3008 	ldr	r3, [sp, #8]
33d02084:	e1a01006 	mov	r1, r6
33d02088:	e1a0200b 	mov	r2, fp
33d0208c:	e1a00004 	mov	r0, r4
33d02090:	e58d9000 	str	r9, [sp]
33d02094:	ebffff8a 	bl	33d01ec4 <NetSetIP>
		memcpy(pkt + IP_HDR_SIZE, (uchar *)NetTxPacket + (pkt - (uchar *)NetArpWaitTxPacket) + IP_HDR_SIZE, len);
33d02098:	e59a3000 	ldr	r3, [sl]
33d0209c:	e5971000 	ldr	r1, [r7]
33d020a0:	e0633004 	rsb	r3, r3, r4
33d020a4:	e0811003 	add	r1, r1, r3
33d020a8:	e281101c 	add	r1, r1, #28	; 0x1c
33d020ac:	e1a02009 	mov	r2, r9
33d020b0:	e284001c 	add	r0, r4, #28	; 0x1c
33d020b4:	eb0060ca 	bl	33d1a3e4 <memcpy>

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = (pkt - NetArpWaitTxPacket) + IP_HDR_SIZE + len;
33d020b8:	e59a3000 	ldr	r3, [sl]
33d020bc:	e0633004 	rsb	r3, r3, r4
33d020c0:	e59f2098 	ldr	r2, [pc, #152]	; 33d02160 <NetSendUDPPacket+0x15c>
33d020c4:	e0833009 	add	r3, r3, r9
33d020c8:	e283301c 	add	r3, r3, #28	; 0x1c

		/* and do the ARP request */
		NetArpWaitTry = 1;
		NetArpWaitTimerStart = get_timer(0);
33d020cc:	e59d0004 	ldr	r0, [sp, #4]

		NetSetIP (pkt, dest, dport, sport, len);
		memcpy(pkt + IP_HDR_SIZE, (uchar *)NetTxPacket + (pkt - (uchar *)NetArpWaitTxPacket) + IP_HDR_SIZE, len);

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = (pkt - NetArpWaitTxPacket) + IP_HDR_SIZE + len;
33d020d0:	e5823000 	str	r3, [r2]

		/* and do the ARP request */
		NetArpWaitTry = 1;
33d020d4:	e59f3088 	ldr	r3, [pc, #136]	; 33d02164 <NetSendUDPPacket+0x160>
33d020d8:	e3a02001 	mov	r2, #1	; 0x1
33d020dc:	e5832000 	str	r2, [r3]
		NetArpWaitTimerStart = get_timer(0);
33d020e0:	ebfffb40 	bl	33d00de8 <get_timer>
33d020e4:	e59f307c 	ldr	r3, [pc, #124]	; 33d02168 <NetSendUDPPacket+0x164>
33d020e8:	e5830000 	str	r0, [r3]
		ArpRequest();
33d020ec:	ebfffeb5 	bl	33d01bc8 <ArpRequest>
		return 1;	/* waiting */
33d020f0:	e3a00001 	mov	r0, #1	; 0x1
33d020f4:	ea000011 	b	33d02140 <NetSendUDPPacket+0x13c>
#ifdef ET_DEBUG
	printf("sending UDP to %08lx/%02x:%02x:%02x:%02x:%02x:%02x\n",
		dest, ether[0], ether[1], ether[2], ether[3], ether[4], ether[5]);
#endif

	pkt = (uchar *)NetTxPacket;
33d020f8:	e5974000 	ldr	r4, [r7]
	pkt += NetSetEther (pkt, ether, PROT_IP);
33d020fc:	e1a01005 	mov	r1, r5
33d02100:	e1a00004 	mov	r0, r4
33d02104:	e3a02b02 	mov	r2, #2048	; 0x800
33d02108:	ebfffe7e 	bl	33d01b08 <NetSetEther>
33d0210c:	e0844000 	add	r4, r4, r0
	NetSetIP (pkt, dest, dport, sport, len);
33d02110:	e1a01006 	mov	r1, r6
33d02114:	e1a0200b 	mov	r2, fp
33d02118:	e59d3008 	ldr	r3, [sp, #8]
33d0211c:	e1a00004 	mov	r0, r4
33d02120:	e58d9000 	str	r9, [sp]
33d02124:	ebffff66 	bl	33d01ec4 <NetSetIP>
	(void) eth_send(NetTxPacket, (pkt - NetTxPacket) + IP_HDR_SIZE + len);
33d02128:	e5970000 	ldr	r0, [r7]
33d0212c:	e0601004 	rsb	r1, r0, r4
33d02130:	e0811009 	add	r1, r1, r9
33d02134:	e281101c 	add	r1, r1, #28	; 0x1c
33d02138:	eb000905 	bl	33d04554 <eth_send>

	return 0;	/* transmitted */
33d0213c:	e3a00000 	mov	r0, #0	; 0x0
}
33d02140:	e28dd00c 	add	sp, sp, #12	; 0xc
33d02144:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d02148:	33d2ddac 	.word	0x33d2ddac
33d0214c:	33d37270 	.word	0x33d37270
33d02150:	33d391f0 	.word	0x33d391f0
33d02154:	33d3726c 	.word	0x33d3726c
33d02158:	33d391e4 	.word	0x33d391e4
33d0215c:	33d391ec 	.word	0x33d391ec
33d02160:	33d391f4 	.word	0x33d391f4
33d02164:	33d3981c 	.word	0x33d3981c
33d02168:	33d39818 	.word	0x33d39818

33d0216c <PingSend>:

#if (CONFIG_COMMANDS & CFG_CMD_PING)
static ushort PingSeqNo;

int PingSend(void)
{
33d0216c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	volatile ushort *s;
	uchar *pkt;

	/* XXX always send arp request */

	memcpy(mac, NetEtherNullAddr, 6);
33d02170:	e59f5150 	ldr	r5, [pc, #336]	; 33d022c8 <PingSend+0x15c>

#ifdef ET_DEBUG
	printf("sending ARP for %08lx\n", NetPingIP);
#endif

	NetArpWaitPacketIP = NetPingIP;
33d02174:	e59fa150 	ldr	sl, [pc, #336]	; 33d022cc <PingSend+0x160>
	volatile ushort *s;
	uchar *pkt;

	/* XXX always send arp request */

	memcpy(mac, NetEtherNullAddr, 6);
33d02178:	e59f1150 	ldr	r1, [pc, #336]	; 33d022d0 <PingSend+0x164>
33d0217c:	e3a02006 	mov	r2, #6	; 0x6
33d02180:	e1a00005 	mov	r0, r5
33d02184:	eb006096 	bl	33d1a3e4 <memcpy>
#endif

	NetArpWaitPacketIP = NetPingIP;
	NetArpWaitPacketMAC = mac;

	pkt = NetArpWaitTxPacket;
33d02188:	e59f9144 	ldr	r9, [pc, #324]	; 33d022d4 <PingSend+0x168>

#ifdef ET_DEBUG
	printf("sending ARP for %08lx\n", NetPingIP);
#endif

	NetArpWaitPacketIP = NetPingIP;
33d0218c:	e59ac000 	ldr	ip, [sl]
33d02190:	e59f3140 	ldr	r3, [pc, #320]	; 33d022d8 <PingSend+0x16c>
	NetArpWaitPacketMAC = mac;

	pkt = NetArpWaitTxPacket;
33d02194:	e5994000 	ldr	r4, [r9]

#ifdef ET_DEBUG
	printf("sending ARP for %08lx\n", NetPingIP);
#endif

	NetArpWaitPacketIP = NetPingIP;
33d02198:	e583c000 	str	ip, [r3]
	NetArpWaitPacketMAC = mac;
33d0219c:	e59f3138 	ldr	r3, [pc, #312]	; 33d022dc <PingSend+0x170>

	pkt = NetArpWaitTxPacket;
	pkt += NetSetEther(pkt, mac, PROT_IP);
33d021a0:	e1a01005 	mov	r1, r5
#ifdef ET_DEBUG
	printf("sending ARP for %08lx\n", NetPingIP);
#endif

	NetArpWaitPacketIP = NetPingIP;
	NetArpWaitPacketMAC = mac;
33d021a4:	e5835000 	str	r5, [r3]

	pkt = NetArpWaitTxPacket;
	pkt += NetSetEther(pkt, mac, PROT_IP);
33d021a8:	e1a00004 	mov	r0, r4
33d021ac:	e3a02b02 	mov	r2, #2048	; 0x800
33d021b0:	ebfffe54 	bl	33d01b08 <NetSetEther>
	ip = (volatile IP_t *)pkt;

	/*
	 *	Construct an IP and ICMP header.  (need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
33d021b4:	e3a03045 	mov	r3, #69	; 0x45
33d021b8:	e7e43000 	strb	r3, [r4, r0]!
	ip->ip_tos   = 0;
33d021bc:	e3a06000 	mov	r6, #0	; 0x0
	ip->ip_len   = htons(IP_HDR_SIZE_NO_UDP + 8);
33d021c0:	e3a03b07 	mov	r3, #7168	; 0x1c00

	/*
	 *	Construct an IP and ICMP header.  (need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_tos   = 0;
33d021c4:	e5c46001 	strb	r6, [r4, #1]
33d021c8:	e59f1110 	ldr	r1, [pc, #272]	; 33d022e0 <PingSend+0x174>
	ip->ip_len   = htons(IP_HDR_SIZE_NO_UDP + 8);
33d021cc:	e1c430b2 	strh	r3, [r4, #2]
33d021d0:	e1d100b0 	ldrh	r0, [r1]
	return __arch__swab16(x);
33d021d4:	e1a03420 	lsr	r3, r0, #8
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d021d8:	e5912000 	ldr	r2, [r1]
	return __arch__swab16(x);
33d021dc:	e1a03803 	lsl	r3, r3, #16
33d021e0:	e1833c00 	orr	r3, r3, r0, lsl #24
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d021e4:	e2822001 	add	r2, r2, #1	; 0x1
	return __arch__swab16(x);
33d021e8:	e1a03823 	lsr	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d021ec:	e5812000 	str	r2, [r1]
33d021f0:	e1c430b4 	strh	r3, [r4, #4]
	ip->ip_id    = htons(NetIPID++);
	ip->ip_off   = htons(0x4000);	/* No fragmentation */
33d021f4:	e3a03040 	mov	r3, #64	; 0x40
33d021f8:	e1c430b6 	strh	r3, [r4, #6]
	ip->ip_ttl   = 255;
	ip->ip_p     = 0x01;		/* ICMP */
33d021fc:	e3a07001 	mov	r7, #1	; 0x1
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE_NO_UDP + 8);
	ip->ip_id    = htons(NetIPID++);
	ip->ip_off   = htons(0x4000);	/* No fragmentation */
	ip->ip_ttl   = 255;
33d02200:	e3e03000 	mvn	r3, #0	; 0x0
33d02204:	e5c43008 	strb	r3, [r4, #8]
33d02208:	e59f10d4 	ldr	r1, [pc, #212]	; 33d022e4 <PingSend+0x178>
	ip->ip_p     = 0x01;		/* ICMP */
33d0220c:	e5c47009 	strb	r7, [r4, #9]
33d02210:	e3a02004 	mov	r2, #4	; 0x4
	ip->ip_sum   = 0;
33d02214:	e1c460ba 	strh	r6, [r4, #10]
33d02218:	e284000c 	add	r0, r4, #12	; 0xc
33d0221c:	eb006070 	bl	33d1a3e4 <memcpy>
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &NetPingIP);	   /* - "" - */
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
33d02220:	e1a0100a 	mov	r1, sl
33d02224:	e3a02004 	mov	r2, #4	; 0x4
33d02228:	e2840010 	add	r0, r4, #16	; 0x10
33d0222c:	eb00606c 	bl	33d1a3e4 <memcpy>
33d02230:	e1a00004 	mov	r0, r4
33d02234:	e3a0100a 	mov	r1, #10	; 0xa
33d02238:	ebffff0e 	bl	33d01e78 <NetCksum>

	s = &ip->udp_src;		/* XXX ICMP starts here */
33d0223c:	e2845014 	add	r5, r4, #20	; 0x14
	ip->ip_ttl   = 255;
	ip->ip_p     = 0x01;		/* ICMP */
	ip->ip_sum   = 0;
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &NetPingIP);	   /* - "" - */
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
33d02240:	e1e00000 	mvn	r0, r0

	s = &ip->udp_src;		/* XXX ICMP starts here */
	s[0] = htons(0x0800);		/* echo-request, code */
33d02244:	e3a03008 	mov	r3, #8	; 0x8
	ip->ip_ttl   = 255;
	ip->ip_p     = 0x01;		/* ICMP */
	ip->ip_sum   = 0;
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &NetPingIP);	   /* - "" - */
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
33d02248:	e1c400ba 	strh	r0, [r4, #10]

	s = &ip->udp_src;		/* XXX ICMP starts here */
	s[0] = htons(0x0800);		/* echo-request, code */
33d0224c:	e1c431b4 	strh	r3, [r4, #20]
33d02250:	e59f0090 	ldr	r0, [pc, #144]	; 33d022e8 <PingSend+0x17c>
	s[1] = 0;			/* checksum */
33d02254:	e1c560b2 	strh	r6, [r5, #2]
	s[2] = 0; 			/* identifier */
33d02258:	e1c560b4 	strh	r6, [r5, #4]
33d0225c:	e1d020b0 	ldrh	r2, [r0]
	return __arch__swab16(x);
33d02260:	e1a03422 	lsr	r3, r2, #8
33d02264:	e1a03803 	lsl	r3, r3, #16
33d02268:	e1833c02 	orr	r3, r3, r2, lsl #24
33d0226c:	e1a03823 	lsr	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02270:	e0822007 	add	r2, r2, r7
33d02274:	e1c020b0 	strh	r2, [r0]
	s[3] = htons(PingSeqNo++);	/* sequence number */
	s[1] = ~NetCksum((uchar *)s, 8/2);
33d02278:	e3a01004 	mov	r1, #4	; 0x4
33d0227c:	e1c530b6 	strh	r3, [r5, #6]
33d02280:	e1a00005 	mov	r0, r5
33d02284:	ebfffefb 	bl	33d01e78 <NetCksum>
33d02288:	e1e00000 	mvn	r0, r0
33d0228c:	e1c500b2 	strh	r0, [r5, #2]

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = (pkt - NetArpWaitTxPacket) + IP_HDR_SIZE_NO_UDP + 8;
33d02290:	e5993000 	ldr	r3, [r9]
33d02294:	e0634004 	rsb	r4, r3, r4
33d02298:	e59f304c 	ldr	r3, [pc, #76]	; 33d022ec <PingSend+0x180>
33d0229c:	e284401c 	add	r4, r4, #28	; 0x1c
33d022a0:	e5834000 	str	r4, [r3]

	/* and do the ARP request */
	NetArpWaitTry = 1;
33d022a4:	e59f3044 	ldr	r3, [pc, #68]	; 33d022f0 <PingSend+0x184>
	NetArpWaitTimerStart = get_timer(0);
33d022a8:	e1a00006 	mov	r0, r6

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = (pkt - NetArpWaitTxPacket) + IP_HDR_SIZE_NO_UDP + 8;

	/* and do the ARP request */
	NetArpWaitTry = 1;
33d022ac:	e5837000 	str	r7, [r3]
	NetArpWaitTimerStart = get_timer(0);
33d022b0:	ebfffacc 	bl	33d00de8 <get_timer>
33d022b4:	e59f3038 	ldr	r3, [pc, #56]	; 33d022f4 <PingSend+0x188>
33d022b8:	e5830000 	str	r0, [r3]
	ArpRequest();
33d022bc:	ebfffe41 	bl	33d01bc8 <ArpRequest>
	return 1;	/* waiting */
}
33d022c0:	e1a00007 	mov	r0, r7
33d022c4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d022c8:	33d39820 	.word	0x33d39820
33d022cc:	33d373c0 	.word	0x33d373c0
33d022d0:	33d37270 	.word	0x33d37270
33d022d4:	33d391f0 	.word	0x33d391f0
33d022d8:	33d391e4 	.word	0x33d391e4
33d022dc:	33d391ec 	.word	0x33d391ec
33d022e0:	33d37338 	.word	0x33d37338
33d022e4:	33d37318 	.word	0x33d37318
33d022e8:	33d39838 	.word	0x33d39838
33d022ec:	33d391f4 	.word	0x33d391f4
33d022f0:	33d3981c 	.word	0x33d3981c
33d022f4:	33d39818 	.word	0x33d39818

33d022f8 <PingTimeout>:

static void
PingTimeout (void)
{
33d022f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	eth_halt();
33d022fc:	eb0008ca 	bl	33d0462c <eth_halt>
	NetState = NETLOOP_FAIL;	/* we did not get the reply */
33d02300:	e59f3008 	ldr	r3, [pc, #8]	; 33d02310 <PingTimeout+0x18>
33d02304:	e3a02004 	mov	r2, #4	; 0x4
33d02308:	e5832000 	str	r2, [r3]
33d0230c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d02310:	33d3733c 	.word	0x33d3733c

33d02314 <PingHandler>:
}

static void
PingHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
33d02314:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d02318:	e24dd004 	sub	sp, sp, #4	; 0x4
 * We're using inline functions, which had the smallest memory
 * footprint in our tests.
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
33d0231c:	e280100c 	add	r1, r0, #12	; 0xc
	IPaddr_t ip;
	memcpy((void*)&ip, from, sizeof(ip));
33d02320:	e3a02004 	mov	r2, #4	; 0x4
33d02324:	e1a0000d 	mov	r0, sp
33d02328:	eb00602d 	bl	33d1a3e4 <memcpy>
	IPaddr_t tmp;
	volatile IP_t *ip = (volatile IP_t *)pkt;

	tmp = NetReadIP((void *)&ip->ip_src);
	if (tmp != NetPingIP)
33d0232c:	e59f301c 	ldr	r3, [pc, #28]	; 33d02350 <PingHandler+0x3c>
33d02330:	e5932000 	ldr	r2, [r3]
33d02334:	e59d3000 	ldr	r3, [sp]
33d02338:	e1530002 	cmp	r3, r2
		return;

	NetState = NETLOOP_SUCCESS;
33d0233c:	059f3010 	ldreq	r3, [pc, #16]	; 33d02354 <PingHandler+0x40>
33d02340:	03a02003 	moveq	r2, #3	; 0x3
33d02344:	05832000 	streq	r2, [r3]
}
33d02348:	e28dd004 	add	sp, sp, #4	; 0x4
33d0234c:	e8bd8000 	pop	{pc}
33d02350:	33d373c0 	.word	0x33d373c0
33d02354:	33d3733c 	.word	0x33d3733c

33d02358 <NetCksumOk>:
}
/**********************************************************************/

int
NetCksumOk(uchar * ptr, int len)
{
33d02358:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return !((NetCksum(ptr, len) + 1) & 0xfffe);
33d0235c:	ebfffec5 	bl	33d01e78 <NetCksum>
33d02360:	e59f3010 	ldr	r3, [pc, #16]	; 33d02378 <NetCksumOk+0x20>
33d02364:	e2800001 	add	r0, r0, #1	; 0x1
33d02368:	e0003003 	and	r3, r0, r3
}
33d0236c:	e2730001 	rsbs	r0, r3, #1	; 0x1
33d02370:	33a00000 	movcc	r0, #0	; 0x0
33d02374:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d02378:	0000fffe 	.word	0x0000fffe

33d0237c <NetEthHdrSize>:
int
NetEthHdrSize(void)
{
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
33d0237c:	e59f3034 	ldr	r3, [pc, #52]	; 33d023b8 <NetEthHdrSize+0x3c>
33d02380:	e1d330b0 	ldrh	r3, [r3]
	return __arch__swab16(x);
33d02384:	e1a00423 	lsr	r0, r3, #8
33d02388:	e1a00800 	lsl	r0, r0, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d0238c:	e1800c03 	orr	r0, r0, r3, lsl #24
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
33d02390:	e59f2024 	ldr	r2, [pc, #36]	; 33d023bc <NetEthHdrSize+0x40>
33d02394:	e3700801 	cmn	r0, #65536	; 0x10000
33d02398:	01a00002 	moveq	r0, r2
33d0239c:	11a00820 	lsrne	r0, r0, #16

	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE : VLAN_ETHER_HDR_SIZE;
33d023a0:	e1a00a00 	lsl	r0, r0, #20
33d023a4:	e1a00a20 	lsr	r0, r0, #20
}
33d023a8:	e1500002 	cmp	r0, r2
33d023ac:	13a00012 	movne	r0, #18	; 0x12
33d023b0:	03a0000e 	moveq	r0, #14	; 0xe
33d023b4:	e1a0f00e 	mov	pc, lr
33d023b8:	33d2ddaa 	.word	0x33d2ddaa
33d023bc:	00000fff 	.word	0x00000fff

33d023c0 <copy_filename>:
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
}

void copy_filename (char *dst, char *src, int size)
{
	if (*src && (*src == '"')) {
33d023c0:	e5d13000 	ldrb	r3, [r1]
33d023c4:	e3530022 	cmp	r3, #34	; 0x22
		++src;
		--size;
33d023c8:	02422001 	subeq	r2, r2, #1	; 0x1
	}

	while ((--size > 0) && *src && (*src != '"')) {
		*dst++ = *src++;
33d023cc:	e2422001 	sub	r2, r2, #1	; 0x1
}

void copy_filename (char *dst, char *src, int size)
{
	if (*src && (*src == '"')) {
		++src;
33d023d0:	02811001 	addeq	r1, r1, #1	; 0x1
		--size;
	}

	while ((--size > 0) && *src && (*src != '"')) {
		*dst++ = *src++;
33d023d4:	e3520000 	cmp	r2, #0	; 0x0
	ip->udp_xsum = 0;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
}

void copy_filename (char *dst, char *src, int size)
{
33d023d8:	ea000005 	b	33d023f4 <copy_filename+0x34>
		++src;
		--size;
	}

	while ((--size > 0) && *src && (*src != '"')) {
		*dst++ = *src++;
33d023dc:	e3530022 	cmp	r3, #34	; 0x22
33d023e0:	0a000008 	beq	33d02408 <copy_filename+0x48>
33d023e4:	e2422001 	sub	r2, r2, #1	; 0x1
33d023e8:	e4c0c001 	strb	ip, [r0], #1
33d023ec:	e3520000 	cmp	r2, #0	; 0x0
33d023f0:	e2811001 	add	r1, r1, #1	; 0x1
33d023f4:	da000003 	ble	33d02408 <copy_filename+0x48>
33d023f8:	e5d1c000 	ldrb	ip, [r1]
33d023fc:	e20c30ff 	and	r3, ip, #255	; 0xff
33d02400:	e3530000 	cmp	r3, #0	; 0x0
33d02404:	1afffff4 	bne	33d023dc <copy_filename+0x1c>
	}
	*dst = '\0';
33d02408:	e3a03000 	mov	r3, #0	; 0x0
33d0240c:	e5c03000 	strb	r3, [r0]
33d02410:	e1a0f00e 	mov	pc, lr

33d02414 <ip_to_string>:
}

#endif /* CFG_CMD_NET */

void ip_to_string (IPaddr_t x, char *s)
{
33d02414:	e200ccff 	and	ip, r0, #65280	; 0xff00
33d02418:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
33d0241c:	e1a0c40c 	lsl	ip, ip, #8
33d02420:	e20038ff 	and	r3, r0, #16711680	; 0xff0000
33d02424:	e18ccc00 	orr	ip, ip, r0, lsl #24
33d02428:	e18cc423 	orr	ip, ip, r3, lsr #8
33d0242c:	e18ccc20 	orr	ip, ip, r0, lsr #24
	x = ntohl (x);
	sprintf (s, "%d.%d.%d.%d",
33d02430:	e1a0382c 	lsr	r3, ip, #16
33d02434:	e1a0e42c 	lsr	lr, ip, #8
}

#endif /* CFG_CMD_NET */

void ip_to_string (IPaddr_t x, char *s)
{
33d02438:	e24dd008 	sub	sp, sp, #8	; 0x8
	x = ntohl (x);
	sprintf (s, "%d.%d.%d.%d",
33d0243c:	e20ee0ff 	and	lr, lr, #255	; 0xff
33d02440:	e1a02c2c 	lsr	r2, ip, #24
33d02444:	e1a00001 	mov	r0, r1
33d02448:	e20cc0ff 	and	ip, ip, #255	; 0xff
33d0244c:	e20330ff 	and	r3, r3, #255	; 0xff
33d02450:	e59f1010 	ldr	r1, [pc, #16]	; 33d02468 <ip_to_string+0x54>
33d02454:	e58de000 	str	lr, [sp]
33d02458:	e58dc004 	str	ip, [sp, #4]
33d0245c:	eb006224 	bl	33d1acf4 <sprintf>
33d02460:	e28dd008 	add	sp, sp, #8	; 0x8
33d02464:	e8bd8000 	pop	{pc}
33d02468:	33d257f0 	.word	0x33d257f0

33d0246c <print_IPaddr>:

	return htons(id);
}

void print_IPaddr (IPaddr_t x)
{
33d0246c:	e92d4010 	push	{r4, lr}
33d02470:	e24dd010 	sub	sp, sp, #16	; 0x10
	char tmp[16];

	ip_to_string (x, tmp);
33d02474:	e1a0100d 	mov	r1, sp
33d02478:	ebffffe5 	bl	33d02414 <ip_to_string>

	puts (tmp);
33d0247c:	e1a0000d 	mov	r0, sp

void print_IPaddr (IPaddr_t x)
{
	char tmp[16];

	ip_to_string (x, tmp);
33d02480:	e1a0400d 	mov	r4, sp

	puts (tmp);
33d02484:	eb0052c8 	bl	33d16fac <puts>
33d02488:	e28dd010 	add	sp, sp, #16	; 0x10
33d0248c:	e8bd8010 	pop	{r4, pc}

33d02490 <NetReceive>:
#endif	/* CFG_CMD_CDP */


void
NetReceive(volatile uchar * inpkt, int len)
{
33d02490:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

#ifdef ET_DEBUG
	printf("packet received\n");
#endif

	NetRxPkt = inpkt;
33d02494:	e59f35e4 	ldr	r3, [pc, #1508]	; 33d02a80 <NetReceive+0x5f0>
33d02498:	e5830000 	str	r0, [r3]
	NetRxPktLen = len;
33d0249c:	e59f35e0 	ldr	r3, [pc, #1504]	; 33d02a84 <NetReceive+0x5f4>
	et = (Ethernet_t *)inpkt;

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
33d024a0:	e351000d 	cmp	r1, #13	; 0xd
#endif	/* CFG_CMD_CDP */


void
NetReceive(volatile uchar * inpkt, int len)
{
33d024a4:	e24dd010 	sub	sp, sp, #16	; 0x10
33d024a8:	e1a05001 	mov	r5, r1
33d024ac:	e1a0a000 	mov	sl, r0
#ifdef ET_DEBUG
	printf("packet received\n");
#endif

	NetRxPkt = inpkt;
	NetRxPktLen = len;
33d024b0:	e5831000 	str	r1, [r3]
	int	x;
	uchar *pkt;
#if (CONFIG_COMMANDS & CFG_CMD_CDP)
	int iscdp;
#endif
	ushort cti = 0, vlanid = VLAN_NONE, myvlanid, mynvlanid;
33d024b4:	e59f65cc 	ldr	r6, [pc, #1484]	; 33d02a88 <NetReceive+0x5f8>
	NetRxPkt = inpkt;
	NetRxPktLen = len;
	et = (Ethernet_t *)inpkt;

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
33d024b8:	da00016e 	ble	33d02a78 <NetReceive+0x5e8>
#if (CONFIG_COMMANDS & CFG_CMD_CDP)
	/* keep track if packet is CDP */
	iscdp = memcmp(et->et_dest, NetCDPAddr, 6) == 0;
#endif

	myvlanid = ntohs(NetOurVLAN);
33d024bc:	e59f35c8 	ldr	r3, [pc, #1480]	; 33d02a8c <NetReceive+0x5fc>
33d024c0:	e1d3e0b0 	ldrh	lr, [r3]
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
33d024c4:	e59f35c4 	ldr	r3, [pc, #1476]	; 33d02a90 <NetReceive+0x600>
33d024c8:	e1d3c0b0 	ldrh	ip, [r3]
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;

	x = ntohs(et->et_protlen);
33d024cc:	e1d000bc 	ldrh	r0, [r0, #12]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
33d024d0:	e1a0342c 	lsr	r3, ip, #8
33d024d4:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d024d8:	e1833c0c 	orr	r3, r3, ip, lsl #24
	return __arch__swab16(x);
33d024dc:	e1a01420 	lsr	r1, r0, #8
	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;
33d024e0:	e1a0242e 	lsr	r2, lr, #8
33d024e4:	e3730801 	cmn	r3, #65536	; 0x10000
33d024e8:	e1a01801 	lsl	r1, r1, #16
33d024ec:	e1a02802 	lsl	r2, r2, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d024f0:	e1811c00 	orr	r1, r1, r0, lsl #24
33d024f4:	e1822c0e 	orr	r2, r2, lr, lsl #24
33d024f8:	11a0c823 	lsrne	ip, r3, #16

#ifdef ET_DEBUG
	printf("packet received\n");
#endif

	if (x < 1514) {
33d024fc:	e59f3590 	ldr	r3, [pc, #1424]	; 33d02a94 <NetReceive+0x604>
33d02500:	e1a04821 	lsr	r4, r1, #16
	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;
33d02504:	01a0c006 	moveq	ip, r6
	iscdp = memcmp(et->et_dest, NetCDPAddr, 6) == 0;
#endif

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
33d02508:	e3720801 	cmn	r2, #65536	; 0x10000
33d0250c:	11a00822 	lsrne	r0, r2, #16
33d02510:	01a00006 	moveq	r0, r6

#ifdef ET_DEBUG
	printf("packet received\n");
#endif

	if (x < 1514) {
33d02514:	e1540003 	cmp	r4, r3
33d02518:	ca000007 	bgt	33d0253c <NetReceive+0xac>
		/*
		 *	Got a 802 packet.  Check the other protocol field.
		 */
		x = ntohs(et->et_prot);
33d0251c:	e1da21b4 	ldrh	r2, [sl, #20]
	return __arch__swab16(x);
33d02520:	e1a03422 	lsr	r3, r2, #8
33d02524:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02528:	e1833c02 	orr	r3, r3, r2, lsl #24
33d0252c:	e1a04823 	lsr	r4, r3, #16

		ip = (IP_t *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;
33d02530:	e2455016 	sub	r5, r5, #22	; 0x16
		/*
		 *	Got a 802 packet.  Check the other protocol field.
		 */
		x = ntohs(et->et_prot);

		ip = (IP_t *)(inpkt + E802_HDR_SIZE);
33d02534:	e28a7016 	add	r7, sl, #22	; 0x16
		len -= E802_HDR_SIZE;
33d02538:	ea000018 	b	33d025a0 <NetReceive+0x110>

	} else if (x != PROT_VLAN) {	/* normal packet */
33d0253c:	e3540c81 	cmp	r4, #33024	; 0x8100
		ip = (IP_t *)(inpkt + ETHER_HDR_SIZE);
		len -= ETHER_HDR_SIZE;
33d02540:	1245500e 	subne	r5, r5, #14	; 0xe

		ip = (IP_t *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;

	} else if (x != PROT_VLAN) {	/* normal packet */
		ip = (IP_t *)(inpkt + ETHER_HDR_SIZE);
33d02544:	128a700e 	addne	r7, sl, #14	; 0xe
		x = ntohs(et->et_prot);

		ip = (IP_t *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;

	} else if (x != PROT_VLAN) {	/* normal packet */
33d02548:	1a000014 	bne	33d025a0 <NetReceive+0x110>

#ifdef ET_DEBUG
		printf("VLAN packet received\n");
#endif
		/* too small packet? */
		if (len < VLAN_ETHER_HDR_SIZE)
33d0254c:	e3550011 	cmp	r5, #17	; 0x11
33d02550:	da000148 	ble	33d02a78 <NetReceive+0x5e8>
33d02554:	e1a03822 	lsr	r3, r2, #16
33d02558:	e1a03a03 	lsl	r3, r3, #20
33d0255c:	e1a03a23 	lsr	r3, r3, #20
33d02560:	e1530006 	cmp	r3, r6
33d02564:	0a000143 	beq	33d02a78 <NetReceive+0x5e8>
				&& iscdp == 0
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
33d02568:	e1da20be 	ldrh	r2, [sl, #14]
		vlanid = cti & VLAN_IDMASK;
		x = ntohs(vet->vet_type);
33d0256c:	e1da11b0 	ldrh	r1, [sl, #16]
	return __arch__swab16(x);
33d02570:	e1a03422 	lsr	r3, r2, #8
33d02574:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02578:	e1833c02 	orr	r3, r3, r2, lsl #24
	return __arch__swab16(x);
33d0257c:	e1a02421 	lsr	r2, r1, #8
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02580:	e1a03823 	lsr	r3, r3, #16
	return __arch__swab16(x);
33d02584:	e1a02802 	lsl	r2, r2, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02588:	e1822c01 	orr	r2, r2, r1, lsl #24
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
33d0258c:	e1a06a03 	lsl	r6, r3, #20
33d02590:	e1a06a26 	lsr	r6, r6, #20
33d02594:	e1a04822 	lsr	r4, r2, #16
		x = ntohs(vet->vet_type);

		ip = (IP_t *)(inpkt + VLAN_ETHER_HDR_SIZE);
		len -= VLAN_ETHER_HDR_SIZE;
33d02598:	e2455012 	sub	r5, r5, #18	; 0x12

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
		x = ntohs(vet->vet_type);

		ip = (IP_t *)(inpkt + VLAN_ETHER_HDR_SIZE);
33d0259c:	e28a7012 	add	r7, sl, #18	; 0x12
		CDPHandler((uchar *)ip, len);
		return;
	}
#endif

	if ((myvlanid & VLAN_IDMASK) != VLAN_NONE) {
33d025a0:	e1a03a00 	lsl	r3, r0, #20
33d025a4:	e59f24dc 	ldr	r2, [pc, #1244]	; 33d02a88 <NetReceive+0x5f8>
33d025a8:	e1a03a23 	lsr	r3, r3, #20
33d025ac:	e1530002 	cmp	r3, r2
33d025b0:	0a000003 	beq	33d025c4 <NetReceive+0x134>
		if (vlanid == VLAN_NONE)
33d025b4:	e1560002 	cmp	r6, r2
			vlanid = (mynvlanid & VLAN_IDMASK);
33d025b8:	000c6006 	andeq	r6, ip, r6
		/* not matched? */
		if (vlanid != (myvlanid & VLAN_IDMASK))
33d025bc:	e1560003 	cmp	r6, r3
33d025c0:	1a00012c 	bne	33d02a78 <NetReceive+0x5e8>
			return;
	}

	switch (x) {
33d025c4:	e59f34cc 	ldr	r3, [pc, #1228]	; 33d02a98 <NetReceive+0x608>
33d025c8:	e1540003 	cmp	r4, r3
33d025cc:	0a000007 	beq	33d025f0 <NetReceive+0x160>
33d025d0:	ca000002 	bgt	33d025e0 <NetReceive+0x150>
33d025d4:	e3540b02 	cmp	r4, #2048	; 0x800
33d025d8:	0a0000a3 	beq	33d0286c <NetReceive+0x3dc>
33d025dc:	ea000125 	b	33d02a78 <NetReceive+0x5e8>
33d025e0:	e59f34b4 	ldr	r3, [pc, #1204]	; 33d02a9c <NetReceive+0x60c>
33d025e4:	e1540003 	cmp	r4, r3
33d025e8:	0a00006d 	beq	33d027a4 <NetReceive+0x314>
33d025ec:	ea000121 	b	33d02a78 <NetReceive+0x5e8>
		 */
#ifdef ET_DEBUG
		puts ("Got ARP\n");
#endif
		arp = (ARP_t *)ip;
		if (len < ARP_HDR_SIZE) {
33d025f0:	e355001b 	cmp	r5, #27	; 0x1b
33d025f4:	da00006c 	ble	33d027ac <NetReceive+0x31c>
			printf("bad length %d < %d\n", len, ARP_HDR_SIZE);
			return;
		}
		if (ntohs(arp->ar_hrd) != ARP_ETHER) {
33d025f8:	e1d720b0 	ldrh	r2, [r7]
	return __arch__swab16(x);
33d025fc:	e1a03422 	lsr	r3, r2, #8
33d02600:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02604:	e1833c02 	orr	r3, r3, r2, lsl #24
33d02608:	e3530801 	cmp	r3, #65536	; 0x10000
33d0260c:	1a000119 	bne	33d02a78 <NetReceive+0x5e8>
			return;
		}
		if (ntohs(arp->ar_pro) != PROT_IP) {
33d02610:	e1d720b2 	ldrh	r2, [r7, #2]
	return __arch__swab16(x);
33d02614:	e1a03422 	lsr	r3, r2, #8
33d02618:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d0261c:	e1833c02 	orr	r3, r3, r2, lsl #24
33d02620:	e3530302 	cmp	r3, #134217728	; 0x8000000
33d02624:	1a000113 	bne	33d02a78 <NetReceive+0x5e8>
			return;
		}
		if (arp->ar_hln != 6) {
33d02628:	e5d7b004 	ldrb	fp, [r7, #4]
33d0262c:	e35b0006 	cmp	fp, #6	; 0x6
33d02630:	1a000110 	bne	33d02a78 <NetReceive+0x5e8>
			return;
		}
		if (arp->ar_pln != 4) {
33d02634:	e5d79005 	ldrb	r9, [r7, #5]
33d02638:	e3590004 	cmp	r9, #4	; 0x4
33d0263c:	1a00010d 	bne	33d02a78 <NetReceive+0x5e8>
			return;
		}

		if (NetOurIP == 0) {
33d02640:	e59f2458 	ldr	r2, [pc, #1112]	; 33d02aa0 <NetReceive+0x610>
33d02644:	e5923000 	ldr	r3, [r2]
33d02648:	e3530000 	cmp	r3, #0	; 0x0
33d0264c:	0a000109 	beq	33d02a78 <NetReceive+0x5e8>
 * We're using inline functions, which had the smallest memory
 * footprint in our tests.
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
33d02650:	e2873018 	add	r3, r7, #24	; 0x18
	IPaddr_t ip;
	memcpy((void*)&ip, from, sizeof(ip));
33d02654:	e1a01003 	mov	r1, r3
33d02658:	e1a02009 	mov	r2, r9
33d0265c:	e28d000c 	add	r0, sp, #12	; 0xc
 * We're using inline functions, which had the smallest memory
 * footprint in our tests.
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
33d02660:	e58d3000 	str	r3, [sp]
	IPaddr_t ip;
	memcpy((void*)&ip, from, sizeof(ip));
33d02664:	eb005f5e 	bl	33d1a3e4 <memcpy>
 * We're using inline functions, which had the smallest memory
 * footprint in our tests.
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
33d02668:	e59f3430 	ldr	r3, [pc, #1072]	; 33d02aa0 <NetReceive+0x610>
33d0266c:	e5932000 	ldr	r2, [r3]
33d02670:	e59d300c 	ldr	r3, [sp, #12]
33d02674:	e1530002 	cmp	r3, r2
33d02678:	1a0000fe 	bne	33d02a78 <NetReceive+0x5e8>

		if (NetReadIP(&arp->ar_data[16]) != NetOurIP) {
			return;
		}

		switch (ntohs(arp->ar_op)) {
33d0267c:	e1d720b6 	ldrh	r2, [r7, #6]
	return __arch__swab16(x);
33d02680:	e1a03422 	lsr	r3, r2, #8
33d02684:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02688:	e1833c02 	orr	r3, r3, r2, lsl #24
33d0268c:	e1a03823 	lsr	r3, r3, #16
33d02690:	e3530001 	cmp	r3, #1	; 0x1
33d02694:	0a000002 	beq	33d026a4 <NetReceive+0x214>
33d02698:	e3530002 	cmp	r3, #2	; 0x2
33d0269c:	0a00001d 	beq	33d02718 <NetReceive+0x288>
33d026a0:	ea0000f4 	b	33d02a78 <NetReceive+0x5e8>
		case ARPOP_REQUEST:		/* reply with our IP address	*/
#ifdef ET_DEBUG
			puts ("Got ARP REQUEST, return our IP\n");
#endif
			pkt = (uchar *)et;
			pkt += NetSetEther(pkt, et->et_src, PROT_ARP);
33d026a4:	e1a02004 	mov	r2, r4
33d026a8:	e28a1006 	add	r1, sl, #6	; 0x6
33d026ac:	e1a0000a 	mov	r0, sl
33d026b0:	ebfffd14 	bl	33d01b08 <NetSetEther>
			arp->ar_op = htons(ARPOP_REPLY);
			memcpy   (&arp->ar_data[10], &arp->ar_data[0], 6);
33d026b4:	e2874008 	add	r4, r7, #8	; 0x8
#ifdef ET_DEBUG
			puts ("Got ARP REQUEST, return our IP\n");
#endif
			pkt = (uchar *)et;
			pkt += NetSetEther(pkt, et->et_src, PROT_ARP);
			arp->ar_op = htons(ARPOP_REPLY);
33d026b8:	e3a02c02 	mov	r2, #512	; 0x200
		case ARPOP_REQUEST:		/* reply with our IP address	*/
#ifdef ET_DEBUG
			puts ("Got ARP REQUEST, return our IP\n");
#endif
			pkt = (uchar *)et;
			pkt += NetSetEther(pkt, et->et_src, PROT_ARP);
33d026bc:	e08a5000 	add	r5, sl, r0
	memcpy(to, (void*)&ip, sizeof(ip));
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
33d026c0:	e287600e 	add	r6, r7, #14	; 0xe
			arp->ar_op = htons(ARPOP_REPLY);
33d026c4:	e1c720b6 	strh	r2, [r7, #6]
			memcpy   (&arp->ar_data[10], &arp->ar_data[0], 6);
33d026c8:	e1a01004 	mov	r1, r4
33d026cc:	e1a0200b 	mov	r2, fp
33d026d0:	e2870012 	add	r0, r7, #18	; 0x12
33d026d4:	eb005f42 	bl	33d1a3e4 <memcpy>
	memcpy(to, from, sizeof(IPaddr_t));
33d026d8:	e1a01006 	mov	r1, r6
33d026dc:	e1a02009 	mov	r2, r9
33d026e0:	e59d0000 	ldr	r0, [sp]
33d026e4:	eb005f3e 	bl	33d1a3e4 <memcpy>
			NetCopyIP(&arp->ar_data[16], &arp->ar_data[6]);
			memcpy   (&arp->ar_data[ 0], NetOurEther, 6);
33d026e8:	e1a0200b 	mov	r2, fp
33d026ec:	e59f13b0 	ldr	r1, [pc, #944]	; 33d02aa4 <NetReceive+0x614>
33d026f0:	e1a00004 	mov	r0, r4
33d026f4:	eb005f3a 	bl	33d1a3e4 <memcpy>
33d026f8:	e59f13a0 	ldr	r1, [pc, #928]	; 33d02aa0 <NetReceive+0x610>
33d026fc:	e1a00006 	mov	r0, r6
33d02700:	e1a02009 	mov	r2, r9
33d02704:	eb005f36 	bl	33d1a3e4 <memcpy>
			NetCopyIP(&arp->ar_data[ 6], &NetOurIP);
			(void) eth_send((uchar *)et, (pkt - (uchar *)et) + ARP_HDR_SIZE);
33d02708:	e06a5005 	rsb	r5, sl, r5
33d0270c:	e1a0000a 	mov	r0, sl
33d02710:	e285101c 	add	r1, r5, #28	; 0x1c
33d02714:	ea0000bf 	b	33d02a18 <NetReceive+0x588>
			return;

		case ARPOP_REPLY:		/* arp reply */
			/* are we waiting for a reply */
			if (!NetArpWaitPacketIP || !NetArpWaitPacketMAC)
33d02718:	e59fa388 	ldr	sl, [pc, #904]	; 33d02aa8 <NetReceive+0x618>
33d0271c:	e59a3000 	ldr	r3, [sl]
33d02720:	e3530000 	cmp	r3, #0	; 0x0
33d02724:	0a0000d3 	beq	33d02a78 <NetReceive+0x5e8>
33d02728:	e59f637c 	ldr	r6, [pc, #892]	; 33d02aac <NetReceive+0x61c>
33d0272c:	e5963000 	ldr	r3, [r6]
33d02730:	e3530000 	cmp	r3, #0	; 0x0
33d02734:	0a0000cf 	beq	33d02a78 <NetReceive+0x5e8>
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;
	memcpy((void*)&ip, from, sizeof(ip));
33d02738:	e1a02009 	mov	r2, r9
33d0273c:	e28d0008 	add	r0, sp, #8	; 0x8
33d02740:	e287100e 	add	r1, r7, #14	; 0xe
33d02744:	eb005f26 	bl	33d1a3e4 <memcpy>
#endif

			tmp = NetReadIP(&arp->ar_data[6]);

			/* matched waiting packet's address */
			if (tmp == NetArpWaitReplyIP) {
33d02748:	e59f3360 	ldr	r3, [pc, #864]	; 33d02ab0 <NetReceive+0x620>
33d0274c:	e59d2008 	ldr	r2, [sp, #8]
33d02750:	e5933000 	ldr	r3, [r3]
33d02754:	e1520003 	cmp	r2, r3
33d02758:	1a0000c6 	bne	33d02a78 <NetReceive+0x5e8>

#ifdef CONFIG_NETCONSOLE
				(*packetHandler)(0,0,0,0);
#endif
				/* modify header, and transmit it */
				memcpy(((Ethernet_t *)NetArpWaitTxPacket)->et_dest, NetArpWaitPacketMAC, 6);
33d0275c:	e59f4350 	ldr	r4, [pc, #848]	; 33d02ab4 <NetReceive+0x624>
			if (tmp == NetArpWaitReplyIP) {
#ifdef ET_DEBUG
				puts ("Got it\n");
#endif
				/* save address for later use */
				memcpy(NetArpWaitPacketMAC, &arp->ar_data[0], 6);
33d02760:	e2871008 	add	r1, r7, #8	; 0x8
33d02764:	e1a0200b 	mov	r2, fp
#ifdef CONFIG_NETCONSOLE
				(*packetHandler)(0,0,0,0);
#endif
				/* modify header, and transmit it */
				memcpy(((Ethernet_t *)NetArpWaitTxPacket)->et_dest, NetArpWaitPacketMAC, 6);
				(void) eth_send(NetArpWaitTxPacket, NetArpWaitTxPacketSize);
33d02768:	e59f5348 	ldr	r5, [pc, #840]	; 33d02ab8 <NetReceive+0x628>
			if (tmp == NetArpWaitReplyIP) {
#ifdef ET_DEBUG
				puts ("Got it\n");
#endif
				/* save address for later use */
				memcpy(NetArpWaitPacketMAC, &arp->ar_data[0], 6);
33d0276c:	e5960000 	ldr	r0, [r6]
33d02770:	eb005f1b 	bl	33d1a3e4 <memcpy>

#ifdef CONFIG_NETCONSOLE
				(*packetHandler)(0,0,0,0);
#endif
				/* modify header, and transmit it */
				memcpy(((Ethernet_t *)NetArpWaitTxPacket)->et_dest, NetArpWaitPacketMAC, 6);
33d02774:	e1a0200b 	mov	r2, fp
33d02778:	e5961000 	ldr	r1, [r6]
33d0277c:	e5940000 	ldr	r0, [r4]
33d02780:	eb005f17 	bl	33d1a3e4 <memcpy>
				(void) eth_send(NetArpWaitTxPacket, NetArpWaitTxPacketSize);
33d02784:	e5940000 	ldr	r0, [r4]
33d02788:	e5951000 	ldr	r1, [r5]
33d0278c:	eb000770 	bl	33d04554 <eth_send>

				/* no arp request pending now */
				NetArpWaitPacketIP = 0;
				NetArpWaitTxPacketSize = 0;
				NetArpWaitPacketMAC = NULL;
33d02790:	e3a03000 	mov	r3, #0	; 0x0
33d02794:	e5863000 	str	r3, [r6]
				/* modify header, and transmit it */
				memcpy(((Ethernet_t *)NetArpWaitTxPacket)->et_dest, NetArpWaitPacketMAC, 6);
				(void) eth_send(NetArpWaitTxPacket, NetArpWaitTxPacketSize);

				/* no arp request pending now */
				NetArpWaitPacketIP = 0;
33d02798:	e58a3000 	str	r3, [sl]
				NetArpWaitTxPacketSize = 0;
33d0279c:	e5853000 	str	r3, [r5]
				NetArpWaitPacketMAC = NULL;

			}
			return;
33d027a0:	ea0000b4 	b	33d02a78 <NetReceive+0x5e8>
	case PROT_RARP:
#ifdef ET_DEBUG
		puts ("Got RARP\n");
#endif
		arp = (ARP_t *)ip;
		if (len < ARP_HDR_SIZE) {
33d027a4:	e355001b 	cmp	r5, #27	; 0x1b
33d027a8:	ca000003 	bgt	33d027bc <NetReceive+0x32c>
			printf("bad length %d < %d\n", len, ARP_HDR_SIZE);
33d027ac:	e59f0308 	ldr	r0, [pc, #776]	; 33d02abc <NetReceive+0x62c>
33d027b0:	e1a01005 	mov	r1, r5
33d027b4:	e3a0201c 	mov	r2, #28	; 0x1c
33d027b8:	ea000036 	b	33d02898 <NetReceive+0x408>
			return;
		}

		if ((ntohs(arp->ar_op) != RARPOP_REPLY) ||
33d027bc:	e1d720b6 	ldrh	r2, [r7, #6]
	return __arch__swab16(x);
33d027c0:	e1a03422 	lsr	r3, r2, #8
33d027c4:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d027c8:	e1833c02 	orr	r3, r3, r2, lsl #24
33d027cc:	e1a04823 	lsr	r4, r3, #16
33d027d0:	e3540004 	cmp	r4, #4	; 0x4
33d027d4:	1a00000f 	bne	33d02818 <NetReceive+0x388>
33d027d8:	e1d720b0 	ldrh	r2, [r7]
	return __arch__swab16(x);
33d027dc:	e1a03422 	lsr	r3, r2, #8
33d027e0:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d027e4:	e1833c02 	orr	r3, r3, r2, lsl #24
33d027e8:	e3530801 	cmp	r3, #65536	; 0x10000
33d027ec:	1a000009 	bne	33d02818 <NetReceive+0x388>
33d027f0:	e1d720b2 	ldrh	r2, [r7, #2]
	return __arch__swab16(x);
33d027f4:	e1a03422 	lsr	r3, r2, #8
33d027f8:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d027fc:	e1833c02 	orr	r3, r3, r2, lsl #24
33d02800:	e3530302 	cmp	r3, #134217728	; 0x8000000
33d02804:	1a000003 	bne	33d02818 <NetReceive+0x388>
33d02808:	e1d720b4 	ldrh	r2, [r7, #4]
33d0280c:	e59f32ac 	ldr	r3, [pc, #684]	; 33d02ac0 <NetReceive+0x630>
33d02810:	e1520003 	cmp	r2, r3
33d02814:	0a000001 	beq	33d02820 <NetReceive+0x390>
			(ntohs(arp->ar_hrd) != ARP_ETHER)   ||
			(ntohs(arp->ar_pro) != PROT_IP)     ||
			(arp->ar_hln != 6) || (arp->ar_pln != 4)) {

			puts ("invalid RARP header\n");
33d02818:	e59f02a4 	ldr	r0, [pc, #676]	; 33d02ac4 <NetReceive+0x634>
33d0281c:	ea00002f 	b	33d028e0 <NetReceive+0x450>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy(to, from, sizeof(IPaddr_t));
33d02820:	e59f0278 	ldr	r0, [pc, #632]	; 33d02aa0 <NetReceive+0x610>
33d02824:	e2871018 	add	r1, r7, #24	; 0x18
33d02828:	e1a02004 	mov	r2, r4
33d0282c:	eb005eec 	bl	33d1a3e4 <memcpy>
		} else {
			NetCopyIP(&NetOurIP,    &arp->ar_data[16]);
			if (NetServerIP == 0)
33d02830:	e59f0290 	ldr	r0, [pc, #656]	; 33d02ac8 <NetReceive+0x638>
33d02834:	e5903000 	ldr	r3, [r0]
33d02838:	e3530000 	cmp	r3, #0	; 0x0
33d0283c:	01a02004 	moveq	r2, r4
33d02840:	0287100e 	addeq	r1, r7, #14	; 0xe
33d02844:	0b005ee6 	bleq	33d1a3e4 <memcpy>
				NetCopyIP(&NetServerIP, &arp->ar_data[ 6]);
			memcpy (NetServerEther, &arp->ar_data[ 0], 6);
33d02848:	e2871008 	add	r1, r7, #8	; 0x8
33d0284c:	e3a02006 	mov	r2, #6	; 0x6
33d02850:	e59f0274 	ldr	r0, [pc, #628]	; 33d02acc <NetReceive+0x63c>
33d02854:	eb005ee2 	bl	33d1a3e4 <memcpy>

			(*packetHandler)(0,0,0,0);
33d02858:	e3a00000 	mov	r0, #0	; 0x0
33d0285c:	e1a01000 	mov	r1, r0
33d02860:	e1a02000 	mov	r2, r0
33d02864:	e1a03000 	mov	r3, r0
33d02868:	ea00007f 	b	33d02a6c <NetReceive+0x5dc>

	case PROT_IP:
#ifdef ET_DEBUG
		puts ("Got IP\n");
#endif
		if (len < IP_HDR_SIZE) {
33d0286c:	e355001b 	cmp	r5, #27	; 0x1b
33d02870:	9a000080 	bls	33d02a78 <NetReceive+0x5e8>
			debug ("len bad %d < %d\n", len, IP_HDR_SIZE);
			return;
		}
		if (len < ntohs(ip->ip_len)) {
33d02874:	e1d720b2 	ldrh	r2, [r7, #2]
	return __arch__swab16(x);
33d02878:	e1a03422 	lsr	r3, r2, #8
33d0287c:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02880:	e1833c02 	orr	r3, r3, r2, lsl #24
33d02884:	e1a02823 	lsr	r2, r3, #16
33d02888:	e1550002 	cmp	r5, r2
33d0288c:	aa000003 	bge	33d028a0 <NetReceive+0x410>
33d02890:	e59f0238 	ldr	r0, [pc, #568]	; 33d02ad0 <NetReceive+0x640>
33d02894:	e1a01005 	mov	r1, r5
33d02898:	eb0051ca 	bl	33d16fc8 <printf>
			printf("len bad %d < %d\n", len, ntohs(ip->ip_len));
			return;
33d0289c:	ea000075 	b	33d02a78 <NetReceive+0x5e8>
		}
		len = ntohs(ip->ip_len);
#ifdef ET_DEBUG
		printf("len=%d, v=%02x\n", len, ip->ip_hl_v & 0xff);
#endif
		if ((ip->ip_hl_v & 0xf0) != 0x40) {
33d028a0:	e5d73000 	ldrb	r3, [r7]
33d028a4:	e20330f0 	and	r3, r3, #240	; 0xf0
33d028a8:	e3530040 	cmp	r3, #64	; 0x40
33d028ac:	e1a05002 	mov	r5, r2
33d028b0:	1a000070 	bne	33d02a78 <NetReceive+0x5e8>
			return;
		}
		if (ip->ip_off & htons(0x1fff)) { /* Can't deal w/ fragments */
33d028b4:	e1d730b6 	ldrh	r3, [r7, #6]
33d028b8:	e59f9214 	ldr	r9, [pc, #532]	; 33d02ad4 <NetReceive+0x644>
33d028bc:	e0039009 	and	r9, r3, r9
33d028c0:	e3590000 	cmp	r9, #0	; 0x0
33d028c4:	1a00006b 	bne	33d02a78 <NetReceive+0x5e8>
			return;
		}
		if (!NetCksumOk((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2)) {
33d028c8:	e1a00007 	mov	r0, r7
33d028cc:	e3a0100a 	mov	r1, #10	; 0xa
33d028d0:	ebfffea0 	bl	33d02358 <NetCksumOk>
33d028d4:	e3500000 	cmp	r0, #0	; 0x0
33d028d8:	1a000002 	bne	33d028e8 <NetReceive+0x458>
			puts ("checksum bad\n");
33d028dc:	e59f01f4 	ldr	r0, [pc, #500]	; 33d02ad8 <NetReceive+0x648>
33d028e0:	eb0051b1 	bl	33d16fac <puts>
			return;
33d028e4:	ea000063 	b	33d02a78 <NetReceive+0x5e8>
 * We're using inline functions, which had the smallest memory
 * footprint in our tests.
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
33d028e8:	e287b010 	add	fp, r7, #16	; 0x10
	IPaddr_t ip;
	memcpy((void*)&ip, from, sizeof(ip));
33d028ec:	e3a02004 	mov	r2, #4	; 0x4
33d028f0:	e28d0004 	add	r0, sp, #4	; 0x4
33d028f4:	e1a0100b 	mov	r1, fp
33d028f8:	eb005eb9 	bl	33d1a3e4 <memcpy>
		}
		tmp = NetReadIP(&ip->ip_dst);
		if (NetOurIP && tmp != NetOurIP && tmp != 0xFFFFFFFF) {
33d028fc:	e59f219c 	ldr	r2, [pc, #412]	; 33d02aa0 <NetReceive+0x610>
33d02900:	e5923000 	ldr	r3, [r2]
33d02904:	e3530000 	cmp	r3, #0	; 0x0
33d02908:	e59d2004 	ldr	r2, [sp, #4]
33d0290c:	0a000002 	beq	33d0291c <NetReceive+0x48c>
33d02910:	e1520003 	cmp	r2, r3
33d02914:	13720001 	cmnne	r2, #1	; 0x1
33d02918:	1a000056 	bne	33d02a78 <NetReceive+0x5e8>
		 * BOOTP reply, but the TFTP server was on the same
		 * subnet. So this is probably a warning that your
		 * configuration might be wrong. But I'm not really
		 * sure if there aren't any other situations.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
33d0291c:	e5d73009 	ldrb	r3, [r7, #9]
33d02920:	e3530001 	cmp	r3, #1	; 0x1
33d02924:	1a00003d 	bne	33d02a20 <NetReceive+0x590>
			ICMP_t *icmph = (ICMP_t *)&(ip->udp_src);

			switch (icmph->type) {
33d02928:	e5d71014 	ldrb	r1, [r7, #20]
33d0292c:	e3510005 	cmp	r1, #5	; 0x5
		 * subnet. So this is probably a warning that your
		 * configuration might be wrong. But I'm not really
		 * sure if there aren't any other situations.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
			ICMP_t *icmph = (ICMP_t *)&(ip->udp_src);
33d02930:	e2876014 	add	r6, r7, #20	; 0x14

			switch (icmph->type) {
33d02934:	0a000006 	beq	33d02954 <NetReceive+0x4c4>
33d02938:	ca000002 	bgt	33d02948 <NetReceive+0x4b8>
33d0293c:	e3510000 	cmp	r1, #0	; 0x0
33d02940:	0a00000d 	beq	33d0297c <NetReceive+0x4ec>
33d02944:	ea00004b 	b	33d02a78 <NetReceive+0x5e8>
33d02948:	e3510008 	cmp	r1, #8	; 0x8
33d0294c:	0a00000e 	beq	33d0298c <NetReceive+0x4fc>
33d02950:	ea000048 	b	33d02a78 <NetReceive+0x5e8>
			case ICMP_REDIRECT:
				if (icmph->code != ICMP_REDIR_HOST)
33d02954:	e5d63001 	ldrb	r3, [r6, #1]
33d02958:	e3530001 	cmp	r3, #1	; 0x1
33d0295c:	1a000045 	bne	33d02a78 <NetReceive+0x5e8>
					return;
				puts (" ICMP Host Redirect to ");
33d02960:	e59f0174 	ldr	r0, [pc, #372]	; 33d02adc <NetReceive+0x64c>
33d02964:	eb005190 	bl	33d16fac <puts>
				print_IPaddr(icmph->un.gateway);
33d02968:	e5960004 	ldr	r0, [r6, #4]
33d0296c:	ebfffebe 	bl	33d0246c <print_IPaddr>
				putc(' ');
33d02970:	e3a00020 	mov	r0, #32	; 0x20
33d02974:	eb005182 	bl	33d16f84 <putc>
				return;
33d02978:	ea00003e 	b	33d02a78 <NetReceive+0x5e8>
			case ICMP_ECHO_REPLY:
				/*
				 *	IP header OK.  Pass the packet to the current handler.
				 */
				/* XXX point to ip packet */
				(*packetHandler)((uchar *)ip, 0, 0, 0);
33d0297c:	e1a00007 	mov	r0, r7
33d02980:	e1a02001 	mov	r2, r1
33d02984:	e1a03001 	mov	r3, r1
33d02988:	ea000037 	b	33d02a6c <NetReceive+0x5dc>
			case ICMP_ECHO_REQUEST:
#ifdef ET_DEBUG
				printf ("Got ICMP ECHO REQUEST, return %d bytes \n",
					ETHER_HDR_SIZE + len);
#endif
				memcpy (&et->et_dest[0], &et->et_src[0], 6);
33d0298c:	e28a4006 	add	r4, sl, #6	; 0x6
33d02990:	e1a01004 	mov	r1, r4
33d02994:	e3a02006 	mov	r2, #6	; 0x6
33d02998:	e1a0000a 	mov	r0, sl
33d0299c:	eb005e90 	bl	33d1a3e4 <memcpy>
				memcpy (&et->et_src[ 0], NetOurEther, 6);
33d029a0:	e1a00004 	mov	r0, r4
33d029a4:	e59f10f8 	ldr	r1, [pc, #248]	; 33d02aa4 <NetReceive+0x614>
	memcpy(to, (void*)&ip, sizeof(ip));
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
33d029a8:	e287400c 	add	r4, r7, #12	; 0xc
33d029ac:	e3a02006 	mov	r2, #6	; 0x6
33d029b0:	eb005e8b 	bl	33d1a3e4 <memcpy>
	memcpy(to, from, sizeof(IPaddr_t));
33d029b4:	e1a01004 	mov	r1, r4
33d029b8:	e3a02004 	mov	r2, #4	; 0x4

				ip->ip_sum = 0;
33d029bc:	e1c790ba 	strh	r9, [r7, #10]
				ip->ip_off = 0;
33d029c0:	e1c790b6 	strh	r9, [r7, #6]
33d029c4:	e1a0000b 	mov	r0, fp
33d029c8:	eb005e85 	bl	33d1a3e4 <memcpy>
				NetCopyIP((void*)&ip->ip_dst, &ip->ip_src);
				NetCopyIP((void*)&ip->ip_src, &NetOurIP);
				ip->ip_sum = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP >> 1);
33d029cc:	e3a02004 	mov	r2, #4	; 0x4
33d029d0:	e59f10c8 	ldr	r1, [pc, #200]	; 33d02aa0 <NetReceive+0x610>
33d029d4:	e1a00004 	mov	r0, r4
33d029d8:	eb005e81 	bl	33d1a3e4 <memcpy>
33d029dc:	e3a0100a 	mov	r1, #10	; 0xa
33d029e0:	e1a00007 	mov	r0, r7
33d029e4:	ebfffd23 	bl	33d01e78 <NetCksum>

				icmph->type = ICMP_ECHO_REPLY;
				icmph->checksum = 0;
				icmph->checksum = ~NetCksum((uchar *)icmph,
33d029e8:	e2451014 	sub	r1, r5, #20	; 0x14

				ip->ip_sum = 0;
				ip->ip_off = 0;
				NetCopyIP((void*)&ip->ip_dst, &ip->ip_src);
				NetCopyIP((void*)&ip->ip_src, &NetOurIP);
				ip->ip_sum = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP >> 1);
33d029ec:	e1e00000 	mvn	r0, r0
33d029f0:	e1c700ba 	strh	r0, [r7, #10]

				icmph->type = ICMP_ECHO_REPLY;
				icmph->checksum = 0;
				icmph->checksum = ~NetCksum((uchar *)icmph,
33d029f4:	e1a010a1 	lsr	r1, r1, #1
				ip->ip_off = 0;
				NetCopyIP((void*)&ip->ip_dst, &ip->ip_src);
				NetCopyIP((void*)&ip->ip_src, &NetOurIP);
				ip->ip_sum = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP >> 1);

				icmph->type = ICMP_ECHO_REPLY;
33d029f8:	e5c79014 	strb	r9, [r7, #20]
				icmph->checksum = 0;
33d029fc:	e1c690b2 	strh	r9, [r6, #2]
				icmph->checksum = ~NetCksum((uchar *)icmph,
33d02a00:	e1a00006 	mov	r0, r6
33d02a04:	ebfffd1b 	bl	33d01e78 <NetCksum>
33d02a08:	e1e00000 	mvn	r0, r0
33d02a0c:	e1c600b2 	strh	r0, [r6, #2]
						(len - IP_HDR_SIZE_NO_UDP) >> 1);
				(void) eth_send((uchar *)et, ETHER_HDR_SIZE + len);
33d02a10:	e285100e 	add	r1, r5, #14	; 0xe
33d02a14:	e1a0000a 	mov	r0, sl
33d02a18:	eb0006cd 	bl	33d04554 <eth_send>
				return;
33d02a1c:	ea000015 	b	33d02a78 <NetReceive+0x5e8>
#endif
			default:
				return;
			}
		} else if (ip->ip_p != IPPROTO_UDP) {	/* Only UDP packets */
33d02a20:	e3530011 	cmp	r3, #17	; 0x11
33d02a24:	1a000013 	bne	33d02a78 <NetReceive+0x5e8>
33d02a28:	e1d701b8 	ldrh	r0, [r7, #24]
						ntohs(ip->udp_len) - 8);
#endif
		/*
		 *	IP header OK.  Pass the packet to the current handler.
		 */
		(*packetHandler)((uchar *)ip +IP_HDR_SIZE,
33d02a2c:	e1d7c1b6 	ldrh	ip, [r7, #22]
33d02a30:	e1d7e1b4 	ldrh	lr, [r7, #20]
	return __arch__swab16(x);
33d02a34:	e1a03420 	lsr	r3, r0, #8
33d02a38:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02a3c:	e1a0142c 	lsr	r1, ip, #8
33d02a40:	e1a0242e 	lsr	r2, lr, #8
33d02a44:	e1833c00 	orr	r3, r3, r0, lsl #24
	return __arch__swab16(x);
33d02a48:	e1a01801 	lsl	r1, r1, #16
33d02a4c:	e1a02802 	lsl	r2, r2, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02a50:	e1811c0c 	orr	r1, r1, ip, lsl #24
33d02a54:	e1822c0e 	orr	r2, r2, lr, lsl #24
33d02a58:	e1a03823 	lsr	r3, r3, #16
33d02a5c:	e287001c 	add	r0, r7, #28	; 0x1c
33d02a60:	e1a01821 	lsr	r1, r1, #16
33d02a64:	e1a02822 	lsr	r2, r2, #16
33d02a68:	e2433008 	sub	r3, r3, #8	; 0x8
33d02a6c:	e59fc06c 	ldr	ip, [pc, #108]	; 33d02ae0 <NetReceive+0x650>
33d02a70:	e1a0e00f 	mov	lr, pc
33d02a74:	e59cf000 	ldr	pc, [ip]
						ntohs(ip->udp_dst),
						ntohs(ip->udp_src),
						ntohs(ip->udp_len) - 8);
		break;
	}
}
33d02a78:	e28dd010 	add	sp, sp, #16	; 0x10
33d02a7c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d02a80:	33d37330 	.word	0x33d37330
33d02a84:	33d37334 	.word	0x33d37334
33d02a88:	00000fff 	.word	0x00000fff
33d02a8c:	33d2ddaa 	.word	0x33d2ddaa
33d02a90:	33d2dda8 	.word	0x33d2dda8
33d02a94:	000005e9 	.word	0x000005e9
33d02a98:	00000806 	.word	0x00000806
33d02a9c:	00008035 	.word	0x00008035
33d02aa0:	33d37318 	.word	0x33d37318
33d02aa4:	33d37310 	.word	0x33d37310
33d02aa8:	33d391e4 	.word	0x33d391e4
33d02aac:	33d391ec 	.word	0x33d391ec
33d02ab0:	33d391e8 	.word	0x33d391e8
33d02ab4:	33d391f0 	.word	0x33d391f0
33d02ab8:	33d391f4 	.word	0x33d391f4
33d02abc:	33d257fc 	.word	0x33d257fc
33d02ac0:	00000406 	.word	0x00000406
33d02ac4:	33d25810 	.word	0x33d25810
33d02ac8:	33d3731c 	.word	0x33d3731c
33d02acc:	33d37276 	.word	0x33d37276
33d02ad0:	33d25828 	.word	0x33d25828
33d02ad4:	0000ff1f 	.word	0x0000ff1f
33d02ad8:	33d2583c 	.word	0x33d2583c
33d02adc:	33d2584c 	.word	0x33d2584c
33d02ae0:	33d39828 	.word	0x33d39828

33d02ae4 <string_to_ip>:
		 (int) ((x >> 8) & 0xff), (int) ((x >> 0) & 0xff)
	);
}

IPaddr_t string_to_ip(char *s)
{
33d02ae4:	e92d4070 	push	{r4, r5, r6, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
33d02ae8:	e2504000 	subs	r4, r0, #0	; 0x0
		 (int) ((x >> 8) & 0xff), (int) ((x >> 0) & 0xff)
	);
}

IPaddr_t string_to_ip(char *s)
{
33d02aec:	e24dd004 	sub	sp, sp, #4	; 0x4
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
		return(0);
33d02af0:	01a00004 	moveq	r0, r4
{
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
33d02af4:	0a000018 	beq	33d02b5c <string_to_ip+0x78>
		return(0);

	for (addr=0, i=0; i<4; ++i) {
33d02af8:	e3a05000 	mov	r5, #0	; 0x0
33d02afc:	e3a06003 	mov	r6, #3	; 0x3
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
33d02b00:	e3540000 	cmp	r4, #0	; 0x0
33d02b04:	e1a00004 	mov	r0, r4
33d02b08:	e1a0100d 	mov	r1, sp
33d02b0c:	e3a0200a 	mov	r2, #10	; 0xa
33d02b10:	01a00004 	moveq	r0, r4
33d02b14:	1b005e90 	blne	33d1a55c <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
33d02b18:	e20030ff 	and	r3, r0, #255	; 0xff
		if (s) {
33d02b1c:	e3540000 	cmp	r4, #0	; 0x0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
		addr <<= 8;
		addr |= (val & 0xFF);
33d02b20:	e1835405 	orr	r5, r3, r5, lsl #8
		if (s) {
33d02b24:	0a000004 	beq	33d02b3c <string_to_ip+0x58>
			s = (*e) ? e+1 : e;
33d02b28:	e59d2000 	ldr	r2, [sp]
33d02b2c:	e5d23000 	ldrb	r3, [r2]
33d02b30:	e3530000 	cmp	r3, #0	; 0x0
33d02b34:	01a04002 	moveq	r4, r2
33d02b38:	12824001 	addne	r4, r2, #1	; 0x1
33d02b3c:	e2566001 	subs	r6, r6, #1	; 0x1
33d02b40:	5affffee 	bpl	33d02b00 <string_to_ip+0x1c>
33d02b44:	e2053cff 	and	r3, r5, #65280	; 0xff00
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
33d02b48:	e1a03403 	lsl	r3, r3, #8
33d02b4c:	e1833c05 	orr	r3, r3, r5, lsl #24
33d02b50:	e20528ff 	and	r2, r5, #16711680	; 0xff0000
33d02b54:	e1833422 	orr	r3, r3, r2, lsr #8
33d02b58:	e1830c25 	orr	r0, r3, r5, lsr #24
		}
	}

	return (htonl(addr));
}
33d02b5c:	e28dd004 	add	sp, sp, #4	; 0x4
33d02b60:	e8bd8070 	pop	{r4, r5, r6, pc}

33d02b64 <getenv_IPaddr>:

	puts (tmp);
}

IPaddr_t getenv_IPaddr (char *var)
{
33d02b64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return (string_to_ip(getenv(var)));
33d02b68:	eb004b38 	bl	33d15850 <getenv>
}
33d02b6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	puts (tmp);
}

IPaddr_t getenv_IPaddr (char *var)
{
	return (string_to_ip(getenv(var)));
33d02b70:	eaffffdb 	b	33d02ae4 <string_to_ip>

33d02b74 <VLAN_to_string>:

	return (htonl(addr));
}

void VLAN_to_string(ushort x, char *s)
{
33d02b74:	e1a00800 	lsl	r0, r0, #16
33d02b78:	e1a0c820 	lsr	ip, r0, #16
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
33d02b7c:	e1a0342c 	lsr	r3, ip, #8
33d02b80:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02b84:	e1833c0c 	orr	r3, r3, ip, lsl #24
	x = ntohs(x);

	if (x == (ushort)-1)
		x = VLAN_NONE;
33d02b88:	e59f0034 	ldr	r0, [pc, #52]	; 33d02bc4 <VLAN_to_string+0x50>
33d02b8c:	e3730801 	cmn	r3, #65536	; 0x10000
33d02b90:	11a0c823 	lsrne	ip, r3, #16
33d02b94:	01a0c000 	moveq	ip, r0

	if (x == VLAN_NONE)
		strcpy(s, "none");
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
33d02b98:	e1a02a0c 	lsl	r2, ip, #20
	x = ntohs(x);

	if (x == (ushort)-1)
		x = VLAN_NONE;

	if (x == VLAN_NONE)
33d02b9c:	e15c0000 	cmp	ip, r0

	return (htonl(addr));
}

void VLAN_to_string(ushort x, char *s)
{
33d02ba0:	e1a03001 	mov	r3, r1

	if (x == (ushort)-1)
		x = VLAN_NONE;

	if (x == VLAN_NONE)
		strcpy(s, "none");
33d02ba4:	e1a00001 	mov	r0, r1
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
33d02ba8:	e1a02a22 	lsr	r2, r2, #20

	if (x == (ushort)-1)
		x = VLAN_NONE;

	if (x == VLAN_NONE)
		strcpy(s, "none");
33d02bac:	e59f1014 	ldr	r1, [pc, #20]	; 33d02bc8 <VLAN_to_string+0x54>
	x = ntohs(x);

	if (x == (ushort)-1)
		x = VLAN_NONE;

	if (x == VLAN_NONE)
33d02bb0:	1a000000 	bne	33d02bb8 <VLAN_to_string+0x44>
		strcpy(s, "none");
33d02bb4:	ea005d00 	b	33d19fbc <strcpy>
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
33d02bb8:	e59f100c 	ldr	r1, [pc, #12]	; 33d02bcc <VLAN_to_string+0x58>
33d02bbc:	e1a00003 	mov	r0, r3
33d02bc0:	ea00604b 	b	33d1acf4 <sprintf>
33d02bc4:	00000fff 	.word	0x00000fff
33d02bc8:	33d25864 	.word	0x33d25864
33d02bcc:	33d2586c 	.word	0x33d2586c

33d02bd0 <string_to_VLAN>:

ushort string_to_VLAN(char *s)
{
	ushort id;

	if (s == NULL)
33d02bd0:	e250c000 	subs	ip, r0, #0	; 0x0
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
}

ushort string_to_VLAN(char *s)
{
33d02bd4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	ushort id;

	if (s == NULL)
		return htons(VLAN_NONE);
33d02bd8:	e59f3040 	ldr	r3, [pc, #64]	; 33d02c20 <string_to_VLAN+0x50>

ushort string_to_VLAN(char *s)
{
	ushort id;

	if (s == NULL)
33d02bdc:	0a00000d 	beq	33d02c18 <string_to_VLAN+0x48>
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
33d02be0:	e5dc3000 	ldrb	r3, [ip]
33d02be4:	e2433030 	sub	r3, r3, #48	; 0x30
33d02be8:	e3530009 	cmp	r3, #9	; 0x9
		id = VLAN_NONE;
	else
		id = (ushort)simple_strtoul(s, NULL, 10);
33d02bec:	e3a01000 	mov	r1, #0	; 0x0
33d02bf0:	e3a0200a 	mov	r2, #10	; 0xa

	if (s == NULL)
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
		id = VLAN_NONE;
33d02bf4:	e59fc028 	ldr	ip, [pc, #40]	; 33d02c24 <string_to_VLAN+0x54>
	ushort id;

	if (s == NULL)
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
33d02bf8:	8a000002 	bhi	33d02c08 <string_to_VLAN+0x38>
		id = VLAN_NONE;
	else
		id = (ushort)simple_strtoul(s, NULL, 10);
33d02bfc:	eb005e56 	bl	33d1a55c <simple_strtoul>
33d02c00:	e1a00800 	lsl	r0, r0, #16
33d02c04:	e1a0c820 	lsr	ip, r0, #16
	return __arch__swab16(x);
33d02c08:	e1a0342c 	lsr	r3, ip, #8
33d02c0c:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d02c10:	e1833c0c 	orr	r3, r3, ip, lsl #24
33d02c14:	e1a03823 	lsr	r3, r3, #16

	return htons(id);
}
33d02c18:	e1a00003 	mov	r0, r3
33d02c1c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d02c20:	0000ff0f 	.word	0x0000ff0f
33d02c24:	00000fff 	.word	0x00000fff

33d02c28 <getenv_VLAN>:
{
	return (string_to_ip(getenv(var)));
}

ushort getenv_VLAN(char *var)
{
33d02c28:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return (string_to_VLAN(getenv(var)));
33d02c2c:	eb004b07 	bl	33d15850 <getenv>
33d02c30:	ebffffe6 	bl	33d02bd0 <string_to_VLAN>
33d02c34:	e1a00800 	lsl	r0, r0, #16
}
33d02c38:	e1a00820 	lsr	r0, r0, #16
33d02c3c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d02c40 <NetLoop>:
 *	Main network processing loop.
 */

int
NetLoop(proto_t protocol)
{
33d02c40:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	NetRestarted = 0;
	NetDevExists = 0;
#endif

	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
33d02c44:	e59f3400 	ldr	r3, [pc, #1024]	; 33d0304c <NetLoop+0x40c>
33d02c48:	e3a02000 	mov	r2, #0	; 0x0
 */

int
NetLoop(proto_t protocol)
{
	bd_t *bd = gd->bd;
33d02c4c:	e5987000 	ldr	r7, [r8]
	NetRestarted = 0;
	NetDevExists = 0;
#endif

	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
33d02c50:	e5832000 	str	r2, [r3]
	NetArpWaitTxPacket = NULL;
	NetArpWaitPacketIP = 0;
33d02c54:	e59f33f4 	ldr	r3, [pc, #1012]	; 33d03050 <NetLoop+0x410>
33d02c58:	e5832000 	str	r2, [r3]
	NetArpWaitReplyIP = 0;
33d02c5c:	e59f33f0 	ldr	r3, [pc, #1008]	; 33d03054 <NetLoop+0x414>
	NetDevExists = 0;
#endif

	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
	NetArpWaitTxPacket = NULL;
33d02c60:	e59fc3f0 	ldr	ip, [pc, #1008]	; 33d03058 <NetLoop+0x418>
		int	i;
		/*
		 *	Setup packet buffers, aligned correctly.
		 */
		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
33d02c64:	e59f13f0 	ldr	r1, [pc, #1008]	; 33d0305c <NetLoop+0x41c>

	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
	NetArpWaitTxPacket = NULL;
	NetArpWaitPacketIP = 0;
	NetArpWaitReplyIP = 0;
33d02c68:	e5832000 	str	r2, [r3]
		int	i;
		/*
		 *	Setup packet buffers, aligned correctly.
		 */
		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
33d02c6c:	e59f33ec 	ldr	r3, [pc, #1004]	; 33d03060 <NetLoop+0x420>
33d02c70:	e3c1101f 	bic	r1, r1, #31	; 0x1f
	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
	NetArpWaitTxPacket = NULL;
	NetArpWaitPacketIP = 0;
	NetArpWaitReplyIP = 0;
	NetArpWaitTxPacket = NULL;
33d02c74:	e58c2000 	str	r2, [ip]
		int	i;
		/*
		 *	Setup packet buffers, aligned correctly.
		 */
		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
33d02c78:	e5831000 	str	r1, [r3]
 *	Main network processing loop.
 */

int
NetLoop(proto_t protocol)
{
33d02c7c:	e24dd00c 	sub	sp, sp, #12	; 0xc
33d02c80:	e1a06000 	mov	r6, r0
33d02c84:	e2811c06 	add	r1, r1, #1536	; 0x600
		 *	Setup packet buffers, aligned correctly.
		 */
		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
		for (i = 0; i < PKTBUFSRX; i++) {
			NetRxPackets[i] = NetTxPacket + (i+1)*PKTSIZE_ALIGN;
33d02c88:	e59f33d4 	ldr	r3, [pc, #980]	; 33d03064 <NetLoop+0x424>
33d02c8c:	e7831102 	str	r1, [r3, r2, lsl #2]
		/*
		 *	Setup packet buffers, aligned correctly.
		 */
		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
		for (i = 0; i < PKTBUFSRX; i++) {
33d02c90:	e2822001 	add	r2, r2, #1	; 0x1
33d02c94:	e3520003 	cmp	r2, #3	; 0x3
33d02c98:	e2811c06 	add	r1, r1, #1536	; 0x600
33d02c9c:	dafffff9 	ble	33d02c88 <NetLoop+0x48>
			NetRxPackets[i] = NetTxPacket + (i+1)*PKTSIZE_ALIGN;
		}
	}

	if (!NetArpWaitTxPacket) {
33d02ca0:	e59c2000 	ldr	r2, [ip]
33d02ca4:	e3520000 	cmp	r2, #0	; 0x0
		NetArpWaitTxPacket = &NetArpWaitPacketBuf[0] + (PKTALIGN - 1);
		NetArpWaitTxPacket -= (ulong)NetArpWaitTxPacket % PKTALIGN;
33d02ca8:	059f33b8 	ldreq	r3, [pc, #952]	; 33d03068 <NetLoop+0x428>
33d02cac:	03c3301f 	biceq	r3, r3, #31	; 0x1f
33d02cb0:	058c3000 	streq	r3, [ip]
		NetArpWaitTxPacketSize = 0;
33d02cb4:	059f33b0 	ldreq	r3, [pc, #944]	; 33d0306c <NetLoop+0x42c>
33d02cb8:	05832000 	streq	r2, [r3]
	}

	eth_halt();
33d02cbc:	eb00065a 	bl	33d0462c <eth_halt>
#ifdef CONFIG_NET_MULTI
	eth_set_current();
#endif
	if (eth_init(bd) < 0) {
33d02cc0:	e1a00007 	mov	r0, r7
33d02cc4:	eb000518 	bl	33d0412c <eth_init>
33d02cc8:	e3500000 	cmp	r0, #0	; 0x0
33d02ccc:	ba000067 	blt	33d02e70 <NetLoop+0x230>

restart:
#ifdef CONFIG_NET_MULTI
	memcpy (NetOurEther, eth_get_dev()->enetaddr, 6);
#else
	memcpy (NetOurEther, bd->bi_enetaddr, 6);
33d02cd0:	e59f0398 	ldr	r0, [pc, #920]	; 33d03070 <NetLoop+0x430>
33d02cd4:	e2871008 	add	r1, r7, #8	; 0x8
33d02cd8:	e3a02006 	mov	r2, #6	; 0x6
#endif

	NetState = NETLOOP_CONTINUE;
33d02cdc:	e59fa390 	ldr	sl, [pc, #912]	; 33d03074 <NetLoop+0x434>

restart:
#ifdef CONFIG_NET_MULTI
	memcpy (NetOurEther, eth_get_dev()->enetaddr, 6);
#else
	memcpy (NetOurEther, bd->bi_enetaddr, 6);
33d02ce0:	eb005dbf 	bl	33d1a3e4 <memcpy>
#endif

	NetState = NETLOOP_CONTINUE;
33d02ce4:	e3a03001 	mov	r3, #1	; 0x1
	 *	Start the ball rolling with the given start function.  From
	 *	here on, this code is a state machine driven by received
	 *	packets and timer events.
	 */

	switch (protocol) {
33d02ce8:	e3560009 	cmp	r6, #9	; 0x9
	memcpy (NetOurEther, eth_get_dev()->enetaddr, 6);
#else
	memcpy (NetOurEther, bd->bi_enetaddr, 6);
#endif

	NetState = NETLOOP_CONTINUE;
33d02cec:	e58a3000 	str	r3, [sl]
	 *	Start the ball rolling with the given start function.  From
	 *	here on, this code is a state machine driven by received
	 *	packets and timer events.
	 */

	switch (protocol) {
33d02cf0:	8a000060 	bhi	33d02e78 <NetLoop+0x238>
33d02cf4:	e1a03613 	lsl	r3, r3, r6
33d02cf8:	e2132f8a 	ands	r2, r3, #552	; 0x228
33d02cfc:	1a000004 	bne	33d02d14 <NetLoop+0xd4>
33d02d00:	e3130003 	tst	r3, #3	; 0x3
33d02d04:	1a00001f 	bne	33d02d88 <NetLoop+0x148>
33d02d08:	e3130c01 	tst	r3, #256	; 0x100
33d02d0c:	1a00002b 	bne	33d02dc0 <NetLoop+0x180>
33d02d10:	ea000032 	b	33d02de0 <NetLoop+0x1a0>
33d02d14:	e2871004 	add	r1, r7, #4	; 0x4
33d02d18:	e3a02004 	mov	r2, #4	; 0x4
33d02d1c:	e59f0354 	ldr	r0, [pc, #852]	; 33d03078 <NetLoop+0x438>
33d02d20:	eb005daf 	bl	33d1a3e4 <memcpy>
	case SNTP:
#endif
	case NETCONS:
	case TFTP:
		NetCopyIP(&NetOurIP, &bd->bi_ip_addr);
		NetOurGatewayIP = getenv_IPaddr ("gatewayip");
33d02d24:	e59f0350 	ldr	r0, [pc, #848]	; 33d0307c <NetLoop+0x43c>
33d02d28:	ebffff8d 	bl	33d02b64 <getenv_IPaddr>
33d02d2c:	e59f334c 	ldr	r3, [pc, #844]	; 33d03080 <NetLoop+0x440>
33d02d30:	e5830000 	str	r0, [r3]
		NetOurSubnetMask= getenv_IPaddr ("netmask");
33d02d34:	e59f0348 	ldr	r0, [pc, #840]	; 33d03084 <NetLoop+0x444>
33d02d38:	ebffff89 	bl	33d02b64 <getenv_IPaddr>
33d02d3c:	e59f3344 	ldr	r3, [pc, #836]	; 33d03088 <NetLoop+0x448>
33d02d40:	e5830000 	str	r0, [r3]
		NetOurVLAN = getenv_VLAN("vlan");
33d02d44:	e59f0340 	ldr	r0, [pc, #832]	; 33d0308c <NetLoop+0x44c>
33d02d48:	ebffffb6 	bl	33d02c28 <getenv_VLAN>
33d02d4c:	e59f333c 	ldr	r3, [pc, #828]	; 33d03090 <NetLoop+0x450>
33d02d50:	e1c300b0 	strh	r0, [r3]
		NetOurNativeVLAN = getenv_VLAN("nvlan");
33d02d54:	e59f0338 	ldr	r0, [pc, #824]	; 33d03094 <NetLoop+0x454>
33d02d58:	ebffffb2 	bl	33d02c28 <getenv_VLAN>
33d02d5c:	e59f3334 	ldr	r3, [pc, #820]	; 33d03098 <NetLoop+0x458>

		switch (protocol) {
33d02d60:	e3560003 	cmp	r6, #3	; 0x3
	case TFTP:
		NetCopyIP(&NetOurIP, &bd->bi_ip_addr);
		NetOurGatewayIP = getenv_IPaddr ("gatewayip");
		NetOurSubnetMask= getenv_IPaddr ("netmask");
		NetOurVLAN = getenv_VLAN("vlan");
		NetOurNativeVLAN = getenv_VLAN("nvlan");
33d02d64:	e1c300b0 	strh	r0, [r3]

		switch (protocol) {
33d02d68:	0a000001 	beq	33d02d74 <NetLoop+0x134>
33d02d6c:	e3560009 	cmp	r6, #9	; 0x9
33d02d70:	1a00001a 	bne	33d02de0 <NetLoop+0x1a0>
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
		case NFS:
#endif
		case NETCONS:
		case TFTP:
			NetServerIP = getenv_IPaddr ("serverip");
33d02d74:	e59f0320 	ldr	r0, [pc, #800]	; 33d0309c <NetLoop+0x45c>
33d02d78:	ebffff79 	bl	33d02b64 <getenv_IPaddr>
33d02d7c:	e59f331c 	ldr	r3, [pc, #796]	; 33d030a0 <NetLoop+0x460>
33d02d80:	e5830000 	str	r0, [r3]
			break;
33d02d84:	ea000015 	b	33d02de0 <NetLoop+0x1a0>
	case RARP:
		/*
		 * initialize our IP addr to 0 in order to accept ANY
		 * IP addr assigned to us by the BOOTP / RARP server
		 */
		NetOurIP = 0;
33d02d88:	e59f32e8 	ldr	r3, [pc, #744]	; 33d03078 <NetLoop+0x438>
		NetServerIP = getenv_IPaddr ("serverip");
33d02d8c:	e59f0308 	ldr	r0, [pc, #776]	; 33d0309c <NetLoop+0x45c>
	case RARP:
		/*
		 * initialize our IP addr to 0 in order to accept ANY
		 * IP addr assigned to us by the BOOTP / RARP server
		 */
		NetOurIP = 0;
33d02d90:	e5832000 	str	r2, [r3]
		NetServerIP = getenv_IPaddr ("serverip");
33d02d94:	ebffff72 	bl	33d02b64 <getenv_IPaddr>
33d02d98:	e59f3300 	ldr	r3, [pc, #768]	; 33d030a0 <NetLoop+0x460>
33d02d9c:	e5830000 	str	r0, [r3]
		NetOurVLAN = getenv_VLAN("vlan");	/* VLANs must be read */
33d02da0:	e59f02e4 	ldr	r0, [pc, #740]	; 33d0308c <NetLoop+0x44c>
33d02da4:	ebffff9f 	bl	33d02c28 <getenv_VLAN>
33d02da8:	e59f32e0 	ldr	r3, [pc, #736]	; 33d03090 <NetLoop+0x450>
33d02dac:	e1c300b0 	strh	r0, [r3]
		NetOurNativeVLAN = getenv_VLAN("nvlan");
33d02db0:	e59f02dc 	ldr	r0, [pc, #732]	; 33d03094 <NetLoop+0x454>
33d02db4:	ebffff9b 	bl	33d02c28 <getenv_VLAN>
33d02db8:	e59f32d8 	ldr	r3, [pc, #728]	; 33d03098 <NetLoop+0x458>
33d02dbc:	e1c300b0 	strh	r0, [r3]
	case CDP:
		NetOurVLAN = getenv_VLAN("vlan");	/* VLANs must be read */
33d02dc0:	e59f02c4 	ldr	r0, [pc, #708]	; 33d0308c <NetLoop+0x44c>
33d02dc4:	ebffff97 	bl	33d02c28 <getenv_VLAN>
33d02dc8:	e59f32c0 	ldr	r3, [pc, #704]	; 33d03090 <NetLoop+0x450>
33d02dcc:	e1c300b0 	strh	r0, [r3]
		NetOurNativeVLAN = getenv_VLAN("nvlan");
33d02dd0:	e59f02bc 	ldr	r0, [pc, #700]	; 33d03094 <NetLoop+0x454>
33d02dd4:	ebffff93 	bl	33d02c28 <getenv_VLAN>
33d02dd8:	e59f32b8 	ldr	r3, [pc, #696]	; 33d03098 <NetLoop+0x458>
33d02ddc:	e1c300b0 	strh	r0, [r3]

/**********************************************************************/

static int net_check_prereq (proto_t protocol)
{
	switch (protocol) {
33d02de0:	e3560009 	cmp	r6, #9	; 0x9
33d02de4:	8a000023 	bhi	33d02e78 <NetLoop+0x238>
33d02de8:	e59f32b4 	ldr	r3, [pc, #692]	; 33d030a4 <NetLoop+0x464>
33d02dec:	e3a02001 	mov	r2, #1	; 0x1
33d02df0:	e1a02612 	lsl	r2, r2, r6
33d02df4:	e0023003 	and	r3, r2, r3
33d02df8:	e3530000 	cmp	r3, #0	; 0x0
33d02dfc:	1a000013 	bne	33d02e50 <NetLoop+0x210>
33d02e00:	e3120f82 	tst	r2, #520	; 0x208
33d02e04:	1a000007 	bne	33d02e28 <NetLoop+0x1e8>
33d02e08:	e3120020 	tst	r2, #32	; 0x20
33d02e0c:	0a000019 	beq	33d02e78 <NetLoop+0x238>
		/* Fall through */
#if (CONFIG_COMMANDS & CFG_CMD_PING)
	case PING:
		if (NetPingIP == 0) {
33d02e10:	e59f3290 	ldr	r3, [pc, #656]	; 33d030a8 <NetLoop+0x468>
33d02e14:	e5933000 	ldr	r3, [r3]
33d02e18:	e3530000 	cmp	r3, #0	; 0x0
33d02e1c:	1a000006 	bne	33d02e3c <NetLoop+0x1fc>
			puts ("*** ERROR: ping address not given\n");
33d02e20:	e59f0284 	ldr	r0, [pc, #644]	; 33d030ac <NetLoop+0x46c>
33d02e24:	ea000010 	b	33d02e6c <NetLoop+0x22c>
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
	case NFS:
#endif
	case NETCONS:
	case TFTP:
		if (NetServerIP == 0) {
33d02e28:	e59f3270 	ldr	r3, [pc, #624]	; 33d030a0 <NetLoop+0x460>
33d02e2c:	e5933000 	ldr	r3, [r3]
33d02e30:	e3530000 	cmp	r3, #0	; 0x0
			puts ("*** ERROR: `serverip' not set\n");
33d02e34:	059f0274 	ldreq	r0, [pc, #628]	; 33d030b0 <NetLoop+0x470>
33d02e38:	0a00000b 	beq	33d02e6c <NetLoop+0x22c>
		}
#if (CONFIG_COMMANDS & (CFG_CMD_PING | CFG_CMD_SNTP))
    common:
#endif

		if (NetOurIP == 0) {
33d02e3c:	e59f3234 	ldr	r3, [pc, #564]	; 33d03078 <NetLoop+0x438>
33d02e40:	e5933000 	ldr	r3, [r3]
33d02e44:	e3530000 	cmp	r3, #0	; 0x0
			puts ("*** ERROR: `ipaddr' not set\n");
33d02e48:	059f0264 	ldreq	r0, [pc, #612]	; 33d030b4 <NetLoop+0x474>
33d02e4c:	0a000006 	beq	33d02e6c <NetLoop+0x22c>

	case DHCP:
	case RARP:
	case BOOTP:
	case CDP:
		if (memcmp (NetOurEther, "\0\0\0\0\0\0", 6) == 0) {
33d02e50:	e59f0218 	ldr	r0, [pc, #536]	; 33d03070 <NetLoop+0x430>
33d02e54:	e59f125c 	ldr	r1, [pc, #604]	; 33d030b8 <NetLoop+0x478>
33d02e58:	e3a02006 	mov	r2, #6	; 0x6
33d02e5c:	eb005d82 	bl	33d1a46c <memcmp>
33d02e60:	e3500000 	cmp	r0, #0	; 0x0
33d02e64:	1a000003 	bne	33d02e78 <NetLoop+0x238>
			}

			NetStartAgain ();
			return (2);
#else
			puts ("*** ERROR: `ethaddr' not set\n");
33d02e68:	e59f024c 	ldr	r0, [pc, #588]	; 33d030bc <NetLoop+0x47c>
33d02e6c:	eb00504e 	bl	33d16fac <puts>
	}

	switch (net_check_prereq (protocol)) {
	case 1:
		/* network not configured */
		eth_halt();
33d02e70:	eb0005ed 	bl	33d0462c <eth_halt>
33d02e74:	ea000071 	b	33d03040 <NetLoop+0x400>

	case 0:
#ifdef CONFIG_NET_MULTI
		NetDevExists = 1;
#endif
		switch (protocol) {
33d02e78:	e3560005 	cmp	r6, #5	; 0x5
33d02e7c:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
33d02e80:	ea00001b 	b	33d02ef4 <NetLoop+0x2b4>
33d02e84:	33d02ea4 	.word	0x33d02ea4
33d02e88:	33d02eb8 	.word	0x33d02eb8
33d02e8c:	33d02ef4 	.word	0x33d02ef4
33d02e90:	33d02e9c 	.word	0x33d02e9c
33d02e94:	33d02ef4 	.word	0x33d02ef4
33d02e98:	33d02edc 	.word	0x33d02edc
		case TFTP:
			/* always use ARP to get server ethernet address */
			TftpStart();
33d02e9c:	eb0001e2 	bl	33d0362c <TftpStart>
			break;
33d02ea0:	ea000013 	b	33d02ef4 <NetLoop+0x2b4>
			DhcpRequest();		/* Basically same as BOOTP */
			break;
#endif /* CFG_CMD_DHCP */

		case BOOTP:
			BootpTry = 0;
33d02ea4:	e59f3214 	ldr	r3, [pc, #532]	; 33d030c0 <NetLoop+0x480>
33d02ea8:	e3a02000 	mov	r2, #0	; 0x0
33d02eac:	e5832000 	str	r2, [r3]
			BootpRequest ();
33d02eb0:	eb00034f 	bl	33d03bf4 <BootpRequest>
			break;
33d02eb4:	ea00000e 	b	33d02ef4 <NetLoop+0x2b4>

		case RARP:
			RarpTry = 0;
33d02eb8:	e59f3204 	ldr	r3, [pc, #516]	; 33d030c4 <NetLoop+0x484>
33d02ebc:	e3a02000 	mov	r2, #0	; 0x0
33d02ec0:	e5832000 	str	r2, [r3]
			RarpRequest ();
33d02ec4:	eb000404 	bl	33d03edc <RarpRequest>
			break;
33d02ec8:	ea000009 	b	33d02ef4 <NetLoop+0x2b4>

		/*
		 *	Abort if ctrl-c was pressed.
		 */
		if (ctrlc()) {
			eth_halt();
33d02ecc:	eb0005d6 	bl	33d0462c <eth_halt>
			puts ("\nAbort\n");
33d02ed0:	e59f01f0 	ldr	r0, [pc, #496]	; 33d030c8 <NetLoop+0x488>
33d02ed4:	eb005034 	bl	33d16fac <puts>
33d02ed8:	ea000058 	b	33d03040 <NetLoop+0x400>
static void PingStart(void)
{
#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif	/* CONFIG_NET_MULTI */
	NetSetTimeout (10 * CFG_HZ, PingTimeout);
33d02edc:	e59f01e8 	ldr	r0, [pc, #488]	; 33d030cc <NetLoop+0x48c>
33d02ee0:	e59f11e8 	ldr	r1, [pc, #488]	; 33d030d0 <NetLoop+0x490>
33d02ee4:	ebfffb8d 	bl	33d01d20 <NetSetTimeout>
	NetSetHandler (PingHandler);
33d02ee8:	e59f01e4 	ldr	r0, [pc, #484]	; 33d030d4 <NetLoop+0x494>
33d02eec:	ebfffb9a 	bl	33d01d5c <NetSetHandler>

	PingSend();
33d02ef0:	ebfffc9d 	bl	33d0216c <PingSend>
#endif
		default:
			break;
		}

		NetBootFileXferSize = 0;
33d02ef4:	e59f31dc 	ldr	r3, [pc, #476]	; 33d030d8 <NetLoop+0x498>
33d02ef8:	e3a02000 	mov	r2, #0	; 0x0
33d02efc:	e5832000 	str	r2, [r3]
#endif
		/*
		 *	Check the ethernet for a new packet.  The ethernet
		 *	receive routine will process it.
		 */
			eth_rx();
33d02f00:	eb0005d7 	bl	33d04664 <eth_rx>

		/*
		 *	Abort if ctrl-c was pressed.
		 */
		if (ctrlc()) {
33d02f04:	eb005048 	bl	33d1702c <ctrlc>
33d02f08:	e2505000 	subs	r5, r0, #0	; 0x0

		/*
		 *	Check for a timeout, and run the timeout handler
		 *	if we have one.
		 */
		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
33d02f0c:	e59f41c8 	ldr	r4, [pc, #456]	; 33d030dc <NetLoop+0x49c>
			eth_rx();

		/*
		 *	Abort if ctrl-c was pressed.
		 */
		if (ctrlc()) {
33d02f10:	1affffed 	bne	33d02ecc <NetLoop+0x28c>
			eth_halt();
			puts ("\nAbort\n");
			return (-1);
		}

		ArpTimeoutCheck();
33d02f14:	ebfffbb4 	bl	33d01dec <ArpTimeoutCheck>

		/*
		 *	Check for a timeout, and run the timeout handler
		 *	if we have one.
		 */
		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
33d02f18:	e5943000 	ldr	r3, [r4]
33d02f1c:	e3530000 	cmp	r3, #0	; 0x0
33d02f20:	e1a00005 	mov	r0, r5
33d02f24:	0a00000a 	beq	33d02f54 <NetLoop+0x314>
33d02f28:	ebfff7ae 	bl	33d00de8 <get_timer>
33d02f2c:	e59f31ac 	ldr	r3, [pc, #428]	; 33d030e0 <NetLoop+0x4a0>
33d02f30:	e5932000 	ldr	r2, [r3]
33d02f34:	e59f31a8 	ldr	r3, [pc, #424]	; 33d030e4 <NetLoop+0x4a4>
33d02f38:	e5933000 	ldr	r3, [r3]
33d02f3c:	e0620000 	rsb	r0, r2, r0
33d02f40:	e1500003 	cmp	r0, r3
			} else {
				status_led_set (STATUS_LED_RED, STATUS_LED_ON);
			}
#  endif /* CFG_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
			x = timeHandler;
33d02f44:	85943000 	ldrhi	r3, [r4]
			timeHandler = (thand_f *)0;
33d02f48:	85845000 	strhi	r5, [r4]
			(*x)();
33d02f4c:	81a0e00f 	movhi	lr, pc
33d02f50:	81a0f003 	movhi	pc, r3
		}


		switch (NetState) {
33d02f54:	e59a3000 	ldr	r3, [sl]
33d02f58:	e3530003 	cmp	r3, #3	; 0x3
33d02f5c:	0a000006 	beq	33d02f7c <NetLoop+0x33c>
33d02f60:	ca000002 	bgt	33d02f70 <NetLoop+0x330>
33d02f64:	e3530002 	cmp	r3, #2	; 0x2
33d02f68:	0affff58 	beq	33d02cd0 <NetLoop+0x90>
33d02f6c:	eaffffe3 	b	33d02f00 <NetLoop+0x2c0>
33d02f70:	e3530004 	cmp	r3, #4	; 0x4
33d02f74:	0a000031 	beq	33d03040 <NetLoop+0x400>
33d02f78:	eaffffe0 	b	33d02f00 <NetLoop+0x2c0>
			NetRestarted = 1;
#endif
			goto restart;

		case NETLOOP_SUCCESS:
			if (NetBootFileXferSize > 0) {
33d02f7c:	e59f5154 	ldr	r5, [pc, #340]	; 33d030d8 <NetLoop+0x498>
33d02f80:	e5951000 	ldr	r1, [r5]
33d02f84:	e3510000 	cmp	r1, #0	; 0x0
33d02f88:	0a000029 	beq	33d03034 <NetLoop+0x3f4>
				char buf[10];
				printf("Bytes transferred = %ld (%lx hex)\n",
33d02f8c:	e1a02001 	mov	r2, r1
33d02f90:	e59f0150 	ldr	r0, [pc, #336]	; 33d030e8 <NetLoop+0x4a8>
33d02f94:	eb00500b 	bl	33d16fc8 <printf>
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lx", NetBootFileXferSize);
33d02f98:	e5952000 	ldr	r2, [r5]
33d02f9c:	e59f1148 	ldr	r1, [pc, #328]	; 33d030ec <NetLoop+0x4ac>
33d02fa0:	e1a0000d 	mov	r0, sp
33d02fa4:	eb005f52 	bl	33d1acf4 <sprintf>
				setenv("filesize", buf);
33d02fa8:	e59f0140 	ldr	r0, [pc, #320]	; 33d030f0 <NetLoop+0x4b0>
33d02fac:	e1a0100d 	mov	r1, sp
33d02fb0:	eb004a08 	bl	33d157d8 <setenv>
if(NF_ReadID() == 0x76)
33d02fb4:	ebfff566 	bl	33d00554 <NF_ReadID>
33d02fb8:	e3500076 	cmp	r0, #118	; 0x76
			if (NetBootFileXferSize > 0) {
				char buf[10];
				printf("Bytes transferred = %ld (%lx hex)\n",
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lx", NetBootFileXferSize);
33d02fbc:	e1a0400d 	mov	r4, sp
33d02fc0:	e5952000 	ldr	r2, [r5]
				setenv("filesize", buf);
if(NF_ReadID() == 0x76)
33d02fc4:	1a000006 	bne	33d02fe4 <NetLoop+0x3a4>
				sprintf(buf, "%lx", NetBootFileXferSize%(512*32) == 0 ? NetBootFileXferSize : (NetBootFileXferSize/(512*32)+1)*32*512);
33d02fc8:	e1a03902 	lsl	r3, r2, #18
33d02fcc:	e1a03923 	lsr	r3, r3, #18
33d02fd0:	e3530000 	cmp	r3, #0	; 0x0
33d02fd4:	13c23dff 	bicne	r3, r2, #16320	; 0x3fc0
33d02fd8:	13c3303f 	bicne	r3, r3, #63	; 0x3f
33d02fdc:	12832901 	addne	r2, r3, #16384	; 0x4000
33d02fe0:	ea000005 	b	33d02ffc <NetLoop+0x3bc>
else
				sprintf(buf, "%lx", NetBootFileXferSize%(2048*64) == 0 ? NetBootFileXferSize : (NetBootFileXferSize/(2048*64)+1)*64*2048);
33d02fe4:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
33d02fe8:	e3c338fe 	bic	r3, r3, #16646144	; 0xfe0000
33d02fec:	e3530000 	cmp	r3, #0	; 0x0
33d02ff0:	11a038a2 	lsrne	r3, r2, #17
33d02ff4:	11a03883 	lslne	r3, r3, #17
33d02ff8:	12832802 	addne	r2, r3, #131072	; 0x20000
33d02ffc:	e59f10e8 	ldr	r1, [pc, #232]	; 33d030ec <NetLoop+0x4ac>
33d03000:	e1a00004 	mov	r0, r4
33d03004:	eb005f3a 	bl	33d1acf4 <sprintf>
				setenv("filesize+1", buf);
33d03008:	e59f00e4 	ldr	r0, [pc, #228]	; 33d030f4 <NetLoop+0x4b4>
33d0300c:	e1a01004 	mov	r1, r4
33d03010:	eb0049f0 	bl	33d157d8 <setenv>

				sprintf(buf, "%lX", (unsigned long)load_addr);
33d03014:	e59f30dc 	ldr	r3, [pc, #220]	; 33d030f8 <NetLoop+0x4b8>
33d03018:	e59f10dc 	ldr	r1, [pc, #220]	; 33d030fc <NetLoop+0x4bc>
33d0301c:	e5932000 	ldr	r2, [r3]
33d03020:	e1a00004 	mov	r0, r4
33d03024:	eb005f32 	bl	33d1acf4 <sprintf>
				setenv("fileaddr", buf);
33d03028:	e1a01004 	mov	r1, r4
33d0302c:	e59f00cc 	ldr	r0, [pc, #204]	; 33d03100 <NetLoop+0x4c0>
33d03030:	eb0049e8 	bl	33d157d8 <setenv>
			}
			eth_halt();
33d03034:	eb00057c 	bl	33d0462c <eth_halt>
			return NetBootFileXferSize;
33d03038:	e5950000 	ldr	r0, [r5]
33d0303c:	ea000000 	b	33d03044 <NetLoop+0x404>

		case NETLOOP_FAIL:
			return (-1);
33d03040:	e3e00000 	mvn	r0, #0	; 0x0
		}
	}
}
33d03044:	e28dd00c 	add	sp, sp, #12	; 0xc
33d03048:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0304c:	33d391ec 	.word	0x33d391ec
33d03050:	33d391e4 	.word	0x33d391e4
33d03054:	33d391e8 	.word	0x33d391e8
33d03058:	33d391f0 	.word	0x33d391f0
33d0305c:	33d373e3 	.word	0x33d373e3
33d03060:	33d3726c 	.word	0x33d3726c
33d03064:	33d37320 	.word	0x33d37320
33d03068:	33d39217 	.word	0x33d39217
33d0306c:	33d391f4 	.word	0x33d391f4
33d03070:	33d37310 	.word	0x33d37310
33d03074:	33d3733c 	.word	0x33d3733c
33d03078:	33d37318 	.word	0x33d37318
33d0307c:	33d25870 	.word	0x33d25870
33d03080:	33d37304 	.word	0x33d37304
33d03084:	33d2587c 	.word	0x33d2587c
33d03088:	33d37308 	.word	0x33d37308
33d0308c:	33d25884 	.word	0x33d25884
33d03090:	33d2ddaa 	.word	0x33d2ddaa
33d03094:	33d2588c 	.word	0x33d2588c
33d03098:	33d2dda8 	.word	0x33d2dda8
33d0309c:	33d25894 	.word	0x33d25894
33d030a0:	33d3731c 	.word	0x33d3731c
33d030a4:	00000113 	.word	0x00000113
33d030a8:	33d373c0 	.word	0x33d373c0
33d030ac:	33d258a0 	.word	0x33d258a0
33d030b0:	33d258c4 	.word	0x33d258c4
33d030b4:	33d258e4 	.word	0x33d258e4
33d030b8:	33d24818 	.word	0x33d24818
33d030bc:	33d25904 	.word	0x33d25904
33d030c0:	33d39874 	.word	0x33d39874
33d030c4:	33d39878 	.word	0x33d39878
33d030c8:	33d25924 	.word	0x33d25924
33d030cc:	00ee6b28 	.word	0x00ee6b28
33d030d0:	33d022f8 	.word	0x33d022f8
33d030d4:	33d02314 	.word	0x33d02314
33d030d8:	33d3730c 	.word	0x33d3730c
33d030dc:	33d3982c 	.word	0x33d3982c
33d030e0:	33d39830 	.word	0x33d39830
33d030e4:	33d39834 	.word	0x33d39834
33d030e8:	33d2592c 	.word	0x33d2592c
33d030ec:	33d25950 	.word	0x33d25950
33d030f0:	33d25954 	.word	0x33d25954
33d030f4:	33d25960 	.word	0x33d25960
33d030f8:	33d35fec 	.word	0x33d35fec
33d030fc:	33d2596c 	.word	0x33d2596c
33d03100:	33d25970 	.word	0x33d25970

33d03104 <TftpSend>:

/**********************************************************************/

static void
TftpSend (void)
{
33d03104:	e92d4070 	push	{r4, r5, r6, lr}
33d03108:	e24dd004 	sub	sp, sp, #4	; 0x4
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE;
33d0310c:	ebfffc9a 	bl	33d0237c <NetEthHdrSize>
33d03110:	e59f3188 	ldr	r3, [pc, #392]	; 33d032a0 <TftpSend+0x19c>
33d03114:	e5932000 	ldr	r2, [r3]

	switch (TftpState) {
33d03118:	e59f3184 	ldr	r3, [pc, #388]	; 33d032a4 <TftpSend+0x1a0>
33d0311c:	e5933000 	ldr	r3, [r3]
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE;
33d03120:	e0822000 	add	r2, r2, r0

	switch (TftpState) {
33d03124:	e2433001 	sub	r3, r3, #1	; 0x1
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE;
33d03128:	e282501c 	add	r5, r2, #28	; 0x1c
static void
TftpSend (void)
{
	volatile uchar *	pkt;
	volatile uchar *	xp;
	int			len = 0;
33d0312c:	e3a0c000 	mov	ip, #0	; 0x0
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE;

	switch (TftpState) {
33d03130:	e3530004 	cmp	r3, #4	; 0x4
33d03134:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d03138:	ea00004d 	b	33d03274 <TftpSend+0x170>
33d0313c:	33d03150 	.word	0x33d03150
33d03140:	33d031dc 	.word	0x33d031dc
33d03144:	33d03214 	.word	0x33d03214
33d03148:	33d03244 	.word	0x33d03244
33d0314c:	33d031dc 	.word	0x33d031dc

	case STATE_RRQ:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_RRQ);
33d03150:	e3a03c01 	mov	r3, #256	; 0x100
		pkt = (uchar *)s;
		strcpy ((char *)pkt, tftp_filename);
33d03154:	e59f414c 	ldr	r4, [pc, #332]	; 33d032a8 <TftpSend+0x1a4>
	pkt = NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE;

	switch (TftpState) {

	case STATE_RRQ:
		xp = pkt;
33d03158:	e1a06005 	mov	r6, r5
		s = (ushort *)pkt;
		*s++ = htons(TFTP_RRQ);
33d0315c:	e0c530b2 	strh	r3, [r5], #2
		pkt = (uchar *)s;
		strcpy ((char *)pkt, tftp_filename);
33d03160:	e5941000 	ldr	r1, [r4]
33d03164:	e1a00005 	mov	r0, r5
33d03168:	eb005b93 	bl	33d19fbc <strcpy>
		pkt += strlen(tftp_filename) + 1;
33d0316c:	e5940000 	ldr	r0, [r4]
33d03170:	eb005be6 	bl	33d1a110 <strlen>
33d03174:	e0854000 	add	r4, r5, r0
		strcpy ((char *)pkt, "octet");
33d03178:	e59f112c 	ldr	r1, [pc, #300]	; 33d032ac <TftpSend+0x1a8>
33d0317c:	e2840001 	add	r0, r4, #1	; 0x1
33d03180:	eb005b8d 	bl	33d19fbc <strcpy>
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy ((char *)pkt, "timeout");
		pkt += 7 /*strlen("timeout")*/ + 1;
33d03184:	e284500f 	add	r5, r4, #15	; 0xf
		pkt = (uchar *)s;
		strcpy ((char *)pkt, tftp_filename);
		pkt += strlen(tftp_filename) + 1;
		strcpy ((char *)pkt, "octet");
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy ((char *)pkt, "timeout");
33d03188:	e59f1120 	ldr	r1, [pc, #288]	; 33d032b0 <TftpSend+0x1ac>
33d0318c:	e2840007 	add	r0, r4, #7	; 0x7
33d03190:	eb005b89 	bl	33d19fbc <strcpy>
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%d", TIMEOUT);
33d03194:	e59f1118 	ldr	r1, [pc, #280]	; 33d032b4 <TftpSend+0x1b0>
33d03198:	e3a02005 	mov	r2, #5	; 0x5
33d0319c:	e1a00005 	mov	r0, r5
33d031a0:	eb005ed3 	bl	33d1acf4 <sprintf>
#ifdef ET_DEBUG
		printf("send option \"timeout %s\"\n", (char *)pkt);
#endif
		pkt += strlen((char *)pkt) + 1;
33d031a4:	e1a00005 	mov	r0, r5
33d031a8:	eb005bd8 	bl	33d1a110 <strlen>
		/* try for more effic. blk size */
		pkt += sprintf((char *)pkt,"blksize%c%d%c",
33d031ac:	e59f3104 	ldr	r3, [pc, #260]	; 33d032b8 <TftpSend+0x1b4>
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%d", TIMEOUT);
#ifdef ET_DEBUG
		printf("send option \"timeout %s\"\n", (char *)pkt);
#endif
		pkt += strlen((char *)pkt) + 1;
33d031b0:	e0850000 	add	r0, r5, r0
		/* try for more effic. blk size */
		pkt += sprintf((char *)pkt,"blksize%c%d%c",
33d031b4:	e3a0c000 	mov	ip, #0	; 0x0
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%d", TIMEOUT);
#ifdef ET_DEBUG
		printf("send option \"timeout %s\"\n", (char *)pkt);
#endif
		pkt += strlen((char *)pkt) + 1;
33d031b8:	e2805001 	add	r5, r0, #1	; 0x1
		/* try for more effic. blk size */
		pkt += sprintf((char *)pkt,"blksize%c%d%c",
33d031bc:	e1d330b0 	ldrh	r3, [r3]
33d031c0:	e1a00005 	mov	r0, r5
33d031c4:	e1a0200c 	mov	r2, ip
33d031c8:	e59f10ec 	ldr	r1, [pc, #236]	; 33d032bc <TftpSend+0x1b8>
33d031cc:	e58dc000 	str	ip, [sp]
33d031d0:	eb005ec7 	bl	33d1acf4 <sprintf>
33d031d4:	e0855000 	add	r5, r5, r0
33d031d8:	ea000024 	b	33d03270 <TftpSend+0x16c>
		/*..falling..*/
#endif
	case STATE_DATA:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ACK);
33d031dc:	e1a00005 	mov	r0, r5
33d031e0:	e3a03b01 	mov	r3, #1024	; 0x400
33d031e4:	e0c030b2 	strh	r3, [r0], #2
		*s++ = htons(TftpBlock);
33d031e8:	e59f30d0 	ldr	r3, [pc, #208]	; 33d032c0 <TftpSend+0x1bc>
33d031ec:	e1d320b0 	ldrh	r2, [r3]
	return __arch__swab16(x);
33d031f0:	e1a03422 	lsr	r3, r2, #8
33d031f4:	e1a03803 	lsl	r3, r3, #16
		if (Multicast)
			TftpBlock=ext2_find_next_zero_bit(Bitmap,(Mapsize*8),0);
		/*..falling..*/
#endif
	case STATE_DATA:
		xp = pkt;
33d031f8:	e1a06005 	mov	r6, r5
33d031fc:	e1833c02 	orr	r3, r3, r2, lsl #24
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ACK);
		*s++ = htons(TftpBlock);
		pkt = (uchar *)s;
33d03200:	e2805002 	add	r5, r0, #2	; 0x2
33d03204:	e1a03823 	lsr	r3, r3, #16
		len = pkt - xp;
33d03208:	e066c005 	rsb	ip, r6, r5
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d0320c:	e1c630b2 	strh	r3, [r6, #2]
		break;
33d03210:	ea000017 	b	33d03274 <TftpSend+0x170>

	case STATE_TOO_LARGE:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
33d03214:	e1a00005 	mov	r0, r5
33d03218:	e3a03c05 	mov	r3, #1280	; 0x500
33d0321c:	e0c030b2 	strh	r3, [r0], #2
		pkt = (uchar *)s;
		len = pkt - xp;
		break;

	case STATE_TOO_LARGE:
		xp = pkt;
33d03220:	e1a06005 	mov	r6, r5
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
		*s++ = htons(3);
33d03224:	e3a03c03 	mov	r3, #768	; 0x300
33d03228:	e2805002 	add	r5, r0, #2	; 0x2
		pkt = (uchar *)s;
		strcpy ((char *)pkt, "File too large");
33d0322c:	e1a00005 	mov	r0, r5

	case STATE_TOO_LARGE:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
		*s++ = htons(3);
33d03230:	e1c630b2 	strh	r3, [r6, #2]
		pkt = (uchar *)s;
		strcpy ((char *)pkt, "File too large");
33d03234:	e59f1088 	ldr	r1, [pc, #136]	; 33d032c4 <TftpSend+0x1c0>
33d03238:	eb005b5f 	bl	33d19fbc <strcpy>
		pkt += 14 /*strlen("File too large")*/ + 1;
33d0323c:	e285500f 	add	r5, r5, #15	; 0xf
33d03240:	ea00000a 	b	33d03270 <TftpSend+0x16c>
		break;

	case STATE_BAD_MAGIC:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
33d03244:	e1a00005 	mov	r0, r5
33d03248:	e3a03c05 	mov	r3, #1280	; 0x500
33d0324c:	e0c030b2 	strh	r3, [r0], #2
		pkt += 14 /*strlen("File too large")*/ + 1;
		len = pkt - xp;
		break;

	case STATE_BAD_MAGIC:
		xp = pkt;
33d03250:	e1a06005 	mov	r6, r5
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
		*s++ = htons(2);
33d03254:	e3a03c02 	mov	r3, #512	; 0x200
33d03258:	e2805002 	add	r5, r0, #2	; 0x2
		pkt = (uchar *)s;
		strcpy ((char *)pkt, "File has bad magic");
33d0325c:	e1a00005 	mov	r0, r5

	case STATE_BAD_MAGIC:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
		*s++ = htons(2);
33d03260:	e1c630b2 	strh	r3, [r6, #2]
		pkt = (uchar *)s;
		strcpy ((char *)pkt, "File has bad magic");
33d03264:	e59f105c 	ldr	r1, [pc, #92]	; 33d032c8 <TftpSend+0x1c4>
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
33d03268:	e2855013 	add	r5, r5, #19	; 0x13
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
		*s++ = htons(2);
		pkt = (uchar *)s;
		strcpy ((char *)pkt, "File has bad magic");
33d0326c:	eb005b52 	bl	33d19fbc <strcpy>
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
		len = pkt - xp;
33d03270:	e066c005 	rsb	ip, r6, r5
		break;
	}

	NetSendUDPPacket(NetServerEther, NetServerIP, TftpServerPort, TftpOurPort, len);
33d03274:	e59f3050 	ldr	r3, [pc, #80]	; 33d032cc <TftpSend+0x1c8>
33d03278:	e5931000 	ldr	r1, [r3]
33d0327c:	e59f304c 	ldr	r3, [pc, #76]	; 33d032d0 <TftpSend+0x1cc>
33d03280:	e5932000 	ldr	r2, [r3]
33d03284:	e59f3048 	ldr	r3, [pc, #72]	; 33d032d4 <TftpSend+0x1d0>
33d03288:	e59f0048 	ldr	r0, [pc, #72]	; 33d032d8 <TftpSend+0x1d4>
33d0328c:	e5933000 	ldr	r3, [r3]
33d03290:	e58dc000 	str	ip, [sp]
33d03294:	ebfffb5a 	bl	33d02004 <NetSendUDPPacket>
33d03298:	e28dd004 	add	sp, sp, #4	; 0x4
33d0329c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d032a0:	33d3726c 	.word	0x33d3726c
33d032a4:	33d39858 	.word	0x33d39858
33d032a8:	33d3986c 	.word	0x33d3986c
33d032ac:	33d259a0 	.word	0x33d259a0
33d032b0:	33d259a8 	.word	0x33d259a8
33d032b4:	33d2586c 	.word	0x33d2586c
33d032b8:	33d2ddb4 	.word	0x33d2ddb4
33d032bc:	33d259b0 	.word	0x33d259b0
33d032c0:	33d39848 	.word	0x33d39848
33d032c4:	33d259c0 	.word	0x33d259c0
33d032c8:	33d259d0 	.word	0x33d259d0
33d032cc:	33d3731c 	.word	0x33d3731c
33d032d0:	33d3983c 	.word	0x33d3983c
33d032d4:	33d39840 	.word	0x33d39840
33d032d8:	33d37276 	.word	0x33d37276

33d032dc <TftpHandler>:
}


static void
TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
33d032dc:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
33d032e0:	e59fc294 	ldr	ip, [pc, #660]	; 33d0357c <TftpHandler+0x2a0>
33d032e4:	e59cc000 	ldr	ip, [ip]
33d032e8:	e151000c 	cmp	r1, ip
}


static void
TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
33d032ec:	e1a07000 	mov	r7, r0
33d032f0:	e1a05002 	mov	r5, r2
33d032f4:	e1a06003 	mov	r6, r3
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
33d032f8:	18bd86f0 	popne	{r4, r5, r6, r7, r9, sl, pc}
		if (Multicast
		 && (!Mcast_port || (dest != Mcast_port)))
#endif
		return;
	}
	if (TftpState != STATE_RRQ && src != TftpServerPort) {
33d032fc:	e59fa27c 	ldr	sl, [pc, #636]	; 33d03580 <TftpHandler+0x2a4>
33d03300:	e59a3000 	ldr	r3, [sl]
33d03304:	e3530001 	cmp	r3, #1	; 0x1
33d03308:	0a000003 	beq	33d0331c <TftpHandler+0x40>
33d0330c:	e59f3270 	ldr	r3, [pc, #624]	; 33d03584 <TftpHandler+0x2a8>
33d03310:	e5933000 	ldr	r3, [r3]
33d03314:	e1520003 	cmp	r2, r3
33d03318:	18bd86f0 	popne	{r4, r5, r6, r7, r9, sl, pc}
		return;
	}

	if (len < 2) {
33d0331c:	e3560001 	cmp	r6, #1	; 0x1
33d03320:	98bd86f0 	popls	{r4, r5, r6, r7, r9, sl, pc}
		return;
	}
	len -= 2;
	/* warning: don't use increment (++) in ntohs() macros!! */
	s = (ushort *)pkt;
	proto = *s++;
33d03324:	e0d720b2 	ldrh	r2, [r7], #2
	return __arch__swab16(x);
33d03328:	e1a03422 	lsr	r3, r2, #8
33d0332c:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d03330:	e1833c02 	orr	r3, r3, r2, lsl #24
33d03334:	e1a03823 	lsr	r3, r3, #16
33d03338:	e3530005 	cmp	r3, #5	; 0x5
	}

	if (len < 2) {
		return;
	}
	len -= 2;
33d0333c:	e2466002 	sub	r6, r6, #2	; 0x2
33d03340:	0a000081 	beq	33d0354c <TftpHandler+0x270>
33d03344:	ca000008 	bgt	33d0336c <TftpHandler+0x90>
33d03348:	e3530003 	cmp	r3, #3	; 0x3
33d0334c:	18bd86f0 	popne	{r4, r5, r6, r7, r9, sl, pc}
33d03350:	ea00001a 	b	33d033c0 <TftpHandler+0xe4>
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i=0; i+8<len; i++) {
			if (strcmp ((char*)pkt+i,"blksize") == 0) {
				TftpBlkSize = (unsigned short)
33d03354:	e2850008 	add	r0, r5, #8	; 0x8
33d03358:	e3a0200a 	mov	r2, #10	; 0xa
33d0335c:	eb005c7e 	bl	33d1a55c <simple_strtoul>
33d03360:	e59f3220 	ldr	r3, [pc, #544]	; 33d03588 <TftpHandler+0x2ac>
33d03364:	e1c300b0 	strh	r0, [r3]
					simple_strtoul((char*)pkt+i+8,NULL,10);
#ifdef ET_DEBUG
				printf ("Blocksize ack: %s, %d\n",
					(char*)pkt+i+8,TftpBlkSize);
#endif
				break;
33d03368:	ea000012 	b	33d033b8 <TftpHandler+0xdc>
33d0336c:	e3530006 	cmp	r3, #6	; 0x6
33d03370:	18bd86f0 	popne	{r4, r5, r6, r7, r9, sl, pc}

	case TFTP_OACK:
#ifdef ET_DEBUG
		printf("Got OACK: %s %s\n", pkt, pkt+strlen(pkt)+1);
#endif
		TftpState = STATE_OACK;
33d03374:	e2433001 	sub	r3, r3, #1	; 0x1
33d03378:	e58a3000 	str	r3, [sl]
		TftpServerPort = src;
33d0337c:	e59f3200 	ldr	r3, [pc, #512]	; 33d03584 <TftpHandler+0x2a8>
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i=0; i+8<len; i++) {
33d03380:	e3560008 	cmp	r6, #8	; 0x8
	case TFTP_OACK:
#ifdef ET_DEBUG
		printf("Got OACK: %s %s\n", pkt, pkt+strlen(pkt)+1);
#endif
		TftpState = STATE_OACK;
		TftpServerPort = src;
33d03384:	e5835000 	str	r5, [r3]
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i=0; i+8<len; i++) {
33d03388:	e3a04000 	mov	r4, #0	; 0x0
33d0338c:	9a000009 	bls	33d033b8 <TftpHandler+0xdc>
			if (strcmp ((char*)pkt+i,"blksize") == 0) {
33d03390:	e0875004 	add	r5, r7, r4
33d03394:	e59f11f0 	ldr	r1, [pc, #496]	; 33d0358c <TftpHandler+0x2b0>
33d03398:	e1a00005 	mov	r0, r5
33d0339c:	eb005b31 	bl	33d1a068 <strcmp>
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i=0; i+8<len; i++) {
33d033a0:	e2844001 	add	r4, r4, #1	; 0x1
			if (strcmp ((char*)pkt+i,"blksize") == 0) {
33d033a4:	e2501000 	subs	r1, r0, #0	; 0x0
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i=0; i+8<len; i++) {
33d033a8:	e2843008 	add	r3, r4, #8	; 0x8
			if (strcmp ((char*)pkt+i,"blksize") == 0) {
33d033ac:	0affffe8 	beq	33d03354 <TftpHandler+0x78>
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i=0; i+8<len; i++) {
33d033b0:	e1530006 	cmp	r3, r6
33d033b4:	3afffff5 	bcc	33d03390 <TftpHandler+0xb4>
		mcast_cleanup();
#endif
		NetStartAgain ();
		break;
	}
}
33d033b8:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		parse_multicast_oack((char *)pkt,len-1);
		if ((Multicast) && (!MasterClient))
			TftpState = STATE_DATA;	/* passive.. */
		else
#endif
		TftpSend (); /* Send ACK */
33d033bc:	eaffff50 	b	33d03104 <TftpSend>
		break;
	case TFTP_DATA:
		if (len < 2)
33d033c0:	e3560001 	cmp	r6, #1	; 0x1
33d033c4:	98bd86f0 	popls	{r4, r5, r6, r7, r9, sl, pc}
			return;
		len -= 2;
		TftpBlock = ntohs(*(ushort *)pkt);
33d033c8:	e1d720b0 	ldrh	r2, [r7]
	return __arch__swab16(x);
33d033cc:	e1a03422 	lsr	r3, r2, #8
33d033d0:	e1a03803 	lsl	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d033d4:	e1833c02 	orr	r3, r3, r2, lsl #24
33d033d8:	e1a04823 	lsr	r4, r3, #16
33d033dc:	e59f91ac 	ldr	r9, [pc, #428]	; 33d03590 <TftpHandler+0x2b4>
		 * RFC1350 specifies that the first data packet will
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
33d033e0:	e3540000 	cmp	r4, #0	; 0x0
		TftpSend (); /* Send ACK */
		break;
	case TFTP_DATA:
		if (len < 2)
			return;
		len -= 2;
33d033e4:	e2466002 	sub	r6, r6, #2	; 0x2
33d033e8:	e5894000 	str	r4, [r9]
		 * RFC1350 specifies that the first data packet will
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
33d033ec:	1a00000d 	bne	33d03428 <TftpHandler+0x14c>
			TftpBlockWrap++;
			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
33d033f0:	e59fe19c 	ldr	lr, [pc, #412]	; 33d03594 <TftpHandler+0x2b8>
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
			TftpBlockWrap++;
33d033f4:	e59fc19c 	ldr	ip, [pc, #412]	; 33d03598 <TftpHandler+0x2bc>
			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
33d033f8:	e59f3188 	ldr	r3, [pc, #392]	; 33d03588 <TftpHandler+0x2ac>
33d033fc:	e59e2000 	ldr	r2, [lr]
33d03400:	e1d310b0 	ldrh	r1, [r3]
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
			TftpBlockWrap++;
33d03404:	e59c3000 	ldr	r3, [ip]
			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
33d03408:	e0822801 	add	r2, r2, r1, lsl #16
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
			TftpBlockWrap++;
33d0340c:	e2833001 	add	r3, r3, #1	; 0x1
			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
			printf ("\n\t %lu MB received\n\t ", TftpBlockWrapOffset>>20);
33d03410:	e1a01a22 	lsr	r1, r2, #20
33d03414:	e59f0180 	ldr	r0, [pc, #384]	; 33d0359c <TftpHandler+0x2c0>
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
			TftpBlockWrap++;
33d03418:	e58c3000 	str	r3, [ip]
			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
33d0341c:	e58e2000 	str	r2, [lr]
			printf ("\n\t %lu MB received\n\t ", TftpBlockWrapOffset>>20);
33d03420:	eb004ee8 	bl	33d16fc8 <printf>
33d03424:	ea00000d 	b	33d03460 <TftpHandler+0x184>
		} else {
			if (((TftpBlock - 1) % 10) == 0) {
33d03428:	e2440001 	sub	r0, r4, #1	; 0x1
33d0342c:	e3a0100a 	mov	r1, #10	; 0xa
33d03430:	eb006d1a 	bl	33d1e8a0 <__umodsi3>
33d03434:	e3500000 	cmp	r0, #0	; 0x0
33d03438:	1a000002 	bne	33d03448 <TftpHandler+0x16c>
				putc ('#');
33d0343c:	e2800023 	add	r0, r0, #35	; 0x23
33d03440:	eb004ecf 	bl	33d16f84 <putc>
33d03444:	ea000005 	b	33d03460 <TftpHandler+0x184>
			} else if ((TftpBlock % (10 * HASHES_PER_LINE)) == 0) {
33d03448:	e1a00004 	mov	r0, r4
33d0344c:	e59f114c 	ldr	r1, [pc, #332]	; 33d035a0 <TftpHandler+0x2c4>
33d03450:	eb006d12 	bl	33d1e8a0 <__umodsi3>
33d03454:	e3500000 	cmp	r0, #0	; 0x0
				puts ("\n\t ");
33d03458:	059f0144 	ldreq	r0, [pc, #324]	; 33d035a4 <TftpHandler+0x2c8>
33d0345c:	0b004ed2 	bleq	33d16fac <puts>
		if (TftpState == STATE_RRQ) {
			puts ("Server did not acknowledge timeout option!\n");
		}
#endif

		if (TftpState == STATE_RRQ || TftpState == STATE_OACK) {
33d03460:	e59a3000 	ldr	r3, [sl]
33d03464:	e3530005 	cmp	r3, #5	; 0x5
33d03468:	13530001 	cmpne	r3, #1	; 0x1
33d0346c:	1a000010 	bne	33d034b4 <TftpHandler+0x1d8>
			/* first block received */
			TftpState = STATE_DATA;
33d03470:	e3a03002 	mov	r3, #2	; 0x2
33d03474:	e58a3000 	str	r3, [sl]
			TftpServerPort = src;
33d03478:	e59f3104 	ldr	r3, [pc, #260]	; 33d03584 <TftpHandler+0x2a8>
33d0347c:	e5835000 	str	r5, [r3]
			TftpLastBlock = 0;
			TftpBlockWrap = 0;
			TftpBlockWrapOffset = 0;
33d03480:	e59f310c 	ldr	r3, [pc, #268]	; 33d03594 <TftpHandler+0x2b8>

		if (TftpState == STATE_RRQ || TftpState == STATE_OACK) {
			/* first block received */
			TftpState = STATE_DATA;
			TftpServerPort = src;
			TftpLastBlock = 0;
33d03484:	e3a02000 	mov	r2, #0	; 0x0
			TftpBlockWrap = 0;
			TftpBlockWrapOffset = 0;
33d03488:	e5832000 	str	r2, [r3]

		if (TftpState == STATE_RRQ || TftpState == STATE_OACK) {
			/* first block received */
			TftpState = STATE_DATA;
			TftpServerPort = src;
			TftpLastBlock = 0;
33d0348c:	e59f3114 	ldr	r3, [pc, #276]	; 33d035a8 <TftpHandler+0x2cc>
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
33d03490:	e5991000 	ldr	r1, [r9]

		if (TftpState == STATE_RRQ || TftpState == STATE_OACK) {
			/* first block received */
			TftpState = STATE_DATA;
			TftpServerPort = src;
			TftpLastBlock = 0;
33d03494:	e5832000 	str	r2, [r3]
			TftpBlockWrap = 0;
33d03498:	e59f30f8 	ldr	r3, [pc, #248]	; 33d03598 <TftpHandler+0x2bc>
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
33d0349c:	e3510001 	cmp	r1, #1	; 0x1
		if (TftpState == STATE_RRQ || TftpState == STATE_OACK) {
			/* first block received */
			TftpState = STATE_DATA;
			TftpServerPort = src;
			TftpLastBlock = 0;
			TftpBlockWrap = 0;
33d034a0:	e5832000 	str	r2, [r3]
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
33d034a4:	0a000002 	beq	33d034b4 <TftpHandler+0x1d8>
				printf ("\nTFTP error: "
33d034a8:	e59f00fc 	ldr	r0, [pc, #252]	; 33d035ac <TftpHandler+0x2d0>
33d034ac:	eb004ec5 	bl	33d16fc8 <printf>
33d034b0:	ea00002f 	b	33d03574 <TftpHandler+0x298>
				NetStartAgain ();
				break;
			}
		}

		if (TftpBlock == TftpLastBlock) {
33d034b4:	e59f40d4 	ldr	r4, [pc, #212]	; 33d03590 <TftpHandler+0x2b4>
33d034b8:	e59fc0e8 	ldr	ip, [pc, #232]	; 33d035a8 <TftpHandler+0x2cc>
33d034bc:	e5942000 	ldr	r2, [r4]
33d034c0:	e59c3000 	ldr	r3, [ip]
33d034c4:	e1520003 	cmp	r2, r3
33d034c8:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
			 *	Same block again; ignore it.
			 */
			break;
		}

		TftpLastBlock = TftpBlock;
33d034cc:	e58c2000 	str	r2, [ip]
		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
33d034d0:	e59f00d8 	ldr	r0, [pc, #216]	; 33d035b0 <TftpHandler+0x2d4>
33d034d4:	e59f10d8 	ldr	r1, [pc, #216]	; 33d035b4 <TftpHandler+0x2d8>
33d034d8:	ebfffa10 	bl	33d01d20 <NetSetTimeout>
#endif	/* CONFIG_MCAST_TFTP */

static __inline__ void
store_block (unsigned block, uchar * src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
33d034dc:	e59f50a4 	ldr	r5, [pc, #164]	; 33d03588 <TftpHandler+0x2ac>
33d034e0:	e59f30ac 	ldr	r3, [pc, #172]	; 33d03594 <TftpHandler+0x2b8>

#endif	/* CONFIG_MCAST_TFTP */

static __inline__ void
store_block (unsigned block, uchar * src, unsigned len)
{
33d034e4:	e5942000 	ldr	r2, [r4]
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
33d034e8:	e5931000 	ldr	r1, [r3]
33d034ec:	e1d530b0 	ldrh	r3, [r5]

#endif	/* CONFIG_MCAST_TFTP */

static __inline__ void
store_block (unsigned block, uchar * src, unsigned len)
{
33d034f0:	e2422001 	sub	r2, r2, #1	; 0x1
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
33d034f4:	e02c1293 	mla	ip, r3, r2, r1
		}
	}
	else
#endif /* CFG_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
33d034f8:	e59f30b8 	ldr	r3, [pc, #184]	; 33d035b8 <TftpHandler+0x2dc>
33d034fc:	e5930000 	ldr	r0, [r3]
33d03500:	e2871002 	add	r1, r7, #2	; 0x2
33d03504:	e080000c 	add	r0, r0, ip
33d03508:	e1a02006 	mov	r2, r6

static __inline__ void
store_block (unsigned block, uchar * src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
	ulong newsize = offset + len;
33d0350c:	e08c4006 	add	r4, ip, r6
		}
	}
	else
#endif /* CFG_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
33d03510:	eb005bb3 	bl	33d1a3e4 <memcpy>
#ifdef CONFIG_MCAST_TFTP
	if (Multicast)
		ext2_set_bit(block, Bitmap);
#endif

	if (NetBootFileXferSize < newsize)
33d03514:	e59f20a0 	ldr	r2, [pc, #160]	; 33d035bc <TftpHandler+0x2e0>
33d03518:	e5923000 	ldr	r3, [r2]
33d0351c:	e1530004 	cmp	r3, r4
		NetBootFileXferSize = newsize;
33d03520:	35824000 	strcc	r4, [r2]
				}
				TftpLastBlock = TftpBlock;
			}
		}
#endif
		TftpSend ();
33d03524:	ebfffef6 	bl	33d03104 <TftpSend>
				NetState = NETLOOP_SUCCESS;
			}
		}
		else
#endif
		if (len < TftpBlkSize) {
33d03528:	e1d530b0 	ldrh	r3, [r5]
33d0352c:	e1560003 	cmp	r6, r3
33d03530:	28bd86f0 	popcs	{r4, r5, r6, r7, r9, sl, pc}
			/*
			 *	We received the whole thing.  Try to
			 *	run it.
			 */
			puts ("\ndone\n");
33d03534:	e59f0084 	ldr	r0, [pc, #132]	; 33d035c0 <TftpHandler+0x2e4>
33d03538:	eb004e9b 	bl	33d16fac <puts>
			NetState = NETLOOP_SUCCESS;
33d0353c:	e59f3080 	ldr	r3, [pc, #128]	; 33d035c4 <TftpHandler+0x2e8>
33d03540:	e3a02003 	mov	r2, #3	; 0x3
33d03544:	e5832000 	str	r2, [r3]
		}
		break;
33d03548:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	case TFTP_ERROR:
		printf ("\nTFTP error: '%s' (%d)\n",
33d0354c:	e0d730b2 	ldrh	r3, [r7], #2
	return __arch__swab16(x);
33d03550:	e1a02423 	lsr	r2, r3, #8
33d03554:	e1a02802 	lsl	r2, r2, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d03558:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0355c:	e59f0064 	ldr	r0, [pc, #100]	; 33d035c8 <TftpHandler+0x2ec>
33d03560:	e1a01007 	mov	r1, r7
33d03564:	e1a02822 	lsr	r2, r2, #16
33d03568:	eb004e96 	bl	33d16fc8 <printf>
					pkt + 2, ntohs(*(ushort *)pkt));
		puts ("Starting again\n\n");
33d0356c:	e59f0058 	ldr	r0, [pc, #88]	; 33d035cc <TftpHandler+0x2f0>
33d03570:	eb004e8d 	bl	33d16fac <puts>
		mcast_cleanup();
#endif
		NetStartAgain ();
		break;
	}
}
33d03574:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
					pkt + 2, ntohs(*(ushort *)pkt));
		puts ("Starting again\n\n");
#ifdef CONFIG_MCAST_TFTP
		mcast_cleanup();
#endif
		NetStartAgain ();
33d03578:	eafff9fb 	b	33d01d6c <NetStartAgain>
33d0357c:	33d39840 	.word	0x33d39840
33d03580:	33d39858 	.word	0x33d39858
33d03584:	33d3983c 	.word	0x33d3983c
33d03588:	33d2ddb2 	.word	0x33d2ddb2
33d0358c:	33d259e4 	.word	0x33d259e4
33d03590:	33d39848 	.word	0x33d39848
33d03594:	33d39854 	.word	0x33d39854
33d03598:	33d39850 	.word	0x33d39850
33d0359c:	33d259ec 	.word	0x33d259ec
33d035a0:	0000028a 	.word	0x0000028a
33d035a4:	33d25a04 	.word	0x33d25a04
33d035a8:	33d3984c 	.word	0x33d3984c
33d035ac:	33d25a08 	.word	0x33d25a08
33d035b0:	00773594 	.word	0x00773594
33d035b4:	33d035d0 	.word	0x33d035d0
33d035b8:	33d35fec 	.word	0x33d35fec
33d035bc:	33d3730c 	.word	0x33d3730c
33d035c0:	33d25a48 	.word	0x33d25a48
33d035c4:	33d3733c 	.word	0x33d3733c
33d035c8:	33d25a50 	.word	0x33d25a50
33d035cc:	33d25a68 	.word	0x33d25a68

33d035d0 <TftpTimeout>:
}


static void
TftpTimeout (void)
{
33d035d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (++TftpTimeoutCount > TIMEOUT_COUNT) {
33d035d4:	e59f203c 	ldr	r2, [pc, #60]	; 33d03618 <TftpTimeout+0x48>
33d035d8:	e5923000 	ldr	r3, [r2]
33d035dc:	e2833001 	add	r3, r3, #1	; 0x1
33d035e0:	e353000a 	cmp	r3, #10	; 0xa
#ifdef CONFIG_MCAST_TFTP
		mcast_cleanup();
#endif
		NetStartAgain ();
	} else {
		puts ("T ");
33d035e4:	e59f0030 	ldr	r0, [pc, #48]	; 33d0361c <TftpTimeout+0x4c>


static void
TftpTimeout (void)
{
	if (++TftpTimeoutCount > TIMEOUT_COUNT) {
33d035e8:	e5823000 	str	r3, [r2]
33d035ec:	da000003 	ble	33d03600 <TftpTimeout+0x30>
		puts ("\nRetry count exceeded; starting again\n");
33d035f0:	e59f0028 	ldr	r0, [pc, #40]	; 33d03620 <TftpTimeout+0x50>
33d035f4:	eb004e6c 	bl	33d16fac <puts>
	} else {
		puts ("T ");
		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
		TftpSend ();
	}
}
33d035f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	if (++TftpTimeoutCount > TIMEOUT_COUNT) {
		puts ("\nRetry count exceeded; starting again\n");
#ifdef CONFIG_MCAST_TFTP
		mcast_cleanup();
#endif
		NetStartAgain ();
33d035fc:	eafff9da 	b	33d01d6c <NetStartAgain>
	} else {
		puts ("T ");
33d03600:	eb004e69 	bl	33d16fac <puts>
		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
33d03604:	e59f0018 	ldr	r0, [pc, #24]	; 33d03624 <TftpTimeout+0x54>
33d03608:	e59f1018 	ldr	r1, [pc, #24]	; 33d03628 <TftpTimeout+0x58>
33d0360c:	ebfff9c3 	bl	33d01d20 <NetSetTimeout>
		TftpSend ();
	}
}
33d03610:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
#endif
		NetStartAgain ();
	} else {
		puts ("T ");
		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
		TftpSend ();
33d03614:	eafffeba 	b	33d03104 <TftpSend>
33d03618:	33d39844 	.word	0x33d39844
33d0361c:	33d2a59c 	.word	0x33d2a59c
33d03620:	33d25a7c 	.word	0x33d25a7c
33d03624:	00773594 	.word	0x00773594
33d03628:	33d035d0 	.word	0x33d035d0

33d0362c <TftpStart>:
}


void
TftpStart (void)
{
33d0362c:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CONFIG_TFTP_PORT
	char *ep;             /* Environment pointer */
#endif

	if (BootFile[0] == '\0') {
33d03630:	e59f21b4 	ldr	r2, [pc, #436]	; 33d037ec <TftpStart+0x1c0>
33d03634:	e5d23000 	ldrb	r3, [r2]
33d03638:	e59f51b0 	ldr	r5, [pc, #432]	; 33d037f0 <TftpStart+0x1c4>
33d0363c:	e3530000 	cmp	r3, #0	; 0x0
}


void
TftpStart (void)
{
33d03640:	e24dd008 	sub	sp, sp, #8	; 0x8
		tftp_filename = default_filename;

		printf ("*** Warning: no boot file name; using '%s'\n",
			tftp_filename);
	} else {
		tftp_filename = BootFile;
33d03644:	15852000 	strne	r2, [r5]
{
#ifdef CONFIG_TFTP_PORT
	char *ep;             /* Environment pointer */
#endif

	if (BootFile[0] == '\0') {
33d03648:	1a000011 	bne	33d03694 <TftpStart+0x68>
		sprintf(default_filename, "%02lX%02lX%02lX%02lX.img",
33d0364c:	e59f31a0 	ldr	r3, [pc, #416]	; 33d037f4 <TftpStart+0x1c8>
33d03650:	e593c000 	ldr	ip, [r3]
33d03654:	e59f419c 	ldr	r4, [pc, #412]	; 33d037f8 <TftpStart+0x1cc>
33d03658:	e1a0342c 	lsr	r3, ip, #8
33d0365c:	e1a0e82c 	lsr	lr, ip, #16
33d03660:	e20c20ff 	and	r2, ip, #255	; 0xff
33d03664:	e20ee0ff 	and	lr, lr, #255	; 0xff
33d03668:	e1a0cc2c 	lsr	ip, ip, #24
33d0366c:	e59f1188 	ldr	r1, [pc, #392]	; 33d037fc <TftpStart+0x1d0>
33d03670:	e20330ff 	and	r3, r3, #255	; 0xff
33d03674:	e1a00004 	mov	r0, r4
33d03678:	e58de000 	str	lr, [sp]
33d0367c:	e58dc004 	str	ip, [sp, #4]
33d03680:	eb005d9b 	bl	33d1acf4 <sprintf>
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF	);
		tftp_filename = default_filename;

		printf ("*** Warning: no boot file name; using '%s'\n",
33d03684:	e1a01004 	mov	r1, r4
33d03688:	e59f0170 	ldr	r0, [pc, #368]	; 33d03800 <TftpStart+0x1d4>
		sprintf(default_filename, "%02lX%02lX%02lX%02lX.img",
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF	);
		tftp_filename = default_filename;
33d0368c:	e5854000 	str	r4, [r5]

		printf ("*** Warning: no boot file name; using '%s'\n",
33d03690:	eb004e4c 	bl	33d16fc8 <printf>
	}

#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif
	puts ("TFTP from server ");	print_IPaddr (NetServerIP);
33d03694:	e59f5168 	ldr	r5, [pc, #360]	; 33d03804 <TftpStart+0x1d8>
33d03698:	e59f0168 	ldr	r0, [pc, #360]	; 33d03808 <TftpStart+0x1dc>
33d0369c:	eb004e42 	bl	33d16fac <puts>
	puts ("; our IP address is ");	print_IPaddr (NetOurIP);
33d036a0:	e59f414c 	ldr	r4, [pc, #332]	; 33d037f4 <TftpStart+0x1c8>
	}

#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif
	puts ("TFTP from server ");	print_IPaddr (NetServerIP);
33d036a4:	e5950000 	ldr	r0, [r5]
33d036a8:	ebfffb6f 	bl	33d0246c <print_IPaddr>
	puts ("; our IP address is ");	print_IPaddr (NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
33d036ac:	e59f6158 	ldr	r6, [pc, #344]	; 33d0380c <TftpStart+0x1e0>

#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif
	puts ("TFTP from server ");	print_IPaddr (NetServerIP);
	puts ("; our IP address is ");	print_IPaddr (NetOurIP);
33d036b0:	e59f0158 	ldr	r0, [pc, #344]	; 33d03810 <TftpStart+0x1e4>
33d036b4:	eb004e3c 	bl	33d16fac <puts>
33d036b8:	e5940000 	ldr	r0, [r4]
33d036bc:	ebfffb6a 	bl	33d0246c <print_IPaddr>

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
33d036c0:	e5963000 	ldr	r3, [r6]
33d036c4:	e3530000 	cmp	r3, #0	; 0x0
33d036c8:	0a00000d 	beq	33d03704 <TftpStart+0xd8>
33d036cc:	e59f3140 	ldr	r3, [pc, #320]	; 33d03814 <TftpStart+0x1e8>
33d036d0:	e5930000 	ldr	r0, [r3]
33d036d4:	e3500000 	cmp	r0, #0	; 0x0
33d036d8:	0a000009 	beq	33d03704 <TftpStart+0xd8>
	    IPaddr_t OurNet 	= NetOurIP    & NetOurSubnetMask;
33d036dc:	e5942000 	ldr	r2, [r4]
	    IPaddr_t ServerNet 	= NetServerIP & NetOurSubnetMask;
33d036e0:	e5953000 	ldr	r3, [r5]
	puts ("TFTP from server ");	print_IPaddr (NetServerIP);
	puts ("; our IP address is ");	print_IPaddr (NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
	    IPaddr_t OurNet 	= NetOurIP    & NetOurSubnetMask;
33d036e4:	e0022000 	and	r2, r2, r0
	    IPaddr_t ServerNet 	= NetServerIP & NetOurSubnetMask;
33d036e8:	e0033000 	and	r3, r3, r0

	    if (OurNet != ServerNet) {
33d036ec:	e1520003 	cmp	r2, r3
33d036f0:	0a000003 	beq	33d03704 <TftpStart+0xd8>
		puts ("; sending through gateway ");
33d036f4:	e59f011c 	ldr	r0, [pc, #284]	; 33d03818 <TftpStart+0x1ec>
33d036f8:	eb004e2b 	bl	33d16fac <puts>
		print_IPaddr (NetOurGatewayIP) ;
33d036fc:	e5960000 	ldr	r0, [r6]
33d03700:	ebfffb59 	bl	33d0246c <print_IPaddr>
	    }
	}
	putc ('\n');
33d03704:	e3a0000a 	mov	r0, #10	; 0xa
33d03708:	eb004e1d 	bl	33d16f84 <putc>

	printf ("Filename '%s'.", tftp_filename);
33d0370c:	e59f30dc 	ldr	r3, [pc, #220]	; 33d037f0 <TftpStart+0x1c4>

	if (NetBootFileSize) {
33d03710:	e59f4104 	ldr	r4, [pc, #260]	; 33d0381c <TftpStart+0x1f0>
		print_IPaddr (NetOurGatewayIP) ;
	    }
	}
	putc ('\n');

	printf ("Filename '%s'.", tftp_filename);
33d03714:	e5931000 	ldr	r1, [r3]
33d03718:	e59f0100 	ldr	r0, [pc, #256]	; 33d03820 <TftpStart+0x1f4>
33d0371c:	eb004e29 	bl	33d16fc8 <printf>

	if (NetBootFileSize) {
33d03720:	e1d410b0 	ldrh	r1, [r4]
33d03724:	e3510000 	cmp	r1, #0	; 0x0
33d03728:	0a000006 	beq	33d03748 <TftpStart+0x11c>
		printf (" Size is 0x%x Bytes = ", NetBootFileSize<<9);
33d0372c:	e1a01481 	lsl	r1, r1, #9
33d03730:	e59f00ec 	ldr	r0, [pc, #236]	; 33d03824 <TftpStart+0x1f8>
33d03734:	eb004e23 	bl	33d16fc8 <printf>
		print_size (NetBootFileSize<<9, "");
33d03738:	e1d400b0 	ldrh	r0, [r4]
33d0373c:	e59f10e4 	ldr	r1, [pc, #228]	; 33d03828 <TftpStart+0x1fc>
33d03740:	e1a00480 	lsl	r0, r0, #9
33d03744:	eb0059f7 	bl	33d19f28 <print_size>
	}

	putc ('\n');
33d03748:	e3a0000a 	mov	r0, #10	; 0xa
33d0374c:	eb004e0c 	bl	33d16f84 <putc>

	printf ("Load address: 0x%lx\n", load_addr);
33d03750:	e59f30d4 	ldr	r3, [pc, #212]	; 33d0382c <TftpStart+0x200>
33d03754:	e59f00d4 	ldr	r0, [pc, #212]	; 33d03830 <TftpStart+0x204>
33d03758:	e5931000 	ldr	r1, [r3]
33d0375c:	eb004e19 	bl	33d16fc8 <printf>

	puts ("Loading: *\b");
33d03760:	e59f00cc 	ldr	r0, [pc, #204]	; 33d03834 <TftpStart+0x208>
33d03764:	eb004e10 	bl	33d16fac <puts>

	NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
33d03768:	e59f10c8 	ldr	r1, [pc, #200]	; 33d03838 <TftpStart+0x20c>
33d0376c:	e59f00c8 	ldr	r0, [pc, #200]	; 33d0383c <TftpStart+0x210>
33d03770:	ebfff96a 	bl	33d01d20 <NetSetTimeout>
	NetSetHandler (TftpHandler);
33d03774:	e59f00c4 	ldr	r0, [pc, #196]	; 33d03840 <TftpStart+0x214>
33d03778:	ebfff977 	bl	33d01d5c <NetSetHandler>

	TftpServerPort = WELL_KNOWN_PORT;
33d0377c:	e59f30c0 	ldr	r3, [pc, #192]	; 33d03844 <TftpStart+0x218>
33d03780:	e3a02045 	mov	r2, #69	; 0x45
33d03784:	e5832000 	str	r2, [r3]
	TftpTimeoutCount = 0;
	TftpState = STATE_RRQ;
33d03788:	e59f30b8 	ldr	r3, [pc, #184]	; 33d03848 <TftpStart+0x21c>
33d0378c:	e2422044 	sub	r2, r2, #68	; 0x44
33d03790:	e5832000 	str	r2, [r3]

	NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
	NetSetHandler (TftpHandler);

	TftpServerPort = WELL_KNOWN_PORT;
	TftpTimeoutCount = 0;
33d03794:	e59f30b0 	ldr	r3, [pc, #176]	; 33d0384c <TftpStart+0x220>
33d03798:	e3a04000 	mov	r4, #0	; 0x0
33d0379c:	e5834000 	str	r4, [r3]
	TftpState = STATE_RRQ;
	/* Use a pseudo-random port unless a specific port is set */
	TftpOurPort = 1024 + (get_timer(0) % 3072);
33d037a0:	e1a00004 	mov	r0, r4
33d037a4:	ebfff58f 	bl	33d00de8 <get_timer>
33d037a8:	e3a01b03 	mov	r1, #3072	; 0xc00
33d037ac:	eb006c3b 	bl	33d1e8a0 <__umodsi3>
33d037b0:	e59f3098 	ldr	r3, [pc, #152]	; 33d03850 <TftpStart+0x224>
33d037b4:	e280cb01 	add	ip, r0, #1024	; 0x400
33d037b8:	e583c000 	str	ip, [r3]
	}
	if ((ep = getenv("tftpsrcp")) != NULL) {
		TftpOurPort= simple_strtol(ep, NULL, 10);
	}
#endif
	TftpBlock = 0;
33d037bc:	e59f3090 	ldr	r3, [pc, #144]	; 33d03854 <TftpStart+0x228>

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
33d037c0:	e1a01004 	mov	r1, r4
	}
	if ((ep = getenv("tftpsrcp")) != NULL) {
		TftpOurPort= simple_strtol(ep, NULL, 10);
	}
#endif
	TftpBlock = 0;
33d037c4:	e5834000 	str	r4, [r3]

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
33d037c8:	e3a02006 	mov	r2, #6	; 0x6
33d037cc:	e59f0084 	ldr	r0, [pc, #132]	; 33d03858 <TftpStart+0x22c>
33d037d0:	eb005aef 	bl	33d1a394 <memset>
	/* Revert TftpBlkSize to dflt */
	TftpBlkSize = TFTP_BLOCK_SIZE;
33d037d4:	e59f3080 	ldr	r3, [pc, #128]	; 33d0385c <TftpStart+0x230>
33d037d8:	e3a02c02 	mov	r2, #512	; 0x200
33d037dc:	e1c320b0 	strh	r2, [r3]
#ifdef CONFIG_MCAST_TFTP
    	mcast_cleanup();
#endif

	TftpSend ();
33d037e0:	e28dd008 	add	sp, sp, #8	; 0x8
33d037e4:	e8bd4070 	pop	{r4, r5, r6, lr}
33d037e8:	eafffe45 	b	33d03104 <TftpSend>
33d037ec:	33d37340 	.word	0x33d37340
33d037f0:	33d3986c 	.word	0x33d3986c
33d037f4:	33d37318 	.word	0x33d37318
33d037f8:	33d3985c 	.word	0x33d3985c
33d037fc:	33d25aa4 	.word	0x33d25aa4
33d03800:	33d25ac0 	.word	0x33d25ac0
33d03804:	33d3731c 	.word	0x33d3731c
33d03808:	33d25aec 	.word	0x33d25aec
33d0380c:	33d37304 	.word	0x33d37304
33d03810:	33d25b00 	.word	0x33d25b00
33d03814:	33d37308 	.word	0x33d37308
33d03818:	33d25b18 	.word	0x33d25b18
33d0381c:	33d3727c 	.word	0x33d3727c
33d03820:	33d25b34 	.word	0x33d25b34
33d03824:	33d25b44 	.word	0x33d25b44
33d03828:	33d2a490 	.word	0x33d2a490
33d0382c:	33d35fec 	.word	0x33d35fec
33d03830:	33d2597c 	.word	0x33d2597c
33d03834:	33d25994 	.word	0x33d25994
33d03838:	33d035d0 	.word	0x33d035d0
33d0383c:	00773594 	.word	0x00773594
33d03840:	33d032dc 	.word	0x33d032dc
33d03844:	33d3983c 	.word	0x33d3983c
33d03848:	33d39858 	.word	0x33d39858
33d0384c:	33d39844 	.word	0x33d39844
33d03850:	33d39840 	.word	0x33d39840
33d03854:	33d39848 	.word	0x33d39848
33d03858:	33d37276 	.word	0x33d37276
33d0385c:	33d2ddb2 	.word	0x33d2ddb2

33d03860 <truncate_sz>:
	}
}

static int truncate_sz (const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
33d03860:	e1520001 	cmp	r2, r1
		setenv ("bootfile", BootFile);
	}
}

static int truncate_sz (const char *name, int maxlen, int curlen)
{
33d03864:	e92d4010 	push	{r4, lr}
	if (curlen >= maxlen) {
		printf("*** WARNING: %s is too long (%d - max: %d) - truncated\n",
33d03868:	e1a03001 	mov	r3, r1
		setenv ("bootfile", BootFile);
	}
}

static int truncate_sz (const char *name, int maxlen, int curlen)
{
33d0386c:	e1a04001 	mov	r4, r1
33d03870:	e1a0c002 	mov	ip, r2
33d03874:	e1a01000 	mov	r1, r0
	if (curlen >= maxlen) {
		printf("*** WARNING: %s is too long (%d - max: %d) - truncated\n",
33d03878:	e59f0010 	ldr	r0, [pc, #16]	; 33d03890 <truncate_sz+0x30>
	}
}

static int truncate_sz (const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
33d0387c:	ba000001 	blt	33d03888 <truncate_sz+0x28>
		printf("*** WARNING: %s is too long (%d - max: %d) - truncated\n",
33d03880:	eb004dd0 	bl	33d16fc8 <printf>
			name, curlen, maxlen);
		curlen = maxlen - 1;
33d03884:	e244c001 	sub	ip, r4, #1	; 0x1
	}
	return (curlen);
}
33d03888:	e1a0000c 	mov	r0, ip
33d0388c:	e8bd8010 	pop	{r4, pc}
33d03890:	33d25b5c 	.word	0x33d25b5c

33d03894 <BootpHandler>:
/*
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
33d03894:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
	Bootp_t *bp = (Bootp_t *) pkt;
	int retval = 0;

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
33d03898:	e3520043 	cmp	r2, #67	; 0x43
33d0389c:	03510044 	cmpeq	r1, #68	; 0x44
/*
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
33d038a0:	e24dd00c 	sub	sp, sp, #12	; 0xc
33d038a4:	e1a04000 	mov	r4, r0
33d038a8:	e1a0a003 	mov	sl, r3
static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
	Bootp_t *bp = (Bootp_t *) pkt;
	int retval = 0;

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
33d038ac:	1a0000ba 	bne	33d03b9c <BootpHandler+0x308>
		retval = -1;
	else if (len < sizeof (Bootp_t) - OPT_SIZE)
33d038b0:	e35300eb 	cmp	r3, #235	; 0xeb
33d038b4:	9a0000b8 	bls	33d03b9c <BootpHandler+0x308>
		retval = -2;
	else if (bp->bp_op != OP_BOOTREQUEST &&
33d038b8:	e5d02000 	ldrb	r2, [r0]
33d038bc:	e2423001 	sub	r3, r2, #1	; 0x1
33d038c0:	e3520005 	cmp	r2, #5	; 0x5
33d038c4:	13530001 	cmpne	r3, #1	; 0x1
33d038c8:	9a000001 	bls	33d038d4 <BootpHandler+0x40>
33d038cc:	e3520006 	cmp	r2, #6	; 0x6
33d038d0:	1a0000b1 	bne	33d03b9c <BootpHandler+0x308>
	    bp->bp_op != DHCP_OFFER &&
	    bp->bp_op != DHCP_ACK &&
	    bp->bp_op != DHCP_NAK ) {
		retval = -3;
	}
	else if (bp->bp_htype != HWT_ETHER)
33d038d4:	e5d43001 	ldrb	r3, [r4, #1]
33d038d8:	e3530001 	cmp	r3, #1	; 0x1
33d038dc:	1a0000ae 	bne	33d03b9c <BootpHandler+0x308>
		retval = -4;
	else if (bp->bp_hlen != HWL_ETHER)
33d038e0:	e5d46002 	ldrb	r6, [r4, #2]
33d038e4:	e3560006 	cmp	r6, #6	; 0x6
33d038e8:	1a0000ab 	bne	33d03b9c <BootpHandler+0x308>

/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
	ulong l;
	memcpy((void*)&l, (void*)from, sizeof(l));
33d038ec:	e3a02004 	mov	r2, #4	; 0x4
33d038f0:	e28d0008 	add	r0, sp, #8	; 0x8
33d038f4:	e2841004 	add	r1, r4, #4	; 0x4
33d038f8:	eb005ab9 	bl	33d1a3e4 <memcpy>
	return ip;
}

/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
33d038fc:	e59f32a0 	ldr	r3, [pc, #672]	; 33d03ba4 <BootpHandler+0x310>
33d03900:	e5932000 	ldr	r2, [r3]
33d03904:	e59d3008 	ldr	r3, [sp, #8]
33d03908:	e1530002 	cmp	r3, r2
33d0390c:	1a0000a2 	bne	33d03b9c <BootpHandler+0x308>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy(to, from, sizeof(IPaddr_t));
33d03910:	e2841010 	add	r1, r4, #16	; 0x10
33d03914:	e3a02004 	mov	r2, #4	; 0x4
33d03918:	e59f0288 	ldr	r0, [pc, #648]	; 33d03ba8 <BootpHandler+0x314>
	memcpy(to, (void*)&ip, sizeof(ip));
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
33d0391c:	e2845014 	add	r5, r4, #20	; 0x14
	memcpy(to, from, sizeof(IPaddr_t));
33d03920:	eb005aaf 	bl	33d1a3e4 <memcpy>
33d03924:	e28d0004 	add	r0, sp, #4	; 0x4
33d03928:	e1a01005 	mov	r1, r5
33d0392c:	e3a02004 	mov	r2, #4	; 0x4
33d03930:	eb005aab 	bl	33d1a3e4 <memcpy>
{
	IPaddr_t tmp_ip;

	NetCopyIP(&NetOurIP, &bp->bp_yiaddr);
	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
	if (tmp_ip != 0)
33d03934:	e59d3004 	ldr	r3, [sp, #4]
33d03938:	e3530000 	cmp	r3, #0	; 0x0
33d0393c:	11a01005 	movne	r1, r5
33d03940:	159f0264 	ldrne	r0, [pc, #612]	; 33d03bac <BootpHandler+0x318>
33d03944:	13a02004 	movne	r2, #4	; 0x4
33d03948:	1b005aa5 	blne	33d1a3e4 <memcpy>
		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
	memcpy (NetServerEther, ((Ethernet_t *)NetRxPkt)->et_src, 6);
33d0394c:	e59f325c 	ldr	r3, [pc, #604]	; 33d03bb0 <BootpHandler+0x31c>
33d03950:	e5931000 	ldr	r1, [r3]
33d03954:	e1a02006 	mov	r2, r6
33d03958:	e2811006 	add	r1, r1, #6	; 0x6
33d0395c:	e59f0250 	ldr	r0, [pc, #592]	; 33d03bb4 <BootpHandler+0x320>
	if (strlen(bp->bp_file) > 0)
33d03960:	e284506c 	add	r5, r4, #108	; 0x6c

	NetCopyIP(&NetOurIP, &bp->bp_yiaddr);
	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
	if (tmp_ip != 0)
		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
	memcpy (NetServerEther, ((Ethernet_t *)NetRxPkt)->et_src, 6);
33d03964:	eb005a9e 	bl	33d1a3e4 <memcpy>
	if (strlen(bp->bp_file) > 0)
33d03968:	e1a00005 	mov	r0, r5
33d0396c:	eb0059e7 	bl	33d1a110 <strlen>
33d03970:	e3500000 	cmp	r0, #0	; 0x0
		copy_filename (BootFile, bp->bp_file, sizeof(BootFile));
33d03974:	11a01005 	movne	r1, r5
33d03978:	159f0238 	ldrne	r0, [pc, #568]	; 33d03bb8 <BootpHandler+0x324>
33d0397c:	13a02080 	movne	r2, #128	; 0x80
33d03980:	1bfffa8e 	blne	33d023c0 <copy_filename>

	/* Propagate to environment:
	 * don't delete exising entry when BOOTP / DHCP reply does
	 * not contain a new value
	 */
	if (*BootFile) {
33d03984:	e59f122c 	ldr	r1, [pc, #556]	; 33d03bb8 <BootpHandler+0x324>
33d03988:	e5d13000 	ldrb	r3, [r1]
33d0398c:	e3530000 	cmp	r3, #0	; 0x0
		setenv ("bootfile", BootFile);
33d03990:	159f0224 	ldrne	r0, [pc, #548]	; 33d03bbc <BootpHandler+0x328>
33d03994:	1b00478f 	blne	33d157d8 <setenv>

/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
	ulong l;
	memcpy((void*)&l, (void*)from, sizeof(l));
33d03998:	e3a02004 	mov	r2, #4	; 0x4
33d0399c:	e1a0000d 	mov	r0, sp
33d039a0:	e28410ec 	add	r1, r4, #236	; 0xec
33d039a4:	eb005a8e 	bl	33d1a3e4 <memcpy>
	return ip;
}

/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
33d039a8:	e59d2000 	ldr	r2, [sp]
33d039ac:	e59f320c 	ldr	r3, [pc, #524]	; 33d03bc0 <BootpHandler+0x32c>
33d039b0:	e1520003 	cmp	r2, r3
33d039b4:	1a00006a 	bne	33d03b64 <BootpHandler+0x2d0>
		/* Reserved (custom) fields (128..254) */
	}
}

static void BootpVendorProcess (u8 * ext, int size)
{
33d039b8:	e28470f0 	add	r7, r4, #240	; 0xf0
	u8 *end = ext + size;
33d039bc:	e087900a 	add	r9, r7, sl
	case 43:		/* Vendor specific info - Not yet supported     */
		/*
		 * Binary information to exchange specific
		 * product information.
		 */
		break;
33d039c0:	e1570009 	cmp	r7, r9
33d039c4:	2a000066 	bcs	33d03b64 <BootpHandler+0x2d0>
33d039c8:	e5d430f0 	ldrb	r3, [r4, #240]
33d039cc:	e35300ff 	cmp	r3, #255	; 0xff
33d039d0:	0a000063 	beq	33d03b64 <BootpHandler+0x2d0>
	u8 *end = ext + size;

	debug_ext ("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
33d039d4:	e5d73000 	ldrb	r3, [r7]
33d039d8:	e3530000 	cmp	r3, #0	; 0x0
			ext++;
33d039dc:	02877001 	addeq	r7, r7, #1	; 0x1
	u8 *end = ext + size;

	debug_ext ("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
33d039e0:	0a00005c 	beq	33d03b58 <BootpHandler+0x2c4>
			ext++;
		} else {
			u8 *opt = ext;

			ext += ext[1] + 2;
33d039e4:	e5d72001 	ldrb	r2, [r7, #1]
33d039e8:	e0873002 	add	r3, r7, r2

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
			ext++;
		} else {
			u8 *opt = ext;
33d039ec:	e1a05007 	mov	r5, r7

			ext += ext[1] + 2;
33d039f0:	e2837002 	add	r7, r3, #2	; 0x2
			if (ext <= end)
33d039f4:	e1570009 	cmp	r7, r9
33d039f8:	8a000059 	bhi	33d03b64 <BootpHandler+0x2d0>
	int size = *(ext + 1);

	debug_ext ("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		   *(ext + 1));

	NetBootFileSize = 0;
33d039fc:	e59f01c0 	ldr	r0, [pc, #448]	; 33d03bc4 <BootpHandler+0x330>
33d03a00:	e3a0a000 	mov	sl, #0	; 0x0
33d03a04:	e1c0a0b0 	strh	sl, [r0]

	switch (*ext) {
33d03a08:	e5d53000 	ldrb	r3, [r5]
33d03a0c:	e353000c 	cmp	r3, #12	; 0xc

#if !(CONFIG_COMMANDS & CFG_CMD_DHCP)

static void BootpVendorFieldProcess (u8 * ext)
{
	int size = *(ext + 1);
33d03a10:	e1a04002 	mov	r4, r2
	debug_ext ("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		   *(ext + 1));

	NetBootFileSize = 0;

	switch (*ext) {
33d03a14:	0a00001e 	beq	33d03a94 <BootpHandler+0x200>
33d03a18:	ca000008 	bgt	33d03a40 <BootpHandler+0x1ac>
33d03a1c:	e3530003 	cmp	r3, #3	; 0x3
33d03a20:	0a000011 	beq	33d03a6c <BootpHandler+0x1d8>
33d03a24:	ca000002 	bgt	33d03a34 <BootpHandler+0x1a0>
33d03a28:	e3530001 	cmp	r3, #1	; 0x1
33d03a2c:	0a00000c 	beq	33d03a64 <BootpHandler+0x1d0>
33d03a30:	ea000048 	b	33d03b58 <BootpHandler+0x2c4>
33d03a34:	e3530006 	cmp	r3, #6	; 0x6
33d03a38:	0a00000d 	beq	33d03a74 <BootpHandler+0x1e0>
33d03a3c:	ea000045 	b	33d03b58 <BootpHandler+0x2c4>
33d03a40:	e3530011 	cmp	r3, #17	; 0x11
33d03a44:	0a00002e 	beq	33d03b04 <BootpHandler+0x270>
33d03a48:	ca000002 	bgt	33d03a58 <BootpHandler+0x1c4>
33d03a4c:	e353000d 	cmp	r3, #13	; 0xd
33d03a50:	0a000017 	beq	33d03ab4 <BootpHandler+0x220>
33d03a54:	ea00003f 	b	33d03b58 <BootpHandler+0x2c4>
33d03a58:	e3530028 	cmp	r3, #40	; 0x28
33d03a5c:	0a000030 	beq	33d03b24 <BootpHandler+0x290>
33d03a60:	ea00003c 	b	33d03b58 <BootpHandler+0x2c4>
		/* Fixed length fields */
	case 1:			/* Subnet mask                                  */
		if (NetOurSubnetMask == 0)
33d03a64:	e59f015c 	ldr	r0, [pc, #348]	; 33d03bc8 <BootpHandler+0x334>
33d03a68:	ea000002 	b	33d03a78 <BootpHandler+0x1e4>
		break;
	case 2:			/* Time offset - Not yet supported              */
		break;
		/* Variable length fields */
	case 3:			/* Gateways list                                */
		if (NetOurGatewayIP == 0) {
33d03a6c:	e59f0158 	ldr	r0, [pc, #344]	; 33d03bcc <BootpHandler+0x338>
33d03a70:	ea000000 	b	33d03a78 <BootpHandler+0x1e4>
	case 4:			/* Time server - Not yet supported              */
		break;
	case 5:			/* IEN-116 name server - Not yet supported      */
		break;
	case 6:
		if (NetOurDNSIP == 0) {
33d03a74:	e59f0154 	ldr	r0, [pc, #340]	; 33d03bd0 <BootpHandler+0x33c>
33d03a78:	e5903000 	ldr	r3, [r0]
33d03a7c:	e3530000 	cmp	r3, #0	; 0x0
33d03a80:	1a000034 	bne	33d03b58 <BootpHandler+0x2c4>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy(to, from, sizeof(IPaddr_t));
33d03a84:	e2851002 	add	r1, r5, #2	; 0x2
33d03a88:	e3a02004 	mov	r2, #4	; 0x4
33d03a8c:	eb005a54 	bl	33d1a3e4 <memcpy>
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_DNS2)
		if ((NetOurDNS2IP == 0) && (size > 4)) {
			NetCopyIP (&NetOurDNS2IP, (IPaddr_t *) (ext + 2 + 4));
		}
#endif
		break;
33d03a90:	ea000030 	b	33d03b58 <BootpHandler+0x2c4>
	case 10:		/* Impress server - Not yet supported           */
		break;
	case 11:		/* RPL server - Not yet supported               */
		break;
	case 12:		/* Host name                                    */
		if (NetOurHostName[0] == 0) {
33d03a94:	e59f6138 	ldr	r6, [pc, #312]	; 33d03bd4 <BootpHandler+0x340>
33d03a98:	e5d63000 	ldrb	r3, [r6]
33d03a9c:	e3530000 	cmp	r3, #0	; 0x0
			size = truncate_sz ("Host Name", sizeof (NetOurHostName), size);
33d03aa0:	01a02002 	moveq	r2, r2
33d03aa4:	03a01020 	moveq	r1, #32	; 0x20
33d03aa8:	059f0128 	ldreq	r0, [pc, #296]	; 33d03bd8 <BootpHandler+0x344>
	case 10:		/* Impress server - Not yet supported           */
		break;
	case 11:		/* RPL server - Not yet supported               */
		break;
	case 12:		/* Host name                                    */
		if (NetOurHostName[0] == 0) {
33d03aac:	0a000022 	beq	33d03b3c <BootpHandler+0x2a8>
33d03ab0:	ea000028 	b	33d03b58 <BootpHandler+0x2c4>
			memcpy (&NetOurHostName, ext + 2, size);
			NetOurHostName[size] = 0;
		}
		break;
	case 13:		/* Boot file size                               */
		if (size == 2)
33d03ab4:	e3520002 	cmp	r2, #2	; 0x2
33d03ab8:	1a000006 	bne	33d03ad8 <BootpHandler+0x244>
			NetBootFileSize = ntohs (*(ushort *) (ext + 2));
33d03abc:	e1d520b2 	ldrh	r2, [r5, #2]
	return __arch__swab16(x);
33d03ac0:	e1a03422 	lsr	r3, r2, #8
33d03ac4:	e1a03803 	lsl	r3, r3, #16
33d03ac8:	e1833c02 	orr	r3, r3, r2, lsl #24
33d03acc:	e1a03823 	lsr	r3, r3, #16
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d03ad0:	e1c030b0 	strh	r3, [r0]
33d03ad4:	ea00001f 	b	33d03b58 <BootpHandler+0x2c4>
		else if (size == 4)
33d03ad8:	e3520004 	cmp	r2, #4	; 0x4
33d03adc:	1a00001d 	bne	33d03b58 <BootpHandler+0x2c4>
33d03ae0:	e5953002 	ldr	r3, [r5, #2]
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
33d03ae4:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d03ae8:	e1a02402 	lsl	r2, r2, #8
33d03aec:	e1822c03 	orr	r2, r2, r3, lsl #24
33d03af0:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d03af4:	e1822421 	orr	r2, r2, r1, lsr #8
33d03af8:	e1822c23 	orr	r2, r2, r3, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d03afc:	e1c020b0 	strh	r2, [r0]
			NetBootFileSize = ntohl (*(ulong *) (ext + 2));
		break;
33d03b00:	ea000014 	b	33d03b58 <BootpHandler+0x2c4>
	case 15:		/* Domain name - Not yet supported              */
		break;
	case 16:		/* Swap server - Not yet supported              */
		break;
	case 17:		/* Root path                                    */
		if (NetOurRootPath[0] == 0) {
33d03b04:	e59f60d0 	ldr	r6, [pc, #208]	; 33d03bdc <BootpHandler+0x348>
33d03b08:	e5d63000 	ldrb	r3, [r6]
33d03b0c:	e3530000 	cmp	r3, #0	; 0x0
			size = truncate_sz ("Root Path", sizeof (NetOurRootPath), size);
33d03b10:	01a02002 	moveq	r2, r2
33d03b14:	03a01040 	moveq	r1, #64	; 0x40
33d03b18:	059f00c0 	ldreq	r0, [pc, #192]	; 33d03be0 <BootpHandler+0x34c>
	case 15:		/* Domain name - Not yet supported              */
		break;
	case 16:		/* Swap server - Not yet supported              */
		break;
	case 17:		/* Root path                                    */
		if (NetOurRootPath[0] == 0) {
33d03b1c:	0a000006 	beq	33d03b3c <BootpHandler+0x2a8>
33d03b20:	ea00000c 	b	33d03b58 <BootpHandler+0x2c4>
		 * access via TFTP.
		 */
		break;
		/* IP host layer fields */
	case 40:		/* NIS Domain name                              */
		if (NetOurNISDomain[0] == 0) {
33d03b24:	e59f60b8 	ldr	r6, [pc, #184]	; 33d03be4 <BootpHandler+0x350>
33d03b28:	e5d63000 	ldrb	r3, [r6]
33d03b2c:	e3530000 	cmp	r3, #0	; 0x0
33d03b30:	1a000008 	bne	33d03b58 <BootpHandler+0x2c4>
			size = truncate_sz ("NIS Domain Name", sizeof (NetOurNISDomain), size);
33d03b34:	e59f00ac 	ldr	r0, [pc, #172]	; 33d03be8 <BootpHandler+0x354>
33d03b38:	e3a01020 	mov	r1, #32	; 0x20
33d03b3c:	ebffff47 	bl	33d03860 <truncate_sz>
33d03b40:	e1a04000 	mov	r4, r0
			memcpy (&NetOurNISDomain, ext + 2, size);
33d03b44:	e2851002 	add	r1, r5, #2	; 0x2
33d03b48:	e1a00006 	mov	r0, r6
33d03b4c:	e1a02004 	mov	r2, r4
33d03b50:	eb005a23 	bl	33d1a3e4 <memcpy>
			NetOurNISDomain[size] = 0;
33d03b54:	e7c6a004 	strb	sl, [r6, r4]
	case 43:		/* Vendor specific info - Not yet supported     */
		/*
		 * Binary information to exchange specific
		 * product information.
		 */
		break;
33d03b58:	e1570009 	cmp	r7, r9
33d03b5c:	35d73000 	ldrbcc	r3, [r7]
33d03b60:	3affff99 	bcc	33d039cc <BootpHandler+0x138>

	/* Retrieve extended information (we must parse the vendor area) */
	if (NetReadLong((ulong*)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);

	NetSetTimeout(0, (thand_f *)0);
33d03b64:	e3a00000 	mov	r0, #0	; 0x0
33d03b68:	e1a01000 	mov	r1, r0
33d03b6c:	ebfff86b 	bl	33d01d20 <NetSetTimeout>

	debug ("Got good BOOTP\n");

	if ((s = getenv("autoload")) != NULL) {
33d03b70:	e59f0074 	ldr	r0, [pc, #116]	; 33d03bec <BootpHandler+0x358>
33d03b74:	eb004735 	bl	33d15850 <getenv>
33d03b78:	e3500000 	cmp	r0, #0	; 0x0
33d03b7c:	0a000005 	beq	33d03b98 <BootpHandler+0x304>
		if (*s == 'n') {
33d03b80:	e5d03000 	ldrb	r3, [r0]
33d03b84:	e353006e 	cmp	r3, #110	; 0x6e
			/*
			 * Just use BOOTP to configure system;
			 * Do not use TFTP to load the bootfile.
			 */
			NetState = NETLOOP_SUCCESS;
33d03b88:	059f3060 	ldreq	r3, [pc, #96]	; 33d03bf0 <BootpHandler+0x35c>
33d03b8c:	03a02003 	moveq	r2, #3	; 0x3
33d03b90:	05832000 	streq	r2, [r3]
	NetSetTimeout(0, (thand_f *)0);

	debug ("Got good BOOTP\n");

	if ((s = getenv("autoload")) != NULL) {
		if (*s == 'n') {
33d03b94:	0a000000 	beq	33d03b9c <BootpHandler+0x308>
			return;
#endif
		}
	}

	TftpStart();
33d03b98:	ebfffea3 	bl	33d0362c <TftpStart>
}
33d03b9c:	e28dd00c 	add	sp, sp, #12	; 0xc
33d03ba0:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d03ba4:	33d39870 	.word	0x33d39870
33d03ba8:	33d37318 	.word	0x33d37318
33d03bac:	33d3731c 	.word	0x33d3731c
33d03bb0:	33d37330 	.word	0x33d37330
33d03bb4:	33d37276 	.word	0x33d37276
33d03bb8:	33d37340 	.word	0x33d37340
33d03bbc:	33d25520 	.word	0x33d25520
33d03bc0:	63538263 	.word	0x63538263
33d03bc4:	33d3727c 	.word	0x33d3727c
33d03bc8:	33d37308 	.word	0x33d37308
33d03bcc:	33d37304 	.word	0x33d37304
33d03bd0:	33d37300 	.word	0x33d37300
33d03bd4:	33d372be 	.word	0x33d372be
33d03bd8:	33d25b94 	.word	0x33d25b94
33d03bdc:	33d3727e 	.word	0x33d3727e
33d03be0:	33d25ba0 	.word	0x33d25ba0
33d03be4:	33d372de 	.word	0x33d372de
33d03be8:	33d25bac 	.word	0x33d25bac
33d03bec:	33d25bbc 	.word	0x33d25bbc
33d03bf0:	33d3733c 	.word	0x33d3733c

33d03bf4 <BootpRequest>:
}
#endif	/* CFG_CMD_DHCP */

void
BootpRequest (void)
{
33d03bf4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	for (reg=0; reg <sum; reg++) {
		udelay(1000); /*Wait 1ms*/
	}
#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
33d03bf8:	e59f2228 	ldr	r2, [pc, #552]	; 33d03e28 <BootpRequest+0x234>
33d03bfc:	e5923000 	ldr	r3, [r2]
	pkt = NetTxPacket;
33d03c00:	e59fb224 	ldr	fp, [pc, #548]	; 33d03e2c <BootpRequest+0x238>
	for (reg=0; reg <sum; reg++) {
		udelay(1000); /*Wait 1ms*/
	}
#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
33d03c04:	e2833001 	add	r3, r3, #1	; 0x1
}
#endif	/* CFG_CMD_DHCP */

void
BootpRequest (void)
{
33d03c08:	e24dd014 	sub	sp, sp, #20	; 0x14
	for (reg=0; reg <sum; reg++) {
		udelay(1000); /*Wait 1ms*/
	}
#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
33d03c0c:	e1a01003 	mov	r1, r3
33d03c10:	e5823000 	str	r3, [r2]
33d03c14:	e59f0214 	ldr	r0, [pc, #532]	; 33d03e30 <BootpRequest+0x23c>
33d03c18:	eb004cea 	bl	33d16fc8 <printf>
	pkt = NetTxPacket;
33d03c1c:	e59b6000 	ldr	r6, [fp]
	memset ((void*)pkt, 0, PKTSIZE);
33d03c20:	e3a01000 	mov	r1, #0	; 0x0
33d03c24:	e59f2208 	ldr	r2, [pc, #520]	; 33d03e34 <BootpRequest+0x240>
33d03c28:	e1a00006 	mov	r0, r6
33d03c2c:	eb0059d8 	bl	33d1a394 <memset>

	pkt += NetSetEther(pkt, NetBcastAddr, PROT_IP);
33d03c30:	e3a02b02 	mov	r2, #2048	; 0x800
33d03c34:	e59f11fc 	ldr	r1, [pc, #508]	; 33d03e38 <BootpRequest+0x244>
33d03c38:	e1a00006 	mov	r0, r6
33d03c3c:	ebfff7b1 	bl	33d01b08 <NetSetEther>
33d03c40:	e0866000 	add	r6, r6, r0

	bp = (Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
	bp->bp_htype = HWT_ETHER;
	bp->bp_hlen = HWL_ETHER;
	bp->bp_hops = 0;
33d03c44:	e3a07000 	mov	r7, #0	; 0x0
	 * set in packet header after extension length has been determined.
	 * C. Hallinan, DS4.COM, Inc.
	 */
	/* NetSetIP(pkt, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, sizeof (Bootp_t)); */
	iphdr = pkt;	/* We need this later for NetSetIP() */
	pkt += IP_HDR_SIZE;
33d03c48:	e286401c 	add	r4, r6, #28	; 0x1c

	bp = (Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
33d03c4c:	e3a0a001 	mov	sl, #1	; 0x1
	bp->bp_htype = HWT_ETHER;
	bp->bp_hlen = HWL_ETHER;
33d03c50:	e3a09006 	mov	r9, #6	; 0x6
	/* NetSetIP(pkt, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, sizeof (Bootp_t)); */
	iphdr = pkt;	/* We need this later for NetSetIP() */
	pkt += IP_HDR_SIZE;

	bp = (Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
33d03c54:	e5c6a01c 	strb	sl, [r6, #28]
	bp->bp_htype = HWT_ETHER;
33d03c58:	e5c4a001 	strb	sl, [r4, #1]
	bp->bp_hlen = HWL_ETHER;
33d03c5c:	e5c49002 	strb	r9, [r4, #2]
	bp->bp_hops = 0;
33d03c60:	e5c47003 	strb	r7, [r4, #3]
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d03c64:	e1a00007 	mov	r0, r7
33d03c68:	ebfff45e 	bl	33d00de8 <get_timer>
33d03c6c:	e59f11c8 	ldr	r1, [pc, #456]	; 33d03e3c <BootpRequest+0x248>
33d03c70:	ebfff5da 	bl	33d013e0 <__udivsi3>
33d03c74:	e1a00800 	lsl	r0, r0, #16
33d03c78:	e1a00820 	lsr	r0, r0, #16
	return __arch__swab16(x);
33d03c7c:	e1a03420 	lsr	r3, r0, #8
33d03c80:	e1a03803 	lsl	r3, r3, #16
33d03c84:	e1833c00 	orr	r3, r3, r0, lsl #24
33d03c88:	e1a03823 	lsr	r3, r3, #16
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d03c8c:	e28d1014 	add	r1, sp, #20	; 0x14
#  define __swab64(x) __fswab64(x)
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
33d03c90:	e1c430b8 	strh	r3, [r4, #8]
	memcpy(to, (void*)&ip, sizeof(ip));
33d03c94:	e3a02004 	mov	r2, #4	; 0x4
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d03c98:	e5217004 	str	r7, [r1, #-4]!
	memcpy(to, (void*)&ip, sizeof(ip));
33d03c9c:	e2860028 	add	r0, r6, #40	; 0x28
33d03ca0:	eb0059cf 	bl	33d1a3e4 <memcpy>
	bp->bp_secs = htons(get_timer(0) / CFG_HZ);
	NetWriteIP(&bp->bp_ciaddr, 0);
	NetWriteIP(&bp->bp_yiaddr, 0);
	NetWriteIP(&bp->bp_siaddr, 0);
	NetWriteIP(&bp->bp_giaddr, 0);
	memcpy (bp->bp_chaddr, NetOurEther, 6);
33d03ca4:	e28d100c 	add	r1, sp, #12	; 0xc
33d03ca8:	e3a02004 	mov	r2, #4	; 0x4
33d03cac:	e286002c 	add	r0, r6, #44	; 0x2c
33d03cb0:	e59f5188 	ldr	r5, [pc, #392]	; 33d03e40 <BootpRequest+0x24c>
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d03cb4:	e58d700c 	str	r7, [sp, #12]
	memcpy(to, (void*)&ip, sizeof(ip));
33d03cb8:	eb0059c9 	bl	33d1a3e4 <memcpy>
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d03cbc:	e28d1008 	add	r1, sp, #8	; 0x8
33d03cc0:	e3a02004 	mov	r2, #4	; 0x4
33d03cc4:	e2860030 	add	r0, r6, #48	; 0x30
33d03cc8:	e58d7008 	str	r7, [sp, #8]
	memcpy(to, (void*)&ip, sizeof(ip));
33d03ccc:	eb0059c4 	bl	33d1a3e4 <memcpy>
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
33d03cd0:	e28d1004 	add	r1, sp, #4	; 0x4
33d03cd4:	e3a02004 	mov	r2, #4	; 0x4
33d03cd8:	e2860034 	add	r0, r6, #52	; 0x34
33d03cdc:	e58d7004 	str	r7, [sp, #4]
	memcpy(to, (void*)&ip, sizeof(ip));
33d03ce0:	eb0059bf 	bl	33d1a3e4 <memcpy>
33d03ce4:	e1a02009 	mov	r2, r9
33d03ce8:	e1a01005 	mov	r1, r5
33d03cec:	e2860038 	add	r0, r6, #56	; 0x38
33d03cf0:	eb0059bb 	bl	33d1a3e4 <memcpy>
	copy_filename (bp->bp_file, BootFile, sizeof(bp->bp_file));
33d03cf4:	e2860088 	add	r0, r6, #136	; 0x88
33d03cf8:	e59f1144 	ldr	r1, [pc, #324]	; 33d03e44 <BootpRequest+0x250>
33d03cfc:	e3a02080 	mov	r2, #128	; 0x80
33d03d00:	ebfff9ae 	bl	33d023c0 <copy_filename>
#else	/* CFG_CMD_DHCP */
/*
 *	Warning: no field size check - change CONFIG_BOOTP_MASK at your own risk!
 */
static int BootpExtended (u8 * e)
{
33d03d04:	e2864f42 	add	r4, r6, #264	; 0x108
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
33d03d08:	e3a02063 	mov	r2, #99	; 0x63
/*
 *	Warning: no field size check - change CONFIG_BOOTP_MASK at your own risk!
 */
static int BootpExtended (u8 * e)
{
	u8 *start = e;
33d03d0c:	e1a0c004 	mov	ip, r4

	*e++ = 99;		/* RFC1048 Magic Cookie */
33d03d10:	e4c42001 	strb	r2, [r4], #1
	*e++ = 130;
33d03d14:	e3e0307d 	mvn	r3, #125	; 0x7d
33d03d18:	e4c43001 	strb	r3, [r4], #1
	*e++ = 83;
33d03d1c:	e28330d1 	add	r3, r3, #209	; 0xd1
33d03d20:	e4c43001 	strb	r3, [r4], #1
	*e++ = 99;
33d03d24:	e4c42001 	strb	r2, [r4], #1
	*e++ = (576 - 312 + OPT_SIZE) >> 16;
	*e++ = (576 - 312 + OPT_SIZE) & 0xff;
#endif /* CFG_CMD_DHCP */

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_SUBNETMASK)
	*e++ = 1;		/* Subnet mask request */
33d03d28:	e4c4a001 	strb	sl, [r4], #1
	*e++ = 4;
33d03d2c:	e28aa003 	add	sl, sl, #3	; 0x3
33d03d30:	e4c4a001 	strb	sl, [r4], #1
	e   += 4;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_GATEWAY)
	*e++ = 3;		/* Default gateway request */
33d03d34:	e2433050 	sub	r3, r3, #80	; 0x50
#endif /* CFG_CMD_DHCP */

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_SUBNETMASK)
	*e++ = 1;		/* Subnet mask request */
	*e++ = 4;
	e   += 4;
33d03d38:	e084400a 	add	r4, r4, sl
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_GATEWAY)
	*e++ = 3;		/* Default gateway request */
33d03d3c:	e4c43001 	strb	r3, [r4], #1
	*e++ = 4;
33d03d40:	e4c4a001 	strb	sl, [r4], #1
	*e++ = 4;
	e   += 4;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_HOSTNAME)
	*e++ = 12;		/* Host name request */
33d03d44:	e2833009 	add	r3, r3, #9	; 0x9
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_GATEWAY)
	*e++ = 3;		/* Default gateway request */
	*e++ = 4;
	e   += 4;
33d03d48:	e084400a 	add	r4, r4, sl
	*e++ = 4;
	e   += 4;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_HOSTNAME)
	*e++ = 12;		/* Host name request */
33d03d4c:	e4c43001 	strb	r3, [r4], #1
	*e++ = 32;
33d03d50:	e2422043 	sub	r2, r2, #67	; 0x43
33d03d54:	e4c42001 	strb	r2, [r4], #1
	*e++ = 2;
	e   += 2;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTPATH)
	*e++ = 17;		/* Boot path */
33d03d58:	e2833005 	add	r3, r3, #5	; 0x5
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_HOSTNAME)
	*e++ = 12;		/* Host name request */
	*e++ = 32;
	e   += 32;
33d03d5c:	e0844002 	add	r4, r4, r2
	*e++ = 2;
	e   += 2;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTPATH)
	*e++ = 17;		/* Boot path */
33d03d60:	e4c43001 	strb	r3, [r4], #1
	*e++ = 32;
33d03d64:	e4c42001 	strb	r2, [r4], #1
	*e++ = 40;		/* NIS Domain name request */
	*e++ = 32;
	e   += 32;
#endif

	*e++ = 255;		/* End of the list */
33d03d68:	e2499007 	sub	r9, r9, #7	; 0x7
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTPATH)
	*e++ = 17;		/* Boot path */
	*e++ = 32;
	e   += 32;
33d03d6c:	e0844002 	add	r4, r4, r2
	*e++ = 40;		/* NIS Domain name request */
	*e++ = 32;
	e   += 32;
#endif

	*e++ = 255;		/* End of the list */
33d03d70:	e4c49001 	strb	r9, [r4], #1

	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in HZ.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
33d03d74:	e5d53003 	ldrb	r3, [r5, #3]
33d03d78:	e5d52002 	ldrb	r2, [r5, #2]
33d03d7c:	e5d51004 	ldrb	r1, [r5, #4]
33d03d80:	e1a03803 	lsl	r3, r3, #16
33d03d84:	e1833c02 	orr	r3, r3, r2, lsl #24
33d03d88:	e5d52005 	ldrb	r2, [r5, #5]
33d03d8c:	e1833401 	orr	r3, r3, r1, lsl #8
33d03d90:	e59f50b0 	ldr	r5, [pc, #176]	; 33d03e48 <BootpRequest+0x254>
33d03d94:	e1833002 	orr	r3, r3, r2
33d03d98:	e5853000 	str	r3, [r5]
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
33d03d9c:	e1a00007 	mov	r0, r7
	*e++ = 40;		/* NIS Domain name request */
	*e++ = 32;
	e   += 32;
#endif

	*e++ = 255;		/* End of the list */
33d03da0:	e06c4004 	rsb	r4, ip, r4
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
33d03da4:	ebfff40f 	bl	33d00de8 <get_timer>
33d03da8:	e5952000 	ldr	r2, [r5]
33d03dac:	e0822000 	add	r2, r2, r0
33d03db0:	e2023cff 	and	r3, r2, #65280	; 0xff00
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
33d03db4:	e1a03403 	lsl	r3, r3, #8
33d03db8:	e20218ff 	and	r1, r2, #16711680	; 0xff0000
33d03dbc:	e1833c02 	orr	r3, r3, r2, lsl #24
33d03dc0:	e1833421 	orr	r3, r3, r1, lsr #8
33d03dc4:	e1833c22 	orr	r3, r3, r2, lsr #24
}

/* copy ulong */
static inline void NetCopyLong(ulong *to, ulong *from)
{
	memcpy((void*)to, (void*)from, sizeof(ulong));
33d03dc8:	e1a01005 	mov	r1, r5
33d03dcc:	e1a0200a 	mov	r2, sl
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d03dd0:	e5853000 	str	r3, [r5]
33d03dd4:	e2860020 	add	r0, r6, #32	; 0x20
33d03dd8:	eb005981 	bl	33d1a3e4 <memcpy>
	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	pktlen = BOOTP_SIZE - sizeof(bp->bp_vend) + ext_len;
	iplen = BOOTP_HDR_SIZE - sizeof(bp->bp_vend) + ext_len;
33d03ddc:	e284c0ec 	add	ip, r4, #236	; 0xec
	NetSetIP(iphdr, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, iplen);
33d03de0:	e3a02043 	mov	r2, #67	; 0x43
33d03de4:	e3a03044 	mov	r3, #68	; 0x44
33d03de8:	e1a00006 	mov	r0, r6
33d03dec:	e1a01009 	mov	r1, r9
33d03df0:	e58dc000 	str	ip, [sp]

	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	pktlen = BOOTP_SIZE - sizeof(bp->bp_vend) + ext_len;
33d03df4:	e2844f45 	add	r4, r4, #276	; 0x114
	iplen = BOOTP_HDR_SIZE - sizeof(bp->bp_vend) + ext_len;
	NetSetIP(iphdr, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, iplen);
33d03df8:	ebfff831 	bl	33d01ec4 <NetSetIP>
	NetSetTimeout(SELECT_TIMEOUT * CFG_HZ, BootpTimeout);
33d03dfc:	e59f1048 	ldr	r1, [pc, #72]	; 33d03e4c <BootpRequest+0x258>
33d03e00:	e59f0048 	ldr	r0, [pc, #72]	; 33d03e50 <BootpRequest+0x25c>
33d03e04:	ebfff7c5 	bl	33d01d20 <NetSetTimeout>

	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	pktlen = BOOTP_SIZE - sizeof(bp->bp_vend) + ext_len;
33d03e08:	e2844002 	add	r4, r4, #2	; 0x2

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
	dhcp_state = SELECTING;
	NetSetHandler(DhcpHandler);
#else
	NetSetHandler(BootpHandler);
33d03e0c:	e59f0040 	ldr	r0, [pc, #64]	; 33d03e54 <BootpRequest+0x260>
33d03e10:	ebfff7d1 	bl	33d01d5c <NetSetHandler>
#endif	/* CFG_CMD_DHCP */
	NetSendPacket(NetTxPacket, pktlen);
33d03e14:	e59b0000 	ldr	r0, [fp]
33d03e18:	e1a01004 	mov	r1, r4
33d03e1c:	ebfff814 	bl	33d01e74 <NetSendPacket>
33d03e20:	e28dd014 	add	sp, sp, #20	; 0x14
33d03e24:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d03e28:	33d39874 	.word	0x33d39874
33d03e2c:	33d3726c 	.word	0x33d3726c
33d03e30:	33d25bc8 	.word	0x33d25bc8
33d03e34:	000005ee 	.word	0x000005ee
33d03e38:	33d2ddac 	.word	0x33d2ddac
33d03e3c:	0017d784 	.word	0x0017d784
33d03e40:	33d37310 	.word	0x33d37310
33d03e44:	33d37340 	.word	0x33d37340
33d03e48:	33d39870 	.word	0x33d39870
33d03e4c:	33d03e58 	.word	0x33d03e58
33d03e50:	0047868c 	.word	0x0047868c
33d03e54:	33d03894 	.word	0x33d03894

33d03e58 <BootpTimeout>:
/*
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
33d03e58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (BootpTry >= TIMEOUT_COUNT) {
33d03e5c:	e59f302c 	ldr	r3, [pc, #44]	; 33d03e90 <BootpTimeout+0x38>
33d03e60:	e5933000 	ldr	r3, [r3]
33d03e64:	e3530004 	cmp	r3, #4	; 0x4
		puts ("\nRetry count exceeded; starting again\n");
33d03e68:	e59f0024 	ldr	r0, [pc, #36]	; 33d03e94 <BootpTimeout+0x3c>
		NetStartAgain ();
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, BootpTimeout);
33d03e6c:	e59f1024 	ldr	r1, [pc, #36]	; 33d03e98 <BootpTimeout+0x40>
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
	if (BootpTry >= TIMEOUT_COUNT) {
33d03e70:	da000002 	ble	33d03e80 <BootpTimeout+0x28>
		puts ("\nRetry count exceeded; starting again\n");
33d03e74:	eb004c4c 	bl	33d16fac <puts>
		NetStartAgain ();
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, BootpTimeout);
		BootpRequest ();
	}
}
33d03e78:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
static void
BootpTimeout(void)
{
	if (BootpTry >= TIMEOUT_COUNT) {
		puts ("\nRetry count exceeded; starting again\n");
		NetStartAgain ();
33d03e7c:	eafff7ba 	b	33d01d6c <NetStartAgain>
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, BootpTimeout);
33d03e80:	e59f0014 	ldr	r0, [pc, #20]	; 33d03e9c <BootpTimeout+0x44>
33d03e84:	ebfff7a5 	bl	33d01d20 <NetSetTimeout>
		BootpRequest ();
	}
}
33d03e88:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	if (BootpTry >= TIMEOUT_COUNT) {
		puts ("\nRetry count exceeded; starting again\n");
		NetStartAgain ();
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, BootpTimeout);
		BootpRequest ();
33d03e8c:	eaffff58 	b	33d03bf4 <BootpRequest>
33d03e90:	33d39874 	.word	0x33d39874
33d03e94:	33d25a7c 	.word	0x33d25a7c
33d03e98:	33d03e58 	.word	0x33d03e58
33d03e9c:	00773594 	.word	0x00773594

33d03ea0 <RarpHandler>:
/*
 *	Handle a RARP received packet.
 */
static void
RarpHandler(uchar * dummi0, unsigned dummi1, unsigned dummi2, unsigned dummi3)
{
33d03ea0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	char *s;
#ifdef	DEBUG
	puts ("Got good RARP\n");
#endif
	if ((s = getenv("autoload")) != NULL) {
33d03ea4:	e59f0028 	ldr	r0, [pc, #40]	; 33d03ed4 <RarpHandler+0x34>
33d03ea8:	eb004668 	bl	33d15850 <getenv>
33d03eac:	e3500000 	cmp	r0, #0	; 0x0
33d03eb0:	0a000005 	beq	33d03ecc <RarpHandler+0x2c>
		if (*s == 'n') {
33d03eb4:	e5d03000 	ldrb	r3, [r0]
33d03eb8:	e353006e 	cmp	r3, #110	; 0x6e
			/*
			 * Just use RARP to configure system;
			 * Do not use TFTP/NFS to to load the bootfile.
			 */
			NetState = NETLOOP_SUCCESS;
33d03ebc:	059f3014 	ldreq	r3, [pc, #20]	; 33d03ed8 <RarpHandler+0x38>
33d03ec0:	03a02003 	moveq	r2, #3	; 0x3
33d03ec4:	05832000 	streq	r2, [r3]
	char *s;
#ifdef	DEBUG
	puts ("Got good RARP\n");
#endif
	if ((s = getenv("autoload")) != NULL) {
		if (*s == 'n') {
33d03ec8:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
			return;
#endif
		}
	}
	TftpStart ();
}
33d03ecc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
			NfsStart();
			return;
#endif
		}
	}
	TftpStart ();
33d03ed0:	eafffdd5 	b	33d0362c <TftpStart>
33d03ed4:	33d25bbc 	.word	0x33d25bbc
33d03ed8:	33d3733c 	.word	0x33d3733c

33d03edc <RarpRequest>:
}


void
RarpRequest (void)
{
33d03edc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int i;
	volatile uchar *pkt;
	ARP_t *	rarp;

	printf("RARP broadcast %d\n", ++RarpTry);
33d03ee0:	e59f20cc 	ldr	r2, [pc, #204]	; 33d03fb4 <RarpRequest+0xd8>
33d03ee4:	e5923000 	ldr	r3, [r2]
	pkt = NetTxPacket;
33d03ee8:	e59f70c8 	ldr	r7, [pc, #200]	; 33d03fb8 <RarpRequest+0xdc>
{
	int i;
	volatile uchar *pkt;
	ARP_t *	rarp;

	printf("RARP broadcast %d\n", ++RarpTry);
33d03eec:	e2833001 	add	r3, r3, #1	; 0x1
33d03ef0:	e1a01003 	mov	r1, r3
33d03ef4:	e5823000 	str	r3, [r2]
33d03ef8:	e59f00bc 	ldr	r0, [pc, #188]	; 33d03fbc <RarpRequest+0xe0>
33d03efc:	eb004c31 	bl	33d16fc8 <printf>
	pkt = NetTxPacket;
33d03f00:	e5976000 	ldr	r6, [r7]

	pkt += NetSetEther(pkt, NetBcastAddr, PROT_RARP);
33d03f04:	e59f10b4 	ldr	r1, [pc, #180]	; 33d03fc0 <RarpRequest+0xe4>
33d03f08:	e1a00006 	mov	r0, r6
33d03f0c:	e59f20b0 	ldr	r2, [pc, #176]	; 33d03fc4 <RarpRequest+0xe8>
33d03f10:	ebfff6fc 	bl	33d01b08 <NetSetEther>

	rarp = (ARP_t *)pkt;

	rarp->ar_hrd = htons (ARP_ETHER);
33d03f14:	e3a03c01 	mov	r3, #256	; 0x100
	ARP_t *	rarp;

	printf("RARP broadcast %d\n", ++RarpTry);
	pkt = NetTxPacket;

	pkt += NetSetEther(pkt, NetBcastAddr, PROT_RARP);
33d03f18:	e0866000 	add	r6, r6, r0

	rarp = (ARP_t *)pkt;

	rarp->ar_hrd = htons (ARP_ETHER);
33d03f1c:	e1c630b0 	strh	r3, [r6]
	rarp->ar_pro = htons (PROT_IP);
33d03f20:	e3a03008 	mov	r3, #8	; 0x8
	rarp->ar_hln = 6;
33d03f24:	e3a04006 	mov	r4, #6	; 0x6
	rarp->ar_pln = 4;
33d03f28:	e3a05004 	mov	r5, #4	; 0x4
	pkt += NetSetEther(pkt, NetBcastAddr, PROT_RARP);

	rarp = (ARP_t *)pkt;

	rarp->ar_hrd = htons (ARP_ETHER);
	rarp->ar_pro = htons (PROT_IP);
33d03f2c:	e1c630b2 	strh	r3, [r6, #2]
	rarp->ar_hln = 6;
	rarp->ar_pln = 4;
	rarp->ar_op  = htons (RARPOP_REQUEST);
33d03f30:	e3a03c03 	mov	r3, #768	; 0x300
33d03f34:	e1c630b6 	strh	r3, [r6, #6]
	memcpy (&rarp->ar_data[0],  NetOurEther, 6);	/* source ET addr */
33d03f38:	e59f1088 	ldr	r1, [pc, #136]	; 33d03fc8 <RarpRequest+0xec>
33d03f3c:	e1a02004 	mov	r2, r4

	rarp = (ARP_t *)pkt;

	rarp->ar_hrd = htons (ARP_ETHER);
	rarp->ar_pro = htons (PROT_IP);
	rarp->ar_hln = 6;
33d03f40:	e5c64004 	strb	r4, [r6, #4]
	rarp->ar_pln = 4;
33d03f44:	e5c65005 	strb	r5, [r6, #5]
	rarp->ar_op  = htons (RARPOP_REQUEST);
	memcpy (&rarp->ar_data[0],  NetOurEther, 6);	/* source ET addr */
33d03f48:	e2860008 	add	r0, r6, #8	; 0x8
33d03f4c:	eb005924 	bl	33d1a3e4 <memcpy>
	memcpy (&rarp->ar_data[6],  &NetOurIP,   4);	/* source IP addr */
33d03f50:	e1a02005 	mov	r2, r5
33d03f54:	e59f1070 	ldr	r1, [pc, #112]	; 33d03fcc <RarpRequest+0xf0>
33d03f58:	e286000e 	add	r0, r6, #14	; 0xe
33d03f5c:	eb005920 	bl	33d1a3e4 <memcpy>
	memcpy (&rarp->ar_data[10], NetOurEther, 6);	/* dest ET addr = source ET addr ??*/
33d03f60:	e59f1060 	ldr	r1, [pc, #96]	; 33d03fc8 <RarpRequest+0xec>
33d03f64:	e1a02004 	mov	r2, r4
33d03f68:	e2860012 	add	r0, r6, #18	; 0x12
33d03f6c:	eb00591c 	bl	33d1a3e4 <memcpy>
	/* dest. IP addr set to broadcast */
	for (i = 0; i <= 3; i++) {
33d03f70:	e3a01000 	mov	r1, #0	; 0x0
		rarp->ar_data[16 + i] = 0xff;
33d03f74:	e0812006 	add	r2, r1, r6
	rarp->ar_op  = htons (RARPOP_REQUEST);
	memcpy (&rarp->ar_data[0],  NetOurEther, 6);	/* source ET addr */
	memcpy (&rarp->ar_data[6],  &NetOurIP,   4);	/* source IP addr */
	memcpy (&rarp->ar_data[10], NetOurEther, 6);	/* dest ET addr = source ET addr ??*/
	/* dest. IP addr set to broadcast */
	for (i = 0; i <= 3; i++) {
33d03f78:	e2811001 	add	r1, r1, #1	; 0x1
		rarp->ar_data[16 + i] = 0xff;
33d03f7c:	e3e03000 	mvn	r3, #0	; 0x0
	rarp->ar_op  = htons (RARPOP_REQUEST);
	memcpy (&rarp->ar_data[0],  NetOurEther, 6);	/* source ET addr */
	memcpy (&rarp->ar_data[6],  &NetOurIP,   4);	/* source IP addr */
	memcpy (&rarp->ar_data[10], NetOurEther, 6);	/* dest ET addr = source ET addr ??*/
	/* dest. IP addr set to broadcast */
	for (i = 0; i <= 3; i++) {
33d03f80:	e3510003 	cmp	r1, #3	; 0x3
		rarp->ar_data[16 + i] = 0xff;
33d03f84:	e5c23018 	strb	r3, [r2, #24]
	rarp->ar_op  = htons (RARPOP_REQUEST);
	memcpy (&rarp->ar_data[0],  NetOurEther, 6);	/* source ET addr */
	memcpy (&rarp->ar_data[6],  &NetOurIP,   4);	/* source IP addr */
	memcpy (&rarp->ar_data[10], NetOurEther, 6);	/* dest ET addr = source ET addr ??*/
	/* dest. IP addr set to broadcast */
	for (i = 0; i <= 3; i++) {
33d03f88:	dafffff9 	ble	33d03f74 <RarpRequest+0x98>
		rarp->ar_data[16 + i] = 0xff;
	}

	NetSendPacket(NetTxPacket, (pkt - NetTxPacket) + ARP_HDR_SIZE);
33d03f8c:	e5970000 	ldr	r0, [r7]
33d03f90:	e0601006 	rsb	r1, r0, r6
33d03f94:	e281101c 	add	r1, r1, #28	; 0x1c
33d03f98:	ebfff7b5 	bl	33d01e74 <NetSendPacket>

	NetSetTimeout(TIMEOUT * CFG_HZ, RarpTimeout);
33d03f9c:	e59f002c 	ldr	r0, [pc, #44]	; 33d03fd0 <RarpRequest+0xf4>
33d03fa0:	e59f102c 	ldr	r1, [pc, #44]	; 33d03fd4 <RarpRequest+0xf8>
33d03fa4:	ebfff75d 	bl	33d01d20 <NetSetTimeout>
	NetSetHandler(RarpHandler);
33d03fa8:	e59f0028 	ldr	r0, [pc, #40]	; 33d03fd8 <RarpRequest+0xfc>
33d03fac:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
33d03fb0:	eafff769 	b	33d01d5c <NetSetHandler>
33d03fb4:	33d39878 	.word	0x33d39878
33d03fb8:	33d3726c 	.word	0x33d3726c
33d03fbc:	33d25bdc 	.word	0x33d25bdc
33d03fc0:	33d2ddac 	.word	0x33d2ddac
33d03fc4:	00008035 	.word	0x00008035
33d03fc8:	33d37310 	.word	0x33d37310
33d03fcc:	33d37318 	.word	0x33d37318
33d03fd0:	00773594 	.word	0x00773594
33d03fd4:	33d03fdc 	.word	0x33d03fdc
33d03fd8:	33d03ea0 	.word	0x33d03ea0

33d03fdc <RarpTimeout>:
/*
 *	Timeout on BOOTP request.
 */
static void
RarpTimeout(void)
{
33d03fdc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (RarpTry >= TIMEOUT_COUNT) {
33d03fe0:	e59f302c 	ldr	r3, [pc, #44]	; 33d04014 <RarpTimeout+0x38>
33d03fe4:	e5933000 	ldr	r3, [r3]
33d03fe8:	e3530004 	cmp	r3, #4	; 0x4
		puts ("\nRetry count exceeded; starting again\n");
33d03fec:	e59f0024 	ldr	r0, [pc, #36]	; 33d04018 <RarpTimeout+0x3c>
		NetStartAgain ();
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, RarpTimeout);
33d03ff0:	e59f1024 	ldr	r1, [pc, #36]	; 33d0401c <RarpTimeout+0x40>
 *	Timeout on BOOTP request.
 */
static void
RarpTimeout(void)
{
	if (RarpTry >= TIMEOUT_COUNT) {
33d03ff4:	da000002 	ble	33d04004 <RarpTimeout+0x28>
		puts ("\nRetry count exceeded; starting again\n");
33d03ff8:	eb004beb 	bl	33d16fac <puts>
		NetStartAgain ();
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, RarpTimeout);
		RarpRequest ();
	}
}
33d03ffc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
static void
RarpTimeout(void)
{
	if (RarpTry >= TIMEOUT_COUNT) {
		puts ("\nRetry count exceeded; starting again\n");
		NetStartAgain ();
33d04000:	eafff759 	b	33d01d6c <NetStartAgain>
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, RarpTimeout);
33d04004:	e59f0014 	ldr	r0, [pc, #20]	; 33d04020 <RarpTimeout+0x44>
33d04008:	ebfff744 	bl	33d01d20 <NetSetTimeout>
		RarpRequest ();
	}
}
33d0400c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	if (RarpTry >= TIMEOUT_COUNT) {
		puts ("\nRetry count exceeded; starting again\n");
		NetStartAgain ();
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, RarpTimeout);
		RarpRequest ();
33d04010:	eaffffb1 	b	33d03edc <RarpRequest>
33d04014:	33d39878 	.word	0x33d39878
33d04018:	33d25a7c 	.word	0x33d25a7c
33d0401c:	33d03fdc 	.word	0x33d03fdc
33d04020:	00773594 	.word	0x00773594

33d04024 <eth_initialize>:
#endif
#if defined(CONFIG_NETARM)
	ns7520_miiphy_initialize(bis);
#endif
	return 0;
}
33d04024:	e3a00000 	mov	r0, #0	; 0x0
33d04028:	e1a0f00e 	mov	pc, lr

33d0402c <DM9000_ior>:
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
33d0402c:	e59f3008 	ldr	r3, [pc, #8]	; 33d0403c <DM9000_ior+0x10>
33d04030:	e4c30004 	strb	r0, [r3], #4
	return DM9000_inb(DM9000_DATA);
33d04034:	e5d30000 	ldrb	r0, [r3]
}
33d04038:	e1a0f00e 	mov	pc, lr
33d0403c:	20000300 	.word	0x20000300

33d04040 <DM9000_iow>:
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
33d04040:	e59f300c 	ldr	r3, [pc, #12]	; 33d04054 <DM9000_iow+0x14>
/*
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
33d04044:	e20110ff 	and	r1, r1, #255	; 0xff
	DM9000_outb(reg, DM9000_IO);
33d04048:	e4c30004 	strb	r0, [r3], #4
	DM9000_outb(value, DM9000_DATA);
33d0404c:	e5c31000 	strb	r1, [r3]
33d04050:	e1a0f00e 	mov	pc, lr
33d04054:	20000300 	.word	0x20000300

33d04058 <phy_write>:
/*
   Write a word to phyxcer
*/
static void
phy_write(int reg, u16 value)
{
33d04058:	e92d4030 	push	{r4, r5, lr}

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
33d0405c:	e3800040 	orr	r0, r0, #64	; 0x40
/*
   Write a word to phyxcer
*/
static void
phy_write(int reg, u16 value)
{
33d04060:	e1a05801 	lsl	r5, r1, #16

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
33d04064:	e20000ff 	and	r0, r0, #255	; 0xff
/*
   Write a word to phyxcer
*/
static void
phy_write(int reg, u16 value)
{
33d04068:	e1a04825 	lsr	r4, r5, #16

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
33d0406c:	e1a01000 	mov	r1, r0

	/* Fill the written data into REG_0D & REG_0E */
	DM9000_iow(DM9000_EPDRL, (value & 0xff));
33d04070:	e20440ff 	and	r4, r4, #255	; 0xff
static void
phy_write(int reg, u16 value)
{

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
33d04074:	e3a0000c 	mov	r0, #12	; 0xc
33d04078:	ebfffff0 	bl	33d04040 <DM9000_iow>

	/* Fill the written data into REG_0D & REG_0E */
	DM9000_iow(DM9000_EPDRL, (value & 0xff));
33d0407c:	e1a01004 	mov	r1, r4
33d04080:	e3a0000d 	mov	r0, #13	; 0xd
33d04084:	ebffffed 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_EPDRH, ((value >> 8) & 0xff));
33d04088:	e1a01c25 	lsr	r1, r5, #24
33d0408c:	e3a0000e 	mov	r0, #14	; 0xe
33d04090:	ebffffea 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
33d04094:	e3a0100a 	mov	r1, #10	; 0xa
33d04098:	e3a0000b 	mov	r0, #11	; 0xb
33d0409c:	ebffffe7 	bl	33d04040 <DM9000_iow>
	udelay(500);		/* Wait write complete */
33d040a0:	e3a00f7d 	mov	r0, #500	; 0x1f4
33d040a4:	ebfff358 	bl	33d00e0c <udelay>
	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
33d040a8:	e3a0000b 	mov	r0, #11	; 0xb
33d040ac:	e3a01000 	mov	r1, #0	; 0x0
33d040b0:	e8bd4030 	pop	{r4, r5, lr}
33d040b4:	eaffffe1 	b	33d04040 <DM9000_iow>

33d040b8 <phy_read>:
phy_read(int reg)
{
	u16 val;

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
33d040b8:	e3801040 	orr	r1, r0, #64	; 0x40
/*
   Read a word from phyxcer
*/
static u16
phy_read(int reg)
{
33d040bc:	e92d4010 	push	{r4, lr}
	u16 val;

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
33d040c0:	e20110ff 	and	r1, r1, #255	; 0xff
33d040c4:	e3a0000c 	mov	r0, #12	; 0xc
33d040c8:	ebffffdc 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
33d040cc:	e3a0100c 	mov	r1, #12	; 0xc
33d040d0:	e3a0000b 	mov	r0, #11	; 0xb
33d040d4:	ebffffd9 	bl	33d04040 <DM9000_iow>
	udelay(100);		/* Wait read complete */
33d040d8:	e3a00064 	mov	r0, #100	; 0x64
33d040dc:	ebfff34a 	bl	33d00e0c <udelay>
	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer read command */
33d040e0:	e3a01000 	mov	r1, #0	; 0x0
33d040e4:	e3a0000b 	mov	r0, #11	; 0xb
33d040e8:	ebffffd4 	bl	33d04040 <DM9000_iow>
	val = (DM9000_ior(DM9000_EPDRH) << 8) | DM9000_ior(DM9000_EPDRL);
33d040ec:	e3a0000e 	mov	r0, #14	; 0xe
33d040f0:	ebffffcd 	bl	33d0402c <DM9000_ior>
33d040f4:	e1a04400 	lsl	r4, r0, #8
33d040f8:	e3a0000d 	mov	r0, #13	; 0xd
33d040fc:	ebffffca 	bl	33d0402c <DM9000_ior>
33d04100:	e2044cff 	and	r4, r4, #65280	; 0xff00
33d04104:	e20000ff 	and	r0, r0, #255	; 0xff

	/* The read data keeps on REG_0D & REG_0E */
	DM9000_DBG("phy_read(%d): %d\n", reg, val);
	return val;
}
33d04108:	e1800004 	orr	r0, r0, r4
33d0410c:	e8bd8010 	pop	{r4, pc}

33d04110 <dm9000_reset>:
}

/* General Purpose dm9000 reset routine */
static void
dm9000_reset(void)
{
33d04110:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	DM9000_DBG("resetting\n");
	DM9000_iow(DM9000_NCR, NCR_RST);
33d04114:	e3a00000 	mov	r0, #0	; 0x0
33d04118:	e3a01001 	mov	r1, #1	; 0x1
33d0411c:	ebffffc7 	bl	33d04040 <DM9000_iow>
	udelay(1000);		/* delay 1ms */
33d04120:	e3a00ffa 	mov	r0, #1000	; 0x3e8
33d04124:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d04128:	eafff337 	b	33d00e0c <udelay>

33d0412c <eth_init>:

/* Initilize dm9000 board
*/
int
eth_init(bd_t * bd)
{
33d0412c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d04130:	e24dd010 	sub	sp, sp, #16	; 0x10
33d04134:	e1a09000 	mov	r9, r0
	int i, oft;
	DM9000_DBG("eth_init()\n");

	/* RESET device */
	dm9000_reset();
33d04138:	ebfffff4 	bl	33d04110 <dm9000_reset>
*/
int
dm9000_probe(void)
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
33d0413c:	e3a00028 	mov	r0, #40	; 0x28
33d04140:	ebffffb9 	bl	33d0402c <DM9000_ior>
33d04144:	e1a03000 	mov	r3, r0
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
33d04148:	e3a00029 	mov	r0, #41	; 0x29
*/
int
dm9000_probe(void)
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
33d0414c:	e20340ff 	and	r4, r3, #255	; 0xff
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
33d04150:	ebffffb5 	bl	33d0402c <DM9000_ior>
33d04154:	e1a03400 	lsl	r3, r0, #8
33d04158:	e2033cff 	and	r3, r3, #65280	; 0xff00
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
33d0415c:	e3a0002a 	mov	r0, #42	; 0x2a
int
dm9000_probe(void)
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
33d04160:	e1844003 	orr	r4, r4, r3
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
33d04164:	ebffffb0 	bl	33d0402c <DM9000_ior>
33d04168:	e1a03800 	lsl	r3, r0, #16
33d0416c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
	id_val |= DM9000_ior(DM9000_PIDH) << 24;
33d04170:	e3a0002b 	mov	r0, #43	; 0x2b
dm9000_probe(void)
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
33d04174:	e1844003 	orr	r4, r4, r3
	id_val |= DM9000_ior(DM9000_PIDH) << 24;
33d04178:	ebffffab 	bl	33d0402c <DM9000_ior>
	if (id_val == DM9000_ID) {
33d0417c:	e59f3398 	ldr	r3, [pc, #920]	; 33d0451c <eth_init+0x3f0>
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
	id_val |= DM9000_ior(DM9000_PIDH) << 24;
33d04180:	e1844c00 	orr	r4, r4, r0, lsl #24
	if (id_val == DM9000_ID) {
33d04184:	e1540003 	cmp	r4, r3
		printf("dm9000 i/o: 0x%x, id: 0x%x \n", CONFIG_DM9000_BASE,
33d04188:	01a02004 	moveq	r2, r4
33d0418c:	059f038c 	ldreq	r0, [pc, #908]	; 33d04520 <eth_init+0x3f4>
		       id_val);
		return 0;
	} else {
		printf("dm9000 not found at 0x%08x id: 0x%08x\n",
33d04190:	11a02004 	movne	r2, r4
33d04194:	159f0388 	ldrne	r0, [pc, #904]	; 33d04524 <eth_init+0x3f8>
33d04198:	e59f1388 	ldr	r1, [pc, #904]	; 33d04528 <eth_init+0x3fc>
33d0419c:	eb004b89 	bl	33d16fc8 <printf>
static void
identify_nic(void)
{
	struct board_info *db = &dmfe_info;	/* Point a board information structure */
	u16 phy_reg3;
	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
33d041a0:	e3a00000 	mov	r0, #0	; 0x0
33d041a4:	e3a01080 	mov	r1, #128	; 0x80
33d041a8:	ebffffa4 	bl	33d04040 <DM9000_iow>
	phy_reg3 = phy_read(3);
33d041ac:	e3a00003 	mov	r0, #3	; 0x3
33d041b0:	ebffffc0 	bl	33d040b8 <phy_read>
	switch (phy_reg3 & 0xfff0) {
33d041b4:	e59f3370 	ldr	r3, [pc, #880]	; 33d0452c <eth_init+0x400>
identify_nic(void)
{
	struct board_info *db = &dmfe_info;	/* Point a board information structure */
	u16 phy_reg3;
	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
	phy_reg3 = phy_read(3);
33d041b8:	e1a00800 	lsl	r0, r0, #16
33d041bc:	e1a0a820 	lsr	sl, r0, #16
	switch (phy_reg3 & 0xfff0) {
33d041c0:	e00a3003 	and	r3, sl, r3
33d041c4:	e3530cb9 	cmp	r3, #47360	; 0xb900
/* Identify NIC type
*/
static void
identify_nic(void)
{
	struct board_info *db = &dmfe_info;	/* Point a board information structure */
33d041c8:	e59f4360 	ldr	r4, [pc, #864]	; 33d04530 <eth_init+0x404>
			DM9000_DBG("found longrun NIC\n");
			program_dm9802();
		}
		break;
	default:
		db->nic_type = FASTETHER_NIC;
33d041cc:	13a03000 	movne	r3, #0	; 0x0
33d041d0:	15c4301c 	strbne	r3, [r4, #28]
{
	struct board_info *db = &dmfe_info;	/* Point a board information structure */
	u16 phy_reg3;
	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
	phy_reg3 = phy_read(3);
	switch (phy_reg3 & 0xfff0) {
33d041d4:	1a000050 	bne	33d0431c <eth_init+0x1f0>
	case 0xb900:
		if (phy_read(31) == 0x4404) {
33d041d8:	e3a0001f 	mov	r0, #31	; 0x1f
33d041dc:	ebffffb5 	bl	33d040b8 <phy_read>
33d041e0:	e59f334c 	ldr	r3, [pc, #844]	; 33d04534 <eth_init+0x408>
33d041e4:	e1a00800 	lsl	r0, r0, #16
33d041e8:	e1530820 	cmp	r3, r0, lsr #16
33d041ec:	e59f6344 	ldr	r6, [pc, #836]	; 33d04538 <eth_init+0x40c>
33d041f0:	1a00003a 	bne	33d042e0 <eth_init+0x1b4>
*/
static void
program_dm9801(u16 HPNA_rev)
{
	__u16 reg16, reg17, reg24, reg25;
	if (!nfloor)
33d041f4:	e5d63000 	ldrb	r3, [r6]
33d041f8:	e3530000 	cmp	r3, #0	; 0x0
	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
	phy_reg3 = phy_read(3);
	switch (phy_reg3 & 0xfff0) {
	case 0xb900:
		if (phy_read(31) == 0x4404) {
			db->nic_type = HOMERUN_NIC;
33d041fc:	e3a03001 	mov	r3, #1	; 0x1
33d04200:	e5c4301c 	strb	r3, [r4, #28]
static void
program_dm9801(u16 HPNA_rev)
{
	__u16 reg16, reg17, reg24, reg25;
	if (!nfloor)
		nfloor = DM9801_NOISE_FLOOR;
33d04204:	02833007 	addeq	r3, r3, #7	; 0x7
33d04208:	05c63000 	strbeq	r3, [r6]
	reg16 = phy_read(16);
33d0420c:	e3a00010 	mov	r0, #16	; 0x10
33d04210:	ebffffa8 	bl	33d040b8 <phy_read>
33d04214:	e1a03800 	lsl	r3, r0, #16
	reg17 = phy_read(17);
33d04218:	e3a00011 	mov	r0, #17	; 0x11
program_dm9801(u16 HPNA_rev)
{
	__u16 reg16, reg17, reg24, reg25;
	if (!nfloor)
		nfloor = DM9801_NOISE_FLOOR;
	reg16 = phy_read(16);
33d0421c:	e1a07823 	lsr	r7, r3, #16
	reg17 = phy_read(17);
33d04220:	ebffffa4 	bl	33d040b8 <phy_read>
33d04224:	e1a03800 	lsl	r3, r0, #16
	reg24 = phy_read(24);
33d04228:	e3a00018 	mov	r0, #24	; 0x18
{
	__u16 reg16, reg17, reg24, reg25;
	if (!nfloor)
		nfloor = DM9801_NOISE_FLOOR;
	reg16 = phy_read(16);
	reg17 = phy_read(17);
33d0422c:	e1a05823 	lsr	r5, r3, #16
	reg24 = phy_read(24);
33d04230:	ebffffa0 	bl	33d040b8 <phy_read>
33d04234:	e1a03800 	lsl	r3, r0, #16
	reg25 = phy_read(25);
33d04238:	e3a00019 	mov	r0, #25	; 0x19
	__u16 reg16, reg17, reg24, reg25;
	if (!nfloor)
		nfloor = DM9801_NOISE_FLOOR;
	reg16 = phy_read(16);
	reg17 = phy_read(17);
	reg24 = phy_read(24);
33d0423c:	e1a04823 	lsr	r4, r3, #16
	reg25 = phy_read(25);
33d04240:	ebffff9c 	bl	33d040b8 <phy_read>
	switch (HPNA_rev) {
33d04244:	e35a0cb9 	cmp	sl, #47360	; 0xb900
*/
static void
program_dm9801(u16 HPNA_rev)
{
	__u16 reg16, reg17, reg24, reg25;
	if (!nfloor)
33d04248:	e1a0b006 	mov	fp, r6
		nfloor = DM9801_NOISE_FLOOR;
	reg16 = phy_read(16);
	reg17 = phy_read(17);
	reg24 = phy_read(24);
	reg25 = phy_read(25);
	switch (HPNA_rev) {
33d0424c:	0a000003 	beq	33d04260 <eth_init+0x134>
33d04250:	e59f32e4 	ldr	r3, [pc, #740]	; 33d0453c <eth_init+0x410>
33d04254:	e15a0003 	cmp	sl, r3
33d04258:	0a000006 	beq	33d04278 <eth_init+0x14c>
33d0425c:	ea00000d 	b	33d04298 <eth_init+0x16c>
	case 0xb900:		/* DM9801 E3 */
		reg16 |= 0x1000;
		reg25 = ((reg24 + nfloor) & 0x00ff) | 0xf000;
33d04260:	e5d63000 	ldrb	r3, [r6]
33d04264:	e0843003 	add	r3, r4, r3
33d04268:	e20330ff 	and	r3, r3, #255	; 0xff
	reg17 = phy_read(17);
	reg24 = phy_read(24);
	reg25 = phy_read(25);
	switch (HPNA_rev) {
	case 0xb900:		/* DM9801 E3 */
		reg16 |= 0x1000;
33d0426c:	e3877a01 	orr	r7, r7, #4096	; 0x1000
		reg25 = ((reg24 + nfloor) & 0x00ff) | 0xf000;
33d04270:	e3834a0f 	orr	r4, r3, #61440	; 0xf000
		break;
33d04274:	ea000011 	b	33d042c0 <eth_init+0x194>
	case 0xb901:		/* DM9801 E4 */
		reg25 = ((reg24 + nfloor) & 0x00ff) | 0xc200;
33d04278:	e5d62000 	ldrb	r2, [r6]
		reg17 = (reg17 & 0xfff0) + nfloor + 3;
33d0427c:	e3c5300f 	bic	r3, r5, #15	; 0xf
33d04280:	e0823003 	add	r3, r2, r3
33d04284:	e2833003 	add	r3, r3, #3	; 0x3
	case 0xb900:		/* DM9801 E3 */
		reg16 |= 0x1000;
		reg25 = ((reg24 + nfloor) & 0x00ff) | 0xf000;
		break;
	case 0xb901:		/* DM9801 E4 */
		reg25 = ((reg24 + nfloor) & 0x00ff) | 0xc200;
33d04288:	e0842002 	add	r2, r4, r2
33d0428c:	e20220ff 	and	r2, r2, #255	; 0xff
		reg17 = (reg17 & 0xfff0) + nfloor + 3;
33d04290:	e1a03803 	lsl	r3, r3, #16
33d04294:	ea000007 	b	33d042b8 <eth_init+0x18c>
		break;
	case 0xb902:		/* DM9801 E5 */
	case 0xb903:		/* DM9801 E6 */
	default:
		reg16 |= 0x1000;
		reg25 = ((reg24 + nfloor - 3) & 0x00ff) | 0xc200;
33d04298:	e5d63000 	ldrb	r3, [r6]
		reg17 = (reg17 & 0xfff0) + nfloor;
33d0429c:	e3c5100f 	bic	r1, r5, #15	; 0xf
		break;
	case 0xb902:		/* DM9801 E5 */
	case 0xb903:		/* DM9801 E6 */
	default:
		reg16 |= 0x1000;
		reg25 = ((reg24 + nfloor - 3) & 0x00ff) | 0xc200;
33d042a0:	e0842003 	add	r2, r4, r3
33d042a4:	e2422003 	sub	r2, r2, #3	; 0x3
		reg17 = (reg17 & 0xfff0) + nfloor;
33d042a8:	e0833001 	add	r3, r3, r1
		break;
	case 0xb902:		/* DM9801 E5 */
	case 0xb903:		/* DM9801 E6 */
	default:
		reg16 |= 0x1000;
		reg25 = ((reg24 + nfloor - 3) & 0x00ff) | 0xc200;
33d042ac:	e20220ff 	and	r2, r2, #255	; 0xff
		reg17 = (reg17 & 0xfff0) + nfloor;
33d042b0:	e1a03803 	lsl	r3, r3, #16
		reg17 = (reg17 & 0xfff0) + nfloor + 3;
		break;
	case 0xb902:		/* DM9801 E5 */
	case 0xb903:		/* DM9801 E6 */
	default:
		reg16 |= 0x1000;
33d042b4:	e3877a01 	orr	r7, r7, #4096	; 0x1000
		reg25 = ((reg24 + nfloor - 3) & 0x00ff) | 0xc200;
33d042b8:	e3824cc2 	orr	r4, r2, #49664	; 0xc200
		reg17 = (reg17 & 0xfff0) + nfloor;
33d042bc:	e1a05823 	lsr	r5, r3, #16
	}
	phy_write(16, reg16);
33d042c0:	e1a01007 	mov	r1, r7
33d042c4:	e3a00010 	mov	r0, #16	; 0x10
33d042c8:	ebffff62 	bl	33d04058 <phy_write>
	phy_write(17, reg17);
33d042cc:	e1a01005 	mov	r1, r5
33d042d0:	e3a00011 	mov	r0, #17	; 0x11
33d042d4:	ebffff5f 	bl	33d04058 <phy_write>
	phy_write(25, reg25);
33d042d8:	e1a01004 	mov	r1, r4
33d042dc:	ea00000c 	b	33d04314 <eth_init+0x1e8>
*/
static void
program_dm9802(void)
{
	__u16 reg25;
	if (!nfloor)
33d042e0:	e5d63000 	ldrb	r3, [r6]
33d042e4:	e3530000 	cmp	r3, #0	; 0x0
		if (phy_read(31) == 0x4404) {
			db->nic_type = HOMERUN_NIC;
			program_dm9801(phy_reg3);
			DM9000_DBG("found homerun NIC\n");
		} else {
			db->nic_type = LONGRUN_NIC;
33d042e8:	e3a03002 	mov	r3, #2	; 0x2
33d042ec:	e5c4301c 	strb	r3, [r4, #28]
static void
program_dm9802(void)
{
	__u16 reg25;
	if (!nfloor)
		nfloor = DM9802_NOISE_FLOOR;
33d042f0:	02833003 	addeq	r3, r3, #3	; 0x3
33d042f4:	05c63000 	strbeq	r3, [r6]
	reg25 = phy_read(25);
33d042f8:	e3a00019 	mov	r0, #25	; 0x19
33d042fc:	ebffff6d 	bl	33d040b8 <phy_read>
	reg25 = (reg25 & 0xff00) + nfloor;
33d04300:	e5d61000 	ldrb	r1, [r6]
33d04304:	e2000cff 	and	r0, r0, #65280	; 0xff00
33d04308:	e0811000 	add	r1, r1, r0
33d0430c:	e1a01801 	lsl	r1, r1, #16
	phy_write(25, reg25);
33d04310:	e1a01821 	lsr	r1, r1, #16
33d04314:	e3a00019 	mov	r0, #25	; 0x19
33d04318:	ebffff4e 	bl	33d04058 <phy_write>
		break;
	default:
		db->nic_type = FASTETHER_NIC;
		break;
	}
	DM9000_iow(DM9000_NCR, 0);
33d0431c:	e3a00000 	mov	r0, #0	; 0x0
33d04320:	e1a01000 	mov	r1, r0
33d04324:	ebffff45 	bl	33d04040 <DM9000_iow>

	/* NIC Type: FASTETHER, HOMERUN, LONGRUN */
	identify_nic();

	/* GPIO0 on pre-activate PHY */
	DM9000_iow(DM9000_GPR, 0x00);	/*REG_1F bit0 activate phyxcer */
33d04328:	e3a01000 	mov	r1, #0	; 0x0
33d0432c:	e3a0001f 	mov	r0, #31	; 0x1f
33d04330:	ebffff42 	bl	33d04040 <DM9000_iow>
*/
static void
set_PHY_mode(void)
{
	u16 phy_reg4 = 0x01e1, phy_reg0 = 0x1000;
	if (!(media_mode & DM9000_AUTO)) {
33d04334:	e59f3204 	ldr	r3, [pc, #516]	; 33d04540 <eth_init+0x414>
33d04338:	e5933000 	ldr	r3, [r3]
33d0433c:	e3130008 	tst	r3, #8	; 0x8
/* Set PHY operationg mode
*/
static void
set_PHY_mode(void)
{
	u16 phy_reg4 = 0x01e1, phy_reg0 = 0x1000;
33d04340:	e59f11fc 	ldr	r1, [pc, #508]	; 33d04544 <eth_init+0x418>
33d04344:	e3a04a01 	mov	r4, #4096	; 0x1000
	if (!(media_mode & DM9000_AUTO)) {
33d04348:	1a000018 	bne	33d043b0 <eth_init+0x284>
		switch (media_mode) {
33d0434c:	e3530005 	cmp	r3, #5	; 0x5
33d04350:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d04354:	ea000010 	b	33d0439c <eth_init+0x270>
33d04358:	33d04370 	.word	0x33d04370
33d0435c:	33d04388 	.word	0x33d04388
33d04360:	33d0439c 	.word	0x33d0439c
33d04364:	33d0439c 	.word	0x33d0439c
33d04368:	33d0437c 	.word	0x33d0437c
33d0436c:	33d04394 	.word	0x33d04394
		case DM9000_10MHD:
			phy_reg4 = 0x21;
33d04370:	e3a01021 	mov	r1, #33	; 0x21
			phy_reg0 = 0x0000;
33d04374:	e3a04000 	mov	r4, #0	; 0x0
			break;
33d04378:	ea000007 	b	33d0439c <eth_init+0x270>
		case DM9000_10MFD:
			phy_reg4 = 0x41;
33d0437c:	e3a01041 	mov	r1, #65	; 0x41
			phy_reg0 = 0x1100;
33d04380:	e3a04c11 	mov	r4, #4352	; 0x1100
			break;
33d04384:	ea000004 	b	33d0439c <eth_init+0x270>
		case DM9000_100MHD:
			phy_reg4 = 0x81;
33d04388:	e3a01081 	mov	r1, #129	; 0x81
			phy_reg0 = 0x2000;
33d0438c:	e3a04a02 	mov	r4, #8192	; 0x2000
			break;
33d04390:	ea000001 	b	33d0439c <eth_init+0x270>
		case DM9000_100MFD:
			phy_reg4 = 0x101;
33d04394:	e59f11ac 	ldr	r1, [pc, #428]	; 33d04548 <eth_init+0x41c>
			phy_reg0 = 0x3100;
33d04398:	e3a04c31 	mov	r4, #12544	; 0x3100
			break;
		}
		phy_write(4, phy_reg4);	/* Set PHY media mode */
33d0439c:	e3a00004 	mov	r0, #4	; 0x4
33d043a0:	ebffff2c 	bl	33d04058 <phy_write>
		phy_write(0, phy_reg0);	/*  Tmp */
33d043a4:	e1a01004 	mov	r1, r4
33d043a8:	e3a00000 	mov	r0, #0	; 0x0
33d043ac:	ebffff29 	bl	33d04058 <phy_write>
	}
	DM9000_iow(DM9000_GPCR, 0x01);	/* Let GPIO0 output */
33d043b0:	e3a0001e 	mov	r0, #30	; 0x1e
33d043b4:	e3a01001 	mov	r1, #1	; 0x1
33d043b8:	ebffff20 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_GPR, 0x00);	/* Enable PHY */
33d043bc:	e3a0001f 	mov	r0, #31	; 0x1f
33d043c0:	e3a01000 	mov	r1, #0	; 0x0
33d043c4:	ebffff1d 	bl	33d04040 <DM9000_iow>

	/* Set PHY */
	set_PHY_mode();

	/* Program operating register */
	DM9000_iow(DM9000_NCR, 0x0);	/* only intern phy supported by now */
33d043c8:	e3a00000 	mov	r0, #0	; 0x0
33d043cc:	e1a01000 	mov	r1, r0
33d043d0:	ebffff1a 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_TCR, 0);	/* TX Polling clear */
33d043d4:	e3a00002 	mov	r0, #2	; 0x2
33d043d8:	e3a01000 	mov	r1, #0	; 0x0
33d043dc:	ebffff17 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_BPTR, 0x3f);	/* Less 3Kb, 200us */
33d043e0:	e3a00008 	mov	r0, #8	; 0x8
33d043e4:	e3a0103f 	mov	r1, #63	; 0x3f
33d043e8:	ebffff14 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));	/* Flow Control : High/Low Water */
33d043ec:	e3a00009 	mov	r0, #9	; 0x9
33d043f0:	e3a01038 	mov	r1, #56	; 0x38
33d043f4:	ebffff11 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_FCR, 0x0);	/* SH FIXME: This looks strange! Flow Control */
33d043f8:	e3a0000a 	mov	r0, #10	; 0xa
33d043fc:	e3a01000 	mov	r1, #0	; 0x0
33d04400:	ebffff0e 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_SMCR, 0);	/* Special Mode */
33d04404:	e3a0002f 	mov	r0, #47	; 0x2f
33d04408:	e3a01000 	mov	r1, #0	; 0x0
33d0440c:	ebffff0b 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);	/* clear TX status */
33d04410:	e3a00001 	mov	r0, #1	; 0x1
33d04414:	e3a0102c 	mov	r1, #44	; 0x2c
33d04418:	ebffff08 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_ISR, 0x0f);	/* Clear interrupt status */
33d0441c:	e3a000fe 	mov	r0, #254	; 0xfe
33d04420:	e3a0100f 	mov	r1, #15	; 0xf
33d04424:	ebffff05 	bl	33d04040 <DM9000_iow>

	/* Set Node address */
//HJ_start				/*   www.embedsky.net   */
	char *tmp = getenv("ethaddr");
33d04428:	e59f011c 	ldr	r0, [pc, #284]	; 33d0454c <eth_init+0x420>
33d0442c:	eb004507 	bl	33d15850 <getenv>
33d04430:	e2896008 	add	r6, r9, #8	; 0x8
33d04434:	e1a05000 	mov	r5, r0
33d04438:	e3a04005 	mov	r4, #5	; 0x5
	char *end;

	for (i = 0; i < 6; i++)
	{
		bd->bi_enetaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
33d0443c:	e3550000 	cmp	r5, #0	; 0x0
33d04440:	e1a00005 	mov	r0, r5
33d04444:	e28d100c 	add	r1, sp, #12	; 0xc
33d04448:	e3a02010 	mov	r2, #16	; 0x10
33d0444c:	01a00005 	moveq	r0, r5
33d04450:	1b005841 	blne	33d1a55c <simple_strtoul>
		if(tmp)
33d04454:	e3550000 	cmp	r5, #0	; 0x0
	char *tmp = getenv("ethaddr");
	char *end;

	for (i = 0; i < 6; i++)
	{
		bd->bi_enetaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
33d04458:	e4c60001 	strb	r0, [r6], #1
		if(tmp)
33d0445c:	0a000004 	beq	33d04474 <eth_init+0x348>
			tmp = (*end) ? end+1 : end;
33d04460:	e59d200c 	ldr	r2, [sp, #12]
33d04464:	e5d23000 	ldrb	r3, [r2]
33d04468:	e3530000 	cmp	r3, #0	; 0x0
33d0446c:	01a05002 	moveq	r5, r2
33d04470:	12825001 	addne	r5, r2, #1	; 0x1
33d04474:	e2544001 	subs	r4, r4, #1	; 0x1
33d04478:	5affffef 	bpl	33d0443c <eth_init+0x310>
	}
//HJ_end				/*   www.embedsky.net   */

	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
33d0447c:	e5d9400d 	ldrb	r4, [r9, #13]
33d04480:	e5d9c00b 	ldrb	ip, [r9, #11]
33d04484:	e5d9e00c 	ldrb	lr, [r9, #12]
33d04488:	e5d91008 	ldrb	r1, [r9, #8]
33d0448c:	e5d92009 	ldrb	r2, [r9, #9]
33d04490:	e5d9300a 	ldrb	r3, [r9, #10]
33d04494:	e59f00b4 	ldr	r0, [pc, #180]	; 33d04550 <eth_init+0x424>
33d04498:	e58d4008 	str	r4, [sp, #8]
33d0449c:	e88d5000 	stm	sp, {ip, lr}
33d044a0:	eb004ac8 	bl	33d16fc8 <printf>
	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
	for (i = 0, oft = 0x10; i < 6; i++, oft++)
33d044a4:	e3a04000 	mov	r4, #0	; 0x0
33d044a8:	e3a05010 	mov	r5, #16	; 0x10
		DM9000_iow(oft, bd->bi_enetaddr[i]);
33d044ac:	e0843009 	add	r3, r4, r9
33d044b0:	e1a00005 	mov	r0, r5
33d044b4:	e5d31008 	ldrb	r1, [r3, #8]
//HJ_end				/*   www.embedsky.net   */

	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
	for (i = 0, oft = 0x10; i < 6; i++, oft++)
33d044b8:	e2844001 	add	r4, r4, #1	; 0x1
		DM9000_iow(oft, bd->bi_enetaddr[i]);
33d044bc:	ebfffedf 	bl	33d04040 <DM9000_iow>
//HJ_end				/*   www.embedsky.net   */

	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
	for (i = 0, oft = 0x10; i < 6; i++, oft++)
33d044c0:	e3540005 	cmp	r4, #5	; 0x5
33d044c4:	e2855001 	add	r5, r5, #1	; 0x1
33d044c8:	dafffff7 	ble	33d044ac <eth_init+0x380>
33d044cc:	e3a05016 	mov	r5, #22	; 0x16
33d044d0:	e3a04007 	mov	r4, #7	; 0x7
		DM9000_iow(oft, bd->bi_enetaddr[i]);
	for (i = 0, oft = 0x16; i < 8; i++, oft++)
		DM9000_iow(oft, 0xff);
33d044d4:	e1a00005 	mov	r0, r5
33d044d8:	e3a010ff 	mov	r1, #255	; 0xff
33d044dc:	ebfffed7 	bl	33d04040 <DM9000_iow>
33d044e0:	e2544001 	subs	r4, r4, #1	; 0x1
	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
	for (i = 0, oft = 0x10; i < 6; i++, oft++)
		DM9000_iow(oft, bd->bi_enetaddr[i]);
	for (i = 0, oft = 0x16; i < 8; i++, oft++)
33d044e4:	e2855001 	add	r5, r5, #1	; 0x1
33d044e8:	5afffff9 	bpl	33d044d4 <eth_init+0x3a8>
33d044ec:	e3a04005 	mov	r4, #5	; 0x5
33d044f0:	e2544001 	subs	r4, r4, #1	; 0x1
33d044f4:	5afffffd 	bpl	33d044f0 <eth_init+0x3c4>
	for (i = 0, oft = 0x10; i < 6; i++, oft++)
		DM9000_DBG("%02x:", DM9000_ior(oft));
	DM9000_DBG("\n");

	/* Activate DM9000 */
	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);	/* RX enable */
33d044f8:	e3a00005 	mov	r0, #5	; 0x5
33d044fc:	e3a01031 	mov	r1, #49	; 0x31
33d04500:	ebfffece 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_IMR, IMR_PAR);	/* Enable TX/RX interrupt mask */
33d04504:	e3a000ff 	mov	r0, #255	; 0xff
33d04508:	e3a01080 	mov	r1, #128	; 0x80
33d0450c:	ebfffecb 	bl	33d04040 <DM9000_iow>

	return 0;
}
33d04510:	e3a00000 	mov	r0, #0	; 0x0
33d04514:	e28dd010 	add	sp, sp, #16	; 0x10
33d04518:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0451c:	90000a46 	.word	0x90000a46
33d04520:	33d25bf0 	.word	0x33d25bf0
33d04524:	33d25c10 	.word	0x33d25c10
33d04528:	20000300 	.word	0x20000300
33d0452c:	0000fff0 	.word	0x0000fff0
33d04530:	33d3987c 	.word	0x33d3987c
33d04534:	00004404 	.word	0x00004404
33d04538:	33d3991c 	.word	0x33d3991c
33d0453c:	0000b901 	.word	0x0000b901
33d04540:	33d2ddb8 	.word	0x33d2ddb8
33d04544:	000001e1 	.word	0x000001e1
33d04548:	00000101 	.word	0x00000101
33d0454c:	33d254ec 	.word	0x33d254ec
33d04550:	33d25c38 	.word	0x33d25c38

33d04554 <eth_send>:
  Hardware start transmission.
  Send a packet to media from the upper layer.
*/
int
eth_send(volatile void *packet, int length)
{
33d04554:	e92d4010 	push	{r4, lr}
33d04558:	e1a04001 	mov	r4, r1
	char *data_ptr;
	u32 tmplen, i;
	int tmo;
	DM9000_DBG("eth_send: length: %d\n", length);
	for (i = 0; i < length; i++) {
33d0455c:	e3a01000 	mov	r1, #0	; 0x0
33d04560:	e1510004 	cmp	r1, r4
33d04564:	32811001 	addcc	r1, r1, #1	; 0x1
33d04568:	3afffffc 	bcc	33d04560 <eth_send+0xc>
	for (i = 0; i < length; i++)
		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (length + 1) / 2;
33d0456c:	e2843001 	add	r3, r4, #1	; 0x1
33d04570:	e0833fa3 	add	r3, r3, r3, lsr #31
33d04574:	e1a0c0c3 	asr	ip, r3, #1
		DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
	} DM9000_DBG("\n");

	/* Move data to DM9000 TX RAM */
	data_ptr = (char *) packet;
	DM9000_outb(DM9000_MWCMD, DM9000_IO);
33d04578:	e59f309c 	ldr	r3, [pc, #156]	; 33d0461c <eth_send+0xc8>
33d0457c:	e3e02007 	mvn	r2, #7	; 0x7
		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (length + 1) / 2;
	for (i = 0; i < tmplen; i++)
33d04580:	e3a01000 	mov	r1, #0	; 0x0
		DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
	} DM9000_DBG("\n");

	/* Move data to DM9000 TX RAM */
	data_ptr = (char *) packet;
	DM9000_outb(DM9000_MWCMD, DM9000_IO);
33d04584:	e5c32000 	strb	r2, [r3]
		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (length + 1) / 2;
	for (i = 0; i < tmplen; i++)
33d04588:	e151000c 	cmp	r1, ip
33d0458c:	2a000006 	bcs	33d045ac <eth_send+0x58>
		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
33d04590:	e1a03081 	lsl	r3, r1, #1
33d04594:	e19320b0 	ldrh	r2, [r3, r0]
		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (length + 1) / 2;
	for (i = 0; i < tmplen; i++)
33d04598:	e2811001 	add	r1, r1, #1	; 0x1
		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
33d0459c:	e59f307c 	ldr	r3, [pc, #124]	; 33d04620 <eth_send+0xcc>
		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (length + 1) / 2;
	for (i = 0; i < tmplen; i++)
33d045a0:	e151000c 	cmp	r1, ip
		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
33d045a4:	e1c320b0 	strh	r2, [r3]
33d045a8:	eafffff7 	b	33d0458c <eth_send+0x38>
		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);

#endif				/*  */

	/* Set TX length to DM9000 */
	DM9000_iow(DM9000_TXPLL, length & 0xff);
33d045ac:	e20410ff 	and	r1, r4, #255	; 0xff
33d045b0:	e3a000fc 	mov	r0, #252	; 0xfc
33d045b4:	ebfffea1 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_TXPLH, (length >> 8) & 0xff);
33d045b8:	e1a01424 	lsr	r1, r4, #8
33d045bc:	e20110ff 	and	r1, r1, #255	; 0xff
33d045c0:	e3a000fd 	mov	r0, #253	; 0xfd
33d045c4:	ebfffe9d 	bl	33d04040 <DM9000_iow>

	/* Issue TX polling command */
	DM9000_iow(DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
33d045c8:	e3a00002 	mov	r0, #2	; 0x2
33d045cc:	e3a01001 	mov	r1, #1	; 0x1
33d045d0:	ebfffe9a 	bl	33d04040 <DM9000_iow>

	/* wait for end of transmission */
	tmo = get_timer(0) + 5 * CFG_HZ;
33d045d4:	e3a00000 	mov	r0, #0	; 0x0
33d045d8:	ebfff202 	bl	33d00de8 <get_timer>
33d045dc:	e59f4040 	ldr	r4, [pc, #64]	; 33d04624 <eth_send+0xd0>
33d045e0:	e0804004 	add	r4, r0, r4
	while (DM9000_ior(DM9000_TCR) & TCR_TXREQ) {
33d045e4:	ea000005 	b	33d04600 <eth_send+0xac>
		if (get_timer(0) >= tmo) {
33d045e8:	ebfff1fe 	bl	33d00de8 <get_timer>
33d045ec:	e1500004 	cmp	r0, r4
33d045f0:	3a000002 	bcc	33d04600 <eth_send+0xac>
			printf("transmission timeout\n");
33d045f4:	e59f002c 	ldr	r0, [pc, #44]	; 33d04628 <eth_send+0xd4>
33d045f8:	eb004a72 	bl	33d16fc8 <printf>
			break;
33d045fc:	ea000004 	b	33d04614 <eth_send+0xc0>
33d04600:	e3a00002 	mov	r0, #2	; 0x2
33d04604:	ebfffe88 	bl	33d0402c <DM9000_ior>
33d04608:	e3100001 	tst	r0, #1	; 0x1
	DM9000_iow(DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */

	/* wait for end of transmission */
	tmo = get_timer(0) + 5 * CFG_HZ;
	while (DM9000_ior(DM9000_TCR) & TCR_TXREQ) {
		if (get_timer(0) >= tmo) {
33d0460c:	e3a00000 	mov	r0, #0	; 0x0
			printf("transmission timeout\n");
			break;
33d04610:	1afffff4 	bne	33d045e8 <eth_send+0x94>
		}
	}
	DM9000_DBG("transmit done\n\n");
	return 0;
}
33d04614:	e3a00000 	mov	r0, #0	; 0x0
33d04618:	e8bd8010 	pop	{r4, pc}
33d0461c:	20000300 	.word	0x20000300
33d04620:	20000304 	.word	0x20000304
33d04624:	00773594 	.word	0x00773594
33d04628:	33d25c5c 	.word	0x33d25c5c

33d0462c <eth_halt>:
  Stop the interface.
  The interface is stopped when it is brought.
*/
void
eth_halt(void)
{
33d0462c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	DM9000_DBG("eth_halt\n");

	/* RESET devie */
	phy_write(0, 0x8000);	/* PHY RESET */
33d04630:	e3a00000 	mov	r0, #0	; 0x0
33d04634:	e3a01902 	mov	r1, #32768	; 0x8000
33d04638:	ebfffe86 	bl	33d04058 <phy_write>
	DM9000_iow(DM9000_GPR, 0x01);	/* Power-Down PHY */
33d0463c:	e3a0001f 	mov	r0, #31	; 0x1f
33d04640:	e3a01001 	mov	r1, #1	; 0x1
33d04644:	ebfffe7d 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_IMR, 0x80);	/* Disable all interrupt */
33d04648:	e3a000ff 	mov	r0, #255	; 0xff
33d0464c:	e3a01080 	mov	r1, #128	; 0x80
33d04650:	ebfffe7a 	bl	33d04040 <DM9000_iow>
	DM9000_iow(DM9000_RCR, 0x00);	/* Disable RX */
33d04654:	e3a00005 	mov	r0, #5	; 0x5
33d04658:	e3a01000 	mov	r1, #0	; 0x0
33d0465c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d04660:	eafffe76 	b	33d04040 <DM9000_iow>

33d04664 <eth_rx>:
/*
  Received a packet and pass to upper layer
*/
int
eth_rx(void)
{
33d04664:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
33d04668:	e59f7108 	ldr	r7, [pc, #264]	; 33d04778 <eth_rx+0x114>
	u32 tmpdata;
#endif

	/* Check packet ready or not */
	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
33d0466c:	e59f4108 	ldr	r4, [pc, #264]	; 33d0477c <eth_rx+0x118>
#ifdef CONFIG_DM9000_USE_32BIT
	u32 tmpdata;
#endif

	/* Check packet ready or not */
	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
33d04670:	e3a000f0 	mov	r0, #240	; 0xf0
  Received a packet and pass to upper layer
*/
int
eth_rx(void)
{
	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
33d04674:	e5976000 	ldr	r6, [r7]
#ifdef CONFIG_DM9000_USE_32BIT
	u32 tmpdata;
#endif

	/* Check packet ready or not */
	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
33d04678:	ebfffe6b 	bl	33d0402c <DM9000_ior>
	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
33d0467c:	e5d43000 	ldrb	r3, [r4]
33d04680:	e20330ff 	and	r3, r3, #255	; 0xff
	if (rxbyte == 0)
33d04684:	e3530000 	cmp	r3, #0	; 0x0
*/
int
eth_rx(void)
{
	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
	u16 RxStatus, RxLen = 0;
33d04688:	e3a05000 	mov	r5, #0	; 0x0
#endif

	/* Check packet ready or not */
	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
	if (rxbyte == 0)
33d0468c:	0a000035 	beq	33d04768 <eth_rx+0x104>
		return 0;

	/* Status check: this byte must be 0 or 1 */
	if (rxbyte > 1) {
33d04690:	e3530001 	cmp	r3, #1	; 0x1
33d04694:	9a000005 	bls	33d046b0 <eth_rx+0x4c>
		DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
33d04698:	e1a01005 	mov	r1, r5
33d0469c:	e3a00005 	mov	r0, #5	; 0x5
33d046a0:	ebfffe66 	bl	33d04040 <DM9000_iow>
		DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
33d046a4:	e3a000fe 	mov	r0, #254	; 0xfe
33d046a8:	e3a01080 	mov	r1, #128	; 0x80
33d046ac:	ebfffe63 	bl	33d04040 <DM9000_iow>
		DM9000_DBG("rx status check: %d\n", rxbyte);
	}
	DM9000_DBG("receiving packet\n");

	/* A packet ready now  & Get status/length */
	DM9000_outb(DM9000_MRCMD, DM9000_IO);
33d046b0:	e59f30c8 	ldr	r3, [pc, #200]	; 33d04780 <eth_rx+0x11c>
33d046b4:	e3e0200d 	mvn	r2, #13	; 0xd
33d046b8:	e5c32000 	strb	r2, [r3]
	RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
	RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	RxStatus = DM9000_inw(DM9000_DATA);
33d046bc:	e1d420b0 	ldrh	r2, [r4]
	RxLen = DM9000_inw(DM9000_DATA);
33d046c0:	e1d430b0 	ldrh	r3, [r4]
33d046c4:	e1a05003 	mov	r5, r3
	for (i = 0; i < RxLen; i++)
		rdptr[i] = DM9000_inb(DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (RxLen + 1) / 2;
33d046c8:	e2833001 	add	r3, r3, #1	; 0x1
33d046cc:	e1a000c3 	asr	r0, r3, #1
	for (i = 0; i < tmplen; i++)
33d046d0:	e3a01000 	mov	r1, #0	; 0x0
33d046d4:	e1510000 	cmp	r1, r0
	RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
	RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	RxStatus = DM9000_inw(DM9000_DATA);
33d046d8:	e1a04002 	mov	r4, r2
		rdptr[i] = DM9000_inb(DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (RxLen + 1) / 2;
	for (i = 0; i < tmplen; i++)
33d046dc:	2a000006 	bcs	33d046fc <eth_rx+0x98>
		((u16 *) rdptr)[i] = DM9000_inw(DM9000_DATA);
33d046e0:	e59f3094 	ldr	r3, [pc, #148]	; 33d0477c <eth_rx+0x118>
33d046e4:	e1d320b0 	ldrh	r2, [r3]
33d046e8:	e1a03081 	lsl	r3, r1, #1
		rdptr[i] = DM9000_inb(DM9000_DATA);

#endif				/*  */
#ifdef CONFIG_DM9000_USE_16BIT
	tmplen = (RxLen + 1) / 2;
	for (i = 0; i < tmplen; i++)
33d046ec:	e2811001 	add	r1, r1, #1	; 0x1
33d046f0:	e1510000 	cmp	r1, r0
		((u16 *) rdptr)[i] = DM9000_inw(DM9000_DATA);
33d046f4:	e18320b6 	strh	r2, [r3, r6]
33d046f8:	eafffff7 	b	33d046dc <eth_rx+0x78>
	tmplen = (RxLen + 3) / 4;
	for (i = 0; i < tmplen; i++)
		((u32 *) rdptr)[i] = DM9000_inl(DM9000_DATA);

#endif				/*  */
	if ((RxStatus & 0xbf00) || (RxLen < 0x40)
33d046fc:	e3140cbf 	tst	r4, #48896	; 0xbf00
33d04700:	03a03000 	moveq	r3, #0	; 0x0
33d04704:	13a03001 	movne	r3, #1	; 0x1
33d04708:	e355003f 	cmp	r5, #63	; 0x3f
33d0470c:	93833001 	orrls	r3, r3, #1	; 0x1
33d04710:	e3530000 	cmp	r3, #0	; 0x0
33d04714:	1a000001 	bne	33d04720 <eth_rx+0xbc>
33d04718:	e3550c06 	cmp	r5, #1536	; 0x600
33d0471c:	9a00000e 	bls	33d0475c <eth_rx+0xf8>
	    || (RxLen > DM9000_PKT_MAX)) {
		if (RxStatus & 0x100) {
33d04720:	e3140c01 	tst	r4, #256	; 0x100
			printf("rx fifo error\n");
33d04724:	159f0058 	ldrne	r0, [pc, #88]	; 33d04784 <eth_rx+0x120>
33d04728:	1b004a26 	blne	33d16fc8 <printf>
		}
		if (RxStatus & 0x200) {
33d0472c:	e3140c02 	tst	r4, #512	; 0x200
			printf("rx crc error\n");
33d04730:	159f0050 	ldrne	r0, [pc, #80]	; 33d04788 <eth_rx+0x124>
33d04734:	1b004a23 	blne	33d16fc8 <printf>
		}
		if (RxStatus & 0x8000) {
33d04738:	e3140902 	tst	r4, #32768	; 0x8000
			printf("rx length error\n");
33d0473c:	159f0048 	ldrne	r0, [pc, #72]	; 33d0478c <eth_rx+0x128>
33d04740:	1b004a20 	blne	33d16fc8 <printf>
		}
		if (RxLen > DM9000_PKT_MAX) {
33d04744:	e3550c06 	cmp	r5, #1536	; 0x600
33d04748:	9a000008 	bls	33d04770 <eth_rx+0x10c>
			printf("rx length too big\n");
33d0474c:	e59f003c 	ldr	r0, [pc, #60]	; 33d04790 <eth_rx+0x12c>
33d04750:	eb004a1c 	bl	33d16fc8 <printf>
			dm9000_reset();
33d04754:	ebfffe6d 	bl	33d04110 <dm9000_reset>
33d04758:	ea000004 	b	33d04770 <eth_rx+0x10c>
		}
	} else {

		/* Pass to upper layer */
		DM9000_DBG("passing packet to upper layer\n");
		NetReceive(NetRxPackets[0], RxLen);
33d0475c:	e5970000 	ldr	r0, [r7]
33d04760:	e1a01005 	mov	r1, r5
33d04764:	ebfff749 	bl	33d02490 <NetReceive>
		return RxLen;
33d04768:	e1a00005 	mov	r0, r5
33d0476c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	}
	return 0;
33d04770:	e3a00000 	mov	r0, #0	; 0x0
}
33d04774:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d04778:	33d37320 	.word	0x33d37320
33d0477c:	20000304 	.word	0x20000304
33d04780:	20000300 	.word	0x20000300
33d04784:	33d25c74 	.word	0x33d25c74
33d04788:	33d25c84 	.word	0x33d25c84
33d0478c:	33d25c94 	.word	0x33d25c94
33d04790:	33d25ca8 	.word	0x33d25ca8

33d04794 <nand_init>:
		mtd->name = NULL;

}

void nand_init(void)
{
33d04794:	e92d4010 	push	{r4, lr}

extern void board_nand_init(struct nand_chip *nand);

static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
			   ulong base_addr)
{
33d04798:	e59f205c 	ldr	r2, [pc, #92]	; 33d047fc <nand_init+0x68>
33d0479c:	e59f305c 	ldr	r3, [pc, #92]	; 33d04800 <nand_init+0x6c>
33d047a0:	e5922000 	ldr	r2, [r2]
33d047a4:	e59f4058 	ldr	r4, [pc, #88]	; 33d04804 <nand_init+0x70>
	mtd->priv = nand;

	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
	board_nand_init(nand);
33d047a8:	e1a00003 	mov	r0, r3
static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
			   ulong base_addr)
{
	mtd->priv = nand;

	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
33d047ac:	e5832000 	str	r2, [r3]
extern void board_nand_init(struct nand_chip *nand);

static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
			   ulong base_addr)
{
	mtd->priv = nand;
33d047b0:	e584313c 	str	r3, [r4, #316]

	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
33d047b4:	e5832004 	str	r2, [r3, #4]
	board_nand_init(nand);
33d047b8:	eb006769 	bl	33d1e564 <board_nand_init>

	if (nand_scan(mtd, 1) == 0) {
33d047bc:	e3a01001 	mov	r1, #1	; 0x1
33d047c0:	e1a00004 	mov	r0, r4
33d047c4:	eb0008c5 	bl	33d06ae0 <nand_scan>
}

void nand_init(void)
{
	int i;
	unsigned int size = 0;
33d047c8:	e3a01000 	mov	r1, #0	; 0x0
	mtd->priv = nand;

	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
	board_nand_init(nand);

	if (nand_scan(mtd, 1) == 0) {
33d047cc:	e3500000 	cmp	r0, #0	; 0x0
		if (!mtd->name)
			mtd->name = (char *)default_nand_name;
	} else
		mtd->name = NULL;
33d047d0:	15841024 	strne	r1, [r4, #36]
	mtd->priv = nand;

	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
	board_nand_init(nand);

	if (nand_scan(mtd, 1) == 0) {
33d047d4:	1a000003 	bne	33d047e8 <nand_init+0x54>
		if (!mtd->name)
33d047d8:	e5943024 	ldr	r3, [r4, #36]
33d047dc:	e1530001 	cmp	r3, r1
			mtd->name = (char *)default_nand_name;
33d047e0:	059f3020 	ldreq	r3, [pc, #32]	; 33d04808 <nand_init+0x74>
33d047e4:	05843024 	streq	r3, [r4, #36]
	int i;
	unsigned int size = 0;
	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
		nand_init_chip(&nand_info[i], &nand_chip[i], base_address[i]);
		size += nand_info[i].size;
		if (nand_curr_device == -1)
33d047e8:	e59f201c 	ldr	r2, [pc, #28]	; 33d0480c <nand_init+0x78>
33d047ec:	e5923000 	ldr	r3, [r2]
33d047f0:	e3730001 	cmn	r3, #1	; 0x1
			nand_curr_device = i;
33d047f4:	05821000 	streq	r1, [r2]
33d047f8:	e8bd8010 	pop	{r4, pc}
33d047fc:	33d39a68 	.word	0x33d39a68
33d04800:	33d39a6c 	.word	0x33d39a6c
33d04804:	33d39920 	.word	0x33d39920
33d04808:	33d24820 	.word	0x33d24820
33d0480c:	33d2ddbc 	.word	0x33d2ddbc

33d04810 <nand_release_device>:
	wake_up (&this->wq);
	spin_unlock (&this->chip_lock);
}
#else
static void nand_release_device (struct mtd_info *mtd)
{
33d04810:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct nand_chip *this = mtd->priv;
	this->select_chip(mtd, -1);	/* De-select the NAND device */
33d04814:	e3e01000 	mvn	r1, #0	; 0x0
	spin_unlock (&this->chip_lock);
}
#else
static void nand_release_device (struct mtd_info *mtd)
{
	struct nand_chip *this = mtd->priv;
33d04818:	e590313c 	ldr	r3, [r0, #316]
	this->select_chip(mtd, -1);	/* De-select the NAND device */
33d0481c:	e1a0e00f 	mov	lr, pc
33d04820:	e593f024 	ldr	pc, [r3, #36]
33d04824:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d04828 <nand_read_byte>:
 *
 * Default read function for 8bit buswith
 */
static u_char nand_read_byte(struct mtd_info *mtd)
{
	struct nand_chip *this = mtd->priv;
33d04828:	e590313c 	ldr	r3, [r0, #316]
	return readb(this->IO_ADDR_R);
33d0482c:	e5933000 	ldr	r3, [r3]
33d04830:	e5d30000 	ldrb	r0, [r3]
}
33d04834:	e1a0f00e 	mov	pc, lr

33d04838 <nand_write_byte>:
 *
 * Default write function for 8it buswith
 */
static void nand_write_byte(struct mtd_info *mtd, u_char byte)
{
	struct nand_chip *this = mtd->priv;
33d04838:	e590313c 	ldr	r3, [r0, #316]
	writeb(byte, this->IO_ADDR_W);
33d0483c:	e5933004 	ldr	r3, [r3, #4]
 * @byte:	pointer to data byte to write
 *
 * Default write function for 8it buswith
 */
static void nand_write_byte(struct mtd_info *mtd, u_char byte)
{
33d04840:	e20110ff 	and	r1, r1, #255	; 0xff
	struct nand_chip *this = mtd->priv;
	writeb(byte, this->IO_ADDR_W);
33d04844:	e5c31000 	strb	r1, [r3]
33d04848:	e1a0f00e 	mov	pc, lr

33d0484c <nand_read_byte16>:
 * Default read function for 16bit buswith with
 * endianess conversion
 */
static u_char nand_read_byte16(struct mtd_info *mtd)
{
	struct nand_chip *this = mtd->priv;
33d0484c:	e590313c 	ldr	r3, [r0, #316]
	return (u_char) cpu_to_le16(readw(this->IO_ADDR_R));
33d04850:	e5933000 	ldr	r3, [r3]
33d04854:	e1d300b0 	ldrh	r0, [r3]
}
33d04858:	e20000ff 	and	r0, r0, #255	; 0xff
33d0485c:	e1a0f00e 	mov	pc, lr

33d04860 <nand_write_byte16>:
 * Default write function for 16bit buswith with
 * endianess conversion
 */
static void nand_write_byte16(struct mtd_info *mtd, u_char byte)
{
	struct nand_chip *this = mtd->priv;
33d04860:	e590313c 	ldr	r3, [r0, #316]
	writew(le16_to_cpu((u16) byte), this->IO_ADDR_W);
33d04864:	e5933004 	ldr	r3, [r3, #4]
 *
 * Default write function for 16bit buswith with
 * endianess conversion
 */
static void nand_write_byte16(struct mtd_info *mtd, u_char byte)
{
33d04868:	e20110ff 	and	r1, r1, #255	; 0xff
	struct nand_chip *this = mtd->priv;
	writew(le16_to_cpu((u16) byte), this->IO_ADDR_W);
33d0486c:	e1c310b0 	strh	r1, [r3]
33d04870:	e1a0f00e 	mov	pc, lr

33d04874 <nand_read_word>:
 * Default read function for 16bit buswith without
 * endianess conversion
 */
static u16 nand_read_word(struct mtd_info *mtd)
{
	struct nand_chip *this = mtd->priv;
33d04874:	e590313c 	ldr	r3, [r0, #316]
	return readw(this->IO_ADDR_R);
33d04878:	e5933000 	ldr	r3, [r3]
33d0487c:	e1d300b0 	ldrh	r0, [r3]
}
33d04880:	e1a0f00e 	mov	pc, lr

33d04884 <nand_write_word>:
 * Default write function for 16bit buswith without
 * endianess conversion
 */
static void nand_write_word(struct mtd_info *mtd, u16 word)
{
	struct nand_chip *this = mtd->priv;
33d04884:	e590313c 	ldr	r3, [r0, #316]
 *
 * Default write function for 16bit buswith without
 * endianess conversion
 */
static void nand_write_word(struct mtd_info *mtd, u16 word)
{
33d04888:	e1a01801 	lsl	r1, r1, #16
	struct nand_chip *this = mtd->priv;
	writew(word, this->IO_ADDR_W);
33d0488c:	e5933004 	ldr	r3, [r3, #4]
 *
 * Default write function for 16bit buswith without
 * endianess conversion
 */
static void nand_write_word(struct mtd_info *mtd, u16 word)
{
33d04890:	e1a01821 	lsr	r1, r1, #16
	struct nand_chip *this = mtd->priv;
	writew(word, this->IO_ADDR_W);
33d04894:	e1c310b0 	strh	r1, [r3]
33d04898:	e1a0f00e 	mov	pc, lr

33d0489c <nand_select_chip>:
 * @chip:	chipnumber to select, -1 for deselect
 *
 * Default select function for 1 chip devices.
 */
static void nand_select_chip(struct mtd_info *mtd, int chip)
{
33d0489c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d048a0:	e1a03001 	mov	r3, r1
	struct nand_chip *this = mtd->priv;
	switch(chip) {
33d048a4:	e3730001 	cmn	r3, #1	; 0x1
	case -1:
		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
33d048a8:	e3a01002 	mov	r1, #2	; 0x2
 *
 * Default select function for 1 chip devices.
 */
static void nand_select_chip(struct mtd_info *mtd, int chip)
{
	struct nand_chip *this = mtd->priv;
33d048ac:	e590213c 	ldr	r2, [r0, #316]
	switch(chip) {
33d048b0:	0a000002 	beq	33d048c0 <nand_select_chip+0x24>
33d048b4:	e3530000 	cmp	r3, #0	; 0x0
	case -1:
		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
		break;
	case 0:
		this->hwcontrol(mtd, NAND_CTL_SETNCE);
33d048b8:	e2411001 	sub	r1, r1, #1	; 0x1
 * Default select function for 1 chip devices.
 */
static void nand_select_chip(struct mtd_info *mtd, int chip)
{
	struct nand_chip *this = mtd->priv;
	switch(chip) {
33d048bc:	1a000002 	bne	33d048cc <nand_select_chip+0x30>
	case -1:
		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
		break;
	case 0:
		this->hwcontrol(mtd, NAND_CTL_SETNCE);
33d048c0:	e1a0e00f 	mov	lr, pc
33d048c4:	e592f030 	ldr	pc, [r2, #48]
		break;
33d048c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

	default:
		BUG();
33d048cc:	e59f0018 	ldr	r0, [pc, #24]	; 33d048ec <nand_select_chip+0x50>
33d048d0:	e59f1018 	ldr	r1, [pc, #24]	; 33d048f0 <nand_select_chip+0x54>
33d048d4:	e59f2018 	ldr	r2, [pc, #24]	; 33d048f4 <nand_select_chip+0x58>
33d048d8:	e59f3018 	ldr	r3, [pc, #24]	; 33d048f8 <nand_select_chip+0x5c>
33d048dc:	eb0049b9 	bl	33d16fc8 <printf>
33d048e0:	e59f0014 	ldr	r0, [pc, #20]	; 33d048fc <nand_select_chip+0x60>
	}
}
33d048e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	case 0:
		this->hwcontrol(mtd, NAND_CTL_SETNCE);
		break;

	default:
		BUG();
33d048e8:	ea005909 	b	33d1ad14 <panic>
33d048ec:	33d25cbc 	.word	0x33d25cbc
33d048f0:	33d25cdc 	.word	0x33d25cdc
33d048f4:	00000135 	.word	0x00000135
33d048f8:	33d24828 	.word	0x33d24828
33d048fc:	33d25ce8 	.word	0x33d25ce8

33d04900 <nand_write_buf>:
 * @len:	number of bytes to write
 *
 * Default write function for 8bit buswith
 */
static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
33d04900:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04904:	e3a0c000 	mov	ip, #0	; 0x0
33d04908:	e15c0002 	cmp	ip, r2
 * @len:	number of bytes to write
 *
 * Default write function for 8bit buswith
 */
static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
33d0490c:	e1a0e002 	mov	lr, r2
	int i;
	struct nand_chip *this = mtd->priv;
33d04910:	e590013c 	ldr	r0, [r0, #316]

	for (i=0; i<len; i++)
33d04914:	a49df004 	popge	{pc}		; (ldrge pc, [sp], #4)
		writeb(buf[i], this->IO_ADDR_W);
33d04918:	e7d1200c 	ldrb	r2, [r1, ip]
33d0491c:	e5903004 	ldr	r3, [r0, #4]
static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04920:	e28cc001 	add	ip, ip, #1	; 0x1
33d04924:	e15c000e 	cmp	ip, lr
		writeb(buf[i], this->IO_ADDR_W);
33d04928:	e5c32000 	strb	r2, [r3]
static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d0492c:	bafffff9 	blt	33d04918 <nand_write_buf+0x18>
33d04930:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d04934 <nand_read_buf>:
static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04934:	e3a0c000 	mov	ip, #0	; 0x0
33d04938:	e15c0002 	cmp	ip, r2
 * Default read function for 8bit buswith
 */
static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
33d0493c:	e590013c 	ldr	r0, [r0, #316]

	for (i=0; i<len; i++)
33d04940:	a1a0f00e 	movge	pc, lr
		buf[i] = readb(this->IO_ADDR_R);
33d04944:	e5903000 	ldr	r3, [r0]
33d04948:	e5d33000 	ldrb	r3, [r3]
33d0494c:	e7c1300c 	strb	r3, [r1, ip]
static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04950:	e28cc001 	add	ip, ip, #1	; 0x1
33d04954:	e15c0002 	cmp	ip, r2
33d04958:	bafffff9 	blt	33d04944 <nand_read_buf+0x10>
33d0495c:	e1a0f00e 	mov	pc, lr

33d04960 <nand_verify_buf>:
 * @len:	number of bytes to compare
 *
 * Default verify function for 8bit buswith
 */
static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
33d04960:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04964:	e3a0c000 	mov	ip, #0	; 0x0
 * Default verify function for 8bit buswith
 */
static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
33d04968:	e590013c 	ldr	r0, [r0, #316]
 * @len:	number of bytes to compare
 *
 * Default verify function for 8bit buswith
 */
static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
33d0496c:	e1a0e002 	mov	lr, r2
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04970:	e15c0002 	cmp	ip, r2
33d04974:	aa000009 	bge	33d049a0 <nand_verify_buf+0x40>
		if (buf[i] != readb(this->IO_ADDR_R))
33d04978:	e5903000 	ldr	r3, [r0]
33d0497c:	e5d32000 	ldrb	r2, [r3]
33d04980:	e7d1300c 	ldrb	r3, [r1, ip]
33d04984:	e1530002 	cmp	r3, r2
static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04988:	e28cc001 	add	ip, ip, #1	; 0x1
		if (buf[i] != readb(this->IO_ADDR_R))
33d0498c:	0a000001 	beq	33d04998 <nand_verify_buf+0x38>
			return -EFAULT;
33d04990:	e3e0000d 	mvn	r0, #13	; 0xd
33d04994:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;

	for (i=0; i<len; i++)
33d04998:	e15c000e 	cmp	ip, lr
33d0499c:	eafffff4 	b	33d04974 <nand_verify_buf+0x14>
		if (buf[i] != readb(this->IO_ADDR_R))
			return -EFAULT;

	return 0;
33d049a0:	e3a00000 	mov	r0, #0	; 0x0
}
33d049a4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d049a8 <nand_write_buf16>:
 * @len:	number of bytes to write
 *
 * Default write function for 16bit buswith
 */
static void nand_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
33d049a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049ac:	e3a0c000 	mov	ip, #0	; 0x0
static void nand_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;
33d049b0:	e1a0e0c2 	asr	lr, r2, #1

	for (i=0; i<len; i++)
33d049b4:	e15c000e 	cmp	ip, lr
 * Default write function for 16bit buswith
 */
static void nand_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
33d049b8:	e590013c 	ldr	r0, [r0, #316]
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049bc:	a49df004 	popge	{pc}		; (ldrge pc, [sp], #4)
		writew(p[i], this->IO_ADDR_W);
33d049c0:	e1a0308c 	lsl	r3, ip, #1
33d049c4:	e19320b1 	ldrh	r2, [r3, r1]
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049c8:	e28cc001 	add	ip, ip, #1	; 0x1
		writew(p[i], this->IO_ADDR_W);
33d049cc:	e5903004 	ldr	r3, [r0, #4]
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049d0:	e15c000e 	cmp	ip, lr
		writew(p[i], this->IO_ADDR_W);
33d049d4:	e1c320b0 	strh	r2, [r3]
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049d8:	bafffff8 	blt	33d049c0 <nand_write_buf16+0x18>
33d049dc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d049e0 <nand_read_buf16>:
 * @len:	number of bytes to read
 *
 * Default read function for 16bit buswith
 */
static void nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
{
33d049e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049e4:	e3a0c000 	mov	ip, #0	; 0x0
static void nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;
33d049e8:	e1a0e0c2 	asr	lr, r2, #1

	for (i=0; i<len; i++)
33d049ec:	e15c000e 	cmp	ip, lr
 * Default read function for 16bit buswith
 */
static void nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
33d049f0:	e590013c 	ldr	r0, [r0, #316]
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d049f4:	a49df004 	popge	{pc}		; (ldrge pc, [sp], #4)
		p[i] = readw(this->IO_ADDR_R);
33d049f8:	e5903000 	ldr	r3, [r0]
33d049fc:	e1d320b0 	ldrh	r2, [r3]
33d04a00:	e1a0308c 	lsl	r3, ip, #1
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a04:	e28cc001 	add	ip, ip, #1	; 0x1
33d04a08:	e15c000e 	cmp	ip, lr
		p[i] = readw(this->IO_ADDR_R);
33d04a0c:	e18320b1 	strh	r2, [r3, r1]
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a10:	bafffff8 	blt	33d049f8 <nand_read_buf16+0x18>
33d04a14:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d04a18 <nand_verify_buf16>:
 * @len:	number of bytes to compare
 *
 * Default verify function for 16bit buswith
 */
static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
33d04a18:	e92d4010 	push	{r4, lr}
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a1c:	e3a0c000 	mov	ip, #0	; 0x0
static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;
33d04a20:	e1a0e0c2 	asr	lr, r2, #1
 * Default verify function for 16bit buswith
 */
static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
	int i;
	struct nand_chip *this = mtd->priv;
33d04a24:	e590013c 	ldr	r0, [r0, #316]
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a28:	e15c000e 	cmp	ip, lr
 * @len:	number of bytes to compare
 *
 * Default verify function for 16bit buswith
 */
static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
{
33d04a2c:	e1a04001 	mov	r4, r1
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a30:	aa00000a 	bge	33d04a60 <nand_verify_buf16+0x48>
		if (p[i] != readw(this->IO_ADDR_R))
33d04a34:	e5903000 	ldr	r3, [r0]
33d04a38:	e1a0208c 	lsl	r2, ip, #1
33d04a3c:	e1d310b0 	ldrh	r1, [r3]
33d04a40:	e19230b4 	ldrh	r3, [r2, r4]
33d04a44:	e1530001 	cmp	r3, r1
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a48:	e28cc001 	add	ip, ip, #1	; 0x1
		if (p[i] != readw(this->IO_ADDR_R))
33d04a4c:	0a000001 	beq	33d04a58 <nand_verify_buf16+0x40>
			return -EFAULT;
33d04a50:	e3e0000d 	mvn	r0, #13	; 0xd
33d04a54:	e8bd8010 	pop	{r4, pc}
	int i;
	struct nand_chip *this = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i=0; i<len; i++)
33d04a58:	e15c000e 	cmp	ip, lr
33d04a5c:	eafffff3 	b	33d04a30 <nand_verify_buf16+0x18>
		if (p[i] != readw(this->IO_ADDR_R))
			return -EFAULT;

	return 0;
33d04a60:	e3a00000 	mov	r0, #0	; 0x0
}
33d04a64:	e8bd8010 	pop	{r4, pc}

33d04a68 <nand_get_device>:
	schedule ();
	remove_wait_queue (&active->wq, &wait);
	goto retry;
}
#else
static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state) {}
33d04a68:	e1a0f00e 	mov	pc, lr

33d04a6c <nand_block_bad>:
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
33d04a6c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int page, chipnr, res = 0;
	struct nand_chip *this = mtd->priv;
33d04a70:	e590613c 	ldr	r6, [r0, #316]
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
33d04a74:	e1a05002 	mov	r5, r2
33d04a78:	e1a04001 	mov	r4, r1
33d04a7c:	e1a07000 	mov	r7, r0
	int page, chipnr, res = 0;
	struct nand_chip *this = mtd->priv;
	u16 bad;

	page = (int)(ofs >> this->page_shift);
33d04a80:	e1a00001 	mov	r0, r1
33d04a84:	e1a01002 	mov	r1, r2
33d04a88:	e5962068 	ldr	r2, [r6, #104]
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
33d04a8c:	e1a09003 	mov	r9, r3
	int page, chipnr, res = 0;
	struct nand_chip *this = mtd->priv;
	u16 bad;

	page = (int)(ofs >> this->page_shift);
33d04a90:	eb0066eb 	bl	33d1e644 <__ashrdi3>
	chipnr = (int)(ofs >> this->chip_shift);
33d04a94:	e5962074 	ldr	r2, [r6, #116]
{
	int page, chipnr, res = 0;
	struct nand_chip *this = mtd->priv;
	u16 bad;

	page = (int)(ofs >> this->page_shift);
33d04a98:	e1a0a000 	mov	sl, r0
	chipnr = (int)(ofs >> this->chip_shift);
33d04a9c:	e1a01005 	mov	r1, r5
33d04aa0:	e1a00004 	mov	r0, r4
33d04aa4:	eb0066e6 	bl	33d1e644 <__ashrdi3>

	if (getchip) {
33d04aa8:	e3590000 	cmp	r9, #0	; 0x0
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
	int page, chipnr, res = 0;
33d04aac:	e3a04000 	mov	r4, #0	; 0x0

		/* Grab the lock and see if the device is available */
		nand_get_device (this, mtd, FL_READING);

		/* Select the NAND device */
		this->select_chip(mtd, chipnr);
33d04ab0:	11a01000 	movne	r1, r0
33d04ab4:	11a00007 	movne	r0, r7
33d04ab8:	11a0e00f 	movne	lr, pc
33d04abc:	1596f024 	ldrne	pc, [r6, #36]
	} 

	if (this->options & NAND_BUSWIDTH_16) {
33d04ac0:	e5963088 	ldr	r3, [r6, #136]
33d04ac4:	e3130002 	tst	r3, #2	; 0x2
33d04ac8:	e596208c 	ldr	r2, [r6, #140]
33d04acc:	e5963098 	ldr	r3, [r6, #152]
33d04ad0:	e596c038 	ldr	ip, [r6, #56]
33d04ad4:	0a000011 	beq	33d04b20 <nand_block_bad+0xb4>
		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
33d04ad8:	e00a3003 	and	r3, sl, r3
33d04adc:	e20220fe 	and	r2, r2, #254	; 0xfe
33d04ae0:	e1a00007 	mov	r0, r7
33d04ae4:	e3a01050 	mov	r1, #80	; 0x50
33d04ae8:	e1a0e00f 	mov	lr, pc
33d04aec:	e1a0f00c 	mov	pc, ip
		bad = cpu_to_le16(this->read_word(mtd));
33d04af0:	e1a00007 	mov	r0, r7
33d04af4:	e1a0e00f 	mov	lr, pc
33d04af8:	e596f010 	ldr	pc, [r6, #16]
		if (this->badblockpos & 0x1)
33d04afc:	e596308c 	ldr	r3, [r6, #140]
		this->select_chip(mtd, chipnr);
	} 

	if (this->options & NAND_BUSWIDTH_16) {
		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
		bad = cpu_to_le16(this->read_word(mtd));
33d04b00:	e1a00800 	lsl	r0, r0, #16
		if (this->badblockpos & 0x1)
33d04b04:	e3130001 	tst	r3, #1	; 0x1
		this->select_chip(mtd, chipnr);
	} 

	if (this->options & NAND_BUSWIDTH_16) {
		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
		bad = cpu_to_le16(this->read_word(mtd));
33d04b08:	e1a03820 	lsr	r3, r0, #16
		if (this->badblockpos & 0x1)
			bad >>= 1;
33d04b0c:	11a038a0 	lsrne	r3, r0, #17
		if ((bad & 0xFF) != 0xff)
33d04b10:	e20330ff 	and	r3, r3, #255	; 0xff
33d04b14:	e35300ff 	cmp	r3, #255	; 0xff
			res = 1;
33d04b18:	13a04001 	movne	r4, #1	; 0x1
33d04b1c:	ea000015 	b	33d04b78 <nand_block_bad+0x10c>
        if (ofs < RESERVED_BOOT_BLOCKS * mtd->erasesize)
            res = 0;
        else
#endif        
        {
    		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
33d04b20:	e00a3003 	and	r3, sl, r3
33d04b24:	e1a00007 	mov	r0, r7
33d04b28:	e3a01050 	mov	r1, #80	; 0x50
33d04b2c:	e1a0e00f 	mov	lr, pc
33d04b30:	e1a0f00c 	mov	pc, ip
    		if (this->read_byte(mtd) != 0xff)
33d04b34:	e1a00007 	mov	r0, r7
33d04b38:	e1a0e00f 	mov	lr, pc
33d04b3c:	e596f008 	ldr	pc, [r6, #8]
    			res = 1;
        }

        // Apply delay or wait for ready/busy pin
        // add by www.embedsky.net, if not, the erase will be failed
		if (!this->dev_ready)
33d04b40:	e5963034 	ldr	r3, [r6, #52]
            res = 0;
        else
#endif        
        {
    		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
    		if (this->read_byte(mtd) != 0xff)
33d04b44:	e20000ff 	and	r0, r0, #255	; 0xff
    			res = 1;
33d04b48:	e25040ff 	subs	r4, r0, #255	; 0xff
33d04b4c:	13a04001 	movne	r4, #1	; 0x1
        }

        // Apply delay or wait for ready/busy pin
        // add by www.embedsky.net, if not, the erase will be failed
		if (!this->dev_ready)
33d04b50:	e3530000 	cmp	r3, #0	; 0x0
33d04b54:	1a000002 	bne	33d04b64 <nand_block_bad+0xf8>
			udelay (this->chip_delay);
33d04b58:	e5960064 	ldr	r0, [r6, #100]
33d04b5c:	ebfff0aa 	bl	33d00e0c <udelay>
33d04b60:	ea000004 	b	33d04b78 <nand_block_bad+0x10c>
		else
			while (!this->dev_ready(mtd));
33d04b64:	e1a00007 	mov	r0, r7
33d04b68:	e1a0e00f 	mov	lr, pc
33d04b6c:	e596f034 	ldr	pc, [r6, #52]
33d04b70:	e3500000 	cmp	r0, #0	; 0x0
33d04b74:	0afffffa 	beq	33d04b64 <nand_block_bad+0xf8>

	}

	if (getchip) {
33d04b78:	e3590000 	cmp	r9, #0	; 0x0
		/* Deselect and wake up anyone waiting on the device */
		nand_release_device(mtd);
33d04b7c:	11a00007 	movne	r0, r7
33d04b80:	1bffff22 	blne	33d04810 <nand_release_device>
	}

	return res;
}
33d04b84:	e1a00004 	mov	r0, r4
33d04b88:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

33d04b8c <nand_check_wp>:
 * Check, if the device is write protected
 *
 * The function expects, that the device is already selected
 */
static int nand_check_wp (struct mtd_info *mtd)
{
33d04b8c:	e92d4030 	push	{r4, r5, lr}
	struct nand_chip *this = mtd->priv;
	/* Check the WP bit */
	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
33d04b90:	e3e02000 	mvn	r2, #0	; 0x0
 *
 * The function expects, that the device is already selected
 */
static int nand_check_wp (struct mtd_info *mtd)
{
	struct nand_chip *this = mtd->priv;
33d04b94:	e590513c 	ldr	r5, [r0, #316]
 * Check, if the device is write protected
 *
 * The function expects, that the device is already selected
 */
static int nand_check_wp (struct mtd_info *mtd)
{
33d04b98:	e1a04000 	mov	r4, r0
	struct nand_chip *this = mtd->priv;
	/* Check the WP bit */
	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
33d04b9c:	e3a01070 	mov	r1, #112	; 0x70
33d04ba0:	e1a03002 	mov	r3, r2
33d04ba4:	e1a0e00f 	mov	lr, pc
33d04ba8:	e595f038 	ldr	pc, [r5, #56]
	return (this->read_byte(mtd) & 0x80) ? 0 : 1;
33d04bac:	e1a00004 	mov	r0, r4
33d04bb0:	e1a0e00f 	mov	lr, pc
33d04bb4:	e595f008 	ldr	pc, [r5, #8]
33d04bb8:	e1a00c00 	lsl	r0, r0, #24
}
33d04bbc:	e1e00000 	mvn	r0, r0
33d04bc0:	e1a00fa0 	lsr	r0, r0, #31
33d04bc4:	e8bd8030 	pop	{r4, r5, pc}

33d04bc8 <nand_write_oob>:
 * @buf:	the data to write
 *
 * NAND write out-of-band
 */
static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
{
33d04bc8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int column, page, status, ret = -EIO, chipnr;
	struct nand_chip *this = mtd->priv;
33d04bcc:	e590613c 	ldr	r6, [r0, #316]
 * @buf:	the data to write
 *
 * NAND write out-of-band
 */
static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
{
33d04bd0:	e24dd004 	sub	sp, sp, #4	; 0x4
33d04bd4:	e1a05002 	mov	r5, r2
33d04bd8:	e1a04001 	mov	r4, r1
33d04bdc:	e1a07000 	mov	r7, r0
	struct nand_chip *this = mtd->priv;

	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Shift to get page */
	page = (int) (to >> this->page_shift);
33d04be0:	e1a00001 	mov	r0, r1
33d04be4:	e1a01002 	mov	r1, r2
33d04be8:	e5962068 	ldr	r2, [r6, #104]
 * @buf:	the data to write
 *
 * NAND write out-of-band
 */
static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
{
33d04bec:	e1a09003 	mov	r9, r3
	struct nand_chip *this = mtd->priv;

	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Shift to get page */
	page = (int) (to >> this->page_shift);
33d04bf0:	eb006693 	bl	33d1e644 <__ashrdi3>
	chipnr = (int) (to >> this->chip_shift);
33d04bf4:	e5962074 	ldr	r2, [r6, #116]
	struct nand_chip *this = mtd->priv;

	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Shift to get page */
	page = (int) (to >> this->page_shift);
33d04bf8:	e1a0a000 	mov	sl, r0
	chipnr = (int) (to >> this->chip_shift);
33d04bfc:	e1a01005 	mov	r1, r5
33d04c00:	e1a00004 	mov	r0, r4
33d04c04:	eb00668e 	bl	33d1e644 <__ashrdi3>

	/* Mask to get column */
	column = to & (mtd->oobsize - 1);

	/* Initialize return length value */
	*retlen = 0;
33d04c08:	e59dc024 	ldr	ip, [sp, #36]
	/* Shift to get page */
	page = (int) (to >> this->page_shift);
	chipnr = (int) (to >> this->chip_shift);

	/* Mask to get column */
	column = to & (mtd->oobsize - 1);
33d04c0c:	e5973014 	ldr	r3, [r7, #20]

	/* Initialize return length value */
	*retlen = 0;
33d04c10:	e3a02000 	mov	r2, #0	; 0x0
33d04c14:	e58c2000 	str	r2, [ip]
	/* Shift to get page */
	page = (int) (to >> this->page_shift);
	chipnr = (int) (to >> this->chip_shift);

	/* Mask to get column */
	column = to & (mtd->oobsize - 1);
33d04c18:	e2433001 	sub	r3, r3, #1	; 0x1
33d04c1c:	e0035004 	and	r5, r3, r4

	/* Initialize return length value */
	*retlen = 0;

	/* Do not allow write past end of page */
	if ((column + len) > mtd->oobsize) {
33d04c20:	e5973014 	ldr	r3, [r7, #20]
33d04c24:	e0852009 	add	r2, r5, r9
33d04c28:	e1520003 	cmp	r2, r3
33d04c2c:	e58d2000 	str	r2, [sp]
 *
 * NAND write out-of-band
 */
static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
{
	int column, page, status, ret = -EIO, chipnr;
33d04c30:	e3e0b004 	mvn	fp, #4	; 0x4
	*retlen = 0;

	/* Do not allow write past end of page */
	if ((column + len) > mtd->oobsize) {
		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: Attempt to write past end of page\n");
		return -EINVAL;
33d04c34:	83e00015 	mvnhi	r0, #21	; 0x15

	/* Initialize return length value */
	*retlen = 0;

	/* Do not allow write past end of page */
	if ((column + len) > mtd->oobsize) {
33d04c38:	8a00004a 	bhi	33d04d68 <nand_write_oob+0x1a0>

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_WRITING);

	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d04c3c:	e1a01000 	mov	r1, r0
	/* Reset the chip. Some chips (like the Toshiba TC5832DC found
	   in one of my DiskOnChip 2000 test units) will clear the whole
	   data page too if we don't do this. I have no clue why, but
	   I seem to have 'fixed' it in the doc2000 driver in
	   August 1999.  dwmw2. */
	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
33d04c40:	e3e04000 	mvn	r4, #0	; 0x0

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_WRITING);

	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d04c44:	e1a00007 	mov	r0, r7
33d04c48:	e1a0e00f 	mov	lr, pc
33d04c4c:	e596f024 	ldr	pc, [r6, #36]
	/* Reset the chip. Some chips (like the Toshiba TC5832DC found
	   in one of my DiskOnChip 2000 test units) will clear the whole
	   data page too if we don't do this. I have no clue why, but
	   I seem to have 'fixed' it in the doc2000 driver in
	   August 1999.  dwmw2. */
	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
33d04c50:	e1a00007 	mov	r0, r7
33d04c54:	e3a010ff 	mov	r1, #255	; 0xff
33d04c58:	e1a02004 	mov	r2, r4
33d04c5c:	e1a03004 	mov	r3, r4
33d04c60:	e1a0e00f 	mov	lr, pc
33d04c64:	e596f038 	ldr	pc, [r6, #56]

	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
33d04c68:	e1a00007 	mov	r0, r7
33d04c6c:	ebffffc6 	bl	33d04b8c <nand_check_wp>
33d04c70:	e3500000 	cmp	r0, #0	; 0x0
33d04c74:	1a000038 	bne	33d04d5c <nand_write_oob+0x194>
		goto out;

	/* Invalidate the page cache, if we write to the cached page */
	if (page == this->pagebuf)
33d04c78:	e596309c 	ldr	r3, [r6, #156]
33d04c7c:	e15a0003 	cmp	sl, r3
		this->pagebuf = -1;

	if (NAND_MUST_PAD(this)) {
33d04c80:	e5963088 	ldr	r3, [r6, #136]
	if (nand_check_wp(mtd))
		goto out;

	/* Invalidate the page cache, if we write to the cached page */
	if (page == this->pagebuf)
		this->pagebuf = -1;
33d04c84:	0586409c 	streq	r4, [r6, #156]

	if (NAND_MUST_PAD(this)) {
33d04c88:	e3130004 	tst	r3, #4	; 0x4
33d04c8c:	e596c038 	ldr	ip, [r6, #56]
33d04c90:	e5972010 	ldr	r2, [r7, #16]
33d04c94:	e5963098 	ldr	r3, [r6, #152]
33d04c98:	1a000014 	bne	33d04cf0 <nand_write_oob+0x128>
		/* Write out desired data */
		this->cmdfunc (mtd, NAND_CMD_SEQIN, mtd->oobblock, page & this->pagemask);
33d04c9c:	e00a3003 	and	r3, sl, r3
33d04ca0:	e1a00007 	mov	r0, r7
33d04ca4:	e3a01080 	mov	r1, #128	; 0x80
33d04ca8:	e1a0e00f 	mov	lr, pc
33d04cac:	e1a0f00c 	mov	pc, ip
		/* prepad 0xff for partial programming */
		this->write_buf(mtd, ffchars, column);
33d04cb0:	e1a00007 	mov	r0, r7
33d04cb4:	e1a02005 	mov	r2, r5
33d04cb8:	e59f10b0 	ldr	r1, [pc, #176]	; 33d04d70 <nand_write_oob+0x1a8>
33d04cbc:	e1a0e00f 	mov	lr, pc
33d04cc0:	e596f018 	ldr	pc, [r6, #24]
		/* write data */
		this->write_buf(mtd, buf, len);
33d04cc4:	e1a00007 	mov	r0, r7
33d04cc8:	e59d1028 	ldr	r1, [sp, #40]
33d04ccc:	e1a02009 	mov	r2, r9
33d04cd0:	e1a0e00f 	mov	lr, pc
33d04cd4:	e596f018 	ldr	pc, [r6, #24]
		/* postpad 0xff for partial programming */
		this->write_buf(mtd, ffchars, mtd->oobsize - (len+column));
33d04cd8:	e5972014 	ldr	r2, [r7, #20]
33d04cdc:	e59d3000 	ldr	r3, [sp]
33d04ce0:	e59f1088 	ldr	r1, [pc, #136]	; 33d04d70 <nand_write_oob+0x1a8>
33d04ce4:	e0632002 	rsb	r2, r3, r2
33d04ce8:	e1a00007 	mov	r0, r7
33d04cec:	ea000008 	b	33d04d14 <nand_write_oob+0x14c>
	} else {
		/* Write out desired data */
		this->cmdfunc (mtd, NAND_CMD_SEQIN, mtd->oobblock + column, page & this->pagemask);
33d04cf0:	e0822005 	add	r2, r2, r5
33d04cf4:	e1a00007 	mov	r0, r7
33d04cf8:	e3a01080 	mov	r1, #128	; 0x80
33d04cfc:	e00a3003 	and	r3, sl, r3
33d04d00:	e1a0e00f 	mov	lr, pc
33d04d04:	e1a0f00c 	mov	pc, ip
		/* write data */
		this->write_buf(mtd, buf, len);
33d04d08:	e59d1028 	ldr	r1, [sp, #40]
33d04d0c:	e1a00007 	mov	r0, r7
33d04d10:	e1a02009 	mov	r2, r9
33d04d14:	e1a0e00f 	mov	lr, pc
33d04d18:	e596f018 	ldr	pc, [r6, #24]
	}
	/* Send command to program the OOB data */
	this->cmdfunc (mtd, NAND_CMD_PAGEPROG, -1, -1);
33d04d1c:	e3e02000 	mvn	r2, #0	; 0x0
33d04d20:	e1a03002 	mov	r3, r2
33d04d24:	e1a00007 	mov	r0, r7
33d04d28:	e3a01010 	mov	r1, #16	; 0x10
33d04d2c:	e1a0e00f 	mov	lr, pc
33d04d30:	e596f038 	ldr	pc, [r6, #56]

	status = this->waitfunc (mtd, this, FL_WRITING);
33d04d34:	e1a00007 	mov	r0, r7
33d04d38:	e1a01006 	mov	r1, r6
33d04d3c:	e3a02002 	mov	r2, #2	; 0x2
33d04d40:	e1a0e00f 	mov	lr, pc
33d04d44:	e596f03c 	ldr	pc, [r6, #60]

	/* See if device thinks it succeeded */
	if (status & 0x01) {
33d04d48:	e2100001 	ands	r0, r0, #1	; 0x1
		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
		ret = -EIO;
		goto out;
	}
	/* Return happy */
	*retlen = len;
33d04d4c:	059dc024 	ldreq	ip, [sp, #36]
33d04d50:	058c9000 	streq	r9, [ip]
	status = this->waitfunc (mtd, this, FL_WRITING);

	/* See if device thinks it succeeded */
	if (status & 0x01) {
		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
		ret = -EIO;
33d04d54:	13e0b004 	mvnne	fp, #4	; 0x4
		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write verify, page 0x%08x\n", page);
		ret = -EIO;
		goto out;
	}
#endif
	ret = 0;
33d04d58:	01a0b000 	moveq	fp, r0
out:
	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d04d5c:	e1a00007 	mov	r0, r7
33d04d60:	ebfffeaa 	bl	33d04810 <nand_release_device>

	return ret;
33d04d64:	e1a0000b 	mov	r0, fp
}
33d04d68:	e28dd004 	add	sp, sp, #4	; 0x4
33d04d6c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d04d70:	33d2e018 	.word	0x33d2e018

33d04d74 <nand_default_block_markbad>:
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
33d04d74:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
	u_char buf[2] = {0, 0};
33d04d78:	e3a04000 	mov	r4, #0	; 0x0
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
33d04d7c:	e24dd010 	sub	sp, sp, #16	; 0x10
	struct nand_chip *this = mtd->priv;
33d04d80:	e590713c 	ldr	r7, [r0, #316]
	u_char buf[2] = {0, 0};
33d04d84:	e1cd40bc 	strh	r4, [sp, #12]
	size_t	retlen;
	int block;

	/* Get block number */
	block = ((int) ofs) >> this->bbt_erase_shift;
33d04d88:	e597c070 	ldr	ip, [r7, #112]
	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
33d04d8c:	e59760a4 	ldr	r6, [r7, #164]
	u_char buf[2] = {0, 0};
	size_t	retlen;
	int block;

	/* Get block number */
	block = ((int) ofs) >> this->bbt_erase_shift;
33d04d90:	e1a0cc51 	asr	ip, r1, ip
	if (this->options & NAND_USE_FLASH_BBT)
		return nand_update_bbt (mtd, ofs);

	/* We write two bytes, so we dont have to mess with 16 bit access */
	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
33d04d94:	e3a03002 	mov	r3, #2	; 0x2
	size_t	retlen;
	int block;

	/* Get block number */
	block = ((int) ofs) >> this->bbt_erase_shift;
	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
33d04d98:	e1a0535c 	asr	r5, ip, r3
33d04d9c:	e7d6e005 	ldrb	lr, [r6, r5]
33d04da0:	e20cc003 	and	ip, ip, #3	; 0x3
33d04da4:	e1a0c08c 	lsl	ip, ip, #1
33d04da8:	e3a04001 	mov	r4, #1	; 0x1
33d04dac:	e18eec14 	orr	lr, lr, r4, lsl ip
33d04db0:	e7c6e005 	strb	lr, [r6, r5]

	/* Do we have a flash based bad block table ? */
	if (this->options & NAND_USE_FLASH_BBT)
33d04db4:	e597c088 	ldr	ip, [r7, #136]
33d04db8:	e31c0801 	tst	ip, #65536	; 0x10000
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
33d04dbc:	e1a09000 	mov	r9, r0
33d04dc0:	e1a0b002 	mov	fp, r2
33d04dc4:	e1a0a001 	mov	sl, r1
	/* Get block number */
	block = ((int) ofs) >> this->bbt_erase_shift;
	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);

	/* Do we have a flash based bad block table ? */
	if (this->options & NAND_USE_FLASH_BBT)
33d04dc8:	0a000001 	beq	33d04dd4 <nand_default_block_markbad+0x60>
		return nand_update_bbt (mtd, ofs);
33d04dcc:	eb000dd6 	bl	33d0852c <nand_update_bbt>
33d04dd0:	ea00000c 	b	33d04e08 <nand_default_block_markbad+0x94>

	/* We write two bytes, so we dont have to mess with 16 bit access */
	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
33d04dd4:	e597208c 	ldr	r2, [r7, #140]
33d04dd8:	e5901014 	ldr	r1, [r0, #20]
33d04ddc:	e3c22001 	bic	r2, r2, #1	; 0x1
33d04de0:	e0811002 	add	r1, r1, r2
	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
33d04de4:	e09a4001 	adds	r4, sl, r1
33d04de8:	e28dc008 	add	ip, sp, #8	; 0x8
33d04dec:	e2ab5000 	adc	r5, fp, #0	; 0x0
33d04df0:	e58dc000 	str	ip, [sp]
33d04df4:	e1a02005 	mov	r2, r5
33d04df8:	e1a01004 	mov	r1, r4
33d04dfc:	e28dc00c 	add	ip, sp, #12	; 0xc
33d04e00:	e58dc004 	str	ip, [sp, #4]
33d04e04:	ebffff6f 	bl	33d04bc8 <nand_write_oob>
}
33d04e08:	e28dd010 	add	sp, sp, #16	; 0x10
33d04e0c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d04e10 <nand_block_checkbad>:
 *
 * Check, if the block is bad. Either by reading the bad block table or
 * calling of the scan function.
 */
static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
{
33d04e10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct nand_chip *this = mtd->priv;
33d04e14:	e590c13c 	ldr	ip, [r0, #316]

//	if (!this->bbt)
		return this->block_bad(mtd, ofs, getchip);
33d04e18:	e1a0e00f 	mov	lr, pc
33d04e1c:	e59cf028 	ldr	pc, [ip, #40]

	/* Return info from the table */
//	return nand_isbad_bbt (mtd, ofs, allowbbt);
}
33d04e20:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d04e24 <nand_command>:
 *
 * Send command to NAND device. This function is used for small page
 * devices (256/512 Bytes per page)
 */
static void nand_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
33d04e24:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d04e28:	e1a07001 	mov	r7, r1
	register struct nand_chip *this = mtd->priv;
33d04e2c:	e590513c 	ldr	r5, [r0, #316]

	/* Begin command latch cycle */
	this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d04e30:	e3a01003 	mov	r1, #3	; 0x3
 *
 * Send command to NAND device. This function is used for small page
 * devices (256/512 Bytes per page)
 */
static void nand_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
33d04e34:	e1a06000 	mov	r6, r0
33d04e38:	e1a04002 	mov	r4, r2
33d04e3c:	e1a0a003 	mov	sl, r3
	register struct nand_chip *this = mtd->priv;

	/* Begin command latch cycle */
	this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d04e40:	e1a0e00f 	mov	lr, pc
33d04e44:	e595f030 	ldr	pc, [r5, #48]
	/*
	 * Write out the command to the device.
	 */
	if (command == NAND_CMD_SEQIN) {
33d04e48:	e3570080 	cmp	r7, #128	; 0x80
33d04e4c:	1a00000b 	bne	33d04e80 <nand_command+0x5c>
		int readcmd;

		if (column >= mtd->oobblock) {
33d04e50:	e5963010 	ldr	r3, [r6, #16]
33d04e54:	e1540003 	cmp	r4, r3
			/* OOB area */
			column -= mtd->oobblock;
33d04e58:	20634004 	rsbcs	r4, r3, r4
			readcmd = NAND_CMD_READOOB;
33d04e5c:	23a01050 	movcs	r1, #80	; 0x50
	 * Write out the command to the device.
	 */
	if (command == NAND_CMD_SEQIN) {
		int readcmd;

		if (column >= mtd->oobblock) {
33d04e60:	2a000003 	bcs	33d04e74 <nand_command+0x50>
			/* OOB area */
			column -= mtd->oobblock;
			readcmd = NAND_CMD_READOOB;
		} else if (column < 256) {
33d04e64:	e35400ff 	cmp	r4, #255	; 0xff
			/* First 256 bytes --> READ0 */
			readcmd = NAND_CMD_READ0;
33d04e68:	d3a01000 	movle	r1, #0	; 0x0
		} else {
			column -= 256;
33d04e6c:	c2444c01 	subgt	r4, r4, #256	; 0x100
			readcmd = NAND_CMD_READ1;
33d04e70:	c3a01001 	movgt	r1, #1	; 0x1
		}
		this->write_byte(mtd, readcmd);
33d04e74:	e1a00006 	mov	r0, r6
33d04e78:	e1a0e00f 	mov	lr, pc
33d04e7c:	e595f00c 	ldr	pc, [r5, #12]
	}
	this->write_byte(mtd, command);
33d04e80:	e20710ff 	and	r1, r7, #255	; 0xff
33d04e84:	e1a00006 	mov	r0, r6
33d04e88:	e1a0e00f 	mov	lr, pc
33d04e8c:	e595f00c 	ldr	pc, [r5, #12]

	/* Set ALE and clear CLE to start address cycle */
	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
33d04e90:	e1a00006 	mov	r0, r6
33d04e94:	e3a01004 	mov	r1, #4	; 0x4
33d04e98:	e1a0e00f 	mov	lr, pc
33d04e9c:	e595f030 	ldr	pc, [r5, #48]

	if (column != -1 || page_addr != -1) {
33d04ea0:	e3740001 	cmn	r4, #1	; 0x1
33d04ea4:	037a0001 	cmneq	sl, #1	; 0x1
33d04ea8:	0a000022 	beq	33d04f38 <nand_command+0x114>
		this->hwcontrol(mtd, NAND_CTL_SETALE);
33d04eac:	e1a00006 	mov	r0, r6
33d04eb0:	e3a01005 	mov	r1, #5	; 0x5
33d04eb4:	e1a0e00f 	mov	lr, pc
33d04eb8:	e595f030 	ldr	pc, [r5, #48]

		/* Serially input address */
		if (column != -1) {
33d04ebc:	e3740001 	cmn	r4, #1	; 0x1
33d04ec0:	0a000006 	beq	33d04ee0 <nand_command+0xbc>
			/* Adjust columns for 16 bit buswidth */
			if (this->options & NAND_BUSWIDTH_16)
33d04ec4:	e5953088 	ldr	r3, [r5, #136]
33d04ec8:	e3130002 	tst	r3, #2	; 0x2
				column >>= 1;
33d04ecc:	11a040c4 	asrne	r4, r4, #1
			this->write_byte(mtd, column);
33d04ed0:	e20410ff 	and	r1, r4, #255	; 0xff
33d04ed4:	e1a00006 	mov	r0, r6
33d04ed8:	e1a0e00f 	mov	lr, pc
33d04edc:	e595f00c 	ldr	pc, [r5, #12]
//			udelay(15);		//HJ
		}
		if (page_addr != -1) {
33d04ee0:	e37a0001 	cmn	sl, #1	; 0x1
33d04ee4:	0a00000f 	beq	33d04f28 <nand_command+0x104>
			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
33d04ee8:	e20a10ff 	and	r1, sl, #255	; 0xff
33d04eec:	e1a00006 	mov	r0, r6
33d04ef0:	e1a0e00f 	mov	lr, pc
33d04ef4:	e595f00c 	ldr	pc, [r5, #12]
//			udelay(15);		//HJ
			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
33d04ef8:	e1a0142a 	lsr	r1, sl, #8
33d04efc:	e20110ff 	and	r1, r1, #255	; 0xff
33d04f00:	e1a00006 	mov	r0, r6
33d04f04:	e1a0e00f 	mov	lr, pc
33d04f08:	e595f00c 	ldr	pc, [r5, #12]
//			udelay(15);		//HJ
			/* One more address cycle for devices > 32MiB */
			if (this->chipsize > (32 << 20))
33d04f0c:	e5953094 	ldr	r3, [r5, #148]
33d04f10:	e3530402 	cmp	r3, #33554432	; 0x2000000
				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0x0f));
33d04f14:	81a0184a 	asrhi	r1, sl, #16
33d04f18:	8201100f 	andhi	r1, r1, #15	; 0xf
33d04f1c:	81a00006 	movhi	r0, r6
33d04f20:	81a0e00f 	movhi	lr, pc
33d04f24:	8595f00c 	ldrhi	pc, [r5, #12]
//   			    udelay(15);		//HJ
		}
		/* Latch in address */
		this->hwcontrol(mtd, NAND_CTL_CLRALE);
33d04f28:	e1a00006 	mov	r0, r6
33d04f2c:	e3a01006 	mov	r1, #6	; 0x6
33d04f30:	e1a0e00f 	mov	lr, pc
33d04f34:	e595f030 	ldr	pc, [r5, #48]

	/*
	 * program and erase have their own busy handlers
	 * status and sequential in needs no delay
	*/
	switch (command) {
33d04f38:	e3570070 	cmp	r7, #112	; 0x70
33d04f3c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d04f40:	8a000004 	bhi	33d04f58 <nand_command+0x134>
33d04f44:	e3570010 	cmp	r7, #16	; 0x10
33d04f48:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d04f4c:	e3570060 	cmp	r7, #96	; 0x60
33d04f50:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d04f54:	ea00001e 	b	33d04fd4 <nand_command+0x1b0>
33d04f58:	e35700d0 	cmp	r7, #208	; 0xd0
33d04f5c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d04f60:	8a000002 	bhi	33d04f70 <nand_command+0x14c>
33d04f64:	e3570080 	cmp	r7, #128	; 0x80
33d04f68:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d04f6c:	ea000018 	b	33d04fd4 <nand_command+0x1b0>
33d04f70:	e35700ff 	cmp	r7, #255	; 0xff
33d04f74:	1a000016 	bne	33d04fd4 <nand_command+0x1b0>
	case NAND_CMD_SEQIN:
	case NAND_CMD_STATUS:
		return;

	case NAND_CMD_RESET:
		if (this->dev_ready)
33d04f78:	e5953034 	ldr	r3, [r5, #52]
33d04f7c:	e3530000 	cmp	r3, #0	; 0x0
33d04f80:	1a000019 	bne	33d04fec <nand_command+0x1c8>
			break;
		udelay(this->chip_delay);
33d04f84:	e5950064 	ldr	r0, [r5, #100]
33d04f88:	ebffef9f 	bl	33d00e0c <udelay>
		this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d04f8c:	e1a00006 	mov	r0, r6
33d04f90:	e3a01003 	mov	r1, #3	; 0x3
33d04f94:	e1a0e00f 	mov	lr, pc
33d04f98:	e595f030 	ldr	pc, [r5, #48]
		this->write_byte(mtd, NAND_CMD_STATUS);
33d04f9c:	e1a00006 	mov	r0, r6
33d04fa0:	e3a01070 	mov	r1, #112	; 0x70
33d04fa4:	e1a0e00f 	mov	lr, pc
33d04fa8:	e595f00c 	ldr	pc, [r5, #12]
		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
33d04fac:	e1a00006 	mov	r0, r6
33d04fb0:	e3a01004 	mov	r1, #4	; 0x4
33d04fb4:	e1a0e00f 	mov	lr, pc
33d04fb8:	e595f030 	ldr	pc, [r5, #48]
		while ( !(this->read_byte(mtd) & 0x40));
33d04fbc:	e1a00006 	mov	r0, r6
33d04fc0:	e1a0e00f 	mov	lr, pc
33d04fc4:	e595f008 	ldr	pc, [r5, #8]
33d04fc8:	e3100040 	tst	r0, #64	; 0x40
33d04fcc:	0afffffa 	beq	33d04fbc <nand_command+0x198>
		return;
33d04fd0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	default:
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		*/
		if (!this->dev_ready) {
33d04fd4:	e5953034 	ldr	r3, [r5, #52]
33d04fd8:	e3530000 	cmp	r3, #0	; 0x0
33d04fdc:	1a000002 	bne	33d04fec <nand_command+0x1c8>
			udelay (this->chip_delay);
33d04fe0:	e5950064 	ldr	r0, [r5, #100]
	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay (100);
	/* wait until command is processed */
	while (!this->dev_ready(mtd));
}
33d04fe4:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		*/
		if (!this->dev_ready) {
			udelay (this->chip_delay);
33d04fe8:	eaffef87 	b	33d00e0c <udelay>
		}
	}

	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay (100);
33d04fec:	e3a00001 	mov	r0, #1	; 0x1
33d04ff0:	ebffef85 	bl	33d00e0c <udelay>
	/* wait until command is processed */
	while (!this->dev_ready(mtd));
33d04ff4:	e1a00006 	mov	r0, r6
33d04ff8:	e1a0e00f 	mov	lr, pc
33d04ffc:	e595f034 	ldr	pc, [r5, #52]
33d05000:	e3500000 	cmp	r0, #0	; 0x0
33d05004:	0afffffa 	beq	33d04ff4 <nand_command+0x1d0>
33d05008:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

33d0500c <nand_command_lp>:
 * We dont have the seperate regions as we have in the small page devices.
 * We must emulate NAND_CMD_READOOB to keep the code compatible.
 *
 */
static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
33d0500c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	register struct nand_chip *this = mtd->priv;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
33d05010:	e3510050 	cmp	r1, #80	; 0x50
 * We dont have the seperate regions as we have in the small page devices.
 * We must emulate NAND_CMD_READOOB to keep the code compatible.
 *
 */
static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
33d05014:	e1a0a003 	mov	sl, r3
	register struct nand_chip *this = mtd->priv;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
		column += mtd->oobblock;
33d05018:	05903010 	ldreq	r3, [r0, #16]
 * We must emulate NAND_CMD_READOOB to keep the code compatible.
 *
 */
static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	register struct nand_chip *this = mtd->priv;
33d0501c:	e590413c 	ldr	r4, [r0, #316]
 * We dont have the seperate regions as we have in the small page devices.
 * We must emulate NAND_CMD_READOOB to keep the code compatible.
 *
 */
static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
33d05020:	e1a06001 	mov	r6, r1
33d05024:	e1a05000 	mov	r5, r0
	register struct nand_chip *this = mtd->priv;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
		column += mtd->oobblock;
		command = NAND_CMD_READ0;
33d05028:	02416050 	subeq	r6, r1, #80	; 0x50
	}


	/* Begin command latch cycle */
	this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d0502c:	e3a01003 	mov	r1, #3	; 0x3
 * We dont have the seperate regions as we have in the small page devices.
 * We must emulate NAND_CMD_READOOB to keep the code compatible.
 *
 */
static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
33d05030:	e1a07002 	mov	r7, r2
	register struct nand_chip *this = mtd->priv;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
		column += mtd->oobblock;
33d05034:	00827003 	addeq	r7, r2, r3
		command = NAND_CMD_READ0;
	}


	/* Begin command latch cycle */
	this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d05038:	e1a0e00f 	mov	lr, pc
33d0503c:	e594f030 	ldr	pc, [r4, #48]
	/* Write out the command to the device. */
	this->write_byte(mtd, command);
33d05040:	e20610ff 	and	r1, r6, #255	; 0xff
33d05044:	e1a00005 	mov	r0, r5
33d05048:	e1a0e00f 	mov	lr, pc
33d0504c:	e594f00c 	ldr	pc, [r4, #12]
	/* End command latch cycle */
	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
33d05050:	e1a00005 	mov	r0, r5
33d05054:	e3a01004 	mov	r1, #4	; 0x4
33d05058:	e1a0e00f 	mov	lr, pc
33d0505c:	e594f030 	ldr	pc, [r4, #48]

	if (column != -1 || page_addr != -1) {
33d05060:	e3770001 	cmn	r7, #1	; 0x1
33d05064:	037a0001 	cmneq	sl, #1	; 0x1
33d05068:	0a000024 	beq	33d05100 <nand_command_lp+0xf4>
		this->hwcontrol(mtd, NAND_CTL_SETALE);
33d0506c:	e1a00005 	mov	r0, r5
33d05070:	e3a01005 	mov	r1, #5	; 0x5
33d05074:	e1a0e00f 	mov	lr, pc
33d05078:	e594f030 	ldr	pc, [r4, #48]

		/* Serially input address */
		if (column != -1) {
33d0507c:	e3770001 	cmn	r7, #1	; 0x1
33d05080:	0a000008 	beq	33d050a8 <nand_command_lp+0x9c>
#if 0
			/* Adjust columns for 16 bit buswidth */
			if (this->options & NAND_BUSWIDTH_16)
				column >>= 1;
#endif
			this->write_byte(mtd, column & 0xff);
33d05084:	e20710ff 	and	r1, r7, #255	; 0xff
33d05088:	e1a00005 	mov	r0, r5
33d0508c:	e1a0e00f 	mov	lr, pc
33d05090:	e594f00c 	ldr	pc, [r4, #12]
			this->write_byte(mtd, column >> 8);
33d05094:	e1a01427 	lsr	r1, r7, #8
33d05098:	e20110ff 	and	r1, r1, #255	; 0xff
33d0509c:	e1a00005 	mov	r0, r5
33d050a0:	e1a0e00f 	mov	lr, pc
33d050a4:	e594f00c 	ldr	pc, [r4, #12]
		}
		if (page_addr != -1) {
33d050a8:	e37a0001 	cmn	sl, #1	; 0x1
33d050ac:	0a00000f 	beq	33d050f0 <nand_command_lp+0xe4>
			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
33d050b0:	e20a10ff 	and	r1, sl, #255	; 0xff
33d050b4:	e1a00005 	mov	r0, r5
33d050b8:	e1a0e00f 	mov	lr, pc
33d050bc:	e594f00c 	ldr	pc, [r4, #12]
			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
33d050c0:	e1a0142a 	lsr	r1, sl, #8
33d050c4:	e20110ff 	and	r1, r1, #255	; 0xff
33d050c8:	e1a00005 	mov	r0, r5
33d050cc:	e1a0e00f 	mov	lr, pc
33d050d0:	e594f00c 	ldr	pc, [r4, #12]
			/* One more address cycle for devices > 128MiB */
			if (this->chipsize > (128 << 20))
33d050d4:	e5943094 	ldr	r3, [r4, #148]
33d050d8:	e3530302 	cmp	r3, #134217728	; 0x8000000
				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0xff));
33d050dc:	81a0182a 	lsrhi	r1, sl, #16
33d050e0:	820110ff 	andhi	r1, r1, #255	; 0xff
33d050e4:	81a00005 	movhi	r0, r5
33d050e8:	81a0e00f 	movhi	lr, pc
33d050ec:	8594f00c 	ldrhi	pc, [r4, #12]
		}
		/* Latch in address */
		this->hwcontrol(mtd, NAND_CTL_CLRALE);
33d050f0:	e1a00005 	mov	r0, r5
33d050f4:	e3a01006 	mov	r1, #6	; 0x6
33d050f8:	e1a0e00f 	mov	lr, pc
33d050fc:	e594f030 	ldr	pc, [r4, #48]

	/*
	 * program and erase have their own busy handlers
	 * status and sequential in needs no delay
	*/
	switch (command) {
33d05100:	e3560060 	cmp	r6, #96	; 0x60
33d05104:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d05108:	8a000008 	bhi	33d05130 <nand_command_lp+0x124>
33d0510c:	e3560010 	cmp	r6, #16	; 0x10
33d05110:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d05114:	8a000002 	bhi	33d05124 <nand_command_lp+0x118>
33d05118:	e3560000 	cmp	r6, #0	; 0x0
33d0511c:	0a000024 	beq	33d051b4 <nand_command_lp+0x1a8>
33d05120:	ea00002f 	b	33d051e4 <nand_command_lp+0x1d8>
33d05124:	e3560015 	cmp	r6, #21	; 0x15
33d05128:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d0512c:	ea00002c 	b	33d051e4 <nand_command_lp+0x1d8>
33d05130:	e3560080 	cmp	r6, #128	; 0x80
33d05134:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d05138:	8a000002 	bhi	33d05148 <nand_command_lp+0x13c>
33d0513c:	e3560070 	cmp	r6, #112	; 0x70
33d05140:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d05144:	ea000026 	b	33d051e4 <nand_command_lp+0x1d8>
33d05148:	e35600d0 	cmp	r6, #208	; 0xd0
33d0514c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d05150:	e35600ff 	cmp	r6, #255	; 0xff
33d05154:	1a000022 	bne	33d051e4 <nand_command_lp+0x1d8>
	case NAND_CMD_STATUS:
		return;


	case NAND_CMD_RESET:
		if (this->dev_ready)
33d05158:	e5943034 	ldr	r3, [r4, #52]
33d0515c:	e3530000 	cmp	r3, #0	; 0x0
33d05160:	1a000025 	bne	33d051fc <nand_command_lp+0x1f0>
			break;
		udelay(this->chip_delay);
33d05164:	e5940064 	ldr	r0, [r4, #100]
33d05168:	ebffef27 	bl	33d00e0c <udelay>
		this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d0516c:	e1a00005 	mov	r0, r5
33d05170:	e3a01003 	mov	r1, #3	; 0x3
33d05174:	e1a0e00f 	mov	lr, pc
33d05178:	e594f030 	ldr	pc, [r4, #48]
		this->write_byte(mtd, NAND_CMD_STATUS);
33d0517c:	e1a00005 	mov	r0, r5
33d05180:	e3a01070 	mov	r1, #112	; 0x70
33d05184:	e1a0e00f 	mov	lr, pc
33d05188:	e594f00c 	ldr	pc, [r4, #12]
		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
33d0518c:	e1a00005 	mov	r0, r5
33d05190:	e3a01004 	mov	r1, #4	; 0x4
33d05194:	e1a0e00f 	mov	lr, pc
33d05198:	e594f030 	ldr	pc, [r4, #48]
		while ( !(this->read_byte(mtd) & 0x40));
33d0519c:	e1a00005 	mov	r0, r5
33d051a0:	e1a0e00f 	mov	lr, pc
33d051a4:	e594f008 	ldr	pc, [r4, #8]
33d051a8:	e3100040 	tst	r0, #64	; 0x40
33d051ac:	0afffffa 	beq	33d0519c <nand_command_lp+0x190>
		return;
33d051b0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	case NAND_CMD_READ0:
		/* Begin command latch cycle */
		this->hwcontrol(mtd, NAND_CTL_SETCLE);
33d051b4:	e1a00005 	mov	r0, r5
33d051b8:	e3a01003 	mov	r1, #3	; 0x3
33d051bc:	e1a0e00f 	mov	lr, pc
33d051c0:	e594f030 	ldr	pc, [r4, #48]
		/* Write out the start read command */
		this->write_byte(mtd, NAND_CMD_READSTART);
33d051c4:	e1a00005 	mov	r0, r5
33d051c8:	e3a01030 	mov	r1, #48	; 0x30
33d051cc:	e1a0e00f 	mov	lr, pc
33d051d0:	e594f00c 	ldr	pc, [r4, #12]
		/* End command latch cycle */
		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
33d051d4:	e1a00005 	mov	r0, r5
33d051d8:	e3a01004 	mov	r1, #4	; 0x4
33d051dc:	e1a0e00f 	mov	lr, pc
33d051e0:	e594f030 	ldr	pc, [r4, #48]
	default:
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		*/
		if (!this->dev_ready) {
33d051e4:	e5943034 	ldr	r3, [r4, #52]
33d051e8:	e3530000 	cmp	r3, #0	; 0x0
33d051ec:	1a000002 	bne	33d051fc <nand_command_lp+0x1f0>
			udelay (this->chip_delay);
33d051f0:	e5940064 	ldr	r0, [r4, #100]
	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay (100);
	/* wait until command is processed */
	while (!this->dev_ready(mtd));
}
33d051f4:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		*/
		if (!this->dev_ready) {
			udelay (this->chip_delay);
33d051f8:	eaffef03 	b	33d00e0c <udelay>
		}
	}

	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay (100);
33d051fc:	e3a00001 	mov	r0, #1	; 0x1
33d05200:	ebffef01 	bl	33d00e0c <udelay>
	/* wait until command is processed */
	while (!this->dev_ready(mtd));
33d05204:	e1a00005 	mov	r0, r5
33d05208:	e1a0e00f 	mov	lr, pc
33d0520c:	e594f034 	ldr	pc, [r4, #52]
33d05210:	e3500000 	cmp	r0, #0	; 0x0
33d05214:	0afffffa 	beq	33d05204 <nand_command_lp+0x1f8>
33d05218:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

33d0521c <nand_wait>:
#else
static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
{
	unsigned long	timeo;

	if (state == FL_ERASING)
33d0521c:	e3520003 	cmp	r2, #3	; 0x3

	return 0;
}
#else
static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
{
33d05220:	e92d4070 	push	{r4, r5, r6, lr}
33d05224:	e1a05000 	mov	r5, r0
33d05228:	e1a04001 	mov	r4, r1
	unsigned long	timeo;

	if (state == FL_ERASING)
		timeo = CFG_HZ * 400;
	else
		timeo = CFG_HZ * 20;
33d0522c:	159f60a8 	ldrne	r6, [pc, #168]	; 33d052dc <nand_wait+0xc0>
#else
static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
{
	unsigned long	timeo;

	if (state == FL_ERASING)
33d05230:	1a00000b 	bne	33d05264 <nand_wait+0x48>
		timeo = CFG_HZ * 400;
	else
		timeo = CFG_HZ * 20;

	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
33d05234:	e5913088 	ldr	r3, [r1, #136]
33d05238:	e3130020 	tst	r3, #32	; 0x20
static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
{
	unsigned long	timeo;

	if (state == FL_ERASING)
		timeo = CFG_HZ * 400;
33d0523c:	e59f609c 	ldr	r6, [pc, #156]	; 33d052e0 <nand_wait+0xc4>
	else
		timeo = CFG_HZ * 20;

	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
		this->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
33d05240:	13e02000 	mvnne	r2, #0	; 0x0
33d05244:	11a00000 	movne	r0, r0
33d05248:	13a01071 	movne	r1, #113	; 0x71
	if (state == FL_ERASING)
		timeo = CFG_HZ * 400;
	else
		timeo = CFG_HZ * 20;

	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
33d0524c:	1a000007 	bne	33d05270 <nand_wait+0x54>
33d05250:	ea000003 	b	33d05264 <nand_wait+0x48>

	reset_timer();

	while (1) {
		if (get_timer(0) > timeo) {
			printf("Timeout!");
33d05254:	e59f0088 	ldr	r0, [pc, #136]	; 33d052e4 <nand_wait+0xc8>
33d05258:	eb00475a 	bl	33d16fc8 <printf>
			return 0;
33d0525c:	e3a00000 	mov	r0, #0	; 0x0
33d05260:	e8bd8070 	pop	{r4, r5, r6, pc}
		timeo = CFG_HZ * 20;

	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
		this->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
	else
		this->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
33d05264:	e3e02000 	mvn	r2, #0	; 0x0
33d05268:	e1a00005 	mov	r0, r5
33d0526c:	e3a01070 	mov	r1, #112	; 0x70
33d05270:	e1a03002 	mov	r3, r2
33d05274:	e1a0e00f 	mov	lr, pc
33d05278:	e594f038 	ldr	pc, [r4, #56]

	reset_timer();
33d0527c:	ebffeebd 	bl	33d00d78 <reset_timer>

	while (1) {
		if (get_timer(0) > timeo) {
33d05280:	e3a00000 	mov	r0, #0	; 0x0
33d05284:	ebffeed7 	bl	33d00de8 <get_timer>
33d05288:	e1500006 	cmp	r0, r6
			printf("Timeout!");
			return 0;
			}

		if (this->dev_ready) {
			if (this->dev_ready(mtd))
33d0528c:	e1a00005 	mov	r0, r5
		this->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);

	reset_timer();

	while (1) {
		if (get_timer(0) > timeo) {
33d05290:	8affffef 	bhi	33d05254 <nand_wait+0x38>
			printf("Timeout!");
			return 0;
			}

		if (this->dev_ready) {
33d05294:	e5943034 	ldr	r3, [r4, #52]
33d05298:	e3530000 	cmp	r3, #0	; 0x0
33d0529c:	0a000004 	beq	33d052b4 <nand_wait+0x98>
			if (this->dev_ready(mtd))
33d052a0:	e1a0e00f 	mov	lr, pc
33d052a4:	e1a0f003 	mov	pc, r3
33d052a8:	e3500000 	cmp	r0, #0	; 0x0
33d052ac:	0afffff3 	beq	33d05280 <nand_wait+0x64>
				break;
33d052b0:	ea000004 	b	33d052c8 <nand_wait+0xac>
		} else {
			if (this->read_byte(mtd) & NAND_STATUS_READY)
33d052b4:	e1a00005 	mov	r0, r5
33d052b8:	e1a0e00f 	mov	lr, pc
33d052bc:	e594f008 	ldr	pc, [r4, #8]
33d052c0:	e3100040 	tst	r0, #64	; 0x40
33d052c4:	0affffed 	beq	33d05280 <nand_wait+0x64>
#ifdef PPCHAMELON_NAND_TIMER_HACK
	reset_timer();
	while (get_timer(0) < 10);
#endif /*  PPCHAMELON_NAND_TIMER_HACK */

	return this->read_byte(mtd);
33d052c8:	e1a00005 	mov	r0, r5
33d052cc:	e1a0e00f 	mov	lr, pc
33d052d0:	e594f008 	ldr	pc, [r4, #8]
33d052d4:	e20000ff 	and	r0, r0, #255	; 0xff
}
33d052d8:	e8bd8070 	pop	{r4, r5, r6, pc}
33d052dc:	01dcd650 	.word	0x01dcd650
33d052e0:	2540be40 	.word	0x2540be40
33d052e4:	33d25cf0 	.word	0x33d25cf0

33d052e8 <nand_read_ecc>:
 *
 * NAND read with ECC
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
33d052e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d052ec:	e24dd090 	sub	sp, sp, #144	; 0x90
	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
	struct nand_chip *this = mtd->priv;
33d052f0:	e590713c 	ldr	r7, [r0, #316]
 *
 * NAND read with ECC
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
33d052f4:	e1a0a000 	mov	sl, r0


	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d052f8:	e5900008 	ldr	r0, [r0, #8]
 *
 * NAND read with ECC
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
33d052fc:	e58d304c 	str	r3, [sp, #76]
33d05300:	e1a06002 	mov	r6, r2
33d05304:	e1a05001 	mov	r5, r1


	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05308:	e59d204c 	ldr	r2, [sp, #76]
	u_char ecc_calc[32];
	u_char ecc_code[32];
	int eccmode, eccsteps;
	unsigned *oob_config;
	int	datidx;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d0530c:	e287106c 	add	r1, r7, #108	; 0x6c
33d05310:	e811000a 	ldmda	r1, {r1, r3}
33d05314:	e0433001 	sub	r3, r3, r1


	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05318:	e095b002 	adds	fp, r5, r2
 * NAND read with ECC
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
33d0531c:	e3a02001 	mov	r2, #1	; 0x1
	u_char ecc_calc[32];
	u_char ecc_code[32];
	int eccmode, eccsteps;
	unsigned *oob_config;
	int	datidx;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05320:	e1a03312 	lsl	r3, r2, r3
33d05324:	e2433001 	sub	r3, r3, #1	; 0x1


	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05328:	e2a6c000 	adc	ip, r6, #0	; 0x0
33d0532c:	e3a01000 	mov	r1, #0	; 0x0
 * NAND read with ECC
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
33d05330:	e58d2038 	str	r2, [sp, #56]
	u_char ecc_calc[32];
	u_char ecc_code[32];
	int eccmode, eccsteps;
	unsigned *oob_config;
	int	datidx;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05334:	e58d3018 	str	r3, [sp, #24]
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
33d05338:	e2422001 	sub	r2, r2, #1	; 0x1
	struct nand_chip *this = mtd->priv;
	u_char *data_poi, *oob_data = oob_buf;
33d0533c:	e59d30b8 	ldr	r3, [sp, #184]
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
33d05340:	e58d2034 	str	r2, [sp, #52]
33d05344:	e58d2030 	str	r2, [sp, #48]
33d05348:	e58d202c 	str	r2, [sp, #44]


	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d0534c:	e15c0001 	cmp	ip, r1
	int eccmode, eccsteps;
	unsigned *oob_config;
	int	datidx;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
	int	eccbytes;
	int	compareecc = 1;
33d05350:	e2822001 	add	r2, r2, #1	; 0x1
 *
 * NAND read with ECC
 */
static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
{
33d05354:	e59d90bc 	ldr	r9, [sp, #188]
	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
	struct nand_chip *this = mtd->priv;
	u_char *data_poi, *oob_data = oob_buf;
33d05358:	e58d3024 	str	r3, [sp, #36]
	int eccmode, eccsteps;
	unsigned *oob_config;
	int	datidx;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
	int	eccbytes;
	int	compareecc = 1;
33d0535c:	e58d2010 	str	r2, [sp, #16]


	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05360:	ca000002 	bgt	33d05370 <nand_read_ecc+0x88>
33d05364:	1a000006 	bne	33d05384 <nand_read_ecc+0x9c>
33d05368:	e15b0000 	cmp	fp, r0
33d0536c:	9a000004 	bls	33d05384 <nand_read_ecc+0x9c>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: Attempt read beyond end of device\n");
		*retlen = 0;
33d05370:	e59d102c 	ldr	r1, [sp, #44]
33d05374:	e59d30b0 	ldr	r3, [sp, #176]
		return -EINVAL;
33d05378:	e3e00015 	mvn	r0, #21	; 0x15
	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: Attempt read beyond end of device\n");
		*retlen = 0;
33d0537c:	e5831000 	str	r1, [r3]
		return -EINVAL;
33d05380:	ea00018a 	b	33d059b0 <nand_read_ecc+0x6c8>

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd ,FL_READING);

	/* use userspace supplied oobinfo, if zero */
	if (oobsel == NULL)
33d05384:	e3590000 	cmp	r9, #0	; 0x0
		oobsel = &mtd->oobinfo;
33d05388:	028a902c 	addeq	r9, sl, #44	; 0x2c

	/* Autoplace of oob data ? Use the default placement scheme */
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
33d0538c:	e5993000 	ldr	r3, [r9]
33d05390:	e3530002 	cmp	r3, #2	; 0x2
		oobsel = this->autooob;
33d05394:	059790a0 	ldreq	r9, [r7, #160]

	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
33d05398:	e5993000 	ldr	r3, [r9]
33d0539c:	e3530000 	cmp	r3, #0	; 0x0
33d053a0:	15972054 	ldrne	r2, [r7, #84]
33d053a4:	058d3020 	streq	r3, [sp, #32]
33d053a8:	158d2020 	strne	r2, [sp, #32]
	oob_config = oobsel->eccpos;

	/* Select the NAND device */
	chipnr = (int)(from >> this->chip_shift);
33d053ac:	e1a01006 	mov	r1, r6
33d053b0:	e1a00005 	mov	r0, r5
33d053b4:	e5972074 	ldr	r2, [r7, #116]
33d053b8:	eb0064a1 	bl	33d1e644 <__ashrdi3>
33d053bc:	e1a04001 	mov	r4, r1
33d053c0:	e1a03000 	mov	r3, r0
33d053c4:	e58d303c 	str	r3, [sp, #60]
	this->select_chip(mtd, chipnr);
33d053c8:	e1a01000 	mov	r1, r0
33d053cc:	e1a0000a 	mov	r0, sl
33d053d0:	e1a0e00f 	mov	lr, pc
33d053d4:	e597f024 	ldr	pc, [r7, #36]

	/* First we calculate the starting page */
	realpage = (int) (from >> this->page_shift);
33d053d8:	e5972068 	ldr	r2, [r7, #104]
33d053dc:	e1a01006 	mov	r1, r6
33d053e0:	e1a00005 	mov	r0, r5
33d053e4:	eb006496 	bl	33d1e644 <__ashrdi3>
33d053e8:	e58d0044 	str	r0, [sp, #68]
	page = realpage & this->pagemask;

	/* Get raw starting column */
	col = from & (mtd->oobblock - 1);
33d053ec:	e59a3010 	ldr	r3, [sl, #16]
33d053f0:	e58d3008 	str	r3, [sp, #8]
	chipnr = (int)(from >> this->chip_shift);
	this->select_chip(mtd, chipnr);

	/* First we calculate the starting page */
	realpage = (int) (from >> this->page_shift);
	page = realpage & this->pagemask;
33d053f4:	e59d1044 	ldr	r1, [sp, #68]
33d053f8:	e5972098 	ldr	r2, [r7, #152]

	/* Get raw starting column */
	col = from & (mtd->oobblock - 1);
33d053fc:	e2433001 	sub	r3, r3, #1	; 0x1
33d05400:	e0033005 	and	r3, r3, r5
	chipnr = (int)(from >> this->chip_shift);
	this->select_chip(mtd, chipnr);

	/* First we calculate the starting page */
	realpage = (int) (from >> this->page_shift);
	page = realpage & this->pagemask;
33d05404:	e0015002 	and	r5, r1, r2
	/* Autoplace of oob data ? Use the default placement scheme */
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
		oobsel = this->autooob;

	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
	oob_config = oobsel->eccpos;
33d05408:	e2892048 	add	r2, r9, #72	; 0x48
	/* First we calculate the starting page */
	realpage = (int) (from >> this->page_shift);
	page = realpage & this->pagemask;

	/* Get raw starting column */
	col = from & (mtd->oobblock - 1);
33d0540c:	e58d3048 	str	r3, [sp, #72]
	/* Autoplace of oob data ? Use the default placement scheme */
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
		oobsel = this->autooob;

	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
	oob_config = oobsel->eccpos;
33d05410:	e58d201c 	str	r2, [sp, #28]

	/* Get raw starting column */
	col = from & (mtd->oobblock - 1);

	end = mtd->oobblock;
	ecc = this->eccsize;
33d05414:	e5973058 	ldr	r3, [r7, #88]
	eccbytes = this->eccbytes;

	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
33d05418:	e59d0020 	ldr	r0, [sp, #32]

	/* Get raw starting column */
	col = from & (mtd->oobblock - 1);

	end = mtd->oobblock;
	ecc = this->eccsize;
33d0541c:	e58d3040 	str	r3, [sp, #64]
	eccbytes = this->eccbytes;

	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
33d05420:	e3500000 	cmp	r0, #0	; 0x0
	/* Get raw starting column */
	col = from & (mtd->oobblock - 1);

	end = mtd->oobblock;
	ecc = this->eccsize;
	eccbytes = this->eccbytes;
33d05424:	e597005c 	ldr	r0, [r7, #92]
33d05428:	e58d0014 	str	r0, [sp, #20]

	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
33d0542c:	0a000002 	beq	33d0543c <nand_read_ecc+0x154>
33d05430:	e5973088 	ldr	r3, [r7, #136]
33d05434:	e3130802 	tst	r3, #131072	; 0x20000
33d05438:	0a000001 	beq	33d05444 <nand_read_ecc+0x15c>
		compareecc = 0;
33d0543c:	e3a01000 	mov	r1, #0	; 0x0
33d05440:	e58d1010 	str	r1, [sp, #16]

	oobreadlen = mtd->oobsize;
33d05444:	e59a2014 	ldr	r2, [sl, #20]
	if (this->options & NAND_HWECC_SYNDROME)
33d05448:	e5973088 	ldr	r3, [r7, #136]
	eccbytes = this->eccbytes;

	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
		compareecc = 0;

	oobreadlen = mtd->oobsize;
33d0544c:	e58d200c 	str	r2, [sp, #12]
	if (this->options & NAND_HWECC_SYNDROME)
33d05450:	e3130802 	tst	r3, #131072	; 0x20000
		oobreadlen -= oobsel->eccbytes;
33d05454:	15993004 	ldrne	r3, [r9, #4]
		}
		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		*/
		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
			sndcmd = 1;
33d05458:	e59d004c 	ldr	r0, [sp, #76]
	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
		compareecc = 0;

	oobreadlen = mtd->oobsize;
	if (this->options & NAND_HWECC_SYNDROME)
		oobreadlen -= oobsel->eccbytes;
33d0545c:	10632002 	rsbne	r2, r3, r2
		}
		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		*/
		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
			sndcmd = 1;
33d05460:	e59d3034 	ldr	r3, [sp, #52]
	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
		compareecc = 0;

	oobreadlen = mtd->oobsize;
	if (this->options & NAND_HWECC_SYNDROME)
		oobreadlen -= oobsel->eccbytes;
33d05464:	158d200c 	strne	r2, [sp, #12]
		}
		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		*/
		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
			sndcmd = 1;
33d05468:	e1530000 	cmp	r3, r0
33d0546c:	2a000146 	bcs	33d0598c <nand_read_ecc+0x6a4>
		oobreadlen -= oobsel->eccbytes;

	/* Loop until all data read */
	while (read < len) {

		int aligned = (!col && (len - read) >= end);
33d05470:	e59d1048 	ldr	r1, [sp, #72]
33d05474:	e3a02000 	mov	r2, #0	; 0x0
33d05478:	e3510000 	cmp	r1, #0	; 0x0
33d0547c:	e58d2004 	str	r2, [sp, #4]
33d05480:	1a00000b 	bne	33d054b4 <nand_read_ecc+0x1cc>
33d05484:	e59d004c 	ldr	r0, [sp, #76]
33d05488:	e59d1034 	ldr	r1, [sp, #52]
33d0548c:	e59d2008 	ldr	r2, [sp, #8]
33d05490:	e0613000 	rsb	r3, r1, r0
33d05494:	e1530002 	cmp	r3, r2
33d05498:	3a000005 	bcc	33d054b4 <nand_read_ecc+0x1cc>
		/*
		 * If the read is not page aligned, we have to read into data buffer
		 * due to ecc, else we read into return buffer direct
		 */
		if (aligned)
			data_poi = &buf[read];
33d0549c:	e59d00b4 	ldr	r0, [sp, #180]
		oobreadlen -= oobsel->eccbytes;

	/* Loop until all data read */
	while (read < len) {

		int aligned = (!col && (len - read) >= end);
33d054a0:	e3a03001 	mov	r3, #1	; 0x1
		/*
		 * If the read is not page aligned, we have to read into data buffer
		 * due to ecc, else we read into return buffer direct
		 */
		if (aligned)
			data_poi = &buf[read];
33d054a4:	e0800001 	add	r0, r0, r1
		oobreadlen -= oobsel->eccbytes;

	/* Loop until all data read */
	while (read < len) {

		int aligned = (!col && (len - read) >= end);
33d054a8:	e58d3004 	str	r3, [sp, #4]
		/*
		 * If the read is not page aligned, we have to read into data buffer
		 * due to ecc, else we read into return buffer direct
		 */
		if (aligned)
			data_poi = &buf[read];
33d054ac:	e58d0028 	str	r0, [sp, #40]
33d054b0:	ea000001 	b	33d054bc <nand_read_ecc+0x1d4>
		else
			data_poi = this->data_buf;
33d054b4:	e5971078 	ldr	r1, [r7, #120]
33d054b8:	e58d1028 	str	r1, [sp, #40]
		/* Check, if we have this page in the buffer
		 *
		 * FIXME: Make it work when we must provide oob data too,
		 * check the usage of data_buf oob field
		 */
		if (realpage == this->pagebuf && !oob_buf) {
33d054bc:	e597309c 	ldr	r3, [r7, #156]
33d054c0:	e59d2044 	ldr	r2, [sp, #68]
33d054c4:	e59d00b8 	ldr	r0, [sp, #184]
33d054c8:	e1520003 	cmp	r2, r3
33d054cc:	03500000 	cmpeq	r0, #0	; 0x0
33d054d0:	13a04000 	movne	r4, #0	; 0x0
33d054d4:	03a04001 	moveq	r4, #1	; 0x1
33d054d8:	1a000007 	bne	33d054fc <nand_read_ecc+0x214>
			/* aligned read ? */
			if (aligned)
33d054dc:	e59d1004 	ldr	r1, [sp, #4]
33d054e0:	e3510000 	cmp	r1, #0	; 0x0
33d054e4:	0a0000e3 	beq	33d05878 <nand_read_ecc+0x590>
				memcpy (data_poi, this->data_buf, end);
33d054e8:	e59d0028 	ldr	r0, [sp, #40]
33d054ec:	e5971078 	ldr	r1, [r7, #120]
33d054f0:	e59d2008 	ldr	r2, [sp, #8]
33d054f4:	eb0053ba 	bl	33d1a3e4 <memcpy>
			goto readdata;
33d054f8:	ea0000d7 	b	33d0585c <nand_read_ecc+0x574>
		}

		/* Check, if we must send the read command */
		if (sndcmd) {
33d054fc:	e59d2038 	ldr	r2, [sp, #56]
33d05500:	e3520000 	cmp	r2, #0	; 0x0
33d05504:	0a000006 	beq	33d05524 <nand_read_ecc+0x23c>
			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
33d05508:	e1a03005 	mov	r3, r5
33d0550c:	e1a0000a 	mov	r0, sl
33d05510:	e1a01004 	mov	r1, r4
33d05514:	e1a02004 	mov	r2, r4
33d05518:	e1a0e00f 	mov	lr, pc
33d0551c:	e597f038 	ldr	pc, [r7, #56]
			sndcmd = 0;
33d05520:	e58d4038 	str	r4, [sp, #56]
		}

		/* get oob area, if we have no oob buffer from fs-driver */
		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
33d05524:	e59d30b8 	ldr	r3, [sp, #184]
33d05528:	e3530000 	cmp	r3, #0	; 0x0
33d0552c:	0a000004 	beq	33d05544 <nand_read_ecc+0x25c>
33d05530:	e5993000 	ldr	r3, [r9]
33d05534:	e3530002 	cmp	r3, #2	; 0x2
33d05538:	0a000001 	beq	33d05544 <nand_read_ecc+0x25c>
33d0553c:	e3530004 	cmp	r3, #4	; 0x4
33d05540:	1a000003 	bne	33d05554 <nand_read_ecc+0x26c>
			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
			oob_data = &this->data_buf[end];
33d05544:	e5973078 	ldr	r3, [r7, #120]
33d05548:	e59d0008 	ldr	r0, [sp, #8]
33d0554c:	e0833000 	add	r3, r3, r0
33d05550:	e58d3024 	str	r3, [sp, #36]

		eccsteps = this->eccsteps;

		switch (eccmode) {
33d05554:	e59d1020 	ldr	r1, [sp, #32]
33d05558:	e3510000 	cmp	r1, #0	; 0x0
		/* get oob area, if we have no oob buffer from fs-driver */
		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
			oob_data = &this->data_buf[end];

		eccsteps = this->eccsteps;
33d0555c:	e5974060 	ldr	r4, [r7, #96]

		switch (eccmode) {
33d05560:	0a000002 	beq	33d05570 <nand_read_ecc+0x288>
33d05564:	e3510001 	cmp	r1, #1	; 0x1
33d05568:	0a000006 	beq	33d05588 <nand_read_ecc+0x2a0>
33d0556c:	ea00001b 	b	33d055e0 <nand_read_ecc+0x2f8>
				lastwhinge = jiffies;
			}
#else
			//puts("Reading data from NAND FLASH without ECC is not recommended\n");
#endif
			this->read_buf(mtd, data_poi, end);
33d05570:	e1a0000a 	mov	r0, sl
33d05574:	e59d1028 	ldr	r1, [sp, #40]
33d05578:	e59d2008 	ldr	r2, [sp, #8]
33d0557c:	e1a0e00f 	mov	lr, pc
33d05580:	e597f01c 	ldr	pc, [r7, #28]
			break;
33d05584:	ea00004b 	b	33d056b8 <nand_read_ecc+0x3d0>
		}

		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
			this->read_buf(mtd, data_poi, end);
33d05588:	e1a0000a 	mov	r0, sl
33d0558c:	e59d1028 	ldr	r1, [sp, #40]
33d05590:	e59d2008 	ldr	r2, [sp, #8]
33d05594:	e1a0e00f 	mov	lr, pc
33d05598:	e597f01c 	ldr	pc, [r7, #28]
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
33d0559c:	e3a05000 	mov	r5, #0	; 0x0
33d055a0:	e3540000 	cmp	r4, #0	; 0x0
33d055a4:	e1a0b005 	mov	fp, r5
33d055a8:	0a000042 	beq	33d056b8 <nand_read_ecc+0x3d0>
				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
33d055ac:	e59d3028 	ldr	r3, [sp, #40]
33d055b0:	e28d2070 	add	r2, sp, #112	; 0x70
33d055b4:	e0822005 	add	r2, r2, r5
33d055b8:	e083100b 	add	r1, r3, fp
33d055bc:	e1a0000a 	mov	r0, sl
33d055c0:	e1a0e00f 	mov	lr, pc
33d055c4:	e597f040 	ldr	pc, [r7, #64]
			break;
		}

		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
			this->read_buf(mtd, data_poi, end);
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
33d055c8:	e59d0040 	ldr	r0, [sp, #64]
33d055cc:	e2544001 	subs	r4, r4, #1	; 0x1
33d055d0:	e2855003 	add	r5, r5, #3	; 0x3
33d055d4:	e08bb000 	add	fp, fp, r0
33d055d8:	1afffff3 	bne	33d055ac <nand_read_ecc+0x2c4>
				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
			break;
33d055dc:	ea000035 	b	33d056b8 <nand_read_ecc+0x3d0>

		default:
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
33d055e0:	e3a05000 	mov	r5, #0	; 0x0
33d055e4:	e3540000 	cmp	r4, #0	; 0x0
33d055e8:	e1a0b005 	mov	fp, r5
33d055ec:	0a000031 	beq	33d056b8 <nand_read_ecc+0x3d0>
				 * syndrome from flash immidiately after the data */
				if (!compareecc) {
					/* Some hw ecc generators need to know when the
					 * syndrome is read from flash */
					this->enable_hwecc(mtd, NAND_ECC_READSYN);
					this->read_buf(mtd, &oob_data[i], eccbytes);
33d055f0:	e28d1024 	add	r1, sp, #36	; 0x24
33d055f4:	e8910006 	ldm	r1, {r1, r2}
33d055f8:	e0811005 	add	r1, r1, r5
			break;

		default:
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
				this->enable_hwecc(mtd, NAND_ECC_READ);
				this->read_buf(mtd, &data_poi[datidx], ecc);
33d055fc:	e082600b 	add	r6, r2, fp
				 * syndrome from flash immidiately after the data */
				if (!compareecc) {
					/* Some hw ecc generators need to know when the
					 * syndrome is read from flash */
					this->enable_hwecc(mtd, NAND_ECC_READSYN);
					this->read_buf(mtd, &oob_data[i], eccbytes);
33d05600:	e58d1000 	str	r1, [sp]
				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
			break;

		default:
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
				this->enable_hwecc(mtd, NAND_ECC_READ);
33d05604:	e1a0000a 	mov	r0, sl
33d05608:	e3a01000 	mov	r1, #0	; 0x0
33d0560c:	e1a0e00f 	mov	lr, pc
33d05610:	e597f048 	ldr	pc, [r7, #72]
				this->read_buf(mtd, &data_poi[datidx], ecc);
33d05614:	e59d2040 	ldr	r2, [sp, #64]
33d05618:	e1a0000a 	mov	r0, sl
33d0561c:	e1a01006 	mov	r1, r6
33d05620:	e1a0e00f 	mov	lr, pc
33d05624:	e597f01c 	ldr	pc, [r7, #28]

				/* HW ecc with syndrome calculation must read the
				 * syndrome from flash immidiately after the data */
				if (!compareecc) {
33d05628:	e59d3010 	ldr	r3, [sp, #16]
						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
						ecc_failed++;
					}
				} else {
					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
33d0562c:	e28d2070 	add	r2, sp, #112	; 0x70
				this->enable_hwecc(mtd, NAND_ECC_READ);
				this->read_buf(mtd, &data_poi[datidx], ecc);

				/* HW ecc with syndrome calculation must read the
				 * syndrome from flash immidiately after the data */
				if (!compareecc) {
33d05630:	e3530000 	cmp	r3, #0	; 0x0
					/* Some hw ecc generators need to know when the
					 * syndrome is read from flash */
					this->enable_hwecc(mtd, NAND_ECC_READSYN);
33d05634:	e1a0000a 	mov	r0, sl
33d05638:	e3a01002 	mov	r1, #2	; 0x2
						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
						ecc_failed++;
					}
				} else {
					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
33d0563c:	e0822005 	add	r2, r2, r5
				this->enable_hwecc(mtd, NAND_ECC_READ);
				this->read_buf(mtd, &data_poi[datidx], ecc);

				/* HW ecc with syndrome calculation must read the
				 * syndrome from flash immidiately after the data */
				if (!compareecc) {
33d05640:	1a000012 	bne	33d05690 <nand_read_ecc+0x3a8>
					/* Some hw ecc generators need to know when the
					 * syndrome is read from flash */
					this->enable_hwecc(mtd, NAND_ECC_READSYN);
33d05644:	e1a0e00f 	mov	lr, pc
33d05648:	e597f048 	ldr	pc, [r7, #72]
					this->read_buf(mtd, &oob_data[i], eccbytes);
33d0564c:	e1a0000a 	mov	r0, sl
33d05650:	e59d1000 	ldr	r1, [sp]
33d05654:	e59d2014 	ldr	r2, [sp, #20]
33d05658:	e1a0e00f 	mov	lr, pc
33d0565c:	e597f01c 	ldr	pc, [r7, #28]
					/* We calc error correction directly, it checks the hw
					 * generator for an error, reads back the syndrome and
					 * does the error correction on the fly */
					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
33d05660:	e28d3050 	add	r3, sp, #80	; 0x50
33d05664:	e0833005 	add	r3, r3, r5
33d05668:	e1a01006 	mov	r1, r6
33d0566c:	e59d2000 	ldr	r2, [sp]
33d05670:	e1a0000a 	mov	r0, sl
33d05674:	e1a0e00f 	mov	lr, pc
33d05678:	e597f044 	ldr	pc, [r7, #68]
33d0567c:	e3700001 	cmn	r0, #1	; 0x1
						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
						ecc_failed++;
33d05680:	059d002c 	ldreq	r0, [sp, #44]
33d05684:	02800001 	addeq	r0, r0, #1	; 0x1
33d05688:	058d002c 	streq	r0, [sp, #44]
33d0568c:	ea000003 	b	33d056a0 <nand_read_ecc+0x3b8>
					}
				} else {
					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
33d05690:	e1a01006 	mov	r1, r6
33d05694:	e1a0000a 	mov	r0, sl
33d05698:	e1a0e00f 	mov	lr, pc
33d0569c:	e597f040 	ldr	pc, [r7, #64]
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
			break;

		default:
			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
33d056a0:	e59d1014 	ldr	r1, [sp, #20]
33d056a4:	e59d2040 	ldr	r2, [sp, #64]
33d056a8:	e2544001 	subs	r4, r4, #1	; 0x1
33d056ac:	e0855001 	add	r5, r5, r1
33d056b0:	e08bb002 	add	fp, fp, r2
33d056b4:	1affffcd 	bne	33d055f0 <nand_read_ecc+0x308>
			}
			break;
		}

		/* read oobdata */
		this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
33d056b8:	e59d300c 	ldr	r3, [sp, #12]
33d056bc:	e59a1014 	ldr	r1, [sl, #20]
33d056c0:	e59d0024 	ldr	r0, [sp, #36]
33d056c4:	e0631001 	rsb	r1, r3, r1
33d056c8:	e0801001 	add	r1, r0, r1
33d056cc:	e1a02003 	mov	r2, r3
33d056d0:	e1a0000a 	mov	r0, sl
33d056d4:	e1a0e00f 	mov	lr, pc
33d056d8:	e597f01c 	ldr	pc, [r7, #28]

		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
		if (!compareecc)
33d056dc:	e59d1010 	ldr	r1, [sp, #16]
33d056e0:	e3510000 	cmp	r1, #0	; 0x0
33d056e4:	0a000031 	beq	33d057b0 <nand_read_ecc+0x4c8>
			goto readoob;

		/* Pick the ECC bytes out of the oob data */
		for (j = 0; j < oobsel->eccbytes; j++)
33d056e8:	e5993004 	ldr	r3, [r9, #4]
33d056ec:	e3a06000 	mov	r6, #0	; 0x0
33d056f0:	e1560003 	cmp	r6, r3
33d056f4:	2a000009 	bcs	33d05720 <nand_read_ecc+0x438>
33d056f8:	e28d2050 	add	r2, sp, #80	; 0x50
			ecc_code[j] = oob_data[oob_config[j]];
33d056fc:	e59d001c 	ldr	r0, [sp, #28]
33d05700:	e59d1024 	ldr	r1, [sp, #36]
33d05704:	e7903106 	ldr	r3, [r0, r6, lsl #2]
33d05708:	e7d13003 	ldrb	r3, [r1, r3]
33d0570c:	e4c23001 	strb	r3, [r2], #1
		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
		if (!compareecc)
			goto readoob;

		/* Pick the ECC bytes out of the oob data */
		for (j = 0; j < oobsel->eccbytes; j++)
33d05710:	e5993004 	ldr	r3, [r9, #4]
33d05714:	e2866001 	add	r6, r6, #1	; 0x1
33d05718:	e1560003 	cmp	r6, r3
33d0571c:	3afffff6 	bcc	33d056fc <nand_read_ecc+0x414>
			ecc_code[j] = oob_data[oob_config[j]];

		/* correct data, if neccecary */
		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
33d05720:	e5973060 	ldr	r3, [r7, #96]
33d05724:	e3a06000 	mov	r6, #0	; 0x0
33d05728:	e1560003 	cmp	r6, r3
33d0572c:	e1a05006 	mov	r5, r6
33d05730:	e1a0b006 	mov	fp, r6
33d05734:	aa00001d 	bge	33d057b0 <nand_read_ecc+0x4c8>
			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
33d05738:	e59d0028 	ldr	r0, [sp, #40]
33d0573c:	e28d2050 	add	r2, sp, #80	; 0x50
33d05740:	e28d3070 	add	r3, sp, #112	; 0x70
33d05744:	e080100b 	add	r1, r0, fp
33d05748:	e0822006 	add	r2, r2, r6
33d0574c:	e0833006 	add	r3, r3, r6
33d05750:	e1a0000a 	mov	r0, sl
33d05754:	e1a0e00f 	mov	lr, pc
33d05758:	e597f044 	ldr	pc, [r7, #68]

			/* Check, if we have a fs supplied oob-buffer,
			 * This is the legacy mode. Used by YAFFS1
			 * Should go away some day
			 */
			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
33d0575c:	e59d10b8 	ldr	r1, [sp, #184]
		/* Pick the ECC bytes out of the oob data */
		for (j = 0; j < oobsel->eccbytes; j++)
			ecc_code[j] = oob_data[oob_config[j]];

		/* correct data, if neccecary */
		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
33d05760:	e59d2040 	ldr	r2, [sp, #64]
			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);

			/* Get next chunk of ecc bytes */
			j += eccbytes;
33d05764:	e59d3014 	ldr	r3, [sp, #20]

			/* Check, if we have a fs supplied oob-buffer,
			 * This is the legacy mode. Used by YAFFS1
			 * Should go away some day
			 */
			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
33d05768:	e3510000 	cmp	r1, #0	; 0x0
		/* Pick the ECC bytes out of the oob data */
		for (j = 0; j < oobsel->eccbytes; j++)
			ecc_code[j] = oob_data[oob_config[j]];

		/* correct data, if neccecary */
		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
33d0576c:	e08bb002 	add	fp, fp, r2
			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);

			/* Get next chunk of ecc bytes */
			j += eccbytes;
33d05770:	e0866003 	add	r6, r6, r3

			/* Check, if we have a fs supplied oob-buffer,
			 * This is the legacy mode. Used by YAFFS1
			 * Should go away some day
			 */
			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
33d05774:	0a000005 	beq	33d05790 <nand_read_ecc+0x4a8>
33d05778:	e5993000 	ldr	r3, [r9]
33d0577c:	e3530001 	cmp	r3, #1	; 0x1
				int *p = (int *)(&oob_data[mtd->oobsize]);
33d05780:	059a3014 	ldreq	r3, [sl, #20]
33d05784:	059d1024 	ldreq	r1, [sp, #36]
33d05788:	00813003 	addeq	r3, r1, r3
				p[i] = ecc_status;
33d0578c:	07830105 	streq	r0, [r3, r5, lsl #2]
			}

			if (ecc_status == -1) {
33d05790:	e3700001 	cmn	r0, #1	; 0x1
				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
				ecc_failed++;
33d05794:	059d202c 	ldreq	r2, [sp, #44]
33d05798:	02822001 	addeq	r2, r2, #1	; 0x1
33d0579c:	058d202c 	streq	r2, [sp, #44]
		/* Pick the ECC bytes out of the oob data */
		for (j = 0; j < oobsel->eccbytes; j++)
			ecc_code[j] = oob_data[oob_config[j]];

		/* correct data, if neccecary */
		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
33d057a0:	e5973060 	ldr	r3, [r7, #96]
33d057a4:	e2855001 	add	r5, r5, #1	; 0x1
33d057a8:	e1550003 	cmp	r5, r3
33d057ac:	eaffffe0 	b	33d05734 <nand_read_ecc+0x44c>
			}
		}

	readoob:
		/* check, if we have a fs supplied oob-buffer */
		if (oob_buf) {
33d057b0:	e59d30b8 	ldr	r3, [sp, #184]
33d057b4:	e3530000 	cmp	r3, #0	; 0x0
33d057b8:	0a000027 	beq	33d0585c <nand_read_ecc+0x574>
			/* without autoplace. Legacy mode used by YAFFS1 */
			switch(oobsel->useecc) {
33d057bc:	e5993000 	ldr	r3, [r9]
33d057c0:	e3530002 	cmp	r3, #2	; 0x2
33d057c4:	0a000008 	beq	33d057ec <nand_read_ecc+0x504>
33d057c8:	8a000005 	bhi	33d057e4 <nand_read_ecc+0x4fc>
33d057cc:	e3530001 	cmp	r3, #1	; 0x1
				}
				oob += mtd->oobavail;
				break;
			case MTD_NANDECC_PLACE:
				/* YAFFS1 legacy mode */
				oob_data += this->eccsteps * sizeof (int);
33d057d0:	05973060 	ldreq	r3, [r7, #96]
33d057d4:	059d1024 	ldreq	r1, [sp, #36]
33d057d8:	00811103 	addeq	r1, r1, r3, lsl #2
33d057dc:	058d1024 	streq	r1, [sp, #36]
33d057e0:	ea000019 	b	33d0584c <nand_read_ecc+0x564>

	readoob:
		/* check, if we have a fs supplied oob-buffer */
		if (oob_buf) {
			/* without autoplace. Legacy mode used by YAFFS1 */
			switch(oobsel->useecc) {
33d057e4:	e3530004 	cmp	r3, #4	; 0x4
33d057e8:	1a000017 	bne	33d0584c <nand_read_ecc+0x564>
			case MTD_NANDECC_AUTOPLACE:
			case MTD_NANDECC_AUTOPL_USR:
				/* Walk through the autoplace chunks */
				for (i = 0, j = 0; j < mtd->oobavail; i++) {
33d057ec:	e59a3018 	ldr	r3, [sl, #24]
33d057f0:	e3a06000 	mov	r6, #0	; 0x0
33d057f4:	e1560003 	cmp	r6, r3
33d057f8:	2a00000e 	bcs	33d05838 <nand_read_ecc+0x550>
33d057fc:	e1a05009 	mov	r5, r9
					int from = oobsel->oobfree[i][0];
					int num = oobsel->oobfree[i][1];
33d05800:	e2851008 	add	r1, r5, #8	; 0x8
33d05804:	e8910012 	ldm	r1, {r1, r4}
					memcpy(&oob_buf[oob], &oob_data[from], num);
33d05808:	e59d0024 	ldr	r0, [sp, #36]
33d0580c:	e59d20b8 	ldr	r2, [sp, #184]
33d05810:	e59d3030 	ldr	r3, [sp, #48]
33d05814:	e0801001 	add	r1, r0, r1
33d05818:	e0820003 	add	r0, r2, r3
33d0581c:	e1a02004 	mov	r2, r4
33d05820:	eb0052ef 	bl	33d1a3e4 <memcpy>
			/* without autoplace. Legacy mode used by YAFFS1 */
			switch(oobsel->useecc) {
			case MTD_NANDECC_AUTOPLACE:
			case MTD_NANDECC_AUTOPL_USR:
				/* Walk through the autoplace chunks */
				for (i = 0, j = 0; j < mtd->oobavail; i++) {
33d05824:	e59a3018 	ldr	r3, [sl, #24]
					int from = oobsel->oobfree[i][0];
					int num = oobsel->oobfree[i][1];
					memcpy(&oob_buf[oob], &oob_data[from], num);
					j+= num;
33d05828:	e0866004 	add	r6, r6, r4
			/* without autoplace. Legacy mode used by YAFFS1 */
			switch(oobsel->useecc) {
			case MTD_NANDECC_AUTOPLACE:
			case MTD_NANDECC_AUTOPL_USR:
				/* Walk through the autoplace chunks */
				for (i = 0, j = 0; j < mtd->oobavail; i++) {
33d0582c:	e1560003 	cmp	r6, r3
33d05830:	e2855008 	add	r5, r5, #8	; 0x8
33d05834:	3afffff1 	bcc	33d05800 <nand_read_ecc+0x518>
					int from = oobsel->oobfree[i][0];
					int num = oobsel->oobfree[i][1];
					memcpy(&oob_buf[oob], &oob_data[from], num);
					j+= num;
				}
				oob += mtd->oobavail;
33d05838:	e59a3018 	ldr	r3, [sl, #24]
33d0583c:	e59d0030 	ldr	r0, [sp, #48]
33d05840:	e0800003 	add	r0, r0, r3
33d05844:	e58d0030 	str	r0, [sp, #48]
				break;
33d05848:	ea000003 	b	33d0585c <nand_read_ecc+0x574>
			case MTD_NANDECC_PLACE:
				/* YAFFS1 legacy mode */
				oob_data += this->eccsteps * sizeof (int);
			default:
				oob_data += mtd->oobsize;
33d0584c:	e59a3014 	ldr	r3, [sl, #20]
33d05850:	e59d2024 	ldr	r2, [sp, #36]
33d05854:	e0822003 	add	r2, r2, r3
33d05858:	e58d2024 	str	r2, [sp, #36]
			}
		}
	readdata:
		/* Partial page read, transfer data into fs buffer */
		if (!aligned) {
33d0585c:	e59d3004 	ldr	r3, [sp, #4]
33d05860:	e3530000 	cmp	r3, #0	; 0x0
			for (j = col; j < end && read < len; j++)
				buf[read++] = data_poi[j];
			this->pagebuf = realpage;
		} else
			read += mtd->oobblock;
33d05864:	159a3010 	ldrne	r3, [sl, #16]
33d05868:	159d0034 	ldrne	r0, [sp, #52]
33d0586c:	10800003 	addne	r0, r0, r3
33d05870:	158d0034 	strne	r0, [sp, #52]
				oob_data += mtd->oobsize;
			}
		}
	readdata:
		/* Partial page read, transfer data into fs buffer */
		if (!aligned) {
33d05874:	1a000016 	bne	33d058d4 <nand_read_ecc+0x5ec>
			for (j = col; j < end && read < len; j++)
33d05878:	e59d6048 	ldr	r6, [sp, #72]
33d0587c:	e59d0008 	ldr	r0, [sp, #8]
33d05880:	e59d1034 	ldr	r1, [sp, #52]
33d05884:	e59d204c 	ldr	r2, [sp, #76]
33d05888:	e1560000 	cmp	r6, r0
33d0588c:	a3a03000 	movge	r3, #0	; 0x0
33d05890:	b3a03001 	movlt	r3, #1	; 0x1
33d05894:	e1510002 	cmp	r1, r2
33d05898:	23a03000 	movcs	r3, #0	; 0x0
33d0589c:	e3530000 	cmp	r3, #0	; 0x0
33d058a0:	0a000009 	beq	33d058cc <nand_read_ecc+0x5e4>
				buf[read++] = data_poi[j];
33d058a4:	e59d0028 	ldr	r0, [sp, #40]
33d058a8:	e59d1034 	ldr	r1, [sp, #52]
33d058ac:	e7d03006 	ldrb	r3, [r0, r6]
33d058b0:	e59d20b4 	ldr	r2, [sp, #180]
33d058b4:	e7c13002 	strb	r3, [r1, r2]
			}
		}
	readdata:
		/* Partial page read, transfer data into fs buffer */
		if (!aligned) {
			for (j = col; j < end && read < len; j++)
33d058b8:	e59d0008 	ldr	r0, [sp, #8]
				buf[read++] = data_poi[j];
33d058bc:	e2811001 	add	r1, r1, #1	; 0x1
			}
		}
	readdata:
		/* Partial page read, transfer data into fs buffer */
		if (!aligned) {
			for (j = col; j < end && read < len; j++)
33d058c0:	e2866001 	add	r6, r6, #1	; 0x1
				buf[read++] = data_poi[j];
33d058c4:	e58d1034 	str	r1, [sp, #52]
33d058c8:	eaffffed 	b	33d05884 <nand_read_ecc+0x59c>
			this->pagebuf = realpage;
33d058cc:	e59d3044 	ldr	r3, [sp, #68]
33d058d0:	e587309c 	str	r3, [r7, #156]
		/* Apply delay or wait for ready/busy pin
		 * Do this before the AUTOINCR check, so no problems
		 * arise if a chip which does auto increment
		 * is marked as NOAUTOINCR by the board driver.
		*/
		if (!this->dev_ready)
33d058d4:	e5973034 	ldr	r3, [r7, #52]
33d058d8:	e3530000 	cmp	r3, #0	; 0x0
33d058dc:	1a000002 	bne	33d058ec <nand_read_ecc+0x604>
			udelay (this->chip_delay);
33d058e0:	e5970064 	ldr	r0, [r7, #100]
33d058e4:	ebffed48 	bl	33d00e0c <udelay>
33d058e8:	ea000004 	b	33d05900 <nand_read_ecc+0x618>
		else
			while (!this->dev_ready(mtd));
33d058ec:	e1a0000a 	mov	r0, sl
33d058f0:	e1a0e00f 	mov	lr, pc
33d058f4:	e597f034 	ldr	pc, [r7, #52]
33d058f8:	e3500000 	cmp	r0, #0	; 0x0
33d058fc:	0afffffa 	beq	33d058ec <nand_read_ecc+0x604>

		if (read == len)
33d05900:	e59d1034 	ldr	r1, [sp, #52]
33d05904:	e59d204c 	ldr	r2, [sp, #76]
33d05908:	e1510002 	cmp	r1, r2
33d0590c:	0a00001e 	beq	33d0598c <nand_read_ecc+0x6a4>
			break;

		/* For subsequent reads align to page boundary. */
		col = 0;
		/* Increment page address */
		realpage++;
33d05910:	e59d0044 	ldr	r0, [sp, #68]

		page = realpage & this->pagemask;
33d05914:	e5973098 	ldr	r3, [r7, #152]
			break;

		/* For subsequent reads align to page boundary. */
		col = 0;
		/* Increment page address */
		realpage++;
33d05918:	e2800001 	add	r0, r0, #1	; 0x1

		if (read == len)
			break;

		/* For subsequent reads align to page boundary. */
		col = 0;
33d0591c:	e3a01000 	mov	r1, #0	; 0x0
		/* Increment page address */
		realpage++;

		page = realpage & this->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
33d05920:	e0105003 	ands	r5, r0, r3
			break;

		/* For subsequent reads align to page boundary. */
		col = 0;
		/* Increment page address */
		realpage++;
33d05924:	e58d0044 	str	r0, [sp, #68]

		if (read == len)
			break;

		/* For subsequent reads align to page boundary. */
		col = 0;
33d05928:	e58d1048 	str	r1, [sp, #72]
		/* Increment page address */
		realpage++;

		page = realpage & this->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
33d0592c:	1a00000a 	bne	33d0595c <nand_read_ecc+0x674>
			chipnr++;
33d05930:	e59d203c 	ldr	r2, [sp, #60]
33d05934:	e2822001 	add	r2, r2, #1	; 0x1
			this->select_chip(mtd, -1);
33d05938:	e1a0000a 	mov	r0, sl
33d0593c:	e2411001 	sub	r1, r1, #1	; 0x1
		realpage++;

		page = realpage & this->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
			chipnr++;
33d05940:	e58d203c 	str	r2, [sp, #60]
			this->select_chip(mtd, -1);
33d05944:	e1a0e00f 	mov	lr, pc
33d05948:	e597f024 	ldr	pc, [r7, #36]
			this->select_chip(mtd, chipnr);
33d0594c:	e1a0000a 	mov	r0, sl
33d05950:	e59d103c 	ldr	r1, [sp, #60]
33d05954:	e1a0e00f 	mov	lr, pc
33d05958:	e597f024 	ldr	pc, [r7, #36]
		}
		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		*/
		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
33d0595c:	e5973088 	ldr	r3, [r7, #136]
33d05960:	e3130001 	tst	r3, #1	; 0x1
33d05964:	1a000002 	bne	33d05974 <nand_read_ecc+0x68c>
33d05968:	e59d3018 	ldr	r3, [sp, #24]
33d0596c:	e1150003 	tst	r5, r3
33d05970:	1a000001 	bne	33d0597c <nand_read_ecc+0x694>
			sndcmd = 1;
33d05974:	e3a00001 	mov	r0, #1	; 0x1
33d05978:	e58d0038 	str	r0, [sp, #56]
33d0597c:	e59d1034 	ldr	r1, [sp, #52]
33d05980:	e59d204c 	ldr	r2, [sp, #76]
33d05984:	e1510002 	cmp	r1, r2
33d05988:	eafffeb7 	b	33d0546c <nand_read_ecc+0x184>
	}

	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d0598c:	e1a0000a 	mov	r0, sl
33d05990:	ebfffb9e 	bl	33d04810 <nand_release_device>
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	*retlen = read;
33d05994:	e59d0034 	ldr	r0, [sp, #52]
33d05998:	e59d30b0 	ldr	r3, [sp, #176]
33d0599c:	e5830000 	str	r0, [r3]
	return ecc_failed ? -EBADMSG : 0;
33d059a0:	e59d102c 	ldr	r1, [sp, #44]
33d059a4:	e3510000 	cmp	r1, #0	; 0x0
33d059a8:	e1a00001 	mov	r0, r1
33d059ac:	13e00049 	mvnne	r0, #73	; 0x49
}
33d059b0:	e28dd090 	add	sp, sp, #144	; 0x90
33d059b4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d059b8 <nand_read>:
 * @buf:	the databuffer to put data
 *
 * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
*/
static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
33d059b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d059bc:	e24dd010 	sub	sp, sp, #16	; 0x10
	return nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
33d059c0:	e59de014 	ldr	lr, [sp, #20]
33d059c4:	e58de000 	str	lr, [sp]
33d059c8:	e59de018 	ldr	lr, [sp, #24]
33d059cc:	e3a0c000 	mov	ip, #0	; 0x0
33d059d0:	e58de004 	str	lr, [sp, #4]
33d059d4:	e58dc00c 	str	ip, [sp, #12]
33d059d8:	e58dc008 	str	ip, [sp, #8]
33d059dc:	ebfffe41 	bl	33d052e8 <nand_read_ecc>
}
33d059e0:	e28dd010 	add	sp, sp, #16	; 0x10
33d059e4:	e8bd8000 	pop	{pc}

33d059e8 <nand_read_oob>:
 * @buf:	the databuffer to put data
 *
 * NAND read out-of-band data from the spare area
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
33d059e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int i, col, page, chipnr;
	struct nand_chip *this = mtd->priv;
33d059ec:	e590613c 	ldr	r6, [r0, #316]
 * @buf:	the databuffer to put data
 *
 * NAND read out-of-band data from the spare area
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
33d059f0:	e1a07000 	mov	r7, r0
	int i, col, page, chipnr;
	struct nand_chip *this = mtd->priv;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d059f4:	e286006c 	add	r0, r6, #108	; 0x6c
33d059f8:	e8104001 	ldmda	r0, {r0, lr}
33d059fc:	e04ee000 	sub	lr, lr, r0
 * @buf:	the databuffer to put data
 *
 * NAND read out-of-band data from the spare area
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
33d05a00:	e1a05002 	mov	r5, r2
33d05a04:	e1a04001 	mov	r4, r1
	int i, col, page, chipnr;
	struct nand_chip *this = mtd->priv;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05a08:	e3e0c000 	mvn	ip, #0	; 0x0
 * @buf:	the databuffer to put data
 *
 * NAND read out-of-band data from the spare area
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
33d05a0c:	e24dd014 	sub	sp, sp, #20	; 0x14
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;

	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Shift to get page */
	page = (int)(from >> this->page_shift);
33d05a10:	e5962068 	ldr	r2, [r6, #104]
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
	int i, col, page, chipnr;
	struct nand_chip *this = mtd->priv;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05a14:	e1e0ce1c 	mvn	ip, ip, lsl lr

	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Shift to get page */
	page = (int)(from >> this->page_shift);
33d05a18:	e1a01005 	mov	r1, r5
33d05a1c:	e1a00004 	mov	r0, r4
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
	int i, col, page, chipnr;
	struct nand_chip *this = mtd->priv;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05a20:	e58dc008 	str	ip, [sp, #8]
 * @buf:	the databuffer to put data
 *
 * NAND read out-of-band data from the spare area
 */
static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
{
33d05a24:	e58d3010 	str	r3, [sp, #16]
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;

	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Shift to get page */
	page = (int)(from >> this->page_shift);
33d05a28:	eb006305 	bl	33d1e644 <__ashrdi3>
	chipnr = (int)(from >> this->chip_shift);
33d05a2c:	e5962074 	ldr	r2, [r6, #116]
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;

	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Shift to get page */
	page = (int)(from >> this->page_shift);
33d05a30:	e1a09000 	mov	r9, r0
	chipnr = (int)(from >> this->chip_shift);
33d05a34:	e1a01005 	mov	r1, r5
33d05a38:	e1a00004 	mov	r0, r4
33d05a3c:	eb006300 	bl	33d1e644 <__ashrdi3>

	/* Mask to get column */
	col = from & (mtd->oobsize - 1);

	/* Initialize return length value */
	*retlen = 0;
33d05a40:	e59d1034 	ldr	r1, [sp, #52]

	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Shift to get page */
	page = (int)(from >> this->page_shift);
	chipnr = (int)(from >> this->chip_shift);
33d05a44:	e58d000c 	str	r0, [sp, #12]

	/* Mask to get column */
	col = from & (mtd->oobsize - 1);

	/* Initialize return length value */
	*retlen = 0;
33d05a48:	e3a0c000 	mov	ip, #0	; 0x0
	/* Shift to get page */
	page = (int)(from >> this->page_shift);
	chipnr = (int)(from >> this->chip_shift);

	/* Mask to get column */
	col = from & (mtd->oobsize - 1);
33d05a4c:	e5973014 	ldr	r3, [r7, #20]

	/* Initialize return length value */
	*retlen = 0;
33d05a50:	e581c000 	str	ip, [r1]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05a54:	e59de010 	ldr	lr, [sp, #16]
33d05a58:	e5972008 	ldr	r2, [r7, #8]
33d05a5c:	e094000e 	adds	r0, r4, lr
33d05a60:	e2a51000 	adc	r1, r5, #0	; 0x0
33d05a64:	e1a0a002 	mov	sl, r2
33d05a68:	e3a0b000 	mov	fp, #0	; 0x0
	/* Shift to get page */
	page = (int)(from >> this->page_shift);
	chipnr = (int)(from >> this->chip_shift);

	/* Mask to get column */
	col = from & (mtd->oobsize - 1);
33d05a6c:	e2433001 	sub	r3, r3, #1	; 0x1

	/* Initialize return length value */
	*retlen = 0;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05a70:	e151000b 	cmp	r1, fp
33d05a74:	e88d0003 	stm	sp, {r0, r1}
	/* Shift to get page */
	page = (int)(from >> this->page_shift);
	chipnr = (int)(from >> this->chip_shift);

	/* Mask to get column */
	col = from & (mtd->oobsize - 1);
33d05a78:	e0035004 	and	r5, r3, r4

	/* Initialize return length value */
	*retlen = 0;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05a7c:	ca000002 	bgt	33d05a8c <nand_read_oob+0xa4>
33d05a80:	1a000005 	bne	33d05a9c <nand_read_oob+0xb4>
33d05a84:	e150000a 	cmp	r0, sl
33d05a88:	9a000003 	bls	33d05a9c <nand_read_oob+0xb4>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: Attempt read beyond end of device\n");
		*retlen = 0;
33d05a8c:	e59d1034 	ldr	r1, [sp, #52]
		return -EINVAL;
33d05a90:	e3e00015 	mvn	r0, #21	; 0x15
	*retlen = 0;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: Attempt read beyond end of device\n");
		*retlen = 0;
33d05a94:	e581c000 	str	ip, [r1]
		return -EINVAL;
33d05a98:	ea00004e 	b	33d05bd8 <nand_read_oob+0x1f0>

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd , FL_READING);

	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d05a9c:	e1a00007 	mov	r0, r7
33d05aa0:	e59d100c 	ldr	r1, [sp, #12]
33d05aa4:	e1a0e00f 	mov	lr, pc
33d05aa8:	e596f024 	ldr	pc, [r6, #36]

	/* Send the read command */
	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
33d05aac:	e5963098 	ldr	r3, [r6, #152]
33d05ab0:	e1a02005 	mov	r2, r5
33d05ab4:	e0093003 	and	r3, r9, r3
33d05ab8:	e1a00007 	mov	r0, r7
33d05abc:	e3a01050 	mov	r1, #80	; 0x50
33d05ac0:	e1a0e00f 	mov	lr, pc
33d05ac4:	e596f038 	ldr	pc, [r6, #56]
			/* Check, if the chip supports auto page increment
			 * or if we have hit a block boundary.
			*/
			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
				/* For subsequent page reads set offset to 0 */
				this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
33d05ac8:	e59d2010 	ldr	r2, [sp, #16]
	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
	/*
	 * Read the data, if we read more than one page
	 * oob data, let the device transfer the data !
	 */
	i = 0;
33d05acc:	e3a0a000 	mov	sl, #0	; 0x0
			/* Check, if the chip supports auto page increment
			 * or if we have hit a block boundary.
			*/
			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
				/* For subsequent page reads set offset to 0 */
				this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
33d05ad0:	e15a0002 	cmp	sl, r2
33d05ad4:	2a000039 	bcs	33d05bc0 <nand_read_oob+0x1d8>
	 * Read the data, if we read more than one page
	 * oob data, let the device transfer the data !
	 */
	i = 0;
	while (i < len) {
		int thislen = mtd->oobsize - col;
33d05ad8:	e5974014 	ldr	r4, [r7, #20]
		thislen = min_t(int, thislen, len);
33d05adc:	e59d3010 	ldr	r3, [sp, #16]
		this->read_buf(mtd, &buf[i], thislen);
33d05ae0:	e59de038 	ldr	lr, [sp, #56]
	 * Read the data, if we read more than one page
	 * oob data, let the device transfer the data !
	 */
	i = 0;
	while (i < len) {
		int thislen = mtd->oobsize - col;
33d05ae4:	e0654004 	rsb	r4, r5, r4
		thislen = min_t(int, thislen, len);
33d05ae8:	e1530004 	cmp	r3, r4
33d05aec:	b1a04003 	movlt	r4, r3
		this->read_buf(mtd, &buf[i], thislen);
33d05af0:	e08e100a 	add	r1, lr, sl
33d05af4:	e1a00007 	mov	r0, r7
33d05af8:	e1a02004 	mov	r2, r4
33d05afc:	e1a0e00f 	mov	lr, pc
33d05b00:	e596f01c 	ldr	pc, [r6, #28]
		/* Apply delay or wait for ready/busy pin
		 * Do this before the AUTOINCR check, so no problems
		 * arise if a chip which does auto increment
		 * is marked as NOAUTOINCR by the board driver.
		*/
		if (!this->dev_ready)
33d05b04:	e5963034 	ldr	r3, [r6, #52]
33d05b08:	e3530000 	cmp	r3, #0	; 0x0
	i = 0;
	while (i < len) {
		int thislen = mtd->oobsize - col;
		thislen = min_t(int, thislen, len);
		this->read_buf(mtd, &buf[i], thislen);
		i += thislen;
33d05b0c:	e08aa004 	add	sl, sl, r4
		/* Apply delay or wait for ready/busy pin
		 * Do this before the AUTOINCR check, so no problems
		 * arise if a chip which does auto increment
		 * is marked as NOAUTOINCR by the board driver.
		*/
		if (!this->dev_ready)
33d05b10:	1a000002 	bne	33d05b20 <nand_read_oob+0x138>
			udelay (this->chip_delay);
33d05b14:	e5960064 	ldr	r0, [r6, #100]
33d05b18:	ebffecbb 	bl	33d00e0c <udelay>
33d05b1c:	ea000004 	b	33d05b34 <nand_read_oob+0x14c>
		else
			while (!this->dev_ready(mtd));
33d05b20:	e1a00007 	mov	r0, r7
33d05b24:	e1a0e00f 	mov	lr, pc
33d05b28:	e596f034 	ldr	pc, [r6, #52]
33d05b2c:	e3500000 	cmp	r0, #0	; 0x0
33d05b30:	0afffffa 	beq	33d05b20 <nand_read_oob+0x138>

		/* Read more ? */
		if (i < len) {
33d05b34:	e59d0010 	ldr	r0, [sp, #16]
33d05b38:	e15a0000 	cmp	sl, r0
33d05b3c:	2a00001f 	bcs	33d05bc0 <nand_read_oob+0x1d8>
			page++;
			col = 0;

			/* Check, if we cross a chip boundary */
			if (!(page & this->pagemask)) {
33d05b40:	e5963098 	ldr	r3, [r6, #152]
		else
			while (!this->dev_ready(mtd));

		/* Read more ? */
		if (i < len) {
			page++;
33d05b44:	e2899001 	add	r9, r9, #1	; 0x1
			col = 0;

			/* Check, if we cross a chip boundary */
			if (!(page & this->pagemask)) {
33d05b48:	e1190003 	tst	r9, r3
			while (!this->dev_ready(mtd));

		/* Read more ? */
		if (i < len) {
			page++;
			col = 0;
33d05b4c:	e3a05000 	mov	r5, #0	; 0x0

			/* Check, if we cross a chip boundary */
			if (!(page & this->pagemask)) {
33d05b50:	1a00000a 	bne	33d05b80 <nand_read_oob+0x198>
				chipnr++;
33d05b54:	e59d100c 	ldr	r1, [sp, #12]
33d05b58:	e2811001 	add	r1, r1, #1	; 0x1
33d05b5c:	e58d100c 	str	r1, [sp, #12]
				this->select_chip(mtd, -1);
33d05b60:	e1a00007 	mov	r0, r7
33d05b64:	e3e01000 	mvn	r1, #0	; 0x0
33d05b68:	e1a0e00f 	mov	lr, pc
33d05b6c:	e596f024 	ldr	pc, [r6, #36]
				this->select_chip(mtd, chipnr);
33d05b70:	e1a00007 	mov	r0, r7
33d05b74:	e59d100c 	ldr	r1, [sp, #12]
33d05b78:	e1a0e00f 	mov	lr, pc
33d05b7c:	e596f024 	ldr	pc, [r6, #36]
			}

			/* Check, if the chip supports auto page increment
			 * or if we have hit a block boundary.
			*/
			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
33d05b80:	e5963088 	ldr	r3, [r6, #136]
33d05b84:	e3130001 	tst	r3, #1	; 0x1
33d05b88:	1a000002 	bne	33d05b98 <nand_read_oob+0x1b0>
33d05b8c:	e59d2008 	ldr	r2, [sp, #8]
33d05b90:	e1190002 	tst	r9, r2
33d05b94:	1a000006 	bne	33d05bb4 <nand_read_oob+0x1cc>
				/* For subsequent page reads set offset to 0 */
				this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
33d05b98:	e5963098 	ldr	r3, [r6, #152]
33d05b9c:	e1a00007 	mov	r0, r7
33d05ba0:	e0093003 	and	r3, r9, r3
33d05ba4:	e3a01050 	mov	r1, #80	; 0x50
33d05ba8:	e1a02005 	mov	r2, r5
33d05bac:	e1a0e00f 	mov	lr, pc
33d05bb0:	e596f038 	ldr	pc, [r6, #56]
33d05bb4:	e59d3010 	ldr	r3, [sp, #16]
33d05bb8:	e15a0003 	cmp	sl, r3
33d05bbc:	eaffffc4 	b	33d05ad4 <nand_read_oob+0xec>
			}
		}
	}

	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d05bc0:	e1a00007 	mov	r0, r7
33d05bc4:	ebfffb11 	bl	33d04810 <nand_release_device>

	/* Return happy */
	*retlen = len;
33d05bc8:	e59d0010 	ldr	r0, [sp, #16]
33d05bcc:	e59de034 	ldr	lr, [sp, #52]
33d05bd0:	e58e0000 	str	r0, [lr]
	return 0;
33d05bd4:	e3a00000 	mov	r0, #0	; 0x0
}
33d05bd8:	e28dd014 	add	sp, sp, #20	; 0x14
33d05bdc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d05be0 <nand_read_raw>:
 * @ooblen:	number of oob data bytes to read
 *
 * Read raw data including oob into buffer
 */
int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
{
33d05be0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
33d05be4:	e590713c 	ldr	r7, [r0, #316]
	int page = (int) (from >> this->page_shift);
33d05be8:	e597a068 	ldr	sl, [r7, #104]
 * @ooblen:	number of oob data bytes to read
 *
 * Read raw data including oob into buffer
 */
int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
{
33d05bec:	e24dd018 	sub	sp, sp, #24	; 0x18
33d05bf0:	e1a05003 	mov	r5, r3
33d05bf4:	e1a04002 	mov	r4, r2
33d05bf8:	e1a09000 	mov	r9, r0
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
33d05bfc:	e1a0200a 	mov	r2, sl
 * @ooblen:	number of oob data bytes to read
 *
 * Read raw data including oob into buffer
 */
int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
{
33d05c00:	e58d1014 	str	r1, [sp, #20]
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
33d05c04:	e1a01005 	mov	r1, r5
33d05c08:	e1a00004 	mov	r0, r4
33d05c0c:	eb00628c 	bl	33d1e644 <__ashrdi3>
33d05c10:	e58d0010 	str	r0, [sp, #16]
	int chip = (int) (from >> this->chip_shift);
33d05c14:	e1a01005 	mov	r1, r5
33d05c18:	e1a00004 	mov	r0, r4
33d05c1c:	e5972074 	ldr	r2, [r7, #116]
33d05c20:	eb006287 	bl	33d1e644 <__ashrdi3>
	int sndcmd = 1;
	int cnt = 0;
	int pagesize = mtd->oobblock + mtd->oobsize;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05c24:	e597306c 	ldr	r3, [r7, #108]
int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
{
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
33d05c28:	e3a01001 	mov	r1, #1	; 0x1
 * @ooblen:	number of oob data bytes to read
 *
 * Read raw data including oob into buffer
 */
int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
{
33d05c2c:	e59d6038 	ldr	r6, [sp, #56]
	int cnt = 0;
	int pagesize = mtd->oobblock + mtd->oobsize;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05c30:	e5992008 	ldr	r2, [r9, #8]
int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
{
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
33d05c34:	e58d100c 	str	r1, [sp, #12]
	int cnt = 0;
	int pagesize = mtd->oobblock + mtd->oobsize;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05c38:	e06a3003 	rsb	r3, sl, r3

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05c3c:	e094a006 	adds	sl, r4, r6
33d05c40:	e2a5b000 	adc	fp, r5, #0	; 0x0
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
	int cnt = 0;
	int pagesize = mtd->oobblock + mtd->oobsize;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05c44:	e1a03311 	lsl	r3, r1, r3

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05c48:	e1a04002 	mov	r4, r2
33d05c4c:	e3a05000 	mov	r5, #0	; 0x0
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
	int cnt = 0;
	int pagesize = mtd->oobblock + mtd->oobsize;
33d05c50:	e2891010 	add	r1, r9, #16	; 0x10
33d05c54:	e8910006 	ldm	r1, {r1, r2}
33d05c58:	e0812002 	add	r2, r1, r2
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05c5c:	e2433001 	sub	r3, r3, #1	; 0x1
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
	int cnt = 0;
	int pagesize = mtd->oobblock + mtd->oobsize;
33d05c60:	e58d2004 	str	r2, [sp, #4]
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05c64:	e15b0005 	cmp	fp, r5
{
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
	int cnt = 0;
33d05c68:	e3a02000 	mov	r2, #0	; 0x0
	int pagesize = mtd->oobblock + mtd->oobsize;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
33d05c6c:	e58d3000 	str	r3, [sp]
{
	struct nand_chip *this = mtd->priv;
	int page = (int) (from >> this->page_shift);
	int chip = (int) (from >> this->chip_shift);
	int sndcmd = 1;
	int cnt = 0;
33d05c70:	e58d2008 	str	r2, [sp, #8]
	int pagesize = mtd->oobblock + mtd->oobsize;
	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
33d05c74:	ca000002 	bgt	33d05c84 <nand_read_raw+0xa4>
33d05c78:	1a000003 	bne	33d05c8c <nand_read_raw+0xac>
33d05c7c:	e15a0004 	cmp	sl, r4
33d05c80:	9a000001 	bls	33d05c8c <nand_read_raw+0xac>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_raw: Attempt read beyond end of device\n");
		return -EINVAL;
33d05c84:	e3e00015 	mvn	r0, #21	; 0x15
33d05c88:	ea00003b 	b	33d05d7c <nand_read_raw+0x19c>
	}

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd , FL_READING);

	this->select_chip (mtd, chip);
33d05c8c:	e1a01000 	mov	r1, r0
33d05c90:	e1a00009 	mov	r0, r9
33d05c94:	e1a0e00f 	mov	lr, pc
33d05c98:	e597f024 	ldr	pc, [r7, #36]
		else
			while (!this->dev_ready(mtd));

		/* Check, if the chip supports auto page increment */
		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
			sndcmd = 1;
33d05c9c:	e59d303c 	ldr	r3, [sp, #60]
33d05ca0:	e0966003 	adds	r6, r6, r3
33d05ca4:	0a000031 	beq	33d05d70 <nand_read_raw+0x190>

	/* Add requested oob length */
	len += ooblen;

	while (len) {
		if (sndcmd)
33d05ca8:	e59d100c 	ldr	r1, [sp, #12]
33d05cac:	e3510000 	cmp	r1, #0	; 0x0
33d05cb0:	0a000007 	beq	33d05cd4 <nand_read_raw+0xf4>
			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
33d05cb4:	e59d2010 	ldr	r2, [sp, #16]
33d05cb8:	e5973098 	ldr	r3, [r7, #152]
33d05cbc:	e3a01000 	mov	r1, #0	; 0x0
33d05cc0:	e0023003 	and	r3, r2, r3
33d05cc4:	e1a00009 	mov	r0, r9
33d05cc8:	e1a02001 	mov	r2, r1
33d05ccc:	e1a0e00f 	mov	lr, pc
33d05cd0:	e597f038 	ldr	pc, [r7, #56]
		sndcmd = 0;

		this->read_buf (mtd, &buf[cnt], pagesize);
33d05cd4:	e59d3014 	ldr	r3, [sp, #20]
33d05cd8:	e59d2008 	ldr	r2, [sp, #8]
33d05cdc:	e1a00009 	mov	r0, r9
33d05ce0:	e0831002 	add	r1, r3, r2
33d05ce4:	e59d2004 	ldr	r2, [sp, #4]
33d05ce8:	e1a0e00f 	mov	lr, pc
33d05cec:	e597f01c 	ldr	pc, [r7, #28]

		len -= pagesize;
		cnt += pagesize;
		page++;

		if (!this->dev_ready)
33d05cf0:	e5973034 	ldr	r3, [r7, #52]
		sndcmd = 0;

		this->read_buf (mtd, &buf[cnt], pagesize);

		len -= pagesize;
		cnt += pagesize;
33d05cf4:	e59d1008 	ldr	r1, [sp, #8]
		page++;
33d05cf8:	e59d2010 	ldr	r2, [sp, #16]

		if (!this->dev_ready)
33d05cfc:	e3530000 	cmp	r3, #0	; 0x0
			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
		sndcmd = 0;

		this->read_buf (mtd, &buf[cnt], pagesize);

		len -= pagesize;
33d05d00:	e59d3004 	ldr	r3, [sp, #4]
		cnt += pagesize;
		page++;
33d05d04:	e2822001 	add	r2, r2, #1	; 0x1
		sndcmd = 0;

		this->read_buf (mtd, &buf[cnt], pagesize);

		len -= pagesize;
		cnt += pagesize;
33d05d08:	e0811003 	add	r1, r1, r3
			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
		sndcmd = 0;

		this->read_buf (mtd, &buf[cnt], pagesize);

		len -= pagesize;
33d05d0c:	e0636006 	rsb	r6, r3, r6
	len += ooblen;

	while (len) {
		if (sndcmd)
			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
		sndcmd = 0;
33d05d10:	e3a03000 	mov	r3, #0	; 0x0

		this->read_buf (mtd, &buf[cnt], pagesize);

		len -= pagesize;
		cnt += pagesize;
33d05d14:	e58d1008 	str	r1, [sp, #8]
		page++;
33d05d18:	e58d2010 	str	r2, [sp, #16]
	len += ooblen;

	while (len) {
		if (sndcmd)
			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
		sndcmd = 0;
33d05d1c:	e58d300c 	str	r3, [sp, #12]

		len -= pagesize;
		cnt += pagesize;
		page++;

		if (!this->dev_ready)
33d05d20:	1a000002 	bne	33d05d30 <nand_read_raw+0x150>
			udelay (this->chip_delay);
33d05d24:	e5970064 	ldr	r0, [r7, #100]
33d05d28:	ebffec37 	bl	33d00e0c <udelay>
33d05d2c:	ea000004 	b	33d05d44 <nand_read_raw+0x164>
		else
			while (!this->dev_ready(mtd));
33d05d30:	e1a00009 	mov	r0, r9
33d05d34:	e1a0e00f 	mov	lr, pc
33d05d38:	e597f034 	ldr	pc, [r7, #52]
33d05d3c:	e3500000 	cmp	r0, #0	; 0x0
33d05d40:	0afffffa 	beq	33d05d30 <nand_read_raw+0x150>

		/* Check, if the chip supports auto page increment */
		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
33d05d44:	e5973088 	ldr	r3, [r7, #136]
33d05d48:	e3130001 	tst	r3, #1	; 0x1
33d05d4c:	1a000003 	bne	33d05d60 <nand_read_raw+0x180>
33d05d50:	e59d1010 	ldr	r1, [sp, #16]
33d05d54:	e59d2000 	ldr	r2, [sp]
33d05d58:	e1110002 	tst	r1, r2
33d05d5c:	1a000001 	bne	33d05d68 <nand_read_raw+0x188>
			sndcmd = 1;
33d05d60:	e3a03001 	mov	r3, #1	; 0x1
33d05d64:	e58d300c 	str	r3, [sp, #12]
33d05d68:	e3560000 	cmp	r6, #0	; 0x0
33d05d6c:	1affffcd 	bne	33d05ca8 <nand_read_raw+0xc8>
	}

	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d05d70:	e1a00009 	mov	r0, r9
33d05d74:	ebfffaa5 	bl	33d04810 <nand_release_device>
	return 0;
33d05d78:	e3a00000 	mov	r0, #0	; 0x0
}
33d05d7c:	e28dd018 	add	sp, sp, #24	; 0x18
33d05d80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d05d84 <nand_prepare_oobbuf>:
 * forces the 0xff fill before using the buffer again.
 *
*/
static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
		int autoplace, int numpages)
{
33d05d84:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
	int i, len, ofs;

	/* Zero copy fs supplied buffer */
	if (fsbuf && !autoplace)
33d05d88:	e2516000 	subs	r6, r1, #0	; 0x0
33d05d8c:	13a06001 	movne	r6, #1	; 0x1
 * forces the 0xff fill before using the buffer again.
 *
*/
static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
		int autoplace, int numpages)
{
33d05d90:	e24dd008 	sub	sp, sp, #8	; 0x8
	struct nand_chip *this = mtd->priv;
	int i, len, ofs;

	/* Zero copy fs supplied buffer */
	if (fsbuf && !autoplace)
33d05d94:	e3530000 	cmp	r3, #0	; 0x0
33d05d98:	13a06000 	movne	r6, #0	; 0x0
 * forces the 0xff fill before using the buffer again.
 *
*/
static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
		int autoplace, int numpages)
{
33d05d9c:	e58d2004 	str	r2, [sp, #4]
	struct nand_chip *this = mtd->priv;
	int i, len, ofs;

	/* Zero copy fs supplied buffer */
	if (fsbuf && !autoplace)
33d05da0:	e3560000 	cmp	r6, #0	; 0x0
 * forces the 0xff fill before using the buffer again.
 *
*/
static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
		int autoplace, int numpages)
{
33d05da4:	e1a0b000 	mov	fp, r0
	struct nand_chip *this = mtd->priv;
33d05da8:	e590513c 	ldr	r5, [r0, #316]
	int i, len, ofs;

	/* Zero copy fs supplied buffer */
	if (fsbuf && !autoplace)
33d05dac:	e1a07001 	mov	r7, r1
33d05db0:	e1a04003 	mov	r4, r3
 * forces the 0xff fill before using the buffer again.
 *
*/
static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
		int autoplace, int numpages)
{
33d05db4:	e59da028 	ldr	sl, [sp, #40]
	struct nand_chip *this = mtd->priv;
	int i, len, ofs;

	/* Zero copy fs supplied buffer */
	if (fsbuf && !autoplace)
		return fsbuf;
33d05db8:	11a00001 	movne	r0, r1
{
	struct nand_chip *this = mtd->priv;
	int i, len, ofs;

	/* Zero copy fs supplied buffer */
	if (fsbuf && !autoplace)
33d05dbc:	1a000035 	bne	33d05e98 <nand_prepare_oobbuf+0x114>
		return fsbuf;

	/* Check, if the buffer must be filled with ff again */
	if (this->oobdirty) {
33d05dc0:	e5953080 	ldr	r3, [r5, #128]
33d05dc4:	e3530000 	cmp	r3, #0	; 0x0
33d05dc8:	0a000008 	beq	33d05df0 <nand_prepare_oobbuf+0x6c>
		memset (this->oob_buf, 0xff,
33d05dcc:	e285206c 	add	r2, r5, #108	; 0x6c
33d05dd0:	e812000c 	ldmda	r2, {r2, r3}
33d05dd4:	e0433002 	sub	r3, r3, r2
33d05dd8:	e59b2014 	ldr	r2, [fp, #20]
33d05ddc:	e595007c 	ldr	r0, [r5, #124]
33d05de0:	e1a02312 	lsl	r2, r2, r3
33d05de4:	e3a010ff 	mov	r1, #255	; 0xff
33d05de8:	eb005169 	bl	33d1a394 <memset>
			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
		this->oobdirty = 0;
33d05dec:	e5856080 	str	r6, [r5, #128]
	}

	/* If we have no autoplacement or no fs buffer use the internal one */
	if (!autoplace || !fsbuf) {				//HJ_add start
33d05df0:	e3570000 	cmp	r7, #0	; 0x0
33d05df4:	13540000 	cmpne	r4, #0	; 0x0
		this->oobdirty = 1;
33d05df8:	03a03001 	moveq	r3, #1	; 0x1
			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
		this->oobdirty = 0;
	}

	/* If we have no autoplacement or no fs buffer use the internal one */
	if (!autoplace || !fsbuf) {				//HJ_add start
33d05dfc:	13a00000 	movne	r0, #0	; 0x0
33d05e00:	03a00001 	moveq	r0, #1	; 0x1
		this->oobdirty = 1;
33d05e04:	05853080 	streq	r3, [r5, #128]
		return this->oob_buf;
33d05e08:	0595007c 	ldreq	r0, [r5, #124]
			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
		this->oobdirty = 0;
	}

	/* If we have no autoplacement or no fs buffer use the internal one */
	if (!autoplace || !fsbuf) {				//HJ_add start
33d05e0c:	0a000021 	beq	33d05e98 <nand_prepare_oobbuf+0x114>
		this->oobdirty = 1;
		return this->oob_buf;
	}						//HJ_add end

	/* Walk through the pages and place the data */
	this->oobdirty = 1;
33d05e10:	e3a03001 	mov	r3, #1	; 0x1
			int num = oobsel->oobfree[i][1];
			memcpy (&this->oob_buf[to], fsbuf, num);
			len += num;
			fsbuf += num;
		}
		ofs += mtd->oobavail;
33d05e14:	e24aa001 	sub	sl, sl, #1	; 0x1
		this->oobdirty = 1;
		return this->oob_buf;
	}						//HJ_add end

	/* Walk through the pages and place the data */
	this->oobdirty = 1;
33d05e18:	e5853080 	str	r3, [r5, #128]
	ofs = 0;
33d05e1c:	e58d0000 	str	r0, [sp]
			int num = oobsel->oobfree[i][1];
			memcpy (&this->oob_buf[to], fsbuf, num);
			len += num;
			fsbuf += num;
		}
		ofs += mtd->oobavail;
33d05e20:	e37a0001 	cmn	sl, #1	; 0x1
33d05e24:	0a00001a 	beq	33d05e94 <nand_prepare_oobbuf+0x110>

	/* Walk through the pages and place the data */
	this->oobdirty = 1;
	ofs = 0;
	while (numpages--) {
		for (i = 0, len = 0; len < mtd->oobavail; i++) {
33d05e28:	e59b3018 	ldr	r3, [fp, #24]
33d05e2c:	e3a09000 	mov	r9, #0	; 0x0
33d05e30:	e1590003 	cmp	r9, r3
33d05e34:	2a00000f 	bcs	33d05e78 <nand_prepare_oobbuf+0xf4>
33d05e38:	e59d6004 	ldr	r6, [sp, #4]
			int to = ofs + oobsel->oobfree[i][0];
33d05e3c:	e5960008 	ldr	r0, [r6, #8]
33d05e40:	e59d2000 	ldr	r2, [sp]
			int num = oobsel->oobfree[i][1];
33d05e44:	e596400c 	ldr	r4, [r6, #12]
			memcpy (&this->oob_buf[to], fsbuf, num);
33d05e48:	e595307c 	ldr	r3, [r5, #124]
	/* Walk through the pages and place the data */
	this->oobdirty = 1;
	ofs = 0;
	while (numpages--) {
		for (i = 0, len = 0; len < mtd->oobavail; i++) {
			int to = ofs + oobsel->oobfree[i][0];
33d05e4c:	e0820000 	add	r0, r2, r0
			int num = oobsel->oobfree[i][1];
			memcpy (&this->oob_buf[to], fsbuf, num);
33d05e50:	e0830000 	add	r0, r3, r0
33d05e54:	e1a01007 	mov	r1, r7
33d05e58:	e1a02004 	mov	r2, r4
33d05e5c:	eb005160 	bl	33d1a3e4 <memcpy>

	/* Walk through the pages and place the data */
	this->oobdirty = 1;
	ofs = 0;
	while (numpages--) {
		for (i = 0, len = 0; len < mtd->oobavail; i++) {
33d05e60:	e59b3018 	ldr	r3, [fp, #24]
			int to = ofs + oobsel->oobfree[i][0];
			int num = oobsel->oobfree[i][1];
			memcpy (&this->oob_buf[to], fsbuf, num);
			len += num;
33d05e64:	e0899004 	add	r9, r9, r4

	/* Walk through the pages and place the data */
	this->oobdirty = 1;
	ofs = 0;
	while (numpages--) {
		for (i = 0, len = 0; len < mtd->oobavail; i++) {
33d05e68:	e1590003 	cmp	r9, r3
			int to = ofs + oobsel->oobfree[i][0];
			int num = oobsel->oobfree[i][1];
			memcpy (&this->oob_buf[to], fsbuf, num);
			len += num;
			fsbuf += num;
33d05e6c:	e0877004 	add	r7, r7, r4
33d05e70:	e2866008 	add	r6, r6, #8	; 0x8

	/* Walk through the pages and place the data */
	this->oobdirty = 1;
	ofs = 0;
	while (numpages--) {
		for (i = 0, len = 0; len < mtd->oobavail; i++) {
33d05e74:	3afffff0 	bcc	33d05e3c <nand_prepare_oobbuf+0xb8>
			int num = oobsel->oobfree[i][1];
			memcpy (&this->oob_buf[to], fsbuf, num);
			len += num;
			fsbuf += num;
		}
		ofs += mtd->oobavail;
33d05e78:	e59b3018 	ldr	r3, [fp, #24]
33d05e7c:	e59d2000 	ldr	r2, [sp]
33d05e80:	e24aa001 	sub	sl, sl, #1	; 0x1
33d05e84:	e0822003 	add	r2, r2, r3
33d05e88:	e37a0001 	cmn	sl, #1	; 0x1
33d05e8c:	e58d2000 	str	r2, [sp]
33d05e90:	eaffffe3 	b	33d05e24 <nand_prepare_oobbuf+0xa0>
	}
	return this->oob_buf;
33d05e94:	e595007c 	ldr	r0, [r5, #124]
}
33d05e98:	e28dd008 	add	sp, sp, #8	; 0x8
33d05e9c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d05ea0 <nand_write_ecc>:
 *
 * NAND write with ECC
 */
static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
{
33d05ea0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d05ea4:	e1a06000 	mov	r6, r0
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
	int autoplace = 0, numpages, totalpages;
	struct nand_chip *this = mtd->priv;
33d05ea8:	e590513c 	ldr	r5, [r0, #316]
 *
 * NAND write with ECC
 */
static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
{
33d05eac:	e24dd068 	sub	sp, sp, #104	; 0x68
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
33d05eb0:	e3a00000 	mov	r0, #0	; 0x0
33d05eb4:	e58d0030 	str	r0, [sp, #48]
	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));

	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	*retlen = 0;
33d05eb8:	e59de088 	ldr	lr, [sp, #136]
{
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
	int autoplace = 0, numpages, totalpages;
	struct nand_chip *this = mtd->priv;
	u_char *oobbuf, *bufstart;
	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
33d05ebc:	e285406c 	add	r4, r5, #108	; 0x6c
33d05ec0:	e8141010 	ldmda	r4, {r4, ip}
33d05ec4:	e04cc004 	sub	ip, ip, r4

	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	*retlen = 0;
33d05ec8:	e58e0000 	str	r0, [lr]

	/* Do not allow write past end of device */
	if ((to + len) > mtd->size) {
33d05ecc:	e5960008 	ldr	r0, [r6, #8]
33d05ed0:	e091a003 	adds	sl, r1, r3
 *
 * NAND write with ECC
 */
static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
{
33d05ed4:	e28d4040 	add	r4, sp, #64	; 0x40
33d05ed8:	e8840006 	stm	r4, {r1, r2}

	/* Initialize retlen, in case of early exit */
	*retlen = 0;

	/* Do not allow write past end of device */
	if ((to + len) > mtd->size) {
33d05edc:	e2a2b000 	adc	fp, r2, #0	; 0x0
 *
 * NAND write with ECC
 */
static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
{
33d05ee0:	e58d303c 	str	r3, [sp, #60]
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
33d05ee4:	e59d2030 	ldr	r2, [sp, #48]

	/* Initialize retlen, in case of early exit */
	*retlen = 0;

	/* Do not allow write past end of device */
	if ((to + len) > mtd->size) {
33d05ee8:	e1a0e003 	mov	lr, r3
33d05eec:	e3a01000 	mov	r1, #0	; 0x0
{
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
	int autoplace = 0, numpages, totalpages;
	struct nand_chip *this = mtd->priv;
	u_char *oobbuf, *bufstart;
	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
33d05ef0:	e3a03001 	mov	r3, #1	; 0x1
33d05ef4:	e1a03c13 	lsl	r3, r3, ip

	/* Initialize retlen, in case of early exit */
	*retlen = 0;

	/* Do not allow write past end of device */
	if ((to + len) > mtd->size) {
33d05ef8:	e15b0001 	cmp	fp, r1
{
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
	int autoplace = 0, numpages, totalpages;
	struct nand_chip *this = mtd->priv;
	u_char *oobbuf, *bufstart;
	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
33d05efc:	e58d301c 	str	r3, [sp, #28]
 * NAND write with ECC
 */
static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
{
	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
33d05f00:	e3e07004 	mvn	r7, #4	; 0x4
33d05f04:	e58d2034 	str	r2, [sp, #52]
	int autoplace = 0, numpages, totalpages;
33d05f08:	e58d2028 	str	r2, [sp, #40]

	/* Initialize retlen, in case of early exit */
	*retlen = 0;

	/* Do not allow write past end of device */
	if ((to + len) > mtd->size) {
33d05f0c:	ca00000f 	bgt	33d05f50 <nand_write_ecc+0xb0>
33d05f10:	1a000001 	bne	33d05f1c <nand_write_ecc+0x7c>
33d05f14:	e15a0000 	cmp	sl, r0
33d05f18:	8a00000c 	bhi	33d05f50 <nand_write_ecc+0xb0>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: Attempt to write past end of page\n");
		return -EINVAL;
	}

	/* reject writes, which are not page aligned */
	if (NOTALIGNED (to) || NOTALIGNED(len)) {
33d05f1c:	e5963010 	ldr	r3, [r6, #16]
33d05f20:	e28dc040 	add	ip, sp, #64	; 0x40
33d05f24:	e2432001 	sub	r2, r3, #1	; 0x1
33d05f28:	e89c0018 	ldm	ip, {r3, r4}
33d05f2c:	e3a04000 	mov	r4, #0	; 0x0
33d05f30:	e0033002 	and	r3, r3, r2
33d05f34:	e1933004 	orrs	r3, r3, r4
33d05f38:	1a000002 	bne	33d05f48 <nand_write_ecc+0xa8>
33d05f3c:	e59de03c 	ldr	lr, [sp, #60]
33d05f40:	e11e0002 	tst	lr, r2
33d05f44:	0a000003 	beq	33d05f58 <nand_write_ecc+0xb8>
		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
33d05f48:	e59f0524 	ldr	r0, [pc, #1316]	; 33d06474 <nand_write_ecc+0x5d4>
33d05f4c:	eb00441d 	bl	33d16fc8 <printf>
		return -EINVAL;
33d05f50:	e3e00015 	mvn	r0, #21	; 0x15
33d05f54:	ea000144 	b	33d0646c <nand_write_ecc+0x5cc>

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_WRITING);

	/* Calculate chipnr */
	chipnr = (int)(to >> this->chip_shift);
33d05f58:	e28d3040 	add	r3, sp, #64	; 0x40
33d05f5c:	e5952074 	ldr	r2, [r5, #116]
33d05f60:	e8930003 	ldm	r3, {r0, r1}
33d05f64:	eb0061b6 	bl	33d1e644 <__ashrdi3>
33d05f68:	e1a04001 	mov	r4, r1
33d05f6c:	e1a03000 	mov	r3, r0
33d05f70:	e58d302c 	str	r3, [sp, #44]
	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d05f74:	e1a01000 	mov	r1, r0
33d05f78:	e1a00006 	mov	r0, r6
33d05f7c:	e1a0e00f 	mov	lr, pc
33d05f80:	e595f024 	ldr	pc, [r5, #36]

	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
33d05f84:	e1a00006 	mov	r0, r6
33d05f88:	ebfffaff 	bl	33d04b8c <nand_check_wp>
33d05f8c:	e3500000 	cmp	r0, #0	; 0x0
33d05f90:	1a000132 	bne	33d06460 <nand_write_ecc+0x5c0>
		goto out;

	/* if oobsel is NULL, use chip defaults */
	if (oobsel == NULL)
33d05f94:	e59d4094 	ldr	r4, [sp, #148]
33d05f98:	e3540000 	cmp	r4, #0	; 0x0
		oobsel = &mtd->oobinfo;
33d05f9c:	0286c02c 	addeq	ip, r6, #44	; 0x2c
33d05fa0:	058dc094 	streq	ip, [sp, #148]

	/* Autoplace of oob data ? Use the default placement scheme */
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
33d05fa4:	e59de094 	ldr	lr, [sp, #148]
33d05fa8:	e59e3000 	ldr	r3, [lr]
33d05fac:	e3530002 	cmp	r3, #2	; 0x2
		oobsel = this->autooob;
33d05fb0:	059500a0 	ldreq	r0, [r5, #160]
33d05fb4:	058d0094 	streq	r0, [sp, #148]
		autoplace = 1;
33d05fb8:	03a01001 	moveq	r1, #1	; 0x1
33d05fbc:	058d1028 	streq	r1, [sp, #40]
	}
	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
33d05fc0:	e59d2094 	ldr	r2, [sp, #148]
33d05fc4:	e5923000 	ldr	r3, [r2]
		autoplace = 1;

	/* Setup variables and oob buffer */
	totalpages = len >> this->page_shift;
33d05fc8:	e595c068 	ldr	ip, [r5, #104]
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
		oobsel = this->autooob;
		autoplace = 1;
	}
	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
		autoplace = 1;
33d05fcc:	e3530004 	cmp	r3, #4	; 0x4

	/* Setup variables and oob buffer */
	totalpages = len >> this->page_shift;
33d05fd0:	e59d303c 	ldr	r3, [sp, #60]
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
		oobsel = this->autooob;
		autoplace = 1;
	}
	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
		autoplace = 1;
33d05fd4:	e59de028 	ldr	lr, [sp, #40]

	/* Setup variables and oob buffer */
	totalpages = len >> this->page_shift;
	page = (int) (to >> this->page_shift);
33d05fd8:	e28d4040 	add	r4, sp, #64	; 0x40
33d05fdc:	e1a0200c 	mov	r2, ip
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
		oobsel = this->autooob;
		autoplace = 1;
	}
	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
		autoplace = 1;
33d05fe0:	03a0e001 	moveq	lr, #1	; 0x1

	/* Setup variables and oob buffer */
	totalpages = len >> this->page_shift;
33d05fe4:	e1a0cc33 	lsr	ip, r3, ip
	page = (int) (to >> this->page_shift);
33d05fe8:	e8940003 	ldm	r4, {r0, r1}
	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
		oobsel = this->autooob;
		autoplace = 1;
	}
	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
		autoplace = 1;
33d05fec:	e58de028 	str	lr, [sp, #40]

	/* Setup variables and oob buffer */
	totalpages = len >> this->page_shift;
33d05ff0:	e58dc024 	str	ip, [sp, #36]
	page = (int) (to >> this->page_shift);
33d05ff4:	eb006192 	bl	33d1e644 <__ashrdi3>
	/* Invalidate the page cache, if we write to the cached page */
	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
33d05ff8:	e595209c 	ldr	r2, [r5, #156]
33d05ffc:	e1500002 	cmp	r0, r2
	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
		autoplace = 1;

	/* Setup variables and oob buffer */
	totalpages = len >> this->page_shift;
	page = (int) (to >> this->page_shift);
33d06000:	e1a0b000 	mov	fp, r0
	/* Invalidate the page cache, if we write to the cached page */
	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
33d06004:	ca000004 	bgt	33d0601c <nand_write_ecc+0x17c>
33d06008:	e59d4024 	ldr	r4, [sp, #36]
33d0600c:	e0803004 	add	r3, r0, r4
33d06010:	e1520003 	cmp	r2, r3
		this->pagebuf = -1;
33d06014:	b3e03000 	mvnlt	r3, #0	; 0x0
33d06018:	b585309c 	strlt	r3, [r5, #156]

	/* Set it relative to chip */
	page &= this->pagemask;
33d0601c:	e5953098 	ldr	r3, [r5, #152]
	startpage = page;
	/* Calc number of pages we can write in one go */
	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
33d06020:	e59dc01c 	ldr	ip, [sp, #28]
	/* Invalidate the page cache, if we write to the cached page */
	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
		this->pagebuf = -1;

	/* Set it relative to chip */
	page &= this->pagemask;
33d06024:	e00bb003 	and	fp, fp, r3
	startpage = page;
	/* Calc number of pages we can write in one go */
	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
33d06028:	e59de01c 	ldr	lr, [sp, #28]
33d0602c:	e24cc001 	sub	ip, ip, #1	; 0x1
33d06030:	e58dc018 	str	ip, [sp, #24]
	oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, autoplace, numpages);
33d06034:	e59d4024 	ldr	r4, [sp, #36]

	/* Set it relative to chip */
	page &= this->pagemask;
	startpage = page;
	/* Calc number of pages we can write in one go */
	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
33d06038:	e00bc00c 	and	ip, fp, ip
33d0603c:	e06cc00e 	rsb	ip, ip, lr
	oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, autoplace, numpages);
33d06040:	e1a00006 	mov	r0, r6
33d06044:	e28d1090 	add	r1, sp, #144	; 0x90
33d06048:	e8910006 	ldm	r1, {r1, r2}
33d0604c:	e59d3028 	ldr	r3, [sp, #40]
33d06050:	e154000c 	cmp	r4, ip
33d06054:	d58d4000 	strle	r4, [sp]
33d06058:	c58dc000 	strgt	ip, [sp]
33d0605c:	ebffff48 	bl	33d05d84 <nand_prepare_oobbuf>
					autoplace, numpages);
			/* Check, if we cross a chip boundary */
			if (!page) {
				chipnr++;
				this->select_chip(mtd, -1);
				this->select_chip(mtd, chipnr);
33d06060:	e59dc030 	ldr	ip, [sp, #48]
33d06064:	e59de03c 	ldr	lr, [sp, #60]
	/* Set it relative to chip */
	page &= this->pagemask;
	startpage = page;
	/* Calc number of pages we can write in one go */
	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
	oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, autoplace, numpages);
33d06068:	e58d0020 	str	r0, [sp, #32]
	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
		this->pagebuf = -1;

	/* Set it relative to chip */
	page &= this->pagemask;
	startpage = page;
33d0606c:	e58db038 	str	fp, [sp, #56]
					autoplace, numpages);
			/* Check, if we cross a chip boundary */
			if (!page) {
				chipnr++;
				this->select_chip(mtd, -1);
				this->select_chip(mtd, chipnr);
33d06070:	e15c000e 	cmp	ip, lr
33d06074:	2a0000f3 	bcs	33d06448 <nand_write_ecc+0x5a8>
	bufstart = (u_char *)buf;

	/* Loop until all data is written */
	while (written < len) {

		this->data_poi = (u_char*) &buf[written];
33d06078:	e59d008c 	ldr	r0, [sp, #140]
33d0607c:	e59d1030 	ldr	r1, [sp, #48]
33d06080:	e0803001 	add	r3, r0, r1
33d06084:	e5853084 	str	r3, [r5, #132]
static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
33d06088:	e59d2094 	ldr	r2, [sp, #148]
 *
 * Cached programming is not supported yet.
 */
static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
33d0608c:	e59d4020 	ldr	r4, [sp, #32]
33d06090:	e59dc034 	ldr	ip, [sp, #52]
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
33d06094:	e5923000 	ldr	r3, [r2]
 *
 * Cached programming is not supported yet.
 */
static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
33d06098:	e084400c 	add	r4, r4, ip
33d0609c:	e58d4014 	str	r4, [sp, #20]
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
33d060a0:	e3530000 	cmp	r3, #0	; 0x0
33d060a4:	1595e054 	ldrne	lr, [r5, #84]

	/* FIXME: Enable cached programming */
	cached = 0;

	/* Send command to begin auto page programming */
	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
33d060a8:	e3a02000 	mov	r2, #0	; 0x0
static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
33d060ac:	058d3010 	streq	r3, [sp, #16]
33d060b0:	158de010 	strne	lr, [sp, #16]
	uint  	*oob_config = oobsel->eccpos;
	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
33d060b4:	e58d2008 	str	r2, [sp, #8]

	/* FIXME: Enable cached programming */
	cached = 0;

	/* Send command to begin auto page programming */
	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
33d060b8:	e1a00006 	mov	r0, r6
33d060bc:	e3a01080 	mov	r1, #128	; 0x80
33d060c0:	e1a0300b 	mov	r3, fp
{
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
	uint  	*oob_config = oobsel->eccpos;
	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
33d060c4:	e595a060 	ldr	sl, [r5, #96]

	/* FIXME: Enable cached programming */
	cached = 0;

	/* Send command to begin auto page programming */
	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
33d060c8:	e1a0e00f 	mov	lr, pc
33d060cc:	e595f038 	ldr	pc, [r5, #56]

	/* Write out complete page of data, take care of eccmode */
	switch (eccmode) {
33d060d0:	e59d0010 	ldr	r0, [sp, #16]
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
	uint  	*oob_config = oobsel->eccpos;
33d060d4:	e59d1094 	ldr	r1, [sp, #148]
	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
33d060d8:	e59d2008 	ldr	r2, [sp, #8]
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
	uint  	*oob_config = oobsel->eccpos;
33d060dc:	e2811048 	add	r1, r1, #72	; 0x48

	/* Send command to begin auto page programming */
	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);

	/* Write out complete page of data, take care of eccmode */
	switch (eccmode) {
33d060e0:	e3500000 	cmp	r0, #0	; 0x0
	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
{
	int 	i, status;
	u_char	ecc_code[32];
	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
	uint  	*oob_config = oobsel->eccpos;
33d060e4:	e58d100c 	str	r1, [sp, #12]
	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
33d060e8:	e58d2004 	str	r2, [sp, #4]

	/* Send command to begin auto page programming */
	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);

	/* Write out complete page of data, take care of eccmode */
	switch (eccmode) {
33d060ec:	0a00001c 	beq	33d06164 <nand_write_ecc+0x2c4>
33d060f0:	e3500001 	cmp	r0, #1	; 0x1
33d060f4:	1a000020 	bne	33d0617c <nand_write_ecc+0x2dc>
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
		break;

	/* Software ecc 3/256, write all */
	case NAND_ECC_SOFT:
		for (; eccsteps; eccsteps--) {
33d060f8:	e35a0000 	cmp	sl, #0	; 0x0
33d060fc:	0a000018 	beq	33d06164 <nand_write_ecc+0x2c4>
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
33d06100:	e5951084 	ldr	r1, [r5, #132]
33d06104:	e59d3008 	ldr	r3, [sp, #8]
33d06108:	e1a00006 	mov	r0, r6
33d0610c:	e0811003 	add	r1, r1, r3
33d06110:	e28d2048 	add	r2, sp, #72	; 0x48
33d06114:	e1a0e00f 	mov	lr, pc
33d06118:	e595f040 	ldr	pc, [r5, #64]
33d0611c:	e3a04002 	mov	r4, #2	; 0x2
33d06120:	e28d1048 	add	r1, sp, #72	; 0x48
			for (i = 0; i < 3; i++, eccidx++)
				oob_buf[oob_config[eccidx]] = ecc_code[i];
33d06124:	e59dc004 	ldr	ip, [sp, #4]
33d06128:	e59de00c 	ldr	lr, [sp, #12]
33d0612c:	e4d13001 	ldrb	r3, [r1], #1
33d06130:	e79e210c 	ldr	r2, [lr, ip, lsl #2]
33d06134:	e59d0014 	ldr	r0, [sp, #20]

	/* Software ecc 3/256, write all */
	case NAND_ECC_SOFT:
		for (; eccsteps; eccsteps--) {
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < 3; i++, eccidx++)
33d06138:	e28cc001 	add	ip, ip, #1	; 0x1
33d0613c:	e2544001 	subs	r4, r4, #1	; 0x1
				oob_buf[oob_config[eccidx]] = ecc_code[i];
33d06140:	e7c03002 	strb	r3, [r0, r2]

	/* Software ecc 3/256, write all */
	case NAND_ECC_SOFT:
		for (; eccsteps; eccsteps--) {
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < 3; i++, eccidx++)
33d06144:	e58dc004 	str	ip, [sp, #4]
33d06148:	5afffff5 	bpl	33d06124 <nand_write_ecc+0x284>
				oob_buf[oob_config[eccidx]] = ecc_code[i];
			datidx += this->eccsize;
33d0614c:	e5953058 	ldr	r3, [r5, #88]
33d06150:	e59d1008 	ldr	r1, [sp, #8]
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
		break;

	/* Software ecc 3/256, write all */
	case NAND_ECC_SOFT:
		for (; eccsteps; eccsteps--) {
33d06154:	e25aa001 	subs	sl, sl, #1	; 0x1
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < 3; i++, eccidx++)
				oob_buf[oob_config[eccidx]] = ecc_code[i];
			datidx += this->eccsize;
33d06158:	e0811003 	add	r1, r1, r3
33d0615c:	e58d1008 	str	r1, [sp, #8]
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
		break;

	/* Software ecc 3/256, write all */
	case NAND_ECC_SOFT:
		for (; eccsteps; eccsteps--) {
33d06160:	1affffe6 	bne	33d06100 <nand_write_ecc+0x260>
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < 3; i++, eccidx++)
				oob_buf[oob_config[eccidx]] = ecc_code[i];
			datidx += this->eccsize;
		}
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
33d06164:	e1a00006 	mov	r0, r6
33d06168:	e5951084 	ldr	r1, [r5, #132]
33d0616c:	e5962010 	ldr	r2, [r6, #16]
33d06170:	e1a0e00f 	mov	lr, pc
33d06174:	e595f018 	ldr	pc, [r5, #24]
		break;
33d06178:	ea000031 	b	33d06244 <nand_write_ecc+0x3a4>
	default:
		eccbytes = this->eccbytes;
		for (; eccsteps; eccsteps--) {
33d0617c:	e35a0000 	cmp	sl, #0	; 0x0
			datidx += this->eccsize;
		}
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
		break;
	default:
		eccbytes = this->eccbytes;
33d06180:	e595705c 	ldr	r7, [r5, #92]
		for (; eccsteps; eccsteps--) {
33d06184:	0a00002e 	beq	33d06244 <nand_write_ecc+0x3a4>
			/* enable hardware ecc logic for write */
			this->enable_hwecc(mtd, NAND_ECC_WRITE);
33d06188:	e1a00006 	mov	r0, r6
33d0618c:	e3a01001 	mov	r1, #1	; 0x1
33d06190:	e1a0e00f 	mov	lr, pc
33d06194:	e595f048 	ldr	pc, [r5, #72]
			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
33d06198:	e59d2008 	ldr	r2, [sp, #8]
33d0619c:	e5951084 	ldr	r1, [r5, #132]
33d061a0:	e1a00006 	mov	r0, r6
33d061a4:	e0811002 	add	r1, r1, r2
33d061a8:	e5952058 	ldr	r2, [r5, #88]
33d061ac:	e1a0e00f 	mov	lr, pc
33d061b0:	e595f018 	ldr	pc, [r5, #24]
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
33d061b4:	e5951084 	ldr	r1, [r5, #132]
33d061b8:	e59d3008 	ldr	r3, [sp, #8]
33d061bc:	e28d9048 	add	r9, sp, #72	; 0x48
33d061c0:	e0811003 	add	r1, r1, r3
33d061c4:	e1a00006 	mov	r0, r6
33d061c8:	e1a02009 	mov	r2, r9
			for (i = 0; i < eccbytes; i++, eccidx++)
33d061cc:	e3a04000 	mov	r4, #0	; 0x0
		eccbytes = this->eccbytes;
		for (; eccsteps; eccsteps--) {
			/* enable hardware ecc logic for write */
			this->enable_hwecc(mtd, NAND_ECC_WRITE);
			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
33d061d0:	e1a0e00f 	mov	lr, pc
33d061d4:	e595f040 	ldr	pc, [r5, #64]
			for (i = 0; i < eccbytes; i++, eccidx++)
33d061d8:	e1540007 	cmp	r4, r7
33d061dc:	aa00000b 	bge	33d06210 <nand_write_ecc+0x370>
33d061e0:	e1a01009 	mov	r1, r9
				oob_buf[oob_config[eccidx]] = ecc_code[i];
33d061e4:	e59dc004 	ldr	ip, [sp, #4]
33d061e8:	e59de00c 	ldr	lr, [sp, #12]
33d061ec:	e4d13001 	ldrb	r3, [r1], #1
33d061f0:	e79e210c 	ldr	r2, [lr, ip, lsl #2]
		for (; eccsteps; eccsteps--) {
			/* enable hardware ecc logic for write */
			this->enable_hwecc(mtd, NAND_ECC_WRITE);
			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < eccbytes; i++, eccidx++)
33d061f4:	e2844001 	add	r4, r4, #1	; 0x1
				oob_buf[oob_config[eccidx]] = ecc_code[i];
33d061f8:	e59d0014 	ldr	r0, [sp, #20]
		for (; eccsteps; eccsteps--) {
			/* enable hardware ecc logic for write */
			this->enable_hwecc(mtd, NAND_ECC_WRITE);
			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < eccbytes; i++, eccidx++)
33d061fc:	e28cc001 	add	ip, ip, #1	; 0x1
33d06200:	e1540007 	cmp	r4, r7
				oob_buf[oob_config[eccidx]] = ecc_code[i];
33d06204:	e7c03002 	strb	r3, [r0, r2]
		for (; eccsteps; eccsteps--) {
			/* enable hardware ecc logic for write */
			this->enable_hwecc(mtd, NAND_ECC_WRITE);
			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
			for (i = 0; i < eccbytes; i++, eccidx++)
33d06208:	e58dc004 	str	ip, [sp, #4]
33d0620c:	bafffff4 	blt	33d061e4 <nand_write_ecc+0x344>
				oob_buf[oob_config[eccidx]] = ecc_code[i];
			/* If the hardware ecc provides syndromes then
			 * the ecc code must be written immidiately after
			 * the data bytes (words) */
			if (this->options & NAND_HWECC_SYNDROME)
33d06210:	e5953088 	ldr	r3, [r5, #136]
33d06214:	e3130802 	tst	r3, #131072	; 0x20000
				this->write_buf(mtd, ecc_code, eccbytes);
33d06218:	11a01009 	movne	r1, r9
33d0621c:	11a00006 	movne	r0, r6
33d06220:	11a02007 	movne	r2, r7
33d06224:	11a0e00f 	movne	lr, pc
33d06228:	1595f018 	ldrne	pc, [r5, #24]
			datidx += this->eccsize;
33d0622c:	e5953058 	ldr	r3, [r5, #88]
33d06230:	e59d1008 	ldr	r1, [sp, #8]
		}
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
		break;
	default:
		eccbytes = this->eccbytes;
		for (; eccsteps; eccsteps--) {
33d06234:	e25aa001 	subs	sl, sl, #1	; 0x1
			/* If the hardware ecc provides syndromes then
			 * the ecc code must be written immidiately after
			 * the data bytes (words) */
			if (this->options & NAND_HWECC_SYNDROME)
				this->write_buf(mtd, ecc_code, eccbytes);
			datidx += this->eccsize;
33d06238:	e0811003 	add	r1, r1, r3
33d0623c:	e58d1008 	str	r1, [sp, #8]
		}
		this->write_buf(mtd, this->data_poi, mtd->oobblock);
		break;
	default:
		eccbytes = this->eccbytes;
		for (; eccsteps; eccsteps--) {
33d06240:	1affffd0 	bne	33d06188 <nand_write_ecc+0x2e8>
		}
		break;
	}

	/* Write out OOB data */
	if (this->options & NAND_HWECC_SYNDROME)
33d06244:	e5953088 	ldr	r3, [r5, #136]
33d06248:	e3130802 	tst	r3, #131072	; 0x20000
33d0624c:	0a000006 	beq	33d0626c <nand_write_ecc+0x3cc>
		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
33d06250:	e59d2094 	ldr	r2, [sp, #148]
33d06254:	e59d3014 	ldr	r3, [sp, #20]
33d06258:	e5921004 	ldr	r1, [r2, #4]
33d0625c:	e5962014 	ldr	r2, [r6, #20]
33d06260:	e0612002 	rsb	r2, r1, r2
33d06264:	e0831001 	add	r1, r3, r1
33d06268:	ea000005 	b	33d06284 <nand_write_ecc+0x3e4>
	else if (eccmode != NAND_ECC_NONE)
33d0626c:	e59d4010 	ldr	r4, [sp, #16]
33d06270:	e3540000 	cmp	r4, #0	; 0x0
33d06274:	e5962014 	ldr	r2, [r6, #20]
		this->write_buf(mtd, oob_buf, mtd->oobsize);
	else {
		for (i = 0; i < mtd->oobsize; i++) {
33d06278:	059d4010 	ldreq	r4, [sp, #16]
	}

	/* Write out OOB data */
	if (this->options & NAND_HWECC_SYNDROME)
		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
	else if (eccmode != NAND_ECC_NONE)
33d0627c:	0a000004 	beq	33d06294 <nand_write_ecc+0x3f4>
		this->write_buf(mtd, oob_buf, mtd->oobsize);
33d06280:	e59d1014 	ldr	r1, [sp, #20]
33d06284:	e1a00006 	mov	r0, r6
33d06288:	e1a0e00f 	mov	lr, pc
33d0628c:	e595f018 	ldr	pc, [r5, #24]
33d06290:	ea000018 	b	33d062f8 <nand_write_ecc+0x458>
	else {
		for (i = 0; i < mtd->oobsize; i++) {
33d06294:	e1540002 	cmp	r4, r2
33d06298:	2a000016 	bcs	33d062f8 <nand_write_ecc+0x458>
			if (oob_buf[i] != 0xff)
33d0629c:	e59dc014 	ldr	ip, [sp, #20]
33d062a0:	e7dc3004 	ldrb	r3, [ip, r4]
33d062a4:	e35300ff 	cmp	r3, #255	; 0xff
	if (this->options & NAND_HWECC_SYNDROME)
		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
	else if (eccmode != NAND_ECC_NONE)
		this->write_buf(mtd, oob_buf, mtd->oobsize);
	else {
		for (i = 0; i < mtd->oobsize; i++) {
33d062a8:	02844001 	addeq	r4, r4, #1	; 0x1
33d062ac:	0afffff8 	beq	33d06294 <nand_write_ecc+0x3f4>
			if (oob_buf[i] != 0xff)
				break;
		}
		if (i < mtd->oobsize) {
33d062b0:	e1540002 	cmp	r4, r2
33d062b4:	2a00000f 	bcs	33d062f8 <nand_write_ecc+0x458>
			printf("Bad oob_buf: page = 0x%x, data = ", page);
33d062b8:	e59f01b8 	ldr	r0, [pc, #440]	; 33d06478 <nand_write_ecc+0x5d8>
33d062bc:	e1a0100b 	mov	r1, fp
33d062c0:	eb004340 	bl	33d16fc8 <printf>
			for (i = 0; i < mtd->oobsize; i++) {
33d062c4:	e5963014 	ldr	r3, [r6, #20]
33d062c8:	e3a04000 	mov	r4, #0	; 0x0
33d062cc:	e1540003 	cmp	r4, r3
33d062d0:	2a000006 	bcs	33d062f0 <nand_write_ecc+0x450>
				printf("%02x ", oob_buf[i]);
33d062d4:	e59de014 	ldr	lr, [sp, #20]
33d062d8:	e59f019c 	ldr	r0, [pc, #412]	; 33d0647c <nand_write_ecc+0x5dc>
33d062dc:	e7de1004 	ldrb	r1, [lr, r4]
33d062e0:	eb004338 	bl	33d16fc8 <printf>
			if (oob_buf[i] != 0xff)
				break;
		}
		if (i < mtd->oobsize) {
			printf("Bad oob_buf: page = 0x%x, data = ", page);
			for (i = 0; i < mtd->oobsize; i++) {
33d062e4:	e5963014 	ldr	r3, [r6, #20]
33d062e8:	e2844001 	add	r4, r4, #1	; 0x1
33d062ec:	eafffff6 	b	33d062cc <nand_write_ecc+0x42c>
				printf("%02x ", oob_buf[i]);
			}
			printf("\n");
33d062f0:	e59f0188 	ldr	r0, [pc, #392]	; 33d06480 <nand_write_ecc+0x5e0>
33d062f4:	eb004333 	bl	33d16fc8 <printf>
		}
	}

	/* Send command to actually program the data */
	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
33d062f8:	e3e02000 	mvn	r2, #0	; 0x0
33d062fc:	e1a03002 	mov	r3, r2
33d06300:	e1a00006 	mov	r0, r6
33d06304:	e3a01010 	mov	r1, #16	; 0x10
33d06308:	e1a0e00f 	mov	lr, pc
33d0630c:	e595f038 	ldr	pc, [r5, #56]

	if (!cached) {
		/* call wait ready function */
		status = this->waitfunc (mtd, this, FL_WRITING);
33d06310:	e1a00006 	mov	r0, r6
33d06314:	e1a01005 	mov	r1, r5
33d06318:	e3a02002 	mov	r2, #2	; 0x2
33d0631c:	e1a0e00f 	mov	lr, pc
33d06320:	e595f03c 	ldr	pc, [r5, #60]
		/* See if device thinks it succeeded */
		if (status & 0x01) {
33d06324:	e3100001 	tst	r0, #1	; 0x1
			DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
33d06328:	03a07000 	moveq	r7, #0	; 0x0
33d0632c:	13e07004 	mvnne	r7, #4	; 0x4
		 * or the last page in this block, then use the
		 * real pageprogram command, else select cached programming
		 * if supported by the chip.
		 */
		ret = nand_write_page (mtd, this, page, &oobbuf[oob], oobsel, (--numpages > 0));
		if (ret) {
33d06330:	e3570000 	cmp	r7, #0	; 0x0
33d06334:	1a000049 	bne	33d06460 <nand_write_ecc+0x5c0>
			goto out;
		}
		/* Next oob page */
		oob += mtd->oobsize;
		/* Update written bytes count */
		written += mtd->oobblock;
33d06338:	e5963010 	ldr	r3, [r6, #16]
33d0633c:	e59d0030 	ldr	r0, [sp, #48]
33d06340:	e0800003 	add	r0, r0, r3
33d06344:	e58d0030 	str	r0, [sp, #48]
		if (ret) {
			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
			goto out;
		}
		/* Next oob page */
		oob += mtd->oobsize;
33d06348:	e59d2034 	ldr	r2, [sp, #52]
33d0634c:	e5963014 	ldr	r3, [r6, #20]
		/* Update written bytes count */
		written += mtd->oobblock;
		if (written == len)
33d06350:	e59d103c 	ldr	r1, [sp, #60]
		if (ret) {
			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
			goto out;
		}
		/* Next oob page */
		oob += mtd->oobsize;
33d06354:	e0822003 	add	r2, r2, r3
		/* Update written bytes count */
		written += mtd->oobblock;
		if (written == len)
33d06358:	e1500001 	cmp	r0, r1
		if (ret) {
			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
			goto out;
		}
		/* Next oob page */
		oob += mtd->oobsize;
33d0635c:	e58d2034 	str	r2, [sp, #52]
		/* Update written bytes count */
		written += mtd->oobblock;
		if (written == len)
33d06360:	0a000038 	beq	33d06448 <nand_write_ecc+0x5a8>

		/* Have we hit a block boundary ? Then we have to verify and
		 * if verify is ok, we have to setup the oob buffer for
		 * the next pages.
		*/
		if (!(page & (ppblock - 1))){
33d06364:	e59d3018 	ldr	r3, [sp, #24]
		written += mtd->oobblock;
		if (written == len)
			goto cmp;

		/* Increment page address */
		page++;
33d06368:	e28bb001 	add	fp, fp, #1	; 0x1

		/* Have we hit a block boundary ? Then we have to verify and
		 * if verify is ok, we have to setup the oob buffer for
		 * the next pages.
		*/
		if (!(page & (ppblock - 1))){
33d0636c:	e11b0003 	tst	fp, r3
33d06370:	1a000030 	bne	33d06438 <nand_write_ecc+0x598>
			int ofs;
			this->data_poi = bufstart;
33d06374:	e59dc08c 	ldr	ip, [sp, #140]
				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
				goto out;
			}
			*retlen = written;

			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
33d06378:	e59d4028 	ldr	r4, [sp, #40]
		 * if verify is ok, we have to setup the oob buffer for
		 * the next pages.
		*/
		if (!(page & (ppblock - 1))){
			int ofs;
			this->data_poi = bufstart;
33d0637c:	e585c084 	str	ip, [r5, #132]
				oobbuf, oobsel, chipnr, (eccbuf != NULL));
			if (ret) {
				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
				goto out;
			}
			*retlen = written;
33d06380:	e59de088 	ldr	lr, [sp, #136]
33d06384:	e58e0000 	str	r0, [lr]

			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
			if (eccbuf)
33d06388:	e59d0090 	ldr	r0, [sp, #144]
				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
				goto out;
			}
			*retlen = written;

			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
33d0638c:	e3540000 	cmp	r4, #0	; 0x0
33d06390:	15962018 	ldrne	r2, [r6, #24]
33d06394:	05962014 	ldreq	r2, [r6, #20]
			if (eccbuf)
33d06398:	e3500000 	cmp	r0, #0	; 0x0
				eccbuf += (page - startpage) * ofs;
33d0639c:	159d1038 	ldrne	r1, [sp, #56]
33d063a0:	1061300b 	rsbne	r3, r1, fp
33d063a4:	10200392 	mlane	r0, r2, r3, r0
			totalpages -= page - startpage;
33d063a8:	e59d2038 	ldr	r2, [sp, #56]
			}
			*retlen = written;

			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
			if (eccbuf)
				eccbuf += (page - startpage) * ofs;
33d063ac:	158d0090 	strne	r0, [sp, #144]
			totalpages -= page - startpage;
33d063b0:	e59d4024 	ldr	r4, [sp, #36]
33d063b4:	e062300b 	rsb	r3, r2, fp
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
33d063b8:	e595c098 	ldr	ip, [r5, #152]
			*retlen = written;

			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
			if (eccbuf)
				eccbuf += (page - startpage) * ofs;
			totalpages -= page - startpage;
33d063bc:	e0634004 	rsb	r4, r3, r4
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
			startpage = page;
			oob = 0;
			this->oobdirty = 1;
33d063c0:	e3a03001 	mov	r3, #1	; 0x1
			*retlen = written;

			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
			if (eccbuf)
				eccbuf += (page - startpage) * ofs;
			totalpages -= page - startpage;
33d063c4:	e58d4024 	str	r4, [sp, #36]
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
			startpage = page;
			oob = 0;
			this->oobdirty = 1;
33d063c8:	e5853080 	str	r3, [r5, #128]
			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
			if (eccbuf)
				eccbuf += (page - startpage) * ofs;
			totalpages -= page - startpage;
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
33d063cc:	e00bb00c 	and	fp, fp, ip
			startpage = page;
			oob = 0;
			this->oobdirty = 1;
			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
33d063d0:	e59dc01c 	ldr	ip, [sp, #28]
33d063d4:	e1a00006 	mov	r0, r6
33d063d8:	e28d1090 	add	r1, sp, #144	; 0x90
33d063dc:	e8910006 	ldm	r1, {r1, r2}
33d063e0:	e59d3028 	ldr	r3, [sp, #40]
33d063e4:	e15c0004 	cmp	ip, r4
33d063e8:	d58dc000 	strle	ip, [sp]
33d063ec:	c58d4000 	strgt	r4, [sp]
33d063f0:	ebfffe63 	bl	33d05d84 <nand_prepare_oobbuf>
				eccbuf += (page - startpage) * ofs;
			totalpages -= page - startpage;
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
			startpage = page;
			oob = 0;
33d063f4:	e3a0e000 	mov	lr, #0	; 0x0
			this->oobdirty = 1;
			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
					autoplace, numpages);
			/* Check, if we cross a chip boundary */
			if (!page) {
33d063f8:	e35b0000 	cmp	fp, #0	; 0x0
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
			startpage = page;
			oob = 0;
			this->oobdirty = 1;
			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
33d063fc:	e58d0020 	str	r0, [sp, #32]
			if (eccbuf)
				eccbuf += (page - startpage) * ofs;
			totalpages -= page - startpage;
			numpages = min (totalpages, ppblock);
			page &= this->pagemask;
			startpage = page;
33d06400:	e58db038 	str	fp, [sp, #56]
			oob = 0;
33d06404:	e58de034 	str	lr, [sp, #52]
			this->oobdirty = 1;
			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
					autoplace, numpages);
			/* Check, if we cross a chip boundary */
			if (!page) {
33d06408:	1a00000a 	bne	33d06438 <nand_write_ecc+0x598>
				chipnr++;
33d0640c:	e59d002c 	ldr	r0, [sp, #44]
33d06410:	e2800001 	add	r0, r0, #1	; 0x1
33d06414:	e58d002c 	str	r0, [sp, #44]
				this->select_chip(mtd, -1);
33d06418:	e3e01000 	mvn	r1, #0	; 0x0
33d0641c:	e1a00006 	mov	r0, r6
33d06420:	e1a0e00f 	mov	lr, pc
33d06424:	e595f024 	ldr	pc, [r5, #36]
				this->select_chip(mtd, chipnr);
33d06428:	e1a00006 	mov	r0, r6
33d0642c:	e59d102c 	ldr	r1, [sp, #44]
33d06430:	e1a0e00f 	mov	lr, pc
33d06434:	e595f024 	ldr	pc, [r5, #36]
33d06438:	e59d1030 	ldr	r1, [sp, #48]
33d0643c:	e59d203c 	ldr	r2, [sp, #60]
33d06440:	e1510002 	cmp	r1, r2
33d06444:	eaffff0a 	b	33d06074 <nand_write_ecc+0x1d4>
			}
		}
	}
	/* Verify the remaining pages */
cmp:
	this->data_poi = bufstart;
33d06448:	e59d308c 	ldr	r3, [sp, #140]
33d0644c:	e5853084 	str	r3, [r5, #132]
 	ret = nand_verify_pages (mtd, this, startpage, totalpages,
		oobbuf, oobsel, chipnr, (eccbuf != NULL));
	if (!ret)
		*retlen = written;
33d06450:	e59dc030 	ldr	ip, [sp, #48]
33d06454:	e59d4088 	ldr	r4, [sp, #136]
33d06458:	e584c000 	str	ip, [r4]
		}
	}
	/* Verify the remaining pages */
cmp:
	this->data_poi = bufstart;
 	ret = nand_verify_pages (mtd, this, startpage, totalpages,
33d0645c:	e3a07000 	mov	r7, #0	; 0x0
	else
		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);

out:
	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d06460:	e1a00006 	mov	r0, r6
33d06464:	ebfff8e9 	bl	33d04810 <nand_release_device>

	return ret;
33d06468:	e1a00007 	mov	r0, r7
}
33d0646c:	e28dd068 	add	sp, sp, #104	; 0x68
33d06470:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d06474:	33d25cfc 	.word	0x33d25cfc
33d06478:	33d25d34 	.word	0x33d25d34
33d0647c:	33d25d58 	.word	0x33d25d58
33d06480:	33d2bd80 	.word	0x33d2bd80

33d06484 <nand_write>:
 *
 * This function simply calls nand_write_ecc with oob buffer and oobsel = NULL
 *
*/
static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
{
33d06484:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d06488:	e24dd010 	sub	sp, sp, #16	; 0x10
	return (nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL));
33d0648c:	e59de014 	ldr	lr, [sp, #20]
33d06490:	e58de000 	str	lr, [sp]
33d06494:	e59de018 	ldr	lr, [sp, #24]
33d06498:	e3a0c000 	mov	ip, #0	; 0x0
33d0649c:	e58de004 	str	lr, [sp, #4]
33d064a0:	e58dc00c 	str	ip, [sp, #12]
33d064a4:	e58dc008 	str	ip, [sp, #8]
33d064a8:	ebfffe7c 	bl	33d05ea0 <nand_write_ecc>
}
33d064ac:	e28dd010 	add	sp, sp, #16	; 0x10
33d064b0:	e8bd8000 	pop	{pc}

33d064b4 <nand_write_calmecc>:
 * NAND write
 */
int
nand_write_calmecc(struct mtd_info *mtd, loff_t to, size_t len, 
           size_t *retlen, const u_char *buf, unsigned int *pdwECCVal)
{
33d064b4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d064b8:	e1a07000 	mov	r7, r0
	DEBUG(MTD_DEBUG_LEVEL3,
		"%s(): to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int)to,
		(int) len);

	/* Do not allow write past end of page */
	if ((to + len) > mtd->size) {
33d064bc:	e5900008 	ldr	r0, [r0, #8]
 * NAND write
 */
int
nand_write_calmecc(struct mtd_info *mtd, loff_t to, size_t len, 
           size_t *retlen, const u_char *buf, unsigned int *pdwECCVal)
{
33d064c0:	e1a06002 	mov	r6, r2
33d064c4:	e1a05001 	mov	r5, r1
	DEBUG(MTD_DEBUG_LEVEL3,
		"%s(): to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int)to,
		(int) len);

	/* Do not allow write past end of page */
	if ((to + len) > mtd->size) {
33d064c8:	e0912003 	adds	r2, r1, r3
 * NAND write
 */
int
nand_write_calmecc(struct mtd_info *mtd, loff_t to, size_t len, 
           size_t *retlen, const u_char *buf, unsigned int *pdwECCVal)
{
33d064cc:	e1a09003 	mov	r9, r3
	DEBUG(MTD_DEBUG_LEVEL3,
		"%s(): to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int)to,
		(int) len);

	/* Do not allow write past end of page */
	if ((to + len) > mtd->size) {
33d064d0:	e3a01000 	mov	r1, #0	; 0x0
33d064d4:	e2a63000 	adc	r3, r6, #0	; 0x0
 * NAND write
 */
int
nand_write_calmecc(struct mtd_info *mtd, loff_t to, size_t len, 
           size_t *retlen, const u_char *buf, unsigned int *pdwECCVal)
{
33d064d8:	e24dd004 	sub	sp, sp, #4	; 0x4
	DEBUG(MTD_DEBUG_LEVEL3,
		"%s(): to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int)to,
		(int) len);

	/* Do not allow write past end of page */
	if ((to + len) > mtd->size) {
33d064dc:	e1530001 	cmp	r3, r1
 * NAND write
 */
int
nand_write_calmecc(struct mtd_info *mtd, loff_t to, size_t len, 
           size_t *retlen, const u_char *buf, unsigned int *pdwECCVal)
{
33d064e0:	e59db024 	ldr	fp, [sp, #36]
	int i, page, col, cnt, status, chipnr;    
	struct nand_chip *this = mtd->priv;
33d064e4:	e597a13c 	ldr	sl, [r7, #316]
	DEBUG(MTD_DEBUG_LEVEL3,
		"%s(): to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int)to,
		(int) len);

	/* Do not allow write past end of page */
	if ((to + len) > mtd->size) {
33d064e8:	ca000002 	bgt	33d064f8 <nand_write_calmecc+0x44>
33d064ec:	1a000005 	bne	33d06508 <nand_write_calmecc+0x54>
33d064f0:	e1520000 	cmp	r2, r0
33d064f4:	9a000003 	bls	33d06508 <nand_write_calmecc+0x54>
		DEBUG(MTD_DEBUG_LEVEL0,
			"%s(): Attempted write past end of device\n", __FUNCTION__);
		return -EINVAL;
33d064f8:	e3e00015 	mvn	r0, #21	; 0x15
33d064fc:	ea00009c 	b	33d06774 <nand_write_calmecc+0x2c0>
    	/* call wait ready function */
    	status = this->waitfunc (mtd, this, FL_WRITING);
    	/* See if device thinks it succeeded */
    	if (status & 0x01) {
    		DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
    		return -EIO;
33d06500:	e3e00004 	mvn	r0, #4	; 0x4
33d06504:	ea00009a 	b	33d06774 <nand_write_calmecc+0x2c0>

	/* Get the starting column */
	col = to & (mtd->oobblock - 1);

	/* Initialize return length value */
	*retlen = 0;
33d06508:	e3a03000 	mov	r3, #0	; 0x0
			"%s(): Attempted write past end of device\n", __FUNCTION__);
		return -EINVAL;
	}

	/* Shift to get page */
	page = ((int)to) >> this->page_shift;
33d0650c:	e59ae068 	ldr	lr, [sl, #104]

	/* Get the starting column */
	col = to & (mtd->oobblock - 1);
33d06510:	e597c010 	ldr	ip, [r7, #16]

	/* Initialize return length value */
	*retlen = 0;
33d06514:	e58b3000 	str	r3, [fp]
			"%s(): Attempted write past end of device\n", __FUNCTION__);
		return -EINVAL;
	}

	/* Shift to get page */
	page = ((int)to) >> this->page_shift;
33d06518:	e1a0ee55 	asr	lr, r5, lr

	/* Get the starting column */
	col = to & (mtd->oobblock - 1);
33d0651c:	e24cc001 	sub	ip, ip, #1	; 0x1

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_WRITING);

	/* Calculate chipnr */
	chipnr = (int)(to >> this->chip_shift);
33d06520:	e59a2074 	ldr	r2, [sl, #116]
33d06524:	e1a01006 	mov	r1, r6
33d06528:	e1a00005 	mov	r0, r5
			"%s(): Attempted write past end of device\n", __FUNCTION__);
		return -EINVAL;
	}

	/* Shift to get page */
	page = ((int)to) >> this->page_shift;
33d0652c:	e58de000 	str	lr, [sp]

	/* Get the starting column */
	col = to & (mtd->oobblock - 1);
33d06530:	e00c5005 	and	r5, ip, r5

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_WRITING);

	/* Calculate chipnr */
	chipnr = (int)(to >> this->chip_shift);
33d06534:	eb006042 	bl	33d1e644 <__ashrdi3>
33d06538:	e1a02001 	mov	r2, r1
33d0653c:	e1a01000 	mov	r1, r0
	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d06540:	e1a00007 	mov	r0, r7
33d06544:	e1a0e00f 	mov	lr, pc
33d06548:	e59af024 	ldr	pc, [sl, #36]

	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
33d0654c:	e1a00007 	mov	r0, r7
33d06550:	ebfff98d 	bl	33d04b8c <nand_check_wp>
33d06554:	e3500000 	cmp	r0, #0	; 0x0
33d06558:	1a000082 	bne	33d06768 <nand_write_calmecc+0x2b4>

		/* Update written bytes count */
		*retlen += cnt;

		/* Increment page address */
		page++;
33d0655c:	e59b3000 	ldr	r3, [fp]
33d06560:	e1530009 	cmp	r3, r9
33d06564:	2a00007d 	bcs	33d06760 <nand_write_calmecc+0x2ac>
		goto nand_write_exit;

	/* Loop until all data is written */
	while (*retlen < len) {
		/* Write data into buffer */
		if ((col + len) >= mtd->oobblock)
33d06568:	e5972010 	ldr	r2, [r7, #16]
33d0656c:	e0853009 	add	r3, r5, r9
33d06570:	e1530002 	cmp	r3, r2
33d06574:	3a00000e 	bcc	33d065b4 <nand_write_calmecc+0x100>
			for (i = col, cnt = 0; i < mtd->oobblock; i++, cnt++)
33d06578:	e1a04005 	mov	r4, r5
33d0657c:	e1550002 	cmp	r5, r2
33d06580:	e3a06000 	mov	r6, #0	; 0x0
33d06584:	2a00001a 	bcs	33d065f4 <nand_write_calmecc+0x140>
				this->data_buf[i] = buf[(*retlen + cnt)];
33d06588:	e59b3000 	ldr	r3, [fp]
33d0658c:	e59d1028 	ldr	r1, [sp, #40]
33d06590:	e0833001 	add	r3, r3, r1
33d06594:	e7d32006 	ldrb	r2, [r3, r6]
33d06598:	e59a3078 	ldr	r3, [sl, #120]
33d0659c:	e7c32004 	strb	r2, [r3, r4]

	/* Loop until all data is written */
	while (*retlen < len) {
		/* Write data into buffer */
		if ((col + len) >= mtd->oobblock)
			for (i = col, cnt = 0; i < mtd->oobblock; i++, cnt++)
33d065a0:	e5973010 	ldr	r3, [r7, #16]
33d065a4:	e2844001 	add	r4, r4, #1	; 0x1
33d065a8:	e1540003 	cmp	r4, r3
33d065ac:	e2866001 	add	r6, r6, #1	; 0x1
33d065b0:	eafffff3 	b	33d06584 <nand_write_calmecc+0xd0>
				this->data_buf[i] = buf[(*retlen + cnt)];
		else
			for (i = col, cnt = 0; cnt < (len - *retlen); i++, cnt++)
33d065b4:	e59b2000 	ldr	r2, [fp]
33d065b8:	e1590002 	cmp	r9, r2
33d065bc:	e1a04005 	mov	r4, r5
33d065c0:	e3a06000 	mov	r6, #0	; 0x0
33d065c4:	0a00000a 	beq	33d065f4 <nand_write_calmecc+0x140>
				this->data_buf[i] = buf[(*retlen + cnt)];
33d065c8:	e59dc028 	ldr	ip, [sp, #40]
33d065cc:	e082300c 	add	r3, r2, ip
33d065d0:	e7d32006 	ldrb	r2, [r3, r6]
33d065d4:	e59a3078 	ldr	r3, [sl, #120]
33d065d8:	e7c32004 	strb	r2, [r3, r4]
		/* Write data into buffer */
		if ((col + len) >= mtd->oobblock)
			for (i = col, cnt = 0; i < mtd->oobblock; i++, cnt++)
				this->data_buf[i] = buf[(*retlen + cnt)];
		else
			for (i = col, cnt = 0; cnt < (len - *retlen); i++, cnt++)
33d065dc:	e59b2000 	ldr	r2, [fp]
33d065e0:	e2866001 	add	r6, r6, #1	; 0x1
33d065e4:	e0623009 	rsb	r3, r2, r9
33d065e8:	e1560003 	cmp	r6, r3
33d065ec:	e2844001 	add	r4, r4, #1	; 0x1
33d065f0:	3afffff4 	bcc	33d065c8 <nand_write_calmecc+0x114>
				this->data_buf[i] = buf[(*retlen + cnt)];
		/* Write ones for partial page programming */
		for (i = mtd->oobblock; i < (mtd->oobblock + mtd->oobsize); i++)
33d065f4:	e2871010 	add	r1, r7, #16	; 0x10
33d065f8:	e891000a 	ldm	r1, {r1, r3}
33d065fc:	e0813003 	add	r3, r1, r3
33d06600:	e5974010 	ldr	r4, [r7, #16]
33d06604:	e1540003 	cmp	r4, r3
33d06608:	2a000007 	bcs	33d0662c <nand_write_calmecc+0x178>
			this->data_buf[i] = 0xff;
33d0660c:	e59a3078 	ldr	r3, [sl, #120]
33d06610:	e3e02000 	mvn	r2, #0	; 0x0
33d06614:	e7c32004 	strb	r2, [r3, r4]
				this->data_buf[i] = buf[(*retlen + cnt)];
		else
			for (i = col, cnt = 0; cnt < (len - *retlen); i++, cnt++)
				this->data_buf[i] = buf[(*retlen + cnt)];
		/* Write ones for partial page programming */
		for (i = mtd->oobblock; i < (mtd->oobblock + mtd->oobsize); i++)
33d06618:	e2872010 	add	r2, r7, #16	; 0x10
33d0661c:	e892000c 	ldm	r2, {r2, r3}
33d06620:	e0823003 	add	r3, r2, r3
33d06624:	e2844001 	add	r4, r4, #1	; 0x1
33d06628:	eafffff5 	b	33d06604 <nand_write_calmecc+0x150>
			this->data_buf[i] = 0xff;
		
		/* Write pre-padding bytes into buffer */
		for (i = 0; i < col; i++)
33d0662c:	e3a04000 	mov	r4, #0	; 0x0
33d06630:	e1540005 	cmp	r4, r5
			this->data_buf[i] = 0xff;
33d06634:	b59a2078 	ldrlt	r2, [sl, #120]
33d06638:	b3e03000 	mvnlt	r3, #0	; 0x0
33d0663c:	b7c23004 	strblt	r3, [r2, r4]
		/* Write ones for partial page programming */
		for (i = mtd->oobblock; i < (mtd->oobblock + mtd->oobsize); i++)
			this->data_buf[i] = 0xff;
		
		/* Write pre-padding bytes into buffer */
		for (i = 0; i < col; i++)
33d06640:	b2844001 	addlt	r4, r4, #1	; 0x1
33d06644:	bafffff9 	blt	33d06630 <nand_write_calmecc+0x17c>
			this->data_buf[i] = 0xff;

		/* Write post-padding bytes into buffer */
		if ((col + (len - *retlen)) < mtd->oobblock) {
33d06648:	e59b3000 	ldr	r3, [fp]
33d0664c:	e5972010 	ldr	r2, [r7, #16]
33d06650:	e0633009 	rsb	r3, r3, r9
33d06654:	e0853003 	add	r3, r5, r3
33d06658:	e1530002 	cmp	r3, r2
33d0665c:	2a000009 	bcs	33d06688 <nand_write_calmecc+0x1d4>
			for (i = (col + cnt); i < mtd->oobblock; i++)
33d06660:	e0854006 	add	r4, r5, r6
33d06664:	e1540002 	cmp	r4, r2
33d06668:	2a000006 	bcs	33d06688 <nand_write_calmecc+0x1d4>
				this->data_buf[i] = 0xff;
33d0666c:	e59a3078 	ldr	r3, [sl, #120]
33d06670:	e3e02000 	mvn	r2, #0	; 0x0
33d06674:	e7c32004 	strb	r2, [r3, r4]
		for (i = 0; i < col; i++)
			this->data_buf[i] = 0xff;

		/* Write post-padding bytes into buffer */
		if ((col + (len - *retlen)) < mtd->oobblock) {
			for (i = (col + cnt); i < mtd->oobblock; i++)
33d06678:	e5973010 	ldr	r3, [r7, #16]
33d0667c:	e2844001 	add	r4, r4, #1	; 0x1
33d06680:	e1540003 	cmp	r4, r3
33d06684:	eafffff7 	b	33d06668 <nand_write_calmecc+0x1b4>
				this->data_buf[i] = 0xff;
		}

        /* HJ for cal ECC */
        s3c2440nand->NFCONT |= (1<<4);   // Reset ECC
33d06688:	e3a0c44e 	mov	ip, #1308622848	; 0x4e000000
33d0668c:	e59c3004 	ldr	r3, [ip, #4]
33d06690:	e3833010 	orr	r3, r3, #16	; 0x10
33d06694:	e58c3004 	str	r3, [ip, #4]
        s3c2440nand->NFCONT &= ~(1<<5);  // UnLock MECC
33d06698:	e59c3004 	ldr	r3, [ip, #4]
33d0669c:	e3c33020 	bic	r3, r3, #32	; 0x20
33d066a0:	e58c3004 	str	r3, [ip, #4]

		/* Send command to begin auto page programming */
		this->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
33d066a4:	e59d3000 	ldr	r3, [sp]
33d066a8:	e1a00007 	mov	r0, r7
33d066ac:	e3a01080 	mov	r1, #128	; 0x80
33d066b0:	e3a02000 	mov	r2, #0	; 0x0
33d066b4:	e1a0e00f 	mov	lr, pc
33d066b8:	e59af038 	ldr	pc, [sl, #56]

		/* Write out complete page of data */
		this->write_buf(mtd, this->data_buf, mtd->oobblock);
33d066bc:	e1a00007 	mov	r0, r7
33d066c0:	e59a1078 	ldr	r1, [sl, #120]
33d066c4:	e5972010 	ldr	r2, [r7, #16]
33d066c8:	e1a0e00f 	mov	lr, pc
33d066cc:	e59af018 	ldr	pc, [sl, #24]

        s3c2440nand->NFCONT |= (1<<5);   // Lock MECC
33d066d0:	e3a0144e 	mov	r1, #1308622848	; 0x4e000000
33d066d4:	e5913004 	ldr	r3, [r1, #4]
33d066d8:	e3833020 	orr	r3, r3, #32	; 0x20
33d066dc:	e5813004 	str	r3, [r1, #4]
        *pdwECCVal = s3c2440nand->NFMECC0; // Read MECC
33d066e0:	e59d202c 	ldr	r2, [sp, #44]
33d066e4:	e591302c 	ldr	r3, [r1, #44]
33d066e8:	e5823000 	str	r3, [r2]

		this->write_buf(mtd, &this->data_buf[mtd->oobblock], mtd->oobsize);
33d066ec:	e59a3078 	ldr	r3, [sl, #120]
33d066f0:	e5971010 	ldr	r1, [r7, #16]
33d066f4:	e1a00007 	mov	r0, r7
33d066f8:	e0831001 	add	r1, r3, r1
33d066fc:	e5972014 	ldr	r2, [r7, #20]
33d06700:	e1a0e00f 	mov	lr, pc
33d06704:	e59af018 	ldr	pc, [sl, #24]
        
    	/* Send command to actually program the data */
    	this->cmdfunc (mtd, NAND_CMD_PAGEPROG, -1, -1);
33d06708:	e3e02000 	mvn	r2, #0	; 0x0
33d0670c:	e1a03002 	mov	r3, r2
33d06710:	e1a00007 	mov	r0, r7
33d06714:	e3a01010 	mov	r1, #16	; 0x10
33d06718:	e1a0e00f 	mov	lr, pc
33d0671c:	e59af038 	ldr	pc, [sl, #56]

    	/* call wait ready function */
    	status = this->waitfunc (mtd, this, FL_WRITING);
33d06720:	e1a00007 	mov	r0, r7
33d06724:	e1a0100a 	mov	r1, sl
33d06728:	e3a02002 	mov	r2, #2	; 0x2
33d0672c:	e1a0e00f 	mov	lr, pc
33d06730:	e59af03c 	ldr	pc, [sl, #60]
    	/* See if device thinks it succeeded */
    	if (status & 0x01) {
33d06734:	e2100001 	ands	r0, r0, #1	; 0x1
33d06738:	1affff70 	bne	33d06500 <nand_write_calmecc+0x4c>
		 */
		if (col)
			col = 0x00;

		/* Update written bytes count */
		*retlen += cnt;
33d0673c:	e59b3000 	ldr	r3, [fp]
33d06740:	e0833006 	add	r3, r3, r6
33d06744:	e58b3000 	str	r3, [fp]

		/* Increment page address */
		page++;
33d06748:	e1530009 	cmp	r3, r9
33d0674c:	e59d3000 	ldr	r3, [sp]
		 * If we are writing a large amount of data and/or it
		 * crosses page or half-page boundaries, we set the
		 * the column to zero. It simplifies the program logic.
		 */
		if (col)
			col = 0x00;
33d06750:	e1a05000 	mov	r5, r0

		/* Update written bytes count */
		*retlen += cnt;

		/* Increment page address */
		page++;
33d06754:	e2833001 	add	r3, r3, #1	; 0x1
33d06758:	e58d3000 	str	r3, [sp]
33d0675c:	eaffff80 	b	33d06564 <nand_write_calmecc+0xb0>
		
	}

	/* Return happy */
	*retlen = len;
33d06760:	e58b9000 	str	r9, [fp]
	i = 0;
33d06764:	e3a04000 	mov	r4, #0	; 0x0

nand_write_exit:
	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d06768:	e1a00007 	mov	r0, r7
33d0676c:	ebfff827 	bl	33d04810 <nand_release_device>

	return i;
33d06770:	e1a00004 	mov	r0, r4
}
33d06774:	e28dd004 	add	sp, sp, #4	; 0x4
33d06778:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d0677c <single_erase_cmd>:
 * @page:	the page address of the block which will be erased
 *
 * Standard erase command for NAND chips
 */
static void single_erase_cmd (struct mtd_info *mtd, int page)
{
33d0677c:	e92d4070 	push	{r4, r5, r6, lr}
	struct nand_chip *this = mtd->priv;
	/* Send commands to erase a block */
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
33d06780:	e3e06000 	mvn	r6, #0	; 0x0
 * @page:	the page address of the block which will be erased
 *
 * Standard erase command for NAND chips
 */
static void single_erase_cmd (struct mtd_info *mtd, int page)
{
33d06784:	e1a03001 	mov	r3, r1
33d06788:	e1a05000 	mov	r5, r0
	struct nand_chip *this = mtd->priv;
	/* Send commands to erase a block */
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
33d0678c:	e1a02006 	mov	r2, r6
 *
 * Standard erase command for NAND chips
 */
static void single_erase_cmd (struct mtd_info *mtd, int page)
{
	struct nand_chip *this = mtd->priv;
33d06790:	e590413c 	ldr	r4, [r0, #316]
	/* Send commands to erase a block */
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
33d06794:	e3a01060 	mov	r1, #96	; 0x60
33d06798:	e1a0e00f 	mov	lr, pc
33d0679c:	e594f038 	ldr	pc, [r4, #56]
	this->cmdfunc (mtd, NAND_CMD_ERASE2, -1, -1);
33d067a0:	e1a00005 	mov	r0, r5
33d067a4:	e1a02006 	mov	r2, r6
33d067a8:	e3a010d0 	mov	r1, #208	; 0xd0
33d067ac:	e1a03006 	mov	r3, r6
33d067b0:	e1a0e00f 	mov	lr, pc
33d067b4:	e594f038 	ldr	pc, [r4, #56]
33d067b8:	e8bd8070 	pop	{r4, r5, r6, pc}

33d067bc <multi_erase_cmd>:
 *
 * AND multi block erase command function
 * Erase 4 consecutive blocks
 */
static void multi_erase_cmd (struct mtd_info *mtd, int page)
{
33d067bc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct nand_chip *this = mtd->priv;
	/* Send commands to erase a block */
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
33d067c0:	e3e07000 	mvn	r7, #0	; 0x0
 *
 * AND multi block erase command function
 * Erase 4 consecutive blocks
 */
static void multi_erase_cmd (struct mtd_info *mtd, int page)
{
33d067c4:	e1a06000 	mov	r6, r0
	struct nand_chip *this = mtd->priv;
33d067c8:	e590513c 	ldr	r5, [r0, #316]
	/* Send commands to erase a block */
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
33d067cc:	e1a03001 	mov	r3, r1
33d067d0:	e2814001 	add	r4, r1, #1	; 0x1
33d067d4:	e1a02007 	mov	r2, r7
33d067d8:	e3a01060 	mov	r1, #96	; 0x60
33d067dc:	e1a0e00f 	mov	lr, pc
33d067e0:	e595f038 	ldr	pc, [r5, #56]
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
33d067e4:	e1a03004 	mov	r3, r4
33d067e8:	e1a00006 	mov	r0, r6
33d067ec:	e1a02007 	mov	r2, r7
33d067f0:	e2844001 	add	r4, r4, #1	; 0x1
33d067f4:	e3a01060 	mov	r1, #96	; 0x60
33d067f8:	e1a0e00f 	mov	lr, pc
33d067fc:	e595f038 	ldr	pc, [r5, #56]
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
33d06800:	e1a03004 	mov	r3, r4
33d06804:	e1a00006 	mov	r0, r6
33d06808:	e1a02007 	mov	r2, r7
33d0680c:	e2844001 	add	r4, r4, #1	; 0x1
33d06810:	e3a01060 	mov	r1, #96	; 0x60
33d06814:	e1a0e00f 	mov	lr, pc
33d06818:	e595f038 	ldr	pc, [r5, #56]
	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
33d0681c:	e1a00006 	mov	r0, r6
33d06820:	e1a03004 	mov	r3, r4
33d06824:	e1a02007 	mov	r2, r7
33d06828:	e3a01060 	mov	r1, #96	; 0x60
33d0682c:	e1a0e00f 	mov	lr, pc
33d06830:	e595f038 	ldr	pc, [r5, #56]
	this->cmdfunc (mtd, NAND_CMD_ERASE2, -1, -1);
33d06834:	e1a00006 	mov	r0, r6
33d06838:	e1a02007 	mov	r2, r7
33d0683c:	e3a010d0 	mov	r1, #208	; 0xd0
33d06840:	e1a03007 	mov	r3, r7
33d06844:	e1a0e00f 	mov	lr, pc
33d06848:	e595f038 	ldr	pc, [r5, #56]
33d0684c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d06850 <nand_erase_nand>:
 * @allowbbt:	allow erasing the bbt area
 *
 * Erase one ore more blocks
 */
int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt)
{
33d06850:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int page, len, status, pages_per_block, ret, chipnr;
	struct nand_chip *this = mtd->priv;
33d06854:	e590413c 	ldr	r4, [r0, #316]

	DEBUG (MTD_DEBUG_LEVEL3,
	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);

	/* Start address must align on block boundary */
	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
33d06858:	e594306c 	ldr	r3, [r4, #108]
33d0685c:	e3a05001 	mov	r5, #1	; 0x1
33d06860:	e591e004 	ldr	lr, [r1, #4]
33d06864:	e1a03315 	lsl	r3, r5, r3
 * @allowbbt:	allow erasing the bbt area
 *
 * Erase one ore more blocks
 */
int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt)
{
33d06868:	e1a06001 	mov	r6, r1

	DEBUG (MTD_DEBUG_LEVEL3,
	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);

	/* Start address must align on block boundary */
	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
33d0686c:	e2431001 	sub	r1, r3, #1	; 0x1
 * @allowbbt:	allow erasing the bbt area
 *
 * Erase one ore more blocks
 */
int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt)
{
33d06870:	e24dd008 	sub	sp, sp, #8	; 0x8

	DEBUG (MTD_DEBUG_LEVEL3,
	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);

	/* Start address must align on block boundary */
	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
33d06874:	e11e0001 	tst	lr, r1
 * @allowbbt:	allow erasing the bbt area
 *
 * Erase one ore more blocks
 */
int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt)
{
33d06878:	e1a07000 	mov	r7, r0
33d0687c:	e58d2004 	str	r2, [sp, #4]

	DEBUG (MTD_DEBUG_LEVEL3,
	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);

	/* Start address must align on block boundary */
	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
33d06880:	1a000006 	bne	33d068a0 <nand_erase_nand+0x50>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Unaligned address\n");
		return -EINVAL;
	}

	/* Length must align on block boundary */
	if (instr->len & ((1 << this->phys_erase_shift) - 1)) {
33d06884:	e5963008 	ldr	r3, [r6, #8]
33d06888:	e1130001 	tst	r3, r1
33d0688c:	1a000003 	bne	33d068a0 <nand_erase_nand+0x50>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Length not block aligned\n");
		return -EINVAL;
	}

	/* Do not allow erase past end of device */
	if ((instr->len + instr->addr) > mtd->size) {
33d06890:	e5902008 	ldr	r2, [r0, #8]
33d06894:	e083300e 	add	r3, r3, lr
33d06898:	e1530002 	cmp	r3, r2
33d0689c:	9a000001 	bls	33d068a8 <nand_erase_nand+0x58>
		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Erase past end of device\n");
		return -EINVAL;
33d068a0:	e3e00015 	mvn	r0, #21	; 0x15
33d068a4:	ea000061 	b	33d06a30 <nand_erase_nand+0x1e0>
	}

	instr->fail_addr = 0xffffffff;
33d068a8:	e3e03000 	mvn	r3, #0	; 0x0
33d068ac:	e586300c 	str	r3, [r6, #12]
	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int) (instr->addr >> this->page_shift);
	chipnr = (int) (instr->addr >> this->chip_shift);
33d068b0:	e5942074 	ldr	r2, [r4, #116]

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int) (instr->addr >> this->page_shift);
33d068b4:	e594c068 	ldr	ip, [r4, #104]
	chipnr = (int) (instr->addr >> this->chip_shift);

	/* Calculate pages in each block */
	pages_per_block = 1 << (this->phys_erase_shift - this->page_shift);
33d068b8:	e594306c 	ldr	r3, [r4, #108]
	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int) (instr->addr >> this->page_shift);
	chipnr = (int) (instr->addr >> this->chip_shift);
33d068bc:	e1a0923e 	lsr	r9, lr, r2

	/* Calculate pages in each block */
	pages_per_block = 1 << (this->phys_erase_shift - this->page_shift);
33d068c0:	e06c3003 	rsb	r3, ip, r3

	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d068c4:	e1a01009 	mov	r1, r9
	/* Shift to get first page */
	page = (int) (instr->addr >> this->page_shift);
	chipnr = (int) (instr->addr >> this->chip_shift);

	/* Calculate pages in each block */
	pages_per_block = 1 << (this->phys_erase_shift - this->page_shift);
33d068c8:	e1a0b315 	lsl	fp, r5, r3

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int) (instr->addr >> this->page_shift);
33d068cc:	e1a05c3e 	lsr	r5, lr, ip

	/* Calculate pages in each block */
	pages_per_block = 1 << (this->phys_erase_shift - this->page_shift);

	/* Select the NAND device */
	this->select_chip(mtd, chipnr);
33d068d0:	e1a0e00f 	mov	lr, pc
33d068d4:	e594f024 	ldr	pc, [r4, #36]

	/* Check the WP bit */
	/* Check, if it is write protected */
	if (nand_check_wp(mtd)) {
33d068d8:	e1a00007 	mov	r0, r7
33d068dc:	ebfff8aa 	bl	33d04b8c <nand_check_wp>
33d068e0:	e3500000 	cmp	r0, #0	; 0x0
33d068e4:	0a00000b 	beq	33d06918 <nand_erase_nand+0xc8>
33d068e8:	ea000002 	b	33d068f8 <nand_erase_nand+0xa8>

	while (len) {
#ifndef NAND_ALLOW_ERASE_ALL
		/* Check if we have a bad block, we do not erase bad blocks ! */
		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
33d068ec:	e1a01005 	mov	r1, r5
33d068f0:	e59f0140 	ldr	r0, [pc, #320]	; 33d06a38 <nand_erase_nand+0x1e8>
33d068f4:	eb0041b3 	bl	33d16fc8 <printf>
			instr->state = MTD_ERASE_FAILED;
33d068f8:	e3a03010 	mov	r3, #16	; 0x10
33d068fc:	ea00003d 	b	33d069f8 <nand_erase_nand+0x1a8>
		status = this->waitfunc (mtd, this, FL_ERASING);

		/* See if block erase succeeded */
		if (status & 0x01) {
			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
			instr->state = MTD_ERASE_FAILED;
33d06900:	e3a03010 	mov	r3, #16	; 0x10
33d06904:	e5c63028 	strb	r3, [r6, #40]
			instr->fail_addr = (page << this->page_shift);
33d06908:	e5943068 	ldr	r3, [r4, #104]
33d0690c:	e1a03315 	lsl	r3, r5, r3
33d06910:	e586300c 	str	r3, [r6, #12]
			goto erase_exit;
33d06914:	ea000038 	b	33d069fc <nand_erase_nand+0x1ac>
		instr->state = MTD_ERASE_FAILED;
		goto erase_exit;
	}

	/* Loop through the pages */
	len = instr->len;
33d06918:	e596a008 	ldr	sl, [r6, #8]

	instr->state = MTD_ERASING;
33d0691c:	e3a03002 	mov	r3, #2	; 0x2

		/* Check, if we cross a chip boundary */
		if (len && !(page & this->pagemask)) {
			chipnr++;
			this->select_chip(mtd, -1);
			this->select_chip(mtd, chipnr);
33d06920:	e35a0000 	cmp	sl, #0	; 0x0
	}

	/* Loop through the pages */
	len = instr->len;

	instr->state = MTD_ERASING;
33d06924:	e5c63028 	strb	r3, [r6, #40]

		/* Check, if we cross a chip boundary */
		if (len && !(page & this->pagemask)) {
			chipnr++;
			this->select_chip(mtd, -1);
			this->select_chip(mtd, chipnr);
33d06928:	0a000031 	beq	33d069f4 <nand_erase_nand+0x1a4>
	instr->state = MTD_ERASING;

	while (len) {
#ifndef NAND_ALLOW_ERASE_ALL
		/* Check if we have a bad block, we do not erase bad blocks ! */
		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
33d0692c:	e5942068 	ldr	r2, [r4, #104]
33d06930:	e1a00005 	mov	r0, r5
33d06934:	e1a01fc0 	asr	r1, r0, #31
33d06938:	eb005f3a 	bl	33d1e628 <__ashldi3>
33d0693c:	e59dc004 	ldr	ip, [sp, #4]
33d06940:	e1a02001 	mov	r2, r1
33d06944:	e1a01000 	mov	r1, r0
33d06948:	e3a03000 	mov	r3, #0	; 0x0
33d0694c:	e1a00007 	mov	r0, r7
33d06950:	e58dc000 	str	ip, [sp]
33d06954:	ebfff92d 	bl	33d04e10 <nand_block_checkbad>
33d06958:	e3500000 	cmp	r0, #0	; 0x0
			goto erase_exit;
		}
#endif
		/* Invalidate the page cache, if we erase the block which contains
		   the current cached page */
		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
33d0695c:	e085200b 	add	r2, r5, fp
			this->pagebuf = -1;

		this->erase_cmd (mtd, page & this->pagemask);
33d06960:	e1a00007 	mov	r0, r7
	instr->state = MTD_ERASING;

	while (len) {
#ifndef NAND_ALLOW_ERASE_ALL
		/* Check if we have a bad block, we do not erase bad blocks ! */
		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
33d06964:	1affffe0 	bne	33d068ec <nand_erase_nand+0x9c>
			goto erase_exit;
		}
#endif
		/* Invalidate the page cache, if we erase the block which contains
		   the current cached page */
		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
33d06968:	e594309c 	ldr	r3, [r4, #156]
33d0696c:	e1550003 	cmp	r5, r3
33d06970:	ca000002 	bgt	33d06980 <nand_erase_nand+0x130>
33d06974:	e1530002 	cmp	r3, r2
			this->pagebuf = -1;
33d06978:	b3e03000 	mvnlt	r3, #0	; 0x0
33d0697c:	b584309c 	strlt	r3, [r4, #156]

		this->erase_cmd (mtd, page & this->pagemask);
33d06980:	e5941098 	ldr	r1, [r4, #152]
33d06984:	e0051001 	and	r1, r5, r1
33d06988:	e1a0e00f 	mov	lr, pc
33d0698c:	e594f04c 	ldr	pc, [r4, #76]

		status = this->waitfunc (mtd, this, FL_ERASING);
33d06990:	e1a01004 	mov	r1, r4
33d06994:	e3a02003 	mov	r2, #3	; 0x3
33d06998:	e1a00007 	mov	r0, r7
33d0699c:	e1a0e00f 	mov	lr, pc
33d069a0:	e594f03c 	ldr	pc, [r4, #60]

		/* See if block erase succeeded */
		if (status & 0x01) {
33d069a4:	e3100001 	tst	r0, #1	; 0x1
		page += pages_per_block;

		/* Check, if we cross a chip boundary */
		if (len && !(page & this->pagemask)) {
			chipnr++;
			this->select_chip(mtd, -1);
33d069a8:	e3e01000 	mvn	r1, #0	; 0x0
			instr->fail_addr = (page << this->page_shift);
			goto erase_exit;
		}

		/* Increment page address and decrement length */
		len -= (1 << this->phys_erase_shift);
33d069ac:	e3a02001 	mov	r2, #1	; 0x1
		page += pages_per_block;

		/* Check, if we cross a chip boundary */
		if (len && !(page & this->pagemask)) {
			chipnr++;
			this->select_chip(mtd, -1);
33d069b0:	e1a00007 	mov	r0, r7
		this->erase_cmd (mtd, page & this->pagemask);

		status = this->waitfunc (mtd, this, FL_ERASING);

		/* See if block erase succeeded */
		if (status & 0x01) {
33d069b4:	1affffd1 	bne	33d06900 <nand_erase_nand+0xb0>
			instr->fail_addr = (page << this->page_shift);
			goto erase_exit;
		}

		/* Increment page address and decrement length */
		len -= (1 << this->phys_erase_shift);
33d069b8:	e594306c 	ldr	r3, [r4, #108]
		page += pages_per_block;

		/* Check, if we cross a chip boundary */
		if (len && !(page & this->pagemask)) {
33d069bc:	e05aa312 	subs	sl, sl, r2, lsl r3
			goto erase_exit;
		}

		/* Increment page address and decrement length */
		len -= (1 << this->phys_erase_shift);
		page += pages_per_block;
33d069c0:	e085500b 	add	r5, r5, fp

		/* Check, if we cross a chip boundary */
		if (len && !(page & this->pagemask)) {
33d069c4:	0a00000a 	beq	33d069f4 <nand_erase_nand+0x1a4>
33d069c8:	e5943098 	ldr	r3, [r4, #152]
33d069cc:	e1150003 	tst	r5, r3
33d069d0:	1affffd5 	bne	33d0692c <nand_erase_nand+0xdc>
			chipnr++;
33d069d4:	e0899002 	add	r9, r9, r2
			this->select_chip(mtd, -1);
33d069d8:	e1a0e00f 	mov	lr, pc
33d069dc:	e594f024 	ldr	pc, [r4, #36]
			this->select_chip(mtd, chipnr);
33d069e0:	e1a00007 	mov	r0, r7
33d069e4:	e1a01009 	mov	r1, r9
33d069e8:	e1a0e00f 	mov	lr, pc
33d069ec:	e594f024 	ldr	pc, [r4, #36]
33d069f0:	eaffffcd 	b	33d0692c <nand_erase_nand+0xdc>
		}
	}
	instr->state = MTD_ERASE_DONE;
33d069f4:	e3a03008 	mov	r3, #8	; 0x8
33d069f8:	e5c63028 	strb	r3, [r6, #40]

erase_exit:

	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
33d069fc:	e5d63028 	ldrb	r3, [r6, #40]
33d06a00:	e3530008 	cmp	r3, #8	; 0x8
33d06a04:	13e04004 	mvnne	r4, #4	; 0x4
33d06a08:	1a000005 	bne	33d06a24 <nand_erase_nand+0x1d4>
#ifdef CONFIG_MTD_PARTITIONS
void mtd_erase_callback(struct erase_info *instr);
#else
static inline void mtd_erase_callback(struct erase_info *instr)
{
	if (instr->callback)
33d06a0c:	e5963020 	ldr	r3, [r6, #32]
33d06a10:	e3530000 	cmp	r3, #0	; 0x0
33d06a14:	e3a04000 	mov	r4, #0	; 0x0
		instr->callback(instr);
33d06a18:	11a00006 	movne	r0, r6
33d06a1c:	11a0e00f 	movne	lr, pc
33d06a20:	11a0f003 	movne	pc, r3
	/* Do call back function */
	if (!ret)
		mtd_erase_callback(instr);

	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
33d06a24:	e1a00007 	mov	r0, r7
33d06a28:	ebfff778 	bl	33d04810 <nand_release_device>

	/* Return more or less happy */
	return ret;
33d06a2c:	e1a00004 	mov	r0, r4
}
33d06a30:	e28dd008 	add	sp, sp, #8	; 0x8
33d06a34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d06a38:	33d25d60 	.word	0x33d25d60

33d06a3c <nand_erase>:
 *
 * Erase one ore more blocks
 */
static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
{
	return nand_erase_nand (mtd, instr, 0);
33d06a3c:	e3a02000 	mov	r2, #0	; 0x0
33d06a40:	eaffff82 	b	33d06850 <nand_erase_nand>

33d06a44 <nand_sync>:
	DEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");

	/* Grab the lock and see if the device is available */
	nand_get_device (this, mtd, FL_SYNCING);
	/* Release it and go back */
	nand_release_device (mtd);
33d06a44:	eafff771 	b	33d04810 <nand_release_device>

33d06a48 <nand_block_isbad>:
 * nand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad
 * @mtd:	MTD device structure
 * @ofs:	offset relative to mtd start
 */
static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
{
33d06a48:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	/* Check for invalid offset */
	if (ofs > mtd->size)
33d06a4c:	e5903008 	ldr	r3, [r0, #8]
 * nand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad
 * @mtd:	MTD device structure
 * @ofs:	offset relative to mtd start
 */
static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
{
33d06a50:	e1a05002 	mov	r5, r2
33d06a54:	e1a04001 	mov	r4, r1
	/* Check for invalid offset */
	if (ofs > mtd->size)
33d06a58:	e1a06003 	mov	r6, r3
33d06a5c:	e3a07000 	mov	r7, #0	; 0x0
33d06a60:	e1550007 	cmp	r5, r7
 * nand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad
 * @mtd:	MTD device structure
 * @ofs:	offset relative to mtd start
 */
static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
{
33d06a64:	e24dd004 	sub	sp, sp, #4	; 0x4
	/* Check for invalid offset */
	if (ofs > mtd->size)
		return -EINVAL;
33d06a68:	e3e0c015 	mvn	ip, #21	; 0x15
 * @ofs:	offset relative to mtd start
 */
static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
{
	/* Check for invalid offset */
	if (ofs > mtd->size)
33d06a6c:	ca000007 	bgt	33d06a90 <nand_block_isbad+0x48>
		return -EINVAL;

	return nand_block_checkbad (mtd, ofs, 1, 0);
33d06a70:	e3a03001 	mov	r3, #1	; 0x1
 * @ofs:	offset relative to mtd start
 */
static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
{
	/* Check for invalid offset */
	if (ofs > mtd->size)
33d06a74:	1a000001 	bne	33d06a80 <nand_block_isbad+0x38>
33d06a78:	e1540006 	cmp	r4, r6
33d06a7c:	8a000003 	bhi	33d06a90 <nand_block_isbad+0x48>
		return -EINVAL;

	return nand_block_checkbad (mtd, ofs, 1, 0);
33d06a80:	e3a0c000 	mov	ip, #0	; 0x0
33d06a84:	e58dc000 	str	ip, [sp]
33d06a88:	ebfff8e0 	bl	33d04e10 <nand_block_checkbad>
33d06a8c:	e1a0c000 	mov	ip, r0
}
33d06a90:	e1a0000c 	mov	r0, ip
33d06a94:	e28dd004 	add	sp, sp, #4	; 0x4
33d06a98:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d06a9c <nand_block_markbad>:
 * nand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
 * @mtd:	MTD device structure
 * @ofs:	offset relative to mtd start
 */
static int nand_block_markbad (struct mtd_info *mtd, loff_t ofs)
{
33d06a9c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d06aa0:	e1a06000 	mov	r6, r0
33d06aa4:	e1a05002 	mov	r5, r2
33d06aa8:	e1a04001 	mov	r4, r1
	struct nand_chip *this = mtd->priv;
33d06aac:	e590713c 	ldr	r7, [r0, #316]
	int ret;

	if ((ret = nand_block_isbad(mtd, ofs))) {
33d06ab0:	ebffffe4 	bl	33d06a48 <nand_block_isbad>
33d06ab4:	e2503000 	subs	r3, r0, #0	; 0x0
		if (ret > 0)
			return 0;
		return ret;
	}

	return this->block_markbad(mtd, ofs);
33d06ab8:	e1a02005 	mov	r2, r5
33d06abc:	e1a01004 	mov	r1, r4
33d06ac0:	e1a00006 	mov	r0, r6
static int nand_block_markbad (struct mtd_info *mtd, loff_t ofs)
{
	struct nand_chip *this = mtd->priv;
	int ret;

	if ((ret = nand_block_isbad(mtd, ofs))) {
33d06ac4:	0a000002 	beq	33d06ad4 <nand_block_markbad+0x38>
		/* If it was bad already, return success and do nothing. */
		if (ret > 0)
			return 0;
		return ret;
33d06ac8:	e1a00003 	mov	r0, r3
	int ret;

	if ((ret = nand_block_isbad(mtd, ofs))) {
		/* If it was bad already, return success and do nothing. */
		if (ret > 0)
			return 0;
33d06acc:	c3a00000 	movgt	r0, #0	; 0x0
33d06ad0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
		return ret;
	}

	return this->block_markbad(mtd, ofs);
33d06ad4:	e1a0e00f 	mov	lr, pc
33d06ad8:	e597f02c 	ldr	pc, [r7, #44]
}
33d06adc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d06ae0 <nand_scan>:
 * filled with the appropriate values. Buffers are allocated if
 * they are not provided by the board driver
 *
 */
int nand_scan (struct mtd_info *mtd, int maxchips)
{
33d06ae0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int i, j, nand_maf_id, nand_dev_id, busw;
	struct nand_chip *this = mtd->priv;
33d06ae4:	e590613c 	ldr	r6, [r0, #316]

	/* Get buswidth to select the correct functions*/
	busw = this->options & NAND_BUSWIDTH_16;

	/* check for proper chip_delay setup, set 20us if not */
	if (!this->chip_delay)
33d06ae8:	e5963064 	ldr	r3, [r6, #100]
 * filled with the appropriate values. Buffers are allocated if
 * they are not provided by the board driver
 *
 */
int nand_scan (struct mtd_info *mtd, int maxchips)
{
33d06aec:	e24dd008 	sub	sp, sp, #8	; 0x8

	/* Get buswidth to select the correct functions*/
	busw = this->options & NAND_BUSWIDTH_16;

	/* check for proper chip_delay setup, set 20us if not */
	if (!this->chip_delay)
33d06af0:	e3530000 	cmp	r3, #0	; 0x0
{
	int i, j, nand_maf_id, nand_dev_id, busw;
	struct nand_chip *this = mtd->priv;

	/* Get buswidth to select the correct functions*/
	busw = this->options & NAND_BUSWIDTH_16;
33d06af4:	e5962088 	ldr	r2, [r6, #136]
 * filled with the appropriate values. Buffers are allocated if
 * they are not provided by the board driver
 *
 */
int nand_scan (struct mtd_info *mtd, int maxchips)
{
33d06af8:	e58d1004 	str	r1, [sp, #4]
	/* Get buswidth to select the correct functions*/
	busw = this->options & NAND_BUSWIDTH_16;

	/* check for proper chip_delay setup, set 20us if not */
	if (!this->chip_delay)
		this->chip_delay = 20;
33d06afc:	02833014 	addeq	r3, r3, #20	; 0x14
33d06b00:	05863064 	streq	r3, [r6, #100]

	/* check, if a user supplied command function given */
	if (this->cmdfunc == NULL)
33d06b04:	e5963038 	ldr	r3, [r6, #56]
33d06b08:	e3530000 	cmp	r3, #0	; 0x0
		this->cmdfunc = nand_command;
33d06b0c:	059f3914 	ldreq	r3, [pc, #2324]	; 33d07428 <nand_scan+0x948>
33d06b10:	05863038 	streq	r3, [r6, #56]

	/* check, if a user supplied wait function given */
	if (this->waitfunc == NULL)
33d06b14:	e596303c 	ldr	r3, [r6, #60]
33d06b18:	e3530000 	cmp	r3, #0	; 0x0
		this->waitfunc = nand_wait;
33d06b1c:	059f3908 	ldreq	r3, [pc, #2312]	; 33d0742c <nand_scan+0x94c>
33d06b20:	0586303c 	streq	r3, [r6, #60]

	if (!this->select_chip)
33d06b24:	e5963024 	ldr	r3, [r6, #36]
33d06b28:	e3530000 	cmp	r3, #0	; 0x0
		this->select_chip = nand_select_chip;
33d06b2c:	059f38fc 	ldreq	r3, [pc, #2300]	; 33d07430 <nand_scan+0x950>
33d06b30:	05863024 	streq	r3, [r6, #36]
	if (!this->write_byte)
33d06b34:	e596300c 	ldr	r3, [r6, #12]
33d06b38:	e3530000 	cmp	r3, #0	; 0x0
 * filled with the appropriate values. Buffers are allocated if
 * they are not provided by the board driver
 *
 */
int nand_scan (struct mtd_info *mtd, int maxchips)
{
33d06b3c:	e1a07000 	mov	r7, r0
	int i, j, nand_maf_id, nand_dev_id, busw;
	struct nand_chip *this = mtd->priv;

	/* Get buswidth to select the correct functions*/
	busw = this->options & NAND_BUSWIDTH_16;
33d06b40:	e2024002 	and	r4, r2, #2	; 0x2
	if (this->waitfunc == NULL)
		this->waitfunc = nand_wait;

	if (!this->select_chip)
		this->select_chip = nand_select_chip;
	if (!this->write_byte)
33d06b44:	1a000004 	bne	33d06b5c <nand_scan+0x7c>
		this->write_byte = busw ? nand_write_byte16 : nand_write_byte;
33d06b48:	e59f28e4 	ldr	r2, [pc, #2276]	; 33d07434 <nand_scan+0x954>
33d06b4c:	e59f38e4 	ldr	r3, [pc, #2276]	; 33d07438 <nand_scan+0x958>
33d06b50:	e3540000 	cmp	r4, #0	; 0x0
33d06b54:	11a03002 	movne	r3, r2
33d06b58:	e586300c 	str	r3, [r6, #12]
	if (!this->read_byte)
33d06b5c:	e5963008 	ldr	r3, [r6, #8]
33d06b60:	e3530000 	cmp	r3, #0	; 0x0
33d06b64:	1a000004 	bne	33d06b7c <nand_scan+0x9c>
		this->read_byte = busw ? nand_read_byte16 : nand_read_byte;
33d06b68:	e59f28cc 	ldr	r2, [pc, #2252]	; 33d0743c <nand_scan+0x95c>
33d06b6c:	e59f38cc 	ldr	r3, [pc, #2252]	; 33d07440 <nand_scan+0x960>
33d06b70:	e3540000 	cmp	r4, #0	; 0x0
33d06b74:	11a03002 	movne	r3, r2
33d06b78:	e5863008 	str	r3, [r6, #8]
	if (!this->write_word)
33d06b7c:	e5963014 	ldr	r3, [r6, #20]
33d06b80:	e3530000 	cmp	r3, #0	; 0x0
		this->write_word = nand_write_word;
33d06b84:	059f38b8 	ldreq	r3, [pc, #2232]	; 33d07444 <nand_scan+0x964>
33d06b88:	05863014 	streq	r3, [r6, #20]
	if (!this->read_word)
33d06b8c:	e5963010 	ldr	r3, [r6, #16]
33d06b90:	e3530000 	cmp	r3, #0	; 0x0
		this->read_word = nand_read_word;
33d06b94:	059f38ac 	ldreq	r3, [pc, #2220]	; 33d07448 <nand_scan+0x968>
33d06b98:	05863010 	streq	r3, [r6, #16]
	if (!this->block_bad)
33d06b9c:	e5963028 	ldr	r3, [r6, #40]
33d06ba0:	e3530000 	cmp	r3, #0	; 0x0
		this->block_bad = nand_block_bad;
33d06ba4:	059f38a0 	ldreq	r3, [pc, #2208]	; 33d0744c <nand_scan+0x96c>
33d06ba8:	05863028 	streq	r3, [r6, #40]
	if (!this->block_markbad)
33d06bac:	e596302c 	ldr	r3, [r6, #44]
33d06bb0:	e3530000 	cmp	r3, #0	; 0x0
		this->block_markbad = nand_default_block_markbad;
33d06bb4:	059f3894 	ldreq	r3, [pc, #2196]	; 33d07450 <nand_scan+0x970>
33d06bb8:	0586302c 	streq	r3, [r6, #44]
	if (!this->write_buf)
33d06bbc:	e5963018 	ldr	r3, [r6, #24]
33d06bc0:	e3530000 	cmp	r3, #0	; 0x0
33d06bc4:	1a000004 	bne	33d06bdc <nand_scan+0xfc>
		this->write_buf = busw ? nand_write_buf16 : nand_write_buf;
33d06bc8:	e59f2884 	ldr	r2, [pc, #2180]	; 33d07454 <nand_scan+0x974>
33d06bcc:	e59f3884 	ldr	r3, [pc, #2180]	; 33d07458 <nand_scan+0x978>
33d06bd0:	e3540000 	cmp	r4, #0	; 0x0
33d06bd4:	11a03002 	movne	r3, r2
33d06bd8:	e5863018 	str	r3, [r6, #24]
	if (!this->read_buf)
33d06bdc:	e596301c 	ldr	r3, [r6, #28]
33d06be0:	e3530000 	cmp	r3, #0	; 0x0
33d06be4:	1a000004 	bne	33d06bfc <nand_scan+0x11c>
		this->read_buf = busw ? nand_read_buf16 : nand_read_buf;
33d06be8:	e59f286c 	ldr	r2, [pc, #2156]	; 33d0745c <nand_scan+0x97c>
33d06bec:	e59f386c 	ldr	r3, [pc, #2156]	; 33d07460 <nand_scan+0x980>
33d06bf0:	e3540000 	cmp	r4, #0	; 0x0
33d06bf4:	11a03002 	movne	r3, r2
33d06bf8:	e586301c 	str	r3, [r6, #28]
	if (!this->verify_buf)
33d06bfc:	e5963020 	ldr	r3, [r6, #32]
33d06c00:	e3530000 	cmp	r3, #0	; 0x0
33d06c04:	1a000004 	bne	33d06c1c <nand_scan+0x13c>
		this->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
33d06c08:	e59f2854 	ldr	r2, [pc, #2132]	; 33d07464 <nand_scan+0x984>
33d06c0c:	e59f3854 	ldr	r3, [pc, #2132]	; 33d07468 <nand_scan+0x988>
33d06c10:	e3540000 	cmp	r4, #0	; 0x0
33d06c14:	11a03002 	movne	r3, r2
33d06c18:	e5863020 	str	r3, [r6, #32]
	if (!this->scan_bbt)
33d06c1c:	e5963050 	ldr	r3, [r6, #80]
33d06c20:	e3530000 	cmp	r3, #0	; 0x0
		this->scan_bbt = nand_default_bbt;
33d06c24:	059f3840 	ldreq	r3, [pc, #2112]	; 33d0746c <nand_scan+0x98c>

	/* Select the device */
	this->select_chip(mtd, 0);
33d06c28:	e1a00007 	mov	r0, r7
	if (!this->read_buf)
		this->read_buf = busw ? nand_read_buf16 : nand_read_buf;
	if (!this->verify_buf)
		this->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
	if (!this->scan_bbt)
		this->scan_bbt = nand_default_bbt;
33d06c2c:	05863050 	streq	r3, [r6, #80]

	/* Select the device */
	this->select_chip(mtd, 0);
33d06c30:	e3a01000 	mov	r1, #0	; 0x0
33d06c34:	e1a0e00f 	mov	lr, pc
33d06c38:	e596f024 	ldr	pc, [r6, #36]

	/* Send the command for reading device ID */
	this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
33d06c3c:	e3a01090 	mov	r1, #144	; 0x90
33d06c40:	e3a02000 	mov	r2, #0	; 0x0
33d06c44:	e3e03000 	mvn	r3, #0	; 0x0
33d06c48:	e1a00007 	mov	r0, r7
33d06c4c:	e1a0e00f 	mov	lr, pc
33d06c50:	e596f038 	ldr	pc, [r6, #56]

	/* Read manufacturer and device IDs */
	nand_maf_id = this->read_byte(mtd);
33d06c54:	e1a00007 	mov	r0, r7
33d06c58:	e1a0e00f 	mov	lr, pc
33d06c5c:	e596f008 	ldr	pc, [r6, #8]
33d06c60:	e1a03000 	mov	r3, r0
	nand_dev_id = this->read_byte(mtd);
33d06c64:	e1a00007 	mov	r0, r7

	/* Send the command for reading device ID */
	this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);

	/* Read manufacturer and device IDs */
	nand_maf_id = this->read_byte(mtd);
33d06c68:	e20390ff 	and	r9, r3, #255	; 0xff
	nand_dev_id = this->read_byte(mtd);
33d06c6c:	e1a0e00f 	mov	lr, pc
33d06c70:	e596f008 	ldr	pc, [r6, #8]

	/* Print and store flash device information */
	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
33d06c74:	e59fc7f4 	ldr	ip, [pc, #2036]	; 33d07470 <nand_scan+0x990>
33d06c78:	e59c3000 	ldr	r3, [ip]
33d06c7c:	e3530000 	cmp	r3, #0	; 0x0
	/* Send the command for reading device ID */
	this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);

	/* Read manufacturer and device IDs */
	nand_maf_id = this->read_byte(mtd);
	nand_dev_id = this->read_byte(mtd);
33d06c80:	e200b0ff 	and	fp, r0, #255	; 0xff

	/* Print and store flash device information */
	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
33d06c84:	e3a05000 	mov	r5, #0	; 0x0
33d06c88:	0a0000ca 	beq	33d06fb8 <nand_scan+0x4d8>
33d06c8c:	e1a0a00c 	mov	sl, ip
33d06c90:	e1a01005 	mov	r1, r5
33d06c94:	e1a02005 	mov	r2, r5

		if (nand_dev_id != nand_flash_ids[i].id)
33d06c98:	e59a3004 	ldr	r3, [sl, #4]
33d06c9c:	e15b0003 	cmp	fp, r3
33d06ca0:	e2822002 	add	r2, r2, #2	; 0x2
33d06ca4:	1a0000bb 	bne	33d06f98 <nand_scan+0x4b8>
			continue;

		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
33d06ca8:	e5973024 	ldr	r3, [r7, #36]
33d06cac:	e3530000 	cmp	r3, #0	; 0x0
33d06cb0:	0791300c 	ldreq	r3, [r1, ip]
33d06cb4:	05873024 	streq	r3, [r7, #36]
		this->chipsize = nand_flash_ids[i].chipsize << 20;
33d06cb8:	e59a300c 	ldr	r3, [sl, #12]
33d06cbc:	e1a03a03 	lsl	r3, r3, #20
33d06cc0:	e5863094 	str	r3, [r6, #148]

		/* New devices have all the information in additional id bytes */
		if (!nand_flash_ids[i].pagesize) {
33d06cc4:	e59a3008 	ldr	r3, [sl, #8]
33d06cc8:	e3530000 	cmp	r3, #0	; 0x0
33d06ccc:	1a00001b 	bne	33d06d40 <nand_scan+0x260>
			int extid;
			/* The 3rd id byte contains non relevant data ATM */
			extid = this->read_byte(mtd);
33d06cd0:	e1a00007 	mov	r0, r7
33d06cd4:	e1a0e00f 	mov	lr, pc
33d06cd8:	e596f008 	ldr	pc, [r6, #8]
			/* The 4th id byte is the important one */
			extid = this->read_byte(mtd);
33d06cdc:	e1a00007 	mov	r0, r7
33d06ce0:	e1a0e00f 	mov	lr, pc
33d06ce4:	e596f008 	ldr	pc, [r6, #8]
33d06ce8:	e20020ff 	and	r2, r0, #255	; 0xff
//			printf("extid = 0x%x\n", extid);		//HJ_del
			/* Calc pagesize */
			mtd->oobblock = 1024 << (extid & 0x3);
			extid >>= 2;
33d06cec:	e1a02142 	asr	r2, r2, #2
			extid = this->read_byte(mtd);
			/* The 4th id byte is the important one */
			extid = this->read_byte(mtd);
//			printf("extid = 0x%x\n", extid);		//HJ_del
			/* Calc pagesize */
			mtd->oobblock = 1024 << (extid & 0x3);
33d06cf0:	e2000003 	and	r0, r0, #3	; 0x3
33d06cf4:	e3a0cb01 	mov	ip, #1024	; 0x400
33d06cf8:	e1a0c01c 	lsl	ip, ip, r0
			extid >>= 2;
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
33d06cfc:	e2021003 	and	r1, r2, #3	; 0x3
33d06d00:	e3a03008 	mov	r3, #8	; 0x8
33d06d04:	e1a03113 	lsl	r3, r3, r1
33d06d08:	e1a014ac 	lsr	r1, ip, #9
33d06d0c:	e0000391 	mul	r0, r1, r3
			extid >>= 2;
33d06d10:	e1a02142 	asr	r2, r2, #2
			/* Calc blocksize. Blocksize is multiples of 64KiB */
			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
33d06d14:	e2021003 	and	r1, r2, #3	; 0x3
			extid >>= 2;
33d06d18:	e1a02142 	asr	r2, r2, #2
			/* Get buswidth information */
			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
33d06d1c:	e2122001 	ands	r2, r2, #1	; 0x1
			extid >>= 2;
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
			extid >>= 2;
			/* Calc blocksize. Blocksize is multiples of 64KiB */
			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
33d06d20:	e3a03801 	mov	r3, #65536	; 0x10000
33d06d24:	e1a03113 	lsl	r3, r3, r1
			extid >>= 2;
			/* Get buswidth information */
			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
33d06d28:	01a04002 	moveq	r4, r2
33d06d2c:	13a04002 	movne	r4, #2	; 0x2
//			printf("extid = 0x%x\n", extid);		//HJ_del
			/* Calc pagesize */
			mtd->oobblock = 1024 << (extid & 0x3);
			extid >>= 2;
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
33d06d30:	e5870014 	str	r0, [r7, #20]
			extid >>= 2;
			/* Calc blocksize. Blocksize is multiples of 64KiB */
			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
33d06d34:	e587300c 	str	r3, [r7, #12]
			extid = this->read_byte(mtd);
			/* The 4th id byte is the important one */
			extid = this->read_byte(mtd);
//			printf("extid = 0x%x\n", extid);		//HJ_del
			/* Calc pagesize */
			mtd->oobblock = 1024 << (extid & 0x3);
33d06d38:	e587c010 	str	ip, [r7, #16]
			extid >>= 2;
			/* Calc blocksize. Blocksize is multiples of 64KiB */
			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
			extid >>= 2;
			/* Get buswidth information */
			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
33d06d3c:	ea000007 	b	33d06d60 <nand_scan+0x280>
//			printf("busw = 0x%x\n", busw);		//HJ_del

		} else {
			/* Old devices have this data hardcoded in the
			 * device id table */
			mtd->erasesize = nand_flash_ids[i].erasesize;
33d06d40:	e59a3010 	ldr	r3, [sl, #16]
33d06d44:	e587300c 	str	r3, [r7, #12]
			mtd->oobblock = nand_flash_ids[i].pagesize;
33d06d48:	e59a2008 	ldr	r2, [sl, #8]
			mtd->oobsize = mtd->oobblock / 32;
33d06d4c:	e1a032a2 	lsr	r3, r2, #5
33d06d50:	e5873014 	str	r3, [r7, #20]

		} else {
			/* Old devices have this data hardcoded in the
			 * device id table */
			mtd->erasesize = nand_flash_ids[i].erasesize;
			mtd->oobblock = nand_flash_ids[i].pagesize;
33d06d54:	e5872010 	str	r2, [r7, #16]
			mtd->oobsize = mtd->oobblock / 32;
			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
33d06d58:	e59a3014 	ldr	r3, [sl, #20]
33d06d5c:	e2034002 	and	r4, r3, #2	; 0x2
		}

		/* Check, if buswidth is correct. Hardware drivers should set
		 * this correct ! */
		if (busw != (this->options & NAND_BUSWIDTH_16)) {
33d06d60:	e5961088 	ldr	r1, [r6, #136]
33d06d64:	e2013002 	and	r3, r1, #2	; 0x2
33d06d68:	e1540003 	cmp	r4, r3
33d06d6c:	0a000012 	beq	33d06dbc <nand_scan+0x2dc>
			printk (KERN_INFO "NAND device: Manufacturer ID:"
33d06d70:	e59f36fc 	ldr	r3, [pc, #1788]	; 33d07474 <nand_scan+0x994>
33d06d74:	e597c024 	ldr	ip, [r7, #36]
33d06d78:	e0833185 	add	r3, r3, r5, lsl #3
33d06d7c:	e1a0200b 	mov	r2, fp
33d06d80:	e5933004 	ldr	r3, [r3, #4]
33d06d84:	e1a01009 	mov	r1, r9
33d06d88:	e59f06e8 	ldr	r0, [pc, #1768]	; 33d07478 <nand_scan+0x998>
33d06d8c:	e58dc000 	str	ip, [sp]
33d06d90:	eb00408c 	bl	33d16fc8 <printf>
				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
				nand_manuf_ids[i].name , mtd->name);
			printk (KERN_WARNING
33d06d94:	e5963088 	ldr	r3, [r6, #136]
33d06d98:	e3130002 	tst	r3, #2	; 0x2
33d06d9c:	03a01008 	moveq	r1, #8	; 0x8
33d06da0:	13a01010 	movne	r1, #16	; 0x10
33d06da4:	e3540000 	cmp	r4, #0	; 0x0
33d06da8:	03a02008 	moveq	r2, #8	; 0x8
33d06dac:	13a02010 	movne	r2, #16	; 0x10
33d06db0:	e59f06c4 	ldr	r0, [pc, #1732]	; 33d0747c <nand_scan+0x99c>
33d06db4:	eb004083 	bl	33d16fc8 <printf>
33d06db8:	ea000085 	b	33d06fd4 <nand_scan+0x4f4>
 * the libc and compiler builtin ffs routines, therefore
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
33d06dbc:	e5972010 	ldr	r2, [r7, #16]
	int r = 1;

	if (!x)
33d06dc0:	e3520000 	cmp	r2, #0	; 0x0
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
	int r = 1;
33d06dc4:	e3a00001 	mov	r0, #1	; 0x1

	if (!x)
33d06dc8:	01a03002 	moveq	r3, r2
33d06dcc:	0a000010 	beq	33d06e14 <nand_scan+0x334>
		return 0;
	if (!(x & 0xffff)) {
33d06dd0:	e1a03802 	lsl	r3, r2, #16
33d06dd4:	e1a03823 	lsr	r3, r3, #16
33d06dd8:	e3530000 	cmp	r3, #0	; 0x0
		x >>= 16;
33d06ddc:	01a02842 	asreq	r2, r2, #16
		r += 16;
33d06de0:	03a00011 	moveq	r0, #17	; 0x11
	}
	if (!(x & 0xff)) {
33d06de4:	e31200ff 	tst	r2, #255	; 0xff
		x >>= 8;
33d06de8:	01a02442 	asreq	r2, r2, #8
		r += 8;
33d06dec:	02800008 	addeq	r0, r0, #8	; 0x8
	}
	if (!(x & 0xf)) {
33d06df0:	e312000f 	tst	r2, #15	; 0xf
		x >>= 4;
33d06df4:	01a02242 	asreq	r2, r2, #4
		r += 4;
33d06df8:	02800004 	addeq	r0, r0, #4	; 0x4
	}
	if (!(x & 3)) {
33d06dfc:	e3120003 	tst	r2, #3	; 0x3
		x >>= 2;
33d06e00:	01a02142 	asreq	r2, r2, #2
		r += 2;
33d06e04:	02800002 	addeq	r0, r0, #2	; 0x2
	}
	if (!(x & 1)) {
33d06e08:	e3120001 	tst	r2, #1	; 0x1
		x >>= 1;
		r += 1;
33d06e0c:	02800001 	addeq	r0, r0, #1	; 0x1
	}
33d06e10:	e1a03000 	mov	r3, r0
 * the libc and compiler builtin ffs routines, therefore
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
33d06e14:	e2433001 	sub	r3, r3, #1	; 0x1
33d06e18:	e5863068 	str	r3, [r6, #104]
	int r = 1;

	if (!x)
33d06e1c:	e597200c 	ldr	r2, [r7, #12]
33d06e20:	e3520000 	cmp	r2, #0	; 0x0
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
	int r = 1;
33d06e24:	e3a00001 	mov	r0, #1	; 0x1

	if (!x)
33d06e28:	01a03002 	moveq	r3, r2
33d06e2c:	0a000010 	beq	33d06e74 <nand_scan+0x394>
		return 0;
	if (!(x & 0xffff)) {
33d06e30:	e1a03802 	lsl	r3, r2, #16
33d06e34:	e1a03823 	lsr	r3, r3, #16
33d06e38:	e3530000 	cmp	r3, #0	; 0x0
		x >>= 16;
33d06e3c:	01a02842 	asreq	r2, r2, #16
		r += 16;
33d06e40:	03a00011 	moveq	r0, #17	; 0x11
	}
	if (!(x & 0xff)) {
33d06e44:	e31200ff 	tst	r2, #255	; 0xff
		x >>= 8;
33d06e48:	01a02442 	asreq	r2, r2, #8
		r += 8;
33d06e4c:	02800008 	addeq	r0, r0, #8	; 0x8
	}
	if (!(x & 0xf)) {
33d06e50:	e312000f 	tst	r2, #15	; 0xf
		x >>= 4;
33d06e54:	01a02242 	asreq	r2, r2, #4
		r += 4;
33d06e58:	02800004 	addeq	r0, r0, #4	; 0x4
	}
	if (!(x & 3)) {
33d06e5c:	e3120003 	tst	r2, #3	; 0x3
		x >>= 2;
33d06e60:	01a02142 	asreq	r2, r2, #2
		r += 2;
33d06e64:	02800002 	addeq	r0, r0, #2	; 0x2
	}
	if (!(x & 1)) {
33d06e68:	e3120001 	tst	r2, #1	; 0x1
		x >>= 1;
		r += 1;
33d06e6c:	02800001 	addeq	r0, r0, #1	; 0x1
	}
33d06e70:	e1a03000 	mov	r3, r0
 * the libc and compiler builtin ffs routines, therefore
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
33d06e74:	e5962094 	ldr	r2, [r6, #148]
33d06e78:	e2433001 	sub	r3, r3, #1	; 0x1
	int r = 1;

	if (!x)
33d06e7c:	e3520000 	cmp	r2, #0	; 0x0
 * the libc and compiler builtin ffs routines, therefore
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
33d06e80:	e5863070 	str	r3, [r6, #112]
33d06e84:	e586306c 	str	r3, [r6, #108]
	int r = 1;
33d06e88:	e3a00001 	mov	r0, #1	; 0x1

	if (!x)
33d06e8c:	01a03002 	moveq	r3, r2
33d06e90:	0a000010 	beq	33d06ed8 <nand_scan+0x3f8>
		return 0;
	if (!(x & 0xffff)) {
33d06e94:	e1a03802 	lsl	r3, r2, #16
33d06e98:	e1a03823 	lsr	r3, r3, #16
33d06e9c:	e3530000 	cmp	r3, #0	; 0x0
		x >>= 16;
33d06ea0:	01a02842 	asreq	r2, r2, #16
		r += 16;
33d06ea4:	03a00011 	moveq	r0, #17	; 0x11
	}
	if (!(x & 0xff)) {
33d06ea8:	e31200ff 	tst	r2, #255	; 0xff
		x >>= 8;
33d06eac:	01a02442 	asreq	r2, r2, #8
		r += 8;
33d06eb0:	02800008 	addeq	r0, r0, #8	; 0x8
	}
	if (!(x & 0xf)) {
33d06eb4:	e312000f 	tst	r2, #15	; 0xf
		x >>= 4;
33d06eb8:	01a02242 	asreq	r2, r2, #4
		r += 4;
33d06ebc:	02800004 	addeq	r0, r0, #4	; 0x4
	}
	if (!(x & 3)) {
33d06ec0:	e3120003 	tst	r2, #3	; 0x3
		x >>= 2;
33d06ec4:	01a02142 	asreq	r2, r2, #2
		r += 2;
33d06ec8:	02800002 	addeq	r0, r0, #2	; 0x2
	}
	if (!(x & 1)) {
33d06ecc:	e3120001 	tst	r2, #1	; 0x1
		x >>= 1;
		r += 1;
33d06ed0:	02800001 	addeq	r0, r0, #1	; 0x1
	}
33d06ed4:	e1a03000 	mov	r3, r0
 * the libc and compiler builtin ffs routines, therefore
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
33d06ed8:	e2433001 	sub	r3, r3, #1	; 0x1
33d06edc:	e5863074 	str	r3, [r6, #116]
		this->page_shift = ffs(mtd->oobblock) - 1;
		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
		this->chip_shift = ffs(this->chipsize) - 1;

		/* Set the bad block position */
		this->badblockpos = mtd->oobblock > 512 ?
33d06ee0:	e5973010 	ldr	r3, [r7, #16]
			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;

		/* Get chip options, preserve non chip based options */
		this->options &= ~NAND_CHIPOPTIONS_MSK;
33d06ee4:	e3c11cff 	bic	r1, r1, #65280	; 0xff00
		this->page_shift = ffs(mtd->oobblock) - 1;
		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
		this->chip_shift = ffs(this->chipsize) - 1;

		/* Set the bad block position */
		this->badblockpos = mtd->oobblock > 512 ?
33d06ee8:	e3530c02 	cmp	r3, #512	; 0x200
33d06eec:	93a03005 	movls	r3, #5	; 0x5
33d06ef0:	83a03000 	movhi	r3, #0	; 0x0
			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;

		/* Get chip options, preserve non chip based options */
		this->options &= ~NAND_CHIPOPTIONS_MSK;
33d06ef4:	e3c110fe 	bic	r1, r1, #254	; 0xfe
33d06ef8:	e5861088 	str	r1, [r6, #136]
		this->page_shift = ffs(mtd->oobblock) - 1;
		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
		this->chip_shift = ffs(this->chipsize) - 1;

		/* Set the bad block position */
		this->badblockpos = mtd->oobblock > 512 ?
33d06efc:	e586308c 	str	r3, [r6, #140]
			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;

		/* Get chip options, preserve non chip based options */
		this->options &= ~NAND_CHIPOPTIONS_MSK;
		this->options |= nand_flash_ids[i].options & NAND_CHIPOPTIONS_MSK;
33d06f00:	e59f3578 	ldr	r3, [pc, #1400]	; 33d07480 <nand_scan+0x9a0>
33d06f04:	e59a2014 	ldr	r2, [sl, #20]
33d06f08:	e0023003 	and	r3, r2, r3
33d06f0c:	e1811003 	orr	r1, r1, r3
		/* Set this as a default. Board drivers can override it, if neccecary */
		this->options |= NAND_NO_AUTOINCR;
33d06f10:	e3811001 	orr	r1, r1, #1	; 0x1
		/* Check if this is a not a samsung device. Do not clear the options
		 * for chips which are not having an extended id.
		 */
		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
33d06f14:	e35900ec 	cmp	r9, #236	; 0xec

		/* Get chip options, preserve non chip based options */
		this->options &= ~NAND_CHIPOPTIONS_MSK;
		this->options |= nand_flash_ids[i].options & NAND_CHIPOPTIONS_MSK;
		/* Set this as a default. Board drivers can override it, if neccecary */
		this->options |= NAND_NO_AUTOINCR;
33d06f18:	e5861088 	str	r1, [r6, #136]
		/* Check if this is a not a samsung device. Do not clear the options
		 * for chips which are not having an extended id.
		 */
		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
33d06f1c:	0a000003 	beq	33d06f30 <nand_scan+0x450>
33d06f20:	e59a3008 	ldr	r3, [sl, #8]
33d06f24:	e3530000 	cmp	r3, #0	; 0x0
			this->options &= ~NAND_SAMSUNG_LP_OPTIONS;
33d06f28:	03c1301c 	biceq	r3, r1, #28	; 0x1c
33d06f2c:	05863088 	streq	r3, [r6, #136]

		/* Check for AND chips with 4 page planes */
		if (this->options & NAND_4PAGE_ARRAY)
33d06f30:	e5963088 	ldr	r3, [r6, #136]
33d06f34:	e3130040 	tst	r3, #64	; 0x40
			this->erase_cmd = multi_erase_cmd;
33d06f38:	159f3544 	ldrne	r3, [pc, #1348]	; 33d07484 <nand_scan+0x9a4>
		else
			this->erase_cmd = single_erase_cmd;
33d06f3c:	059f3544 	ldreq	r3, [pc, #1348]	; 33d07488 <nand_scan+0x9a8>
33d06f40:	e586304c 	str	r3, [r6, #76]

		/* Do not replace user supplied command function ! */
		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
33d06f44:	e5973010 	ldr	r3, [r7, #16]
33d06f48:	e3530c02 	cmp	r3, #512	; 0x200
33d06f4c:	9a000004 	bls	33d06f64 <nand_scan+0x484>
33d06f50:	e59f34d0 	ldr	r3, [pc, #1232]	; 33d07428 <nand_scan+0x948>
33d06f54:	e5962038 	ldr	r2, [r6, #56]
33d06f58:	e1520003 	cmp	r2, r3
			this->cmdfunc = nand_command_lp;
33d06f5c:	059f3528 	ldreq	r3, [pc, #1320]	; 33d0748c <nand_scan+0x9ac>
33d06f60:	05863038 	streq	r3, [r6, #56]

		/* Try to identify manufacturer */
		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
33d06f64:	e59f1508 	ldr	r1, [pc, #1288]	; 33d07474 <nand_scan+0x994>
33d06f68:	e5913000 	ldr	r3, [r1]
33d06f6c:	e3a02000 	mov	r2, #0	; 0x0
33d06f70:	e3530000 	cmp	r3, #0	; 0x0
33d06f74:	0a00000f 	beq	33d06fb8 <nand_scan+0x4d8>
			if (nand_manuf_ids[j].id == nand_maf_id)
33d06f78:	e7913182 	ldr	r3, [r1, r2, lsl #3]
33d06f7c:	e1530009 	cmp	r3, r9
		/* Do not replace user supplied command function ! */
		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
			this->cmdfunc = nand_command_lp;

		/* Try to identify manufacturer */
		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
33d06f80:	e2822001 	add	r2, r2, #1	; 0x1
33d06f84:	e59f14e8 	ldr	r1, [pc, #1256]	; 33d07474 <nand_scan+0x994>
			if (nand_manuf_ids[j].id == nand_maf_id)
33d06f88:	0a00000a 	beq	33d06fb8 <nand_scan+0x4d8>
		/* Do not replace user supplied command function ! */
		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
			this->cmdfunc = nand_command_lp;

		/* Try to identify manufacturer */
		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
33d06f8c:	e7913182 	ldr	r3, [r1, r2, lsl #3]
33d06f90:	e3530000 	cmp	r3, #0	; 0x0
33d06f94:	eafffff6 	b	33d06f74 <nand_scan+0x494>
	/* Read manufacturer and device IDs */
	nand_maf_id = this->read_byte(mtd);
	nand_dev_id = this->read_byte(mtd);

	/* Print and store flash device information */
	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
33d06f98:	e2855001 	add	r5, r5, #1	; 0x1
33d06f9c:	e59fc4cc 	ldr	ip, [pc, #1228]	; 33d07470 <nand_scan+0x990>
33d06fa0:	e0823005 	add	r3, r2, r5
33d06fa4:	e79c3183 	ldr	r3, [ip, r3, lsl #3]
33d06fa8:	e3530000 	cmp	r3, #0	; 0x0
33d06fac:	e2811018 	add	r1, r1, #24	; 0x18
33d06fb0:	e28aa018 	add	sl, sl, #24	; 0x18
33d06fb4:	1affff37 	bne	33d06c98 <nand_scan+0x1b8>
				break;
		}
		break;
	}

	if (!nand_flash_ids[i].name) {
33d06fb8:	e59f24b0 	ldr	r2, [pc, #1200]	; 33d07470 <nand_scan+0x990>
33d06fbc:	e0853085 	add	r3, r5, r5, lsl #1
33d06fc0:	e7923183 	ldr	r3, [r2, r3, lsl #3]
33d06fc4:	e3530000 	cmp	r3, #0	; 0x0
33d06fc8:	1a000007 	bne	33d06fec <nand_scan+0x50c>
		printk (KERN_WARNING "No NAND device found!!!\n");
33d06fcc:	e59f04bc 	ldr	r0, [pc, #1212]	; 33d07490 <nand_scan+0x9b0>
33d06fd0:	eb003ffc 	bl	33d16fc8 <printf>
		this->select_chip(mtd, -1);
33d06fd4:	e1a00007 	mov	r0, r7
33d06fd8:	e3e01000 	mvn	r1, #0	; 0x0
33d06fdc:	e1a0e00f 	mov	lr, pc
33d06fe0:	e596f024 	ldr	pc, [r6, #36]
		return 1;
33d06fe4:	e3a00001 	mov	r0, #1	; 0x1
33d06fe8:	ea00010c 	b	33d07420 <nand_scan+0x940>
	}

	for (i=1; i < maxchips; i++) {
33d06fec:	e59d3004 	ldr	r3, [sp, #4]
33d06ff0:	e3a05001 	mov	r5, #1	; 0x1
33d06ff4:	e1550003 	cmp	r5, r3
33d06ff8:	aa00001e 	bge	33d07078 <nand_scan+0x598>
		this->select_chip(mtd, i);
33d06ffc:	e1a01005 	mov	r1, r5
33d07000:	e1a00007 	mov	r0, r7
33d07004:	e1a0e00f 	mov	lr, pc
33d07008:	e596f024 	ldr	pc, [r6, #36]

		/* Send the command for reading device ID */
		this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
33d0700c:	e3e03000 	mvn	r3, #0	; 0x0
33d07010:	e1a00007 	mov	r0, r7
33d07014:	e3a01090 	mov	r1, #144	; 0x90
33d07018:	e3a02000 	mov	r2, #0	; 0x0
33d0701c:	e1a0e00f 	mov	lr, pc
33d07020:	e596f038 	ldr	pc, [r6, #56]

		/* Read manufacturer and device IDs */
		if (nand_maf_id != this->read_byte(mtd) ||
33d07024:	e1a00007 	mov	r0, r7
33d07028:	e1a0e00f 	mov	lr, pc
33d0702c:	e596f008 	ldr	pc, [r6, #8]
33d07030:	e1a03000 	mov	r3, r0
33d07034:	e20330ff 	and	r3, r3, #255	; 0xff
33d07038:	e1590003 	cmp	r9, r3
33d0703c:	e1a00007 	mov	r0, r7
33d07040:	1a000008 	bne	33d07068 <nand_scan+0x588>
33d07044:	e1a0e00f 	mov	lr, pc
33d07048:	e596f008 	ldr	pc, [r6, #8]
33d0704c:	e20000ff 	and	r0, r0, #255	; 0xff
33d07050:	e15b0000 	cmp	fp, r0
33d07054:	1a000003 	bne	33d07068 <nand_scan+0x588>
		printk (KERN_WARNING "No NAND device found!!!\n");
		this->select_chip(mtd, -1);
		return 1;
	}

	for (i=1; i < maxchips; i++) {
33d07058:	e59d3004 	ldr	r3, [sp, #4]
33d0705c:	e2855001 	add	r5, r5, #1	; 0x1
33d07060:	e1550003 	cmp	r5, r3
33d07064:	baffffe4 	blt	33d06ffc <nand_scan+0x51c>
		/* Read manufacturer and device IDs */
		if (nand_maf_id != this->read_byte(mtd) ||
		    nand_dev_id != this->read_byte(mtd))
			break;
	}
	if (i > 1)
33d07068:	e3550001 	cmp	r5, #1	; 0x1
		printk(KERN_INFO "%d NAND chips detected\n", i);
33d0706c:	c59f0420 	ldrgt	r0, [pc, #1056]	; 33d07494 <nand_scan+0x9b4>
33d07070:	c1a01005 	movgt	r1, r5
33d07074:	cb003fd3 	blgt	33d16fc8 <printf>

	/* Allocate buffers, if neccecary */
	if (!this->oob_buf) {
33d07078:	e596307c 	ldr	r3, [r6, #124]
33d0707c:	e3530000 	cmp	r3, #0	; 0x0
33d07080:	1a00000c 	bne	33d070b8 <nand_scan+0x5d8>
		size_t len;
		len = mtd->oobsize << (this->phys_erase_shift - this->page_shift);
33d07084:	e286306c 	add	r3, r6, #108	; 0x6c
33d07088:	e8130009 	ldmda	r3, {r0, r3}
33d0708c:	e0430000 	sub	r0, r3, r0
33d07090:	e5973014 	ldr	r3, [r7, #20]
		this->oob_buf = kmalloc (len, GFP_KERNEL);
33d07094:	e1a00013 	lsl	r0, r3, r0
33d07098:	eb004172 	bl	33d17668 <malloc>
		if (!this->oob_buf) {
33d0709c:	e3500000 	cmp	r0, #0	; 0x0

	/* Allocate buffers, if neccecary */
	if (!this->oob_buf) {
		size_t len;
		len = mtd->oobsize << (this->phys_erase_shift - this->page_shift);
		this->oob_buf = kmalloc (len, GFP_KERNEL);
33d070a0:	e586007c 	str	r0, [r6, #124]
		if (!this->oob_buf) {
			printk (KERN_ERR "nand_scan(): Cannot allocate oob_buf\n");
33d070a4:	059f03ec 	ldreq	r0, [pc, #1004]	; 33d07498 <nand_scan+0x9b8>
	/* Allocate buffers, if neccecary */
	if (!this->oob_buf) {
		size_t len;
		len = mtd->oobsize << (this->phys_erase_shift - this->page_shift);
		this->oob_buf = kmalloc (len, GFP_KERNEL);
		if (!this->oob_buf) {
33d070a8:	0a000013 	beq	33d070fc <nand_scan+0x61c>
			printk (KERN_ERR "nand_scan(): Cannot allocate oob_buf\n");
			return -ENOMEM;
		}
		this->options |= NAND_OOBBUF_ALLOC;
33d070ac:	e5963088 	ldr	r3, [r6, #136]
33d070b0:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
33d070b4:	e5863088 	str	r3, [r6, #136]
	}

	if (!this->data_buf) {
33d070b8:	e5963078 	ldr	r3, [r6, #120]
33d070bc:	e3530000 	cmp	r3, #0	; 0x0
33d070c0:	1a000010 	bne	33d07108 <nand_scan+0x628>
		size_t len;
		len = mtd->oobblock + mtd->oobsize;
		this->data_buf = kmalloc (len, GFP_KERNEL);
33d070c4:	e2873010 	add	r3, r7, #16	; 0x10
33d070c8:	e8930009 	ldm	r3, {r0, r3}
33d070cc:	e0800003 	add	r0, r0, r3
33d070d0:	eb004164 	bl	33d17668 <malloc>
33d070d4:	e5963088 	ldr	r3, [r6, #136]
		if (!this->data_buf) {
33d070d8:	e3500000 	cmp	r0, #0	; 0x0
			if (this->options & NAND_OOBBUF_ALLOC)
				kfree (this->oob_buf);
			printk (KERN_ERR "nand_scan(): Cannot allocate data_buf\n");
			return -ENOMEM;
		}
		this->options |= NAND_DATABUF_ALLOC;
33d070dc:	13833102 	orrne	r3, r3, #-2147483648	; 0x80000000
	}

	if (!this->data_buf) {
		size_t len;
		len = mtd->oobblock + mtd->oobsize;
		this->data_buf = kmalloc (len, GFP_KERNEL);
33d070e0:	e5860078 	str	r0, [r6, #120]
			if (this->options & NAND_OOBBUF_ALLOC)
				kfree (this->oob_buf);
			printk (KERN_ERR "nand_scan(): Cannot allocate data_buf\n");
			return -ENOMEM;
		}
		this->options |= NAND_DATABUF_ALLOC;
33d070e4:	15863088 	strne	r3, [r6, #136]

	if (!this->data_buf) {
		size_t len;
		len = mtd->oobblock + mtd->oobsize;
		this->data_buf = kmalloc (len, GFP_KERNEL);
		if (!this->data_buf) {
33d070e8:	1a000006 	bne	33d07108 <nand_scan+0x628>
			if (this->options & NAND_OOBBUF_ALLOC)
33d070ec:	e3130101 	tst	r3, #1073741824	; 0x40000000
				kfree (this->oob_buf);
33d070f0:	1596007c 	ldrne	r0, [r6, #124]
33d070f4:	1b0040d6 	blne	33d17454 <free>
			printk (KERN_ERR "nand_scan(): Cannot allocate data_buf\n");
33d070f8:	e59f039c 	ldr	r0, [pc, #924]	; 33d0749c <nand_scan+0x9bc>
33d070fc:	eb003fb1 	bl	33d16fc8 <printf>
			return -ENOMEM;
33d07100:	e3e0000b 	mvn	r0, #11	; 0xb
33d07104:	ea0000c5 	b	33d07420 <nand_scan+0x940>
		this->options |= NAND_DATABUF_ALLOC;
	}

	/* Store the number of chips and calc total size for mtd */
	this->numchips = i;
	mtd->size = i * this->chipsize;
33d07108:	e5963094 	ldr	r3, [r6, #148]
33d0710c:	e0030395 	mul	r3, r5, r3
		}
		this->options |= NAND_DATABUF_ALLOC;
	}

	/* Store the number of chips and calc total size for mtd */
	this->numchips = i;
33d07110:	e5865090 	str	r5, [r6, #144]
	mtd->size = i * this->chipsize;
33d07114:	e5873008 	str	r3, [r7, #8]
	/* Convert chipsize to number of pages per chip -1. */
	this->pagemask = (this->chipsize >> this->page_shift) - 1;
33d07118:	e5961068 	ldr	r1, [r6, #104]
33d0711c:	e5963094 	ldr	r3, [r6, #148]
33d07120:	e1a03133 	lsr	r3, r3, r1
33d07124:	e2433001 	sub	r3, r3, #1	; 0x1
33d07128:	e5863098 	str	r3, [r6, #152]
	/* Preset the internal oob buffer */
	memset(this->oob_buf, 0xff, mtd->oobsize << (this->phys_erase_shift - this->page_shift));
33d0712c:	e596206c 	ldr	r2, [r6, #108]
33d07130:	e5973014 	ldr	r3, [r7, #20]
33d07134:	e0612002 	rsb	r2, r1, r2
33d07138:	e1a02213 	lsl	r2, r3, r2
33d0713c:	e596007c 	ldr	r0, [r6, #124]
33d07140:	e3a010ff 	mov	r1, #255	; 0xff
33d07144:	eb004c92 	bl	33d1a394 <memset>

	/* If no default placement scheme is given, select an
	 * appropriate one */
	if (!this->autooob) {
33d07148:	e59630a0 	ldr	r3, [r6, #160]
33d0714c:	e3530000 	cmp	r3, #0	; 0x0
33d07150:	1a000012 	bne	33d071a0 <nand_scan+0x6c0>
		/* Select the appropriate default oob placement scheme for
		 * placement agnostic filesystems */
		switch (mtd->oobsize) {
33d07154:	e5971014 	ldr	r1, [r7, #20]
33d07158:	e3510010 	cmp	r1, #16	; 0x10
33d0715c:	0a000008 	beq	33d07184 <nand_scan+0x6a4>
33d07160:	8a000002 	bhi	33d07170 <nand_scan+0x690>
33d07164:	e3510008 	cmp	r1, #8	; 0x8
33d07168:	0a000003 	beq	33d0717c <nand_scan+0x69c>
33d0716c:	ea000009 	b	33d07198 <nand_scan+0x6b8>
33d07170:	e3510040 	cmp	r1, #64	; 0x40
33d07174:	0a000004 	beq	33d0718c <nand_scan+0x6ac>
33d07178:	ea000006 	b	33d07198 <nand_scan+0x6b8>
		case 8:
			this->autooob = &nand_oob_8;
33d0717c:	e59f331c 	ldr	r3, [pc, #796]	; 33d074a0 <nand_scan+0x9c0>
33d07180:	ea000002 	b	33d07190 <nand_scan+0x6b0>
			break;
		case 16:
			this->autooob = &nand_oob_16;
33d07184:	e59f3318 	ldr	r3, [pc, #792]	; 33d074a4 <nand_scan+0x9c4>
33d07188:	ea000000 	b	33d07190 <nand_scan+0x6b0>
			break;
		case 64:
			this->autooob = &nand_oob_64;
33d0718c:	e59f3314 	ldr	r3, [pc, #788]	; 33d074a8 <nand_scan+0x9c8>
33d07190:	e58630a0 	str	r3, [r6, #160]
			break;
33d07194:	ea000001 	b	33d071a0 <nand_scan+0x6c0>
		default:
			printk (KERN_WARNING "No oob scheme defined for oobsize %d\n",
33d07198:	e59f030c 	ldr	r0, [pc, #780]	; 33d074ac <nand_scan+0x9cc>
33d0719c:	eb003f89 	bl	33d16fc8 <printf>
		}
	}

	/* The number of bytes available for the filesystem to place fs dependend
	 * oob data */
	if (this->options & NAND_BUSWIDTH_16) {
33d071a0:	e5963088 	ldr	r3, [r6, #136]
33d071a4:	e3130002 	tst	r3, #2	; 0x2
33d071a8:	e59630a0 	ldr	r3, [r6, #160]
33d071ac:	e5972014 	ldr	r2, [r7, #20]
		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
		if (this->autooob->eccbytes & 0x01)
			mtd->oobavail--;
	} else
		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 1);
33d071b0:	05933004 	ldreq	r3, [r3, #4]
33d071b4:	00633002 	rsbeq	r3, r3, r2
33d071b8:	02433001 	subeq	r3, r3, #1	; 0x1
		}
	}

	/* The number of bytes available for the filesystem to place fs dependend
	 * oob data */
	if (this->options & NAND_BUSWIDTH_16) {
33d071bc:	0a000008 	beq	33d071e4 <nand_scan+0x704>
		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
33d071c0:	e5933004 	ldr	r3, [r3, #4]
33d071c4:	e0632002 	rsb	r2, r3, r2
33d071c8:	e2423002 	sub	r3, r2, #2	; 0x2
33d071cc:	e5873018 	str	r3, [r7, #24]
		if (this->autooob->eccbytes & 0x01)
33d071d0:	e59630a0 	ldr	r3, [r6, #160]
33d071d4:	e5933004 	ldr	r3, [r3, #4]
33d071d8:	e3130001 	tst	r3, #1	; 0x1
			mtd->oobavail--;
33d071dc:	12423003 	subne	r3, r2, #3	; 0x3

	/* The number of bytes available for the filesystem to place fs dependend
	 * oob data */
	if (this->options & NAND_BUSWIDTH_16) {
		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
		if (this->autooob->eccbytes & 0x01)
33d071e0:	0a000000 	beq	33d071e8 <nand_scan+0x708>
			mtd->oobavail--;
	} else
		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 1);
33d071e4:	e5873018 	str	r3, [r7, #24]
	/*
	 * check ECC mode, default to software
	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
	 * fallback to software ECC
	*/
	this->eccsize = 256;	/* set default eccsize */
33d071e8:	e3a03c01 	mov	r3, #256	; 0x100
	this->eccbytes = 3;

	switch (this->eccmode) {
33d071ec:	e5961054 	ldr	r1, [r6, #84]
	/*
	 * check ECC mode, default to software
	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
	 * fallback to software ECC
	*/
	this->eccsize = 256;	/* set default eccsize */
33d071f0:	e5863058 	str	r3, [r6, #88]
	this->eccbytes = 3;
33d071f4:	e24330fd 	sub	r3, r3, #253	; 0xfd
33d071f8:	e586305c 	str	r3, [r6, #92]

	switch (this->eccmode) {
33d071fc:	e3510007 	cmp	r1, #7	; 0x7
33d07200:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
33d07204:	ea000023 	b	33d07298 <nand_scan+0x7b8>
33d07208:	33d07270 	.word	0x33d07270
33d0720c:	33d07284 	.word	0x33d07284
33d07210:	33d072a0 	.word	0x33d072a0
33d07214:	33d07244 	.word	0x33d07244
33d07218:	33d07244 	.word	0x33d07244
33d0721c:	33d07298 	.word	0x33d07298
33d07220:	33d07244 	.word	0x33d07244
33d07224:	33d07228 	.word	0x33d07228
	case NAND_ECC_HW12_2048:
		if (mtd->oobblock < 2048) {
33d07228:	e5971010 	ldr	r1, [r7, #16]
33d0722c:	e3510b02 	cmp	r1, #2048	; 0x800
			       mtd->oobblock);
			this->eccmode = NAND_ECC_SOFT;
			this->calculate_ecc = nand_calculate_ecc;
			this->correct_data = nand_correct_data;
		} else
			this->eccsize = 2048;
33d07230:	23a03b02 	movcs	r3, #2048	; 0x800
	this->eccsize = 256;	/* set default eccsize */
	this->eccbytes = 3;

	switch (this->eccmode) {
	case NAND_ECC_HW12_2048:
		if (mtd->oobblock < 2048) {
33d07234:	2a00000b 	bcs	33d07268 <nand_scan+0x788>
			printk(KERN_WARNING "2048 byte HW ECC not possible on %d byte page size, fallback to SW ECC\n",
33d07238:	e59f0270 	ldr	r0, [pc, #624]	; 33d074b0 <nand_scan+0x9d0>
33d0723c:	eb003f61 	bl	33d16fc8 <printf>
33d07240:	ea000005 	b	33d0725c <nand_scan+0x77c>
		break;

	case NAND_ECC_HW3_512:
	case NAND_ECC_HW6_512:
	case NAND_ECC_HW8_512:
		if (mtd->oobblock == 256) {
33d07244:	e5973010 	ldr	r3, [r7, #16]
33d07248:	e3530c01 	cmp	r3, #256	; 0x100
			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
			this->eccmode = NAND_ECC_SOFT;
			this->calculate_ecc = nand_calculate_ecc;
			this->correct_data = nand_correct_data;
		} else
			this->eccsize = 512; /* set eccsize to 512 */
33d0724c:	13a03c02 	movne	r3, #512	; 0x200
		break;

	case NAND_ECC_HW3_512:
	case NAND_ECC_HW6_512:
	case NAND_ECC_HW8_512:
		if (mtd->oobblock == 256) {
33d07250:	1a000004 	bne	33d07268 <nand_scan+0x788>
			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
33d07254:	e59f0258 	ldr	r0, [pc, #600]	; 33d074b4 <nand_scan+0x9d4>
33d07258:	eb003f5a 	bl	33d16fc8 <printf>
			this->eccmode = NAND_ECC_SOFT;
33d0725c:	e3a03001 	mov	r3, #1	; 0x1
33d07260:	e5863054 	str	r3, [r6, #84]
33d07264:	ea000006 	b	33d07284 <nand_scan+0x7a4>
			this->calculate_ecc = nand_calculate_ecc;
			this->correct_data = nand_correct_data;
		} else
			this->eccsize = 512; /* set eccsize to 512 */
33d07268:	e5863058 	str	r3, [r6, #88]
		break;
33d0726c:	ea00000b 	b	33d072a0 <nand_scan+0x7c0>

	case NAND_ECC_HW3_256:
		break;

	case NAND_ECC_NONE:
		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
33d07270:	e59f0240 	ldr	r0, [pc, #576]	; 33d074b8 <nand_scan+0x9d8>
33d07274:	eb003f53 	bl	33d16fc8 <printf>
		this->eccmode = NAND_ECC_NONE;
33d07278:	e3a03000 	mov	r3, #0	; 0x0
33d0727c:	e5863054 	str	r3, [r6, #84]
		break;
33d07280:	ea000006 	b	33d072a0 <nand_scan+0x7c0>

	case NAND_ECC_SOFT:
		this->calculate_ecc = nand_calculate_ecc;
33d07284:	e59f3230 	ldr	r3, [pc, #560]	; 33d074bc <nand_scan+0x9dc>
33d07288:	e5863040 	str	r3, [r6, #64]
		this->correct_data = nand_correct_data;
33d0728c:	e59f322c 	ldr	r3, [pc, #556]	; 33d074c0 <nand_scan+0x9e0>
33d07290:	e5863044 	str	r3, [r6, #68]
		break;
33d07294:	ea000001 	b	33d072a0 <nand_scan+0x7c0>

	default:
		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
33d07298:	e59f0224 	ldr	r0, [pc, #548]	; 33d074c4 <nand_scan+0x9e4>
33d0729c:	eb003f49 	bl	33d16fc8 <printf>
	}

	/* Check hardware ecc function availability and adjust number of ecc bytes per
	 * calculation step
	*/
	switch (this->eccmode) {
33d072a0:	e5963054 	ldr	r3, [r6, #84]
33d072a4:	e2433002 	sub	r3, r3, #2	; 0x2
33d072a8:	e3530005 	cmp	r3, #5	; 0x5
33d072ac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d072b0:	ea000019 	b	33d0731c <nand_scan+0x83c>
33d072b4:	33d072f0 	.word	0x33d072f0
33d072b8:	33d072f0 	.word	0x33d072f0
33d072bc:	33d072e4 	.word	0x33d072e4
33d072c0:	33d0731c 	.word	0x33d0731c
33d072c4:	33d072d8 	.word	0x33d072d8
33d072c8:	33d072cc 	.word	0x33d072cc
	case NAND_ECC_HW12_2048:
		this->eccbytes += 4;
33d072cc:	e596305c 	ldr	r3, [r6, #92]
33d072d0:	e2833004 	add	r3, r3, #4	; 0x4
33d072d4:	e586305c 	str	r3, [r6, #92]
	case NAND_ECC_HW8_512:
		this->eccbytes += 2;
33d072d8:	e596305c 	ldr	r3, [r6, #92]
33d072dc:	e2833002 	add	r3, r3, #2	; 0x2
33d072e0:	e586305c 	str	r3, [r6, #92]
	case NAND_ECC_HW6_512:
		this->eccbytes += 3;
33d072e4:	e596305c 	ldr	r3, [r6, #92]
33d072e8:	e2833003 	add	r3, r3, #3	; 0x3
33d072ec:	e586305c 	str	r3, [r6, #92]
	case NAND_ECC_HW3_512:
	case NAND_ECC_HW3_256:
		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
33d072f0:	e5963040 	ldr	r3, [r6, #64]
33d072f4:	e3530000 	cmp	r3, #0	; 0x0
33d072f8:	0a000005 	beq	33d07314 <nand_scan+0x834>
33d072fc:	e5963044 	ldr	r3, [r6, #68]
33d07300:	e3530000 	cmp	r3, #0	; 0x0
33d07304:	0a000002 	beq	33d07314 <nand_scan+0x834>
33d07308:	e5963048 	ldr	r3, [r6, #72]
33d0730c:	e3530000 	cmp	r3, #0	; 0x0
33d07310:	1a000001 	bne	33d0731c <nand_scan+0x83c>
			break;
		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
33d07314:	e59f01ac 	ldr	r0, [pc, #428]	; 33d074c8 <nand_scan+0x9e8>
33d07318:	eb003f2a 	bl	33d16fc8 <printf>
/*		BUG();	*/
	}

	mtd->eccsize = this->eccsize;
33d0731c:	e5963058 	ldr	r3, [r6, #88]
33d07320:	e5873020 	str	r3, [r7, #32]

	/* Set the number of read / write steps for one page to ensure ECC generation */
	switch (this->eccmode) {
33d07324:	e5963054 	ldr	r3, [r6, #84]
33d07328:	e3530007 	cmp	r3, #7	; 0x7
33d0732c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d07330:	ea000012 	b	33d07380 <nand_scan+0x8a0>
33d07334:	33d07378 	.word	0x33d07378
33d07338:	33d0736c 	.word	0x33d0736c
33d0733c:	33d0736c 	.word	0x33d0736c
33d07340:	33d07360 	.word	0x33d07360
33d07344:	33d07360 	.word	0x33d07360
33d07348:	33d07380 	.word	0x33d07380
33d0734c:	33d07360 	.word	0x33d07360
33d07350:	33d07354 	.word	0x33d07354
	case NAND_ECC_HW12_2048:
		this->eccsteps = mtd->oobblock / 2048;
33d07354:	e5973010 	ldr	r3, [r7, #16]
33d07358:	e1a035a3 	lsr	r3, r3, #11
33d0735c:	ea000006 	b	33d0737c <nand_scan+0x89c>
		break;
	case NAND_ECC_HW3_512:
	case NAND_ECC_HW6_512:
	case NAND_ECC_HW8_512:
		this->eccsteps = mtd->oobblock / 512;
33d07360:	e5973010 	ldr	r3, [r7, #16]
33d07364:	e1a034a3 	lsr	r3, r3, #9
33d07368:	ea000003 	b	33d0737c <nand_scan+0x89c>
		break;
	case NAND_ECC_HW3_256:
	case NAND_ECC_SOFT:
		this->eccsteps = mtd->oobblock / 256;
33d0736c:	e5973010 	ldr	r3, [r7, #16]
33d07370:	e1a03423 	lsr	r3, r3, #8
33d07374:	ea000000 	b	33d0737c <nand_scan+0x89c>
		break;

	case NAND_ECC_NONE:
		this->eccsteps = 1;
33d07378:	e3a03001 	mov	r3, #1	; 0x1
33d0737c:	e5863060 	str	r3, [r6, #96]
	init_waitqueue_head (&this->wq);
	spin_lock_init (&this->chip_lock);
#endif

	/* De-select the device */
	this->select_chip(mtd, -1);
33d07380:	e3e04000 	mvn	r4, #0	; 0x0
33d07384:	e1a00007 	mov	r0, r7
33d07388:	e1a01004 	mov	r1, r4
33d0738c:	e1a0e00f 	mov	lr, pc
33d07390:	e596f024 	ldr	pc, [r6, #36]

	/* Invalidate the pagebuffer reference */
	this->pagebuf = -1;

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
33d07394:	e3a03004 	mov	r3, #4	; 0x4

	/* De-select the device */
	this->select_chip(mtd, -1);

	/* Invalidate the pagebuffer reference */
	this->pagebuf = -1;
33d07398:	e586409c 	str	r4, [r6, #156]

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
33d0739c:	e5c73000 	strb	r3, [r7]
	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
33d073a0:	e28330c1 	add	r3, r3, #193	; 0xc1
33d073a4:	e5873004 	str	r3, [r7, #4]
	mtd->ecctype = MTD_ECC_SW;
33d073a8:	e24330c3 	sub	r3, r3, #195	; 0xc3
33d073ac:	e587301c 	str	r3, [r7, #28]
	mtd->erase = nand_erase;
33d073b0:	e59f3114 	ldr	r3, [pc, #276]	; 33d074cc <nand_scan+0x9ec>
33d073b4:	e5873100 	str	r3, [r7, #256]
	mtd->point = NULL;
	mtd->unpoint = NULL;
	mtd->read = nand_read;
33d073b8:	e59f3110 	ldr	r3, [pc, #272]	; 33d074d0 <nand_scan+0x9f0>
33d073bc:	e587310c 	str	r3, [r7, #268]
	mtd->write = nand_write;
33d073c0:	e59f310c 	ldr	r3, [pc, #268]	; 33d074d4 <nand_scan+0x9f4>
33d073c4:	e5873110 	str	r3, [r7, #272]
	mtd->read_ecc = nand_read_ecc;
33d073c8:	e59f3108 	ldr	r3, [pc, #264]	; 33d074d8 <nand_scan+0x9f8>
33d073cc:	e5873114 	str	r3, [r7, #276]
	mtd->write_ecc = nand_write_ecc;
33d073d0:	e59f3104 	ldr	r3, [pc, #260]	; 33d074dc <nand_scan+0x9fc>
33d073d4:	e5873118 	str	r3, [r7, #280]
	mtd->read_oob = nand_read_oob;
33d073d8:	e59f3100 	ldr	r3, [pc, #256]	; 33d074e0 <nand_scan+0xa00>
33d073dc:	e587311c 	str	r3, [r7, #284]
	mtd->write_oob = nand_write_oob;
33d073e0:	e59f30fc 	ldr	r3, [pc, #252]	; 33d074e4 <nand_scan+0xa04>
33d073e4:	e5873120 	str	r3, [r7, #288]
#if 0
	mtd->readv = NULL;
	mtd->writev = nand_writev;
	mtd->writev_ecc = nand_writev_ecc;
#endif
	mtd->sync = nand_sync;
33d073e8:	e59f30f8 	ldr	r3, [pc, #248]	; 33d074e8 <nand_scan+0xa08>
33d073ec:	e5873130 	str	r3, [r7, #304]
	mtd->lock = NULL;
	mtd->unlock = NULL;
	mtd->suspend = NULL;
	mtd->resume = NULL;
#endif
	mtd->block_isbad = nand_block_isbad;
33d073f0:	e59f30f4 	ldr	r3, [pc, #244]	; 33d074ec <nand_scan+0xa0c>
33d073f4:	e5873134 	str	r3, [r7, #308]
	mtd->block_markbad = nand_block_markbad;
33d073f8:	e59f30f0 	ldr	r3, [pc, #240]	; 33d074f0 <nand_scan+0xa10>
	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
	mtd->ecctype = MTD_ECC_SW;
	mtd->erase = nand_erase;
	mtd->point = NULL;
33d073fc:	e3a05000 	mov	r5, #0	; 0x0
	mtd->unlock = NULL;
	mtd->suspend = NULL;
	mtd->resume = NULL;
#endif
	mtd->block_isbad = nand_block_isbad;
	mtd->block_markbad = nand_block_markbad;
33d07400:	e5873138 	str	r3, [r7, #312]
	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
	mtd->ecctype = MTD_ECC_SW;
	mtd->erase = nand_erase;
	mtd->point = NULL;
33d07404:	e5875104 	str	r5, [r7, #260]
	mtd->unpoint = NULL;
33d07408:	e5875108 	str	r5, [r7, #264]
#endif
	mtd->block_isbad = nand_block_isbad;
	mtd->block_markbad = nand_block_markbad;

	/* and make the autooob the default one */
	memcpy(&mtd->oobinfo, this->autooob, sizeof(mtd->oobinfo));
33d0740c:	e287002c 	add	r0, r7, #44	; 0x2c
33d07410:	e59610a0 	ldr	r1, [r6, #160]
33d07414:	e3a020c8 	mov	r2, #200	; 0xc8
33d07418:	eb004bf1 	bl	33d1a3e4 <memcpy>
#if 0
	mtd->owner = THIS_MODULE;
#endif
//	printf("this->options = 0x%x\n", this->options);			//HJ_del
	/* Build bad block table */
	return 0; //this->scan_bbt (mtd); // cancelled by www.embedsky.net, scan_bbt uses more time
33d0741c:	e1a00005 	mov	r0, r5
}
33d07420:	e28dd008 	add	sp, sp, #8	; 0x8
33d07424:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d07428:	33d04e24 	.word	0x33d04e24
33d0742c:	33d0521c 	.word	0x33d0521c
33d07430:	33d0489c 	.word	0x33d0489c
33d07434:	33d04860 	.word	0x33d04860
33d07438:	33d04838 	.word	0x33d04838
33d0743c:	33d0484c 	.word	0x33d0484c
33d07440:	33d04828 	.word	0x33d04828
33d07444:	33d04884 	.word	0x33d04884
33d07448:	33d04874 	.word	0x33d04874
33d0744c:	33d04a6c 	.word	0x33d04a6c
33d07450:	33d04d74 	.word	0x33d04d74
33d07454:	33d049a8 	.word	0x33d049a8
33d07458:	33d04900 	.word	0x33d04900
33d0745c:	33d049e0 	.word	0x33d049e0
33d07460:	33d04934 	.word	0x33d04934
33d07464:	33d04a18 	.word	0x33d04a18
33d07468:	33d04960 	.word	0x33d04960
33d0746c:	33d08c78 	.word	0x33d08c78
33d07470:	33d2e090 	.word	0x33d2e090
33d07474:	33d2e058 	.word	0x33d2e058
33d07478:	33d25d9c 	.word	0x33d25d9c
33d0747c:	33d25ddc 	.word	0x33d25ddc
33d07480:	0000fffe 	.word	0x0000fffe
33d07484:	33d067bc 	.word	0x33d067bc
33d07488:	33d0677c 	.word	0x33d0677c
33d0748c:	33d0500c 	.word	0x33d0500c
33d07490:	33d25e00 	.word	0x33d25e00
33d07494:	33d25e1c 	.word	0x33d25e1c
33d07498:	33d25e34 	.word	0x33d25e34
33d0749c:	33d25e5c 	.word	0x33d25e5c
33d074a0:	33d2df50 	.word	0x33d2df50
33d074a4:	33d2de88 	.word	0x33d2de88
33d074a8:	33d2ddc0 	.word	0x33d2ddc0
33d074ac:	33d25e84 	.word	0x33d25e84
33d074b0:	33d25eac 	.word	0x33d25eac
33d074b4:	33d25ef4 	.word	0x33d25ef4
33d074b8:	33d25f3c 	.word	0x33d25f3c
33d074bc:	33d07530 	.word	0x33d07530
33d074c0:	33d07644 	.word	0x33d07644
33d074c4:	33d25f80 	.word	0x33d25f80
33d074c8:	33d25f9c 	.word	0x33d25f9c
33d074cc:	33d06a3c 	.word	0x33d06a3c
33d074d0:	33d059b8 	.word	0x33d059b8
33d074d4:	33d06484 	.word	0x33d06484
33d074d8:	33d052e8 	.word	0x33d052e8
33d074dc:	33d05ea0 	.word	0x33d05ea0
33d074e0:	33d059e8 	.word	0x33d059e8
33d074e4:	33d04bc8 	.word	0x33d04bc8
33d074e8:	33d06a44 	.word	0x33d06a44
33d074ec:	33d06a48 	.word	0x33d06a48
33d074f0:	33d06a9c 	.word	0x33d06a9c

33d074f4 <nand_release>:
/**
 * nand_release - [NAND Interface] Free resources held by the NAND device
 * @mtd:	MTD device structure
 */
void nand_release (struct mtd_info *mtd)
{
33d074f4:	e92d4010 	push	{r4, lr}
	struct nand_chip *this = mtd->priv;
33d074f8:	e590413c 	ldr	r4, [r0, #316]
/* XXX U-BOOT XXX */
#if 0
	del_mtd_device (mtd);
#endif
	/* Free bad block table memory, if allocated */
	if (this->bbt)
33d074fc:	e59400a4 	ldr	r0, [r4, #164]
33d07500:	e3500000 	cmp	r0, #0	; 0x0
		kfree (this->bbt);
33d07504:	1b003fd2 	blne	33d17454 <free>
	/* Buffer allocated by nand_scan ? */
	if (this->options & NAND_OOBBUF_ALLOC)
33d07508:	e5943088 	ldr	r3, [r4, #136]
33d0750c:	e3130101 	tst	r3, #1073741824	; 0x40000000
		kfree (this->oob_buf);
33d07510:	1594007c 	ldrne	r0, [r4, #124]
33d07514:	1b003fce 	blne	33d17454 <free>
	/* Buffer allocated by nand_scan ? */
	if (this->options & NAND_DATABUF_ALLOC)
33d07518:	e5943088 	ldr	r3, [r4, #136]
33d0751c:	e3530000 	cmp	r3, #0	; 0x0
33d07520:	a8bd8010 	popge	{r4, pc}
		kfree (this->data_buf);
33d07524:	e5940078 	ldr	r0, [r4, #120]
}
33d07528:	e8bd4010 	pop	{r4, lr}
	/* Buffer allocated by nand_scan ? */
	if (this->options & NAND_OOBBUF_ALLOC)
		kfree (this->oob_buf);
	/* Buffer allocated by nand_scan ? */
	if (this->options & NAND_DATABUF_ALLOC)
		kfree (this->data_buf);
33d0752c:	ea003fc8 	b	33d17454 <free>

33d07530 <nand_calculate_ecc>:
 * @mtd:	MTD block structure
 * @dat:	raw data
 * @ecc_code:	buffer for ECC
 */
int nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
{
33d07530:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d07534:	e1a00002 	mov	r0, r2
	u_char idx, reg1, reg2, reg3;
	int j;

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
33d07538:	e3a06000 	mov	r6, #0	; 0x0
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;
33d0753c:	e5c06002 	strb	r6, [r0, #2]
33d07540:	e5c06001 	strb	r6, [r0, #1]
33d07544:	e5c06000 	strb	r6, [r0]
{
	u_char idx, reg1, reg2, reg3;
	int j;

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
33d07548:	e1a04006 	mov	r4, r6
33d0754c:	e1a07006 	mov	r7, r6
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {
33d07550:	e1a0c006 	mov	ip, r6

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
33d07554:	e7d1200c 	ldrb	r2, [r1, ip]
33d07558:	e59f30e0 	ldr	r3, [pc, #224]	; 33d07640 <nand_calculate_ecc+0x110>
33d0755c:	e7d32002 	ldrb	r2, [r3, r2]
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (u_char) j;
			reg2 ^= ~((u_char) j);
33d07560:	e1e0300c 	mvn	r3, ip
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
33d07564:	e3120040 	tst	r2, #64	; 0x40
			reg3 ^= (u_char) j;
			reg2 ^= ~((u_char) j);
33d07568:	e026e003 	eor	lr, r6, r3
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (u_char) j;
33d0756c:	e027300c 	eor	r3, r7, ip
	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {
33d07570:	e28cc001 	add	ip, ip, #1	; 0x1

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= (idx & 0x3f);
33d07574:	e202203f 	and	r2, r2, #63	; 0x3f

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (u_char) j;
33d07578:	120370ff 	andne	r7, r3, #255	; 0xff
			reg2 ^= ~((u_char) j);
33d0757c:	120e60ff 	andne	r6, lr, #255	; 0xff
	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {
33d07580:	e35c00ff 	cmp	ip, #255	; 0xff

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= (idx & 0x3f);
33d07584:	e0244002 	eor	r4, r4, r2
	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {
33d07588:	dafffff1 	ble	33d07554 <nand_calculate_ecc+0x24>
{
	u_char a, b, i, tmp1, tmp2;

	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;
33d0758c:	e3a0e000 	mov	lr, #0	; 0x0
	u_char *ecc_code)
{
	u_char a, b, i, tmp1, tmp2;

	/* Initialize variables */
	a = b = 0x80;
33d07590:	e3a0c080 	mov	ip, #128	; 0x80
33d07594:	e1a0200c 	mov	r2, ip
	tmp1 = tmp2 = 0;
33d07598:	e1a0500e 	mov	r5, lr

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
33d0759c:	e1a0300e 	mov	r3, lr
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
33d075a0:	e117000c 	tst	r7, ip
			tmp1 |= b;
33d075a4:	11855002 	orrne	r5, r5, r2
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
33d075a8:	e2833001 	add	r3, r3, #1	; 0x1
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
33d075ac:	e1a020a2 	lsr	r2, r2, #1
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
33d075b0:	e116000c 	tst	r6, ip
			tmp1 |= b;
33d075b4:	e1851002 	orr	r1, r5, r2
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
33d075b8:	e20330ff 	and	r3, r3, #255	; 0xff
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
33d075bc:	120150ff 	andne	r5, r1, #255	; 0xff
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
33d075c0:	e3530003 	cmp	r3, #3	; 0x3
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		a >>= 1;
33d075c4:	e1a0c0ac 	lsr	ip, ip, #1
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
33d075c8:	e1a020a2 	lsr	r2, r2, #1
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
33d075cc:	9afffff3 	bls	33d075a0 <nand_calculate_ecc+0x70>
		b >>= 1;
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
33d075d0:	e3a02080 	mov	r2, #128	; 0x80
	for (i = 0; i < 4; i++) {
33d075d4:	e3a03000 	mov	r3, #0	; 0x0
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
33d075d8:	e117000c 	tst	r7, ip
			tmp2 |= b;
33d075dc:	118ee002 	orrne	lr, lr, r2
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
33d075e0:	e2833001 	add	r3, r3, #1	; 0x1
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
33d075e4:	e1a020a2 	lsr	r2, r2, #1
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
33d075e8:	e116000c 	tst	r6, ip
			tmp2 |= b;
33d075ec:	e18e1002 	orr	r1, lr, r2
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
33d075f0:	e20330ff 	and	r3, r3, #255	; 0xff
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
			tmp2 |= b;
33d075f4:	1201e0ff 	andne	lr, r1, #255	; 0xff
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
33d075f8:	e3530003 	cmp	r3, #3	; 0x3
			tmp2 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		a >>= 1;
33d075fc:	e1a0c0ac 	lsr	ip, ip, #1
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
33d07600:	e1a020a2 	lsr	r2, r2, #1
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
33d07604:	9afffff3 	bls	33d075d8 <nand_calculate_ecc+0xa8>
		b >>= 1;
		a >>= 1;
	}

	/* Store two of the ECC bytes */
	ecc_code[0] = tmp1;
33d07608:	e5c05000 	strb	r5, [r0]
	ecc_code[1] = tmp2;
33d0760c:	e5c0e001 	strb	lr, [r0, #1]

	/* Create non-inverted ECC code from line parity */
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
33d07610:	e5d02000 	ldrb	r2, [r0]
	ecc_code[1] = ~ecc_code[1];
33d07614:	e5d01001 	ldrb	r1, [r0, #1]
	ecc_code[2] = ((~reg1) << 2) | 0x03;
33d07618:	e1e03004 	mvn	r3, r4
33d0761c:	e1a03103 	lsl	r3, r3, #2

	/* Create non-inverted ECC code from line parity */
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
33d07620:	e1e02002 	mvn	r2, r2
	ecc_code[1] = ~ecc_code[1];
33d07624:	e1e01001 	mvn	r1, r1
	ecc_code[2] = ((~reg1) << 2) | 0x03;
33d07628:	e3833003 	orr	r3, r3, #3	; 0x3
33d0762c:	e5c03002 	strb	r3, [r0, #2]

	/* Create non-inverted ECC code from line parity */
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
33d07630:	e5c02000 	strb	r2, [r0]
	ecc_code[1] = ~ecc_code[1];
33d07634:	e5c01001 	strb	r1, [r0, #1]
	ecc_code[2] = ((~reg1) << 2) | 0x03;
	return 0;
}
33d07638:	e3a00000 	mov	r0, #0	; 0x0
33d0763c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d07640:	33d2483c 	.word	0x33d2483c

33d07644 <nand_correct_data>:
 * @calc_ecc:	the ECC calculated from raw data
 *
 * Detect and correct a 1 bit error for 256 byte block
 */
int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
33d07644:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d07648:	e1a07003 	mov	r7, r3
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
33d0764c:	e5d30001 	ldrb	r0, [r3, #1]
int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
33d07650:	e5d3a000 	ldrb	sl, [r3]
33d07654:	e5d2e000 	ldrb	lr, [r2]
	d2 = calc_ecc[1] ^ read_ecc[1];
33d07658:	e5d23001 	ldrb	r3, [r2, #1]
 * @calc_ecc:	the ECC calculated from raw data
 *
 * Detect and correct a 1 bit error for 256 byte block
 */
int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
33d0765c:	e1a06002 	mov	r6, r2
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
	d3 = calc_ecc[2] ^ read_ecc[2];
33d07660:	e5d7c002 	ldrb	ip, [r7, #2]
33d07664:	e5d22002 	ldrb	r2, [r2, #2]
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
33d07668:	e0205003 	eor	r5, r0, r3
int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
33d0766c:	e02a400e 	eor	r4, sl, lr
	d2 = calc_ecc[1] ^ read_ecc[1];
	d3 = calc_ecc[2] ^ read_ecc[2];
33d07670:	e02cc002 	eor	ip, ip, r2

	if ((d1 | d2 | d3) == 0) {
33d07674:	e1843005 	orr	r3, r4, r5
33d07678:	e19c0003 	orrs	r0, ip, r3
 * @calc_ecc:	the ECC calculated from raw data
 *
 * Detect and correct a 1 bit error for 256 byte block
 */
int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
33d0767c:	e1a09001 	mov	r9, r1
	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
	d3 = calc_ecc[2] ^ read_ecc[2];

	if ((d1 | d2 | d3) == 0) {
33d07680:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
		/* No errors */
		return 0;
	}
	else {
		a = (d1 ^ (d1 >> 1)) & 0x55;
33d07684:	e02430a4 	eor	r3, r4, r4, lsr #1
		b = (d2 ^ (d2 >> 1)) & 0x55;
33d07688:	e02520a5 	eor	r2, r5, r5, lsr #1
	if ((d1 | d2 | d3) == 0) {
		/* No errors */
		return 0;
	}
	else {
		a = (d1 ^ (d1 >> 1)) & 0x55;
33d0768c:	e203e055 	and	lr, r3, #85	; 0x55
		b = (d2 ^ (d2 >> 1)) & 0x55;
33d07690:	e2020055 	and	r0, r2, #85	; 0x55
		c = (d3 ^ (d3 >> 1)) & 0x54;
33d07694:	e02c30ac 	eor	r3, ip, ip, lsr #1

		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
33d07698:	e35e0055 	cmp	lr, #85	; 0x55
33d0769c:	03500055 	cmpeq	r0, #85	; 0x55
		return 0;
	}
	else {
		a = (d1 ^ (d1 >> 1)) & 0x55;
		b = (d2 ^ (d2 >> 1)) & 0x55;
		c = (d3 ^ (d3 >> 1)) & 0x54;
33d076a0:	e2032054 	and	r2, r3, #84	; 0x54

		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
33d076a4:	1a000028 	bne	33d0774c <nand_correct_data+0x108>
33d076a8:	e3520054 	cmp	r2, #84	; 0x54
33d076ac:	1a000026 	bne	33d0774c <nand_correct_data+0x108>
			c = 0x80;
33d076b0:	e282202c 	add	r2, r2, #44	; 0x2c
			add = 0;
33d076b4:	e3a01000 	mov	r1, #0	; 0x0
			a = 0x80;
33d076b8:	e1a0e002 	mov	lr, r2
			for (i=0; i<4; i++) {
33d076bc:	e1a03001 	mov	r3, r1
33d076c0:	e2833001 	add	r3, r3, #1	; 0x1
				if (d1 & c)
33d076c4:	e1140002 	tst	r4, r2
		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
			c = 0x80;
			add = 0;
			a = 0x80;
			for (i=0; i<4; i++) {
33d076c8:	e20330ff 	and	r3, r3, #255	; 0xff
				if (d1 & c)
					add |= a;
33d076cc:	1181100e 	orrne	r1, r1, lr
		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
			c = 0x80;
			add = 0;
			a = 0x80;
			for (i=0; i<4; i++) {
33d076d0:	e3530003 	cmp	r3, #3	; 0x3
				if (d1 & c)
					add |= a;
				c >>= 2;
33d076d4:	e1a02122 	lsr	r2, r2, #2
				a >>= 1;
33d076d8:	e1a0e0ae 	lsr	lr, lr, #1
		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
			c = 0x80;
			add = 0;
			a = 0x80;
			for (i=0; i<4; i++) {
33d076dc:	9afffff7 	bls	33d076c0 <nand_correct_data+0x7c>
				if (d1 & c)
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			c = 0x80;
33d076e0:	e3a02080 	mov	r2, #128	; 0x80
			for (i=0; i<4; i++) {
33d076e4:	e3a03000 	mov	r3, #0	; 0x0
33d076e8:	e2833001 	add	r3, r3, #1	; 0x1
				if (d2 & c)
33d076ec:	e1150002 	tst	r5, r2
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			c = 0x80;
			for (i=0; i<4; i++) {
33d076f0:	e20330ff 	and	r3, r3, #255	; 0xff
				if (d2 & c)
					add |= a;
33d076f4:	1181100e 	orrne	r1, r1, lr
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			c = 0x80;
			for (i=0; i<4; i++) {
33d076f8:	e3530003 	cmp	r3, #3	; 0x3
				if (d2 & c)
					add |= a;
				c >>= 2;
33d076fc:	e1a02122 	lsr	r2, r2, #2
				a >>= 1;
33d07700:	e1a0e0ae 	lsr	lr, lr, #1
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			c = 0x80;
			for (i=0; i<4; i++) {
33d07704:	9afffff7 	bls	33d076e8 <nand_correct_data+0xa4>
				if (d2 & c)
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			bit = 0;
33d07708:	e3a04000 	mov	r4, #0	; 0x0
			b = 0x04;
33d0770c:	e3a00004 	mov	r0, #4	; 0x4
			c = 0x80;
33d07710:	e3a02080 	mov	r2, #128	; 0x80
			for (i=0; i<3; i++) {
33d07714:	e1a03004 	mov	r3, r4
33d07718:	e2833001 	add	r3, r3, #1	; 0x1
				if (d3 & c)
33d0771c:	e11c0002 	tst	ip, r2
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
33d07720:	e20330ff 	and	r3, r3, #255	; 0xff
				if (d3 & c)
					bit |= b;
33d07724:	11844000 	orrne	r4, r4, r0
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
33d07728:	e3530002 	cmp	r3, #2	; 0x2
				if (d3 & c)
					bit |= b;
				c >>= 2;
33d0772c:	e1a02122 	lsr	r2, r2, #2
				b >>= 1;
33d07730:	e1a000a0 	lsr	r0, r0, #1
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
33d07734:	9afffff7 	bls	33d07718 <nand_correct_data+0xd4>
					bit |= b;
				c >>= 2;
				b >>= 1;
			}
			b = 0x01;
			a = dat[add];
33d07738:	e7d9e001 	ldrb	lr, [r9, r1]
				if (d3 & c)
					bit |= b;
				c >>= 2;
				b >>= 1;
			}
			b = 0x01;
33d0773c:	e3a00001 	mov	r0, #1	; 0x1
			a = dat[add];
			a ^= (b << bit);
33d07740:	e02e3410 	eor	r3, lr, r0, lsl r4
			dat[add] = a;
33d07744:	e7c93001 	strb	r3, [r9, r1]
			return 1;
33d07748:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
		} else {
			i = 0;
			while (d1) {
				if (d1 & 0x01)
					++i;
				d1 >>= 1;
33d0774c:	e3540000 	cmp	r4, #0	; 0x0
			a = dat[add];
			a ^= (b << bit);
			dat[add] = a;
			return 1;
		} else {
			i = 0;
33d07750:	e3a03000 	mov	r3, #0	; 0x0
			while (d1) {
				if (d1 & 0x01)
					++i;
				d1 >>= 1;
33d07754:	0a000004 	beq	33d0776c <nand_correct_data+0x128>
			dat[add] = a;
			return 1;
		} else {
			i = 0;
			while (d1) {
				if (d1 & 0x01)
33d07758:	e3140001 	tst	r4, #1	; 0x1
					++i;
33d0775c:	e2832001 	add	r2, r3, #1	; 0x1
33d07760:	120230ff 	andne	r3, r2, #255	; 0xff
				d1 >>= 1;
33d07764:	e1b040a4 	lsrs	r4, r4, #1
33d07768:	1afffffa 	bne	33d07758 <nand_correct_data+0x114>
			}
			while (d2) {
				if (d2 & 0x01)
					++i;
				d2 >>= 1;
33d0776c:	e3550000 	cmp	r5, #0	; 0x0
33d07770:	0a000004 	beq	33d07788 <nand_correct_data+0x144>
				if (d1 & 0x01)
					++i;
				d1 >>= 1;
			}
			while (d2) {
				if (d2 & 0x01)
33d07774:	e3150001 	tst	r5, #1	; 0x1
					++i;
33d07778:	e2832001 	add	r2, r3, #1	; 0x1
33d0777c:	120230ff 	andne	r3, r2, #255	; 0xff
				d2 >>= 1;
33d07780:	e1b050a5 	lsrs	r5, r5, #1
33d07784:	1afffffa 	bne	33d07774 <nand_correct_data+0x130>
			}
			while (d3) {
				if (d3 & 0x01)
					++i;
				d3 >>= 1;
33d07788:	e35c0000 	cmp	ip, #0	; 0x0
33d0778c:	0a000004 	beq	33d077a4 <nand_correct_data+0x160>
				if (d2 & 0x01)
					++i;
				d2 >>= 1;
			}
			while (d3) {
				if (d3 & 0x01)
33d07790:	e31c0001 	tst	ip, #1	; 0x1
					++i;
33d07794:	e2832001 	add	r2, r3, #1	; 0x1
33d07798:	120230ff 	andne	r3, r2, #255	; 0xff
				d3 >>= 1;
33d0779c:	e1b0c0ac 	lsrs	ip, ip, #1
33d077a0:	1afffffa 	bne	33d07790 <nand_correct_data+0x14c>
			}
			if (i == 1) {
33d077a4:	e3530001 	cmp	r3, #1	; 0x1
				/* ECC Code Error Correction */
				read_ecc[0] = calc_ecc[0];
33d077a8:	05c6a000 	strbeq	sl, [r6]
				read_ecc[1] = calc_ecc[1];
33d077ac:	05d73001 	ldrbeq	r3, [r7, #1]
33d077b0:	05c63001 	strbeq	r3, [r6, #1]
				read_ecc[2] = calc_ecc[2];
33d077b4:	05d73002 	ldrbeq	r3, [r7, #2]
				return 2;
33d077b8:	03a00002 	moveq	r0, #2	; 0x2
			}
			else {
				/* Uncorrectable Error */
				return -1;
33d077bc:	13e00000 	mvnne	r0, #0	; 0x0
			}
			if (i == 1) {
				/* ECC Code Error Correction */
				read_ecc[0] = calc_ecc[0];
				read_ecc[1] = calc_ecc[1];
				read_ecc[2] = calc_ecc[2];
33d077c0:	05c63002 	strbeq	r3, [r6, #2]
		}
	}

	/* Should never happen */
	return -1;
}
33d077c4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

33d077c8 <check_pattern>:
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
33d077c8:	e92d4070 	push	{r4, r5, r6, lr}
	int i, end;
	uint8_t *p = buf;

	end = paglen + td->offs;
	if (td->options & NAND_BBT_SCANEMPTY) {
33d077cc:	e5935000 	ldr	r5, [r3]
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
33d077d0:	e1a04003 	mov	r4, r3
	int i, end;
	uint8_t *p = buf;

	end = paglen + td->offs;
33d077d4:	e5933008 	ldr	r3, [r3, #8]
	if (td->options & NAND_BBT_SCANEMPTY) {
33d077d8:	e3150b02 	tst	r5, #2048	; 0x800
static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
	int i, end;
	uint8_t *p = buf;

	end = paglen + td->offs;
33d077dc:	e082e003 	add	lr, r2, r3
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
33d077e0:	e1a06001 	mov	r6, r1
	int i, end;
	uint8_t *p = buf;

	end = paglen + td->offs;
	if (td->options & NAND_BBT_SCANEMPTY) {
33d077e4:	0a000007 	beq	33d07808 <check_pattern+0x40>
		for (i = 0; i < end; i++) {
33d077e8:	e3a0c000 	mov	ip, #0	; 0x0
33d077ec:	e15c000e 	cmp	ip, lr
33d077f0:	aa000004 	bge	33d07808 <check_pattern+0x40>
			if (p[i] != 0xff)
33d077f4:	e7d0300c 	ldrb	r3, [r0, ip]
33d077f8:	e35300ff 	cmp	r3, #255	; 0xff
	int i, end;
	uint8_t *p = buf;

	end = paglen + td->offs;
	if (td->options & NAND_BBT_SCANEMPTY) {
		for (i = 0; i < end; i++) {
33d077fc:	e28cc001 	add	ip, ip, #1	; 0x1
			if (p[i] != 0xff)
33d07800:	0afffff9 	beq	33d077ec <check_pattern+0x24>
33d07804:	ea000018 	b	33d0786c <check_pattern+0xa4>
		}
	}
	p += end;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
33d07808:	e5941014 	ldr	r1, [r4, #20]
33d0780c:	e3a0c000 	mov	ip, #0	; 0x0
33d07810:	e15c0001 	cmp	ip, r1
		for (i = 0; i < end; i++) {
			if (p[i] != 0xff)
				return -1;
		}
	}
	p += end;
33d07814:	e080000e 	add	r0, r0, lr

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
33d07818:	aa000007 	bge	33d0783c <check_pattern+0x74>
		if (p[i] != td->pattern[i])
33d0781c:	e5943020 	ldr	r3, [r4, #32]
33d07820:	e7d3200c 	ldrb	r2, [r3, ip]
33d07824:	e7d0300c 	ldrb	r3, [r0, ip]
33d07828:	e1530002 	cmp	r3, r2
		}
	}
	p += end;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
33d0782c:	e28cc001 	add	ip, ip, #1	; 0x1
		if (p[i] != td->pattern[i])
33d07830:	1a00000d 	bne	33d0786c <check_pattern+0xa4>
		}
	}
	p += end;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
33d07834:	e15c0001 	cmp	ip, r1
33d07838:	eafffff6 	b	33d07818 <check_pattern+0x50>
		if (p[i] != td->pattern[i])
			return -1;
	}

	p += td->len;
33d0783c:	e5943014 	ldr	r3, [r4, #20]
	end += td->len;
	if (td->options & NAND_BBT_SCANEMPTY) {
33d07840:	e3150b02 	tst	r5, #2048	; 0x800
		if (p[i] != td->pattern[i])
			return -1;
	}

	p += td->len;
	end += td->len;
33d07844:	e08ee003 	add	lr, lr, r3
	for (i = 0; i < td->len; i++) {
		if (p[i] != td->pattern[i])
			return -1;
	}

	p += td->len;
33d07848:	e0800003 	add	r0, r0, r3
	end += td->len;
	if (td->options & NAND_BBT_SCANEMPTY) {
33d0784c:	0a000008 	beq	33d07874 <check_pattern+0xac>
		for (i = end; i < len; i++) {
33d07850:	e1a0c00e 	mov	ip, lr
33d07854:	e15c0006 	cmp	ip, r6
33d07858:	aa000005 	bge	33d07874 <check_pattern+0xac>
			if (*p++ != 0xff)
33d0785c:	e4d03001 	ldrb	r3, [r0], #1
33d07860:	e35300ff 	cmp	r3, #255	; 0xff
	}

	p += td->len;
	end += td->len;
	if (td->options & NAND_BBT_SCANEMPTY) {
		for (i = end; i < len; i++) {
33d07864:	e28cc001 	add	ip, ip, #1	; 0x1
			if (*p++ != 0xff)
33d07868:	0afffff9 	beq	33d07854 <check_pattern+0x8c>
				return -1;
33d0786c:	e3e00000 	mvn	r0, #0	; 0x0
33d07870:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}
	return 0;
33d07874:	e3a00000 	mov	r0, #0	; 0x0
}
33d07878:	e8bd8070 	pop	{r4, r5, r6, pc}

33d0787c <read_bbt>:
 * Read the bad block table starting from page.
 *
 */
static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
	int bits, int offs, int reserved_block_code)
{
33d0787c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d07880:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);

	totlen = (num * bits) >> 3;
33d07884:	e59dc04c 	ldr	ip, [sp, #76]
33d07888:	e00c0c93 	mul	ip, r3, ip
 * Read the bad block table starting from page.
 *
 */
static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
	int bits, int offs, int reserved_block_code)
{
33d0788c:	e58d0024 	str	r0, [sp, #36]
	int res, i, j, act = 0;
	struct nand_chip *this = mtd->priv;
33d07890:	e590613c 	ldr	r6, [r0, #316]
	size_t retlen, len, totlen;
	loff_t from;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
33d07894:	e59d004c 	ldr	r0, [sp, #76]
 * Read the bad block table starting from page.
 *
 */
static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
	int bits, int offs, int reserved_block_code)
{
33d07898:	e58d1020 	str	r1, [sp, #32]
	int res, i, j, act = 0;
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
33d0789c:	e3e03000 	mvn	r3, #0	; 0x0
33d078a0:	e1e03013 	mvn	r3, r3, lsl r0
33d078a4:	e20330ff 	and	r3, r3, #255	; 0xff

	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;
33d078a8:	e1a00002 	mov	r0, r2
33d078ac:	e1a01fc0 	asr	r1, r0, #31
33d078b0:	e5962068 	ldr	r2, [r6, #104]
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);

	totlen = (num * bits) >> 3;
33d078b4:	e1a091cc 	asr	r9, ip, #3
{
	int res, i, j, act = 0;
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
33d078b8:	e58d3014 	str	r3, [sp, #20]

	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;
33d078bc:	eb005b59 	bl	33d1e628 <__ashldi3>
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
			}
		}
		totlen -= len;
		from += len;
33d078c0:	e3590000 	cmp	r9, #0	; 0x0
	size_t retlen, len, totlen;
	loff_t from;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);

	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;
33d078c4:	e1a0b001 	mov	fp, r1
33d078c8:	e1a0a000 	mov	sl, r0
 *
 */
static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
	int bits, int offs, int reserved_block_code)
{
	int res, i, j, act = 0;
33d078cc:	e3a07000 	mov	r7, #0	; 0x0
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
			}
		}
		totlen -= len;
		from += len;
33d078d0:	0a000065 	beq	33d07a6c <read_bbt+0x1f0>
	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;

	while (totlen) {
		len = min (totlen, (size_t) (1 << this->bbt_erase_shift));
		res = mtd->read_ecc (mtd, from, len, &retlen, buf, NULL, this->autooob);
33d078d4:	e59d1020 	ldr	r1, [sp, #32]
33d078d8:	e28d3028 	add	r3, sp, #40	; 0x28

	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;

	while (totlen) {
		len = min (totlen, (size_t) (1 << this->bbt_erase_shift));
33d078dc:	e5962070 	ldr	r2, [r6, #112]
		res = mtd->read_ecc (mtd, from, len, &retlen, buf, NULL, this->autooob);
33d078e0:	e58d3000 	str	r3, [sp]
33d078e4:	e3a03000 	mov	r3, #0	; 0x0
33d078e8:	e98d000a 	stmib	sp, {r1, r3}

	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;

	while (totlen) {
		len = min (totlen, (size_t) (1 << this->bbt_erase_shift));
33d078ec:	e2833001 	add	r3, r3, #1	; 0x1
33d078f0:	e1a03213 	lsl	r3, r3, r2
		res = mtd->read_ecc (mtd, from, len, &retlen, buf, NULL, this->autooob);
33d078f4:	e59620a0 	ldr	r2, [r6, #160]

	totlen = (num * bits) >> 3;
	from = ((loff_t)page) << this->page_shift;

	while (totlen) {
		len = min (totlen, (size_t) (1 << this->bbt_erase_shift));
33d078f8:	e1530009 	cmp	r3, r9
33d078fc:	31a05003 	movcc	r5, r3
33d07900:	21a05009 	movcs	r5, r9
		res = mtd->read_ecc (mtd, from, len, &retlen, buf, NULL, this->autooob);
33d07904:	e58d200c 	str	r2, [sp, #12]
33d07908:	e59d0024 	ldr	r0, [sp, #36]
33d0790c:	e1a0200b 	mov	r2, fp
33d07910:	e1a0100a 	mov	r1, sl
33d07914:	e1a03005 	mov	r3, r5
33d07918:	e1a0e00f 	mov	lr, pc
33d0791c:	e590f114 	ldr	pc, [r0, #276]
		if (res < 0) {
33d07920:	e2504000 	subs	r4, r0, #0	; 0x0
33d07924:	aa000008 	bge	33d0794c <read_bbt+0xd0>
			if (retlen != len) {
33d07928:	e59d3028 	ldr	r3, [sp, #40]
33d0792c:	e1530005 	cmp	r3, r5
33d07930:	0a000003 	beq	33d07944 <read_bbt+0xc8>
				printk (KERN_INFO "nand_bbt: Error reading bad block table\n");
33d07934:	e59f013c 	ldr	r0, [pc, #316]	; 33d07a78 <read_bbt+0x1fc>
33d07938:	eb003da2 	bl	33d16fc8 <printf>
				return res;
33d0793c:	e1a00004 	mov	r0, r4
33d07940:	ea00004a 	b	33d07a70 <read_bbt+0x1f4>
			}
			printk (KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
33d07944:	e59f0130 	ldr	r0, [pc, #304]	; 33d07a7c <read_bbt+0x200>
33d07948:	eb003d9e 	bl	33d16fc8 <printf>
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
33d0794c:	e3a02000 	mov	r2, #0	; 0x0
33d07950:	e1520005 	cmp	r2, r5
33d07954:	e58d201c 	str	r2, [sp, #28]
33d07958:	2a00003f 	bcs	33d07a5c <read_bbt+0x1e0>
			uint8_t dat = buf[i];
33d0795c:	e59dc01c 	ldr	ip, [sp, #28]
33d07960:	e59d3020 	ldr	r3, [sp, #32]
33d07964:	e7d3300c 	ldrb	r3, [r3, ip]
			for (j = 0; j < 8; j += bits, act += 2) {
33d07968:	e3a0c000 	mov	ip, #0	; 0x0
			printk (KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
33d0796c:	e58d3010 	str	r3, [sp, #16]
			for (j = 0; j < 8; j += bits, act += 2) {
33d07970:	e58dc018 	str	ip, [sp, #24]
				uint8_t tmp = (dat >> j) & msk;
33d07974:	e59d0014 	ldr	r0, [sp, #20]
33d07978:	e59d1010 	ldr	r1, [sp, #16]
33d0797c:	e59d2018 	ldr	r2, [sp, #24]
33d07980:	e0004251 	and	r4, r0, r1, asr r2
				if (tmp == msk)
33d07984:	e1540000 	cmp	r4, r0
33d07988:	0a000029 	beq	33d07a34 <read_bbt+0x1b8>
					continue;
				if (reserved_block_code &&
33d0798c:	e59d1054 	ldr	r1, [sp, #84]
					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
					continue;
				}
				/* Leave it for now, if its matured we can move this
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
33d07990:	e59dc050 	ldr	ip, [sp, #80]
33d07994:	e1a030c7 	asr	r3, r7, #1
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code &&
33d07998:	e3510000 	cmp	r1, #0	; 0x0
					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
					continue;
				}
				/* Leave it for now, if its matured we can move this
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
33d0799c:	e083210c 	add	r2, r3, ip, lsl #2
33d079a0:	e59f00d8 	ldr	r0, [pc, #216]	; 33d07a80 <read_bbt+0x204>
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code &&
33d079a4:	0a000010 	beq	33d079ec <read_bbt+0x170>
33d079a8:	e1540001 	cmp	r4, r1
				    (tmp == reserved_block_code)) {
					printk (KERN_DEBUG "nand_read_bbt: Reserved block at 0x%08x\n",
33d079ac:	e083310c 	add	r3, r3, ip, lsl #2
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code &&
33d079b0:	1a00000d 	bne	33d079ec <read_bbt+0x170>
				    (tmp == reserved_block_code)) {
					printk (KERN_DEBUG "nand_read_bbt: Reserved block at 0x%08x\n",
33d079b4:	e5961070 	ldr	r1, [r6, #112]
33d079b8:	e59f00c4 	ldr	r0, [pc, #196]	; 33d07a84 <read_bbt+0x208>
33d079bc:	e1a01113 	lsl	r1, r3, r1
33d079c0:	eb003d80 	bl	33d16fc8 <printf>
						((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
33d079c4:	e59d2050 	ldr	r2, [sp, #80]
33d079c8:	e59610a4 	ldr	r1, [r6, #164]
33d079cc:	e1a0c1c7 	asr	ip, r7, #3
33d079d0:	e0821001 	add	r1, r2, r1
33d079d4:	e7d1300c 	ldrb	r3, [r1, ip]
33d079d8:	e2070006 	and	r0, r7, #6	; 0x6
33d079dc:	e3a02002 	mov	r2, #2	; 0x2
33d079e0:	e1833012 	orr	r3, r3, r2, lsl r0
33d079e4:	e7c1300c 	strb	r3, [r1, ip]
					continue;
33d079e8:	ea000011 	b	33d07a34 <read_bbt+0x1b8>
				}
				/* Leave it for now, if its matured we can move this
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
33d079ec:	e5961070 	ldr	r1, [r6, #112]
33d079f0:	e1a01112 	lsl	r1, r2, r1
33d079f4:	eb003d73 	bl	33d16fc8 <printf>
33d079f8:	e59630a4 	ldr	r3, [r6, #164]
					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
33d079fc:	e59dc050 	ldr	ip, [sp, #80]
				/* Leave it for now, if its matured we can move this
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
33d07a00:	e3540000 	cmp	r4, #0	; 0x0
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
33d07a04:	e08ce003 	add	lr, ip, r3
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
33d07a08:	e08c0003 	add	r0, ip, r3
33d07a0c:	e1a011c7 	asr	r1, r7, #3
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
33d07a10:	07de3001 	ldrbeq	r3, [lr, r1]
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
33d07a14:	17d03001 	ldrbne	r3, [r0, r1]
33d07a18:	e207c006 	and	ip, r7, #6	; 0x6
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
33d07a1c:	03a02003 	moveq	r2, #3	; 0x3
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
33d07a20:	13a02001 	movne	r2, #1	; 0x1
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
33d07a24:	01833c12 	orreq	r3, r3, r2, lsl ip
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
33d07a28:	11833c12 	orrne	r3, r3, r2, lsl ip
				 * message to MTD_DEBUG_LEVEL0 */
				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
33d07a2c:	07ce3001 	strbeq	r3, [lr, r1]
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
33d07a30:	17c03001 	strbne	r3, [r0, r1]
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
33d07a34:	e59d0018 	ldr	r0, [sp, #24]
33d07a38:	e59d104c 	ldr	r1, [sp, #76]
33d07a3c:	e0800001 	add	r0, r0, r1
33d07a40:	e3500007 	cmp	r0, #7	; 0x7
33d07a44:	e58d0018 	str	r0, [sp, #24]
33d07a48:	e2877002 	add	r7, r7, #2	; 0x2
33d07a4c:	daffffc8 	ble	33d07974 <read_bbt+0xf8>
			}
			printk (KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
33d07a50:	e59d201c 	ldr	r2, [sp, #28]
33d07a54:	e2822001 	add	r2, r2, #1	; 0x1
33d07a58:	eaffffbc 	b	33d07950 <read_bbt+0xd4>
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
			}
		}
		totlen -= len;
		from += len;
33d07a5c:	e09aa005 	adds	sl, sl, r5
33d07a60:	e2abb000 	adc	fp, fp, #0	; 0x0
33d07a64:	e0599005 	subs	r9, r9, r5
33d07a68:	1affff99 	bne	33d078d4 <read_bbt+0x58>
	}
	return 0;
33d07a6c:	e3a00000 	mov	r0, #0	; 0x0
}
33d07a70:	e28dd02c 	add	sp, sp, #44	; 0x2c
33d07a74:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d07a78:	33d26410 	.word	0x33d26410
33d07a7c:	33d2643c 	.word	0x33d2643c
33d07a80:	33d26470 	.word	0x33d26470
33d07a84:	33d26494 	.word	0x33d26494

33d07a88 <read_abs_bbt>:
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
33d07a88:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d07a8c:	e1a06002 	mov	r6, r2
33d07a90:	e24dd014 	sub	sp, sp, #20	; 0x14
	struct nand_chip *this = mtd->priv;
	int res = 0, i;
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
33d07a94:	e5922000 	ldr	r2, [r2]
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
33d07a98:	e58d1010 	str	r1, [sp, #16]
	struct nand_chip *this = mtd->priv;
	int res = 0, i;
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
33d07a9c:	e3120080 	tst	r2, #128	; 0x80
{
	struct nand_chip *this = mtd->priv;
	int res = 0, i;
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
33d07aa0:	e202200f 	and	r2, r2, #15	; 0xf
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
	struct nand_chip *this = mtd->priv;
33d07aa4:	e590413c 	ldr	r4, [r0, #316]
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
33d07aa8:	e1a0a000 	mov	sl, r0
33d07aac:	e1a0b003 	mov	fp, r3
	struct nand_chip *this = mtd->priv;
	int res = 0, i;
33d07ab0:	e3a05000 	mov	r5, #0	; 0x0
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
33d07ab4:	e58d200c 	str	r2, [sp, #12]
	if (td->options & NAND_BBT_PERCHIP) {
33d07ab8:	0a00001d 	beq	33d07b34 <read_abs_bbt+0xac>
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
33d07abc:	e5943090 	ldr	r3, [r4, #144]
	int res = 0, i;
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
33d07ac0:	e1a09005 	mov	r9, r5
		for (i = 0; i < this->numchips; i++) {
33d07ac4:	e1550003 	cmp	r5, r3
33d07ac8:	e1a07005 	mov	r7, r5
33d07acc:	aa000026 	bge	33d07b6c <read_abs_bbt+0xe4>
			if (chip == -1 || chip == i)
33d07ad0:	e37b0001 	cmn	fp, #1	; 0x1
33d07ad4:	115b0007 	cmpne	fp, r7
				res = read_bbt (mtd, buf, td->pages[i], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
33d07ad8:	e0863107 	add	r3, r6, r7, lsl #2
33d07adc:	e1a0000a 	mov	r0, sl
33d07ae0:	e59d1010 	ldr	r1, [sp, #16]
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
33d07ae4:	e2877001 	add	r7, r7, #1	; 0x1
			if (chip == -1 || chip == i)
33d07ae8:	1a00000a 	bne	33d07b18 <read_abs_bbt+0x90>
				res = read_bbt (mtd, buf, td->pages[i], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
33d07aec:	e594c094 	ldr	ip, [r4, #148]
33d07af0:	e5932004 	ldr	r2, [r3, #4]
33d07af4:	e5943070 	ldr	r3, [r4, #112]
33d07af8:	e596e01c 	ldr	lr, [r6, #28]
33d07afc:	e1a0333c 	lsr	r3, ip, r3
33d07b00:	e59dc00c 	ldr	ip, [sp, #12]
33d07b04:	e98d4200 	stmib	sp, {r9, lr}
33d07b08:	e58dc000 	str	ip, [sp]
33d07b0c:	ebffff5a 	bl	33d0787c <read_bbt>
			if (res)
33d07b10:	e2505000 	subs	r5, r0, #0	; 0x0
33d07b14:	1a000012 	bne	33d07b64 <read_abs_bbt+0xdc>
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
33d07b18:	e5943070 	ldr	r3, [r4, #112]
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
33d07b1c:	e5942090 	ldr	r2, [r4, #144]
			if (chip == -1 || chip == i)
				res = read_bbt (mtd, buf, td->pages[i], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
			if (res)
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
33d07b20:	e5941094 	ldr	r1, [r4, #148]
33d07b24:	e2833002 	add	r3, r3, #2	; 0x2
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
33d07b28:	e1570002 	cmp	r7, r2
			if (chip == -1 || chip == i)
				res = read_bbt (mtd, buf, td->pages[i], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
			if (res)
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
33d07b2c:	e0899331 	add	r9, r9, r1, lsr r3
33d07b30:	eaffffe5 	b	33d07acc <read_abs_bbt+0x44>
		}
	} else {
		res = read_bbt (mtd, buf, td->pages[0], mtd->size >> this->bbt_erase_shift, bits, 0, td->reserved_block_code);
33d07b34:	e594c070 	ldr	ip, [r4, #112]
33d07b38:	e5903008 	ldr	r3, [r0, #8]
33d07b3c:	e596e01c 	ldr	lr, [r6, #28]
33d07b40:	e1a03c33 	lsr	r3, r3, ip
33d07b44:	e59dc00c 	ldr	ip, [sp, #12]
33d07b48:	e5962004 	ldr	r2, [r6, #4]
33d07b4c:	e58d5004 	str	r5, [sp, #4]
33d07b50:	e58dc000 	str	ip, [sp]
33d07b54:	e58de008 	str	lr, [sp, #8]
33d07b58:	ebffff47 	bl	33d0787c <read_bbt>
		if (res)
33d07b5c:	e2505000 	subs	r5, r0, #0	; 0x0
33d07b60:	0a000001 	beq	33d07b6c <read_abs_bbt+0xe4>
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
			if (chip == -1 || chip == i)
				res = read_bbt (mtd, buf, td->pages[i], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
			if (res)
				return res;
33d07b64:	e1a00005 	mov	r0, r5
33d07b68:	ea000000 	b	33d07b70 <read_abs_bbt+0xe8>
	} else {
		res = read_bbt (mtd, buf, td->pages[0], mtd->size >> this->bbt_erase_shift, bits, 0, td->reserved_block_code);
		if (res)
			return res;
	}
	return 0;
33d07b6c:	e3a00000 	mov	r0, #0	; 0x0
}
33d07b70:	e28dd014 	add	sp, sp, #20	; 0x14
33d07b74:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d07b78 <create_bbt>:
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
{
33d07b78:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d07b7c:	e24dd024 	sub	sp, sp, #36	; 0x24
33d07b80:	e58d201c 	str	r2, [sp, #28]
	int i, j, numblocks, len, scanlen;
	int startblock;
	loff_t from;
	size_t readlen, ooblen;

	if (bd->options & NAND_BBT_SCANALLPAGES)
33d07b84:	e5922000 	ldr	r2, [r2]
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
{
33d07b88:	e58d1020 	str	r1, [sp, #32]
	int i, j, numblocks, len, scanlen;
	int startblock;
	loff_t from;
	size_t readlen, ooblen;

	if (bd->options & NAND_BBT_SCANALLPAGES)
33d07b8c:	e3120b01 	tst	r2, #1024	; 0x400
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
{
33d07b90:	e1a09000 	mov	r9, r0
33d07b94:	e1a01003 	mov	r1, r3
	struct nand_chip *this = mtd->priv;
33d07b98:	e590513c 	ldr	r5, [r0, #316]
	int i, j, numblocks, len, scanlen;
	int startblock;
	loff_t from;
	size_t readlen, ooblen;

	if (bd->options & NAND_BBT_SCANALLPAGES)
33d07b9c:	0a000005 	beq	33d07bb8 <create_bbt+0x40>
		len = 1 << (this->bbt_erase_shift - this->page_shift);
33d07ba0:	e5952068 	ldr	r2, [r5, #104]
33d07ba4:	e5953070 	ldr	r3, [r5, #112]
33d07ba8:	e0623003 	rsb	r3, r2, r3
33d07bac:	e3a02001 	mov	r2, #1	; 0x1
33d07bb0:	e1a0b312 	lsl	fp, r2, r3
33d07bb4:	ea000002 	b	33d07bc4 <create_bbt+0x4c>
	else {
		if (bd->options & NAND_BBT_SCAN2NDPAGE)
33d07bb8:	e3120901 	tst	r2, #16384	; 0x4000
			len = 2;
33d07bbc:	03a0b001 	moveq	fp, #1	; 0x1
33d07bc0:	13a0b002 	movne	fp, #2	; 0x2
		else
			len = 1;
	}
	scanlen	= mtd->oobblock + mtd->oobsize;
33d07bc4:	e2892010 	add	r2, r9, #16	; 0x10
33d07bc8:	e892000c 	ldm	r2, {r2, r3}
	readlen = len * mtd->oobblock;
33d07bcc:	e0000b92 	mul	r0, r2, fp
	ooblen = len * mtd->oobsize;
33d07bd0:	e0040b93 	mul	r4, r3, fp
		if (bd->options & NAND_BBT_SCAN2NDPAGE)
			len = 2;
		else
			len = 1;
	}
	scanlen	= mtd->oobblock + mtd->oobsize;
33d07bd4:	e0822003 	add	r2, r2, r3
	readlen = len * mtd->oobblock;
	ooblen = len * mtd->oobsize;

	if (chip == -1) {
33d07bd8:	e3710001 	cmn	r1, #1	; 0x1
			len = 2;
		else
			len = 1;
	}
	scanlen	= mtd->oobblock + mtd->oobsize;
	readlen = len * mtd->oobblock;
33d07bdc:	e58d000c 	str	r0, [sp, #12]
	ooblen = len * mtd->oobsize;
33d07be0:	e58d4008 	str	r4, [sp, #8]
		if (bd->options & NAND_BBT_SCAN2NDPAGE)
			len = 2;
		else
			len = 1;
	}
	scanlen	= mtd->oobblock + mtd->oobsize;
33d07be4:	e58d2018 	str	r2, [sp, #24]
	readlen = len * mtd->oobblock;
	ooblen = len * mtd->oobsize;

	if (chip == -1) {
33d07be8:	1a000009 	bne	33d07c14 <create_bbt+0x9c>
		/* Note that numblocks is 2 * (real numblocks) here, see i+=2 below as it
		 * makes shifting and masking less painful */
		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
33d07bec:	e5953070 	ldr	r3, [r5, #112]
33d07bf0:	e5992008 	ldr	r2, [r9, #8]
33d07bf4:	e2433001 	sub	r3, r3, #1	; 0x1
33d07bf8:	e1a07332 	lsr	r7, r2, r3
		startblock = 0;
33d07bfc:	e3a00000 	mov	r0, #0	; 0x0
		from = 0;
33d07c00:	e3a02000 	mov	r2, #0	; 0x0
33d07c04:	e3a01000 	mov	r1, #0	; 0x0
33d07c08:	e28d3010 	add	r3, sp, #16	; 0x10
33d07c0c:	e8830006 	stm	r3, {r1, r2}
33d07c10:	ea000012 	b	33d07c60 <create_bbt+0xe8>
	} else {
		if (chip >= this->numchips) {
33d07c14:	e5952090 	ldr	r2, [r5, #144]
33d07c18:	e1510002 	cmp	r1, r2
33d07c1c:	ba000004 	blt	33d07c34 <create_bbt+0xbc>
			printk (KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
33d07c20:	e59f00f8 	ldr	r0, [pc, #248]	; 33d07d20 <create_bbt+0x1a8>
33d07c24:	e2811001 	add	r1, r1, #1	; 0x1
			}
		}
		i += 2;
		from += (1 << this->bbt_erase_shift);
	}
}
33d07c28:	e28dd024 	add	sp, sp, #36	; 0x24
33d07c2c:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
		startblock = 0;
		from = 0;
	} else {
		if (chip >= this->numchips) {
			printk (KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
33d07c30:	ea003ce4 	b	33d16fc8 <printf>
				chip + 1, this->numchips);
			return;
		}
		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
33d07c34:	e5953070 	ldr	r3, [r5, #112]
33d07c38:	e5952094 	ldr	r2, [r5, #148]
33d07c3c:	e2433001 	sub	r3, r3, #1	; 0x1
33d07c40:	e1a07332 	lsr	r7, r2, r3
		startblock = chip * numblocks;
33d07c44:	e0000197 	mul	r0, r7, r1
		numblocks += startblock;
		from = startblock << (this->bbt_erase_shift - 1);
33d07c48:	e1a03310 	lsl	r3, r0, r3
33d07c4c:	e1a01003 	mov	r1, r3
33d07c50:	e1a02fc1 	asr	r2, r1, #31
33d07c54:	e28d4010 	add	r4, sp, #16	; 0x10
33d07c58:	e8840006 	stm	r4, {r1, r2}
				chip + 1, this->numchips);
			return;
		}
		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
		startblock = chip * numblocks;
		numblocks += startblock;
33d07c5c:	e0877000 	add	r7, r7, r0
		from = startblock << (this->bbt_erase_shift - 1);
	}

	for (i = startblock; i < numblocks;) {
33d07c60:	e1a06000 	mov	r6, r0
33d07c64:	e1560007 	cmp	r6, r7
33d07c68:	aa00002a 	bge	33d07d18 <create_bbt+0x1a0>
		nand_read_raw (mtd, buf, from, readlen, ooblen);
33d07c6c:	e28dc010 	add	ip, sp, #16	; 0x10
33d07c70:	e89c000c 	ldm	ip, {r2, r3}
33d07c74:	e59d400c 	ldr	r4, [sp, #12]
33d07c78:	e59dc008 	ldr	ip, [sp, #8]
33d07c7c:	e1a00009 	mov	r0, r9
33d07c80:	e59d1020 	ldr	r1, [sp, #32]
		for (j = 0; j < len; j++) {
33d07c84:	e3a0a000 	mov	sl, #0	; 0x0
		numblocks += startblock;
		from = startblock << (this->bbt_erase_shift - 1);
	}

	for (i = startblock; i < numblocks;) {
		nand_read_raw (mtd, buf, from, readlen, ooblen);
33d07c88:	e88d1010 	stm	sp, {r4, ip}
33d07c8c:	ebfff7d3 	bl	33d05be0 <nand_read_raw>
		for (j = 0; j < len; j++) {
33d07c90:	e15a000b 	cmp	sl, fp
33d07c94:	aa000014 	bge	33d07cec <create_bbt+0x174>
33d07c98:	e59d4020 	ldr	r4, [sp, #32]
			if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
33d07c9c:	e1a00004 	mov	r0, r4
33d07ca0:	e59d1018 	ldr	r1, [sp, #24]
33d07ca4:	e5992010 	ldr	r2, [r9, #16]
33d07ca8:	e59d301c 	ldr	r3, [sp, #28]
33d07cac:	ebfffec5 	bl	33d077c8 <check_pattern>
33d07cb0:	e3500000 	cmp	r0, #0	; 0x0
33d07cb4:	e59d0018 	ldr	r0, [sp, #24]
		from = startblock << (this->bbt_erase_shift - 1);
	}

	for (i = startblock; i < numblocks;) {
		nand_read_raw (mtd, buf, from, readlen, ooblen);
		for (j = 0; j < len; j++) {
33d07cb8:	e28aa001 	add	sl, sl, #1	; 0x1
33d07cbc:	e0844000 	add	r4, r4, r0
			if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
33d07cc0:	0a000007 	beq	33d07ce4 <create_bbt+0x16c>
				this->bbt[i >> 3] |= 0x03 << (i & 0x6);
33d07cc4:	e595c0a4 	ldr	ip, [r5, #164]
33d07cc8:	e1a001c6 	asr	r0, r6, #3
33d07ccc:	e7dc3000 	ldrb	r3, [ip, r0]
33d07cd0:	e2061006 	and	r1, r6, #6	; 0x6
33d07cd4:	e3a02003 	mov	r2, #3	; 0x3
33d07cd8:	e1833112 	orr	r3, r3, r2, lsl r1
33d07cdc:	e7cc3000 	strb	r3, [ip, r0]
				break;
33d07ce0:	ea000001 	b	33d07cec <create_bbt+0x174>
		from = startblock << (this->bbt_erase_shift - 1);
	}

	for (i = startblock; i < numblocks;) {
		nand_read_raw (mtd, buf, from, readlen, ooblen);
		for (j = 0; j < len; j++) {
33d07ce4:	e15a000b 	cmp	sl, fp
33d07ce8:	baffffeb 	blt	33d07c9c <create_bbt+0x124>
				this->bbt[i >> 3] |= 0x03 << (i & 0x6);
				break;
			}
		}
		i += 2;
		from += (1 << this->bbt_erase_shift);
33d07cec:	e5952070 	ldr	r2, [r5, #112]
33d07cf0:	e3a03001 	mov	r3, #1	; 0x1
33d07cf4:	e1a00213 	lsl	r0, r3, r2
33d07cf8:	e28d3010 	add	r3, sp, #16	; 0x10
33d07cfc:	e8930018 	ldm	r3, {r3, r4}
33d07d00:	e0931000 	adds	r1, r3, r0
33d07d04:	e0a42fc0 	adc	r2, r4, r0, asr #31
			if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
				this->bbt[i >> 3] |= 0x03 << (i & 0x6);
				break;
			}
		}
		i += 2;
33d07d08:	e2866002 	add	r6, r6, #2	; 0x2
		from += (1 << this->bbt_erase_shift);
33d07d0c:	e28d4010 	add	r4, sp, #16	; 0x10
33d07d10:	e8840006 	stm	r4, {r1, r2}
33d07d14:	eaffffd2 	b	33d07c64 <create_bbt+0xec>
	}
}
33d07d18:	e28dd024 	add	sp, sp, #36	; 0x24
33d07d1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d07d20:	33d264c0 	.word	0x33d264c0

33d07d24 <search_bbt>:
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
33d07d24:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d07d28:	e24dd020 	sub	sp, sp, #32	; 0x20
	int bits, startblock, block, dir;
	int scanlen = mtd->oobblock + mtd->oobsize;
	int bbtblocks;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
33d07d2c:	e592c000 	ldr	ip, [r2]
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
33d07d30:	e58d101c 	str	r1, [sp, #28]
33d07d34:	e1a06002 	mov	r6, r2
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int bits, startblock, block, dir;
	int scanlen = mtd->oobblock + mtd->oobsize;
33d07d38:	e2802010 	add	r2, r0, #16	; 0x10
33d07d3c:	e8920006 	ldm	r2, {r1, r2}
33d07d40:	e0811002 	add	r1, r1, r2
33d07d44:	e58d1010 	str	r1, [sp, #16]
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
	struct nand_chip *this = mtd->priv;
33d07d48:	e590413c 	ldr	r4, [r0, #316]
	int bits, startblock, block, dir;
	int scanlen = mtd->oobblock + mtd->oobsize;
	int bbtblocks;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
33d07d4c:	e21c3010 	ands	r3, ip, #16	; 0x10
		startblock = (mtd->size >> this->bbt_erase_shift) -1;
33d07d50:	15903008 	ldrne	r3, [r0, #8]
33d07d54:	15942070 	ldrne	r2, [r4, #112]
33d07d58:	11a03233 	lsrne	r3, r3, r2
33d07d5c:	12439001 	subne	r9, r3, #1	; 0x1
		dir = -1;
	} else {
		startblock = 0;
		dir = 1;
33d07d60:	03a01001 	moveq	r1, #1	; 0x1
	int bbtblocks;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = (mtd->size >> this->bbt_erase_shift) -1;
		dir = -1;
33d07d64:	13e03000 	mvnne	r3, #0	; 0x0
33d07d68:	158d3014 	strne	r3, [sp, #20]
	} else {
		startblock = 0;
		dir = 1;
33d07d6c:	058d1014 	streq	r1, [sp, #20]
	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = (mtd->size >> this->bbt_erase_shift) -1;
		dir = -1;
	} else {
		startblock = 0;
33d07d70:	01a09003 	moveq	r9, r3
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d07d74:	e31c0080 	tst	ip, #128	; 0x80
		chips = this->numchips;
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
33d07d78:	15943094 	ldrne	r3, [r4, #148]
33d07d7c:	e5942070 	ldr	r2, [r4, #112]
33d07d80:	11a03233 	lsrne	r3, r3, r2
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
33d07d84:	15942090 	ldrne	r2, [r4, #144]
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
	} else {
		chips = 1;
33d07d88:	03a03001 	moveq	r3, #1	; 0x1
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
33d07d8c:	158d2018 	strne	r2, [sp, #24]
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
	} else {
		chips = 1;
33d07d90:	058d3018 	streq	r3, [sp, #24]
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07d94:	e59d1018 	ldr	r1, [sp, #24]

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
33d07d98:	12433001 	subne	r3, r3, #1	; 0x1
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07d9c:	e3a0a000 	mov	sl, #0	; 0x0

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
33d07da0:	10099003 	andne	r9, r9, r3
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07da4:	e15a0001 	cmp	sl, r1
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
33d07da8:	e1a05000 	mov	r5, r0
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07dac:	aa000051 	bge	33d07ef8 <search_bbt+0x1d4>
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
33d07db0:	e5963018 	ldr	r3, [r6, #24]
	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
33d07db4:	e3a01000 	mov	r1, #0	; 0x0
		td->pages[i] = -1;
33d07db8:	e1a0210a 	lsl	r2, sl, #2
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
33d07dbc:	e1510003 	cmp	r1, r3
	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
33d07dc0:	e08a3006 	add	r3, sl, r6
33d07dc4:	e58d300c 	str	r3, [sp, #12]
		td->pages[i] = -1;
33d07dc8:	e58d2008 	str	r2, [sp, #8]
33d07dcc:	e3e03000 	mvn	r3, #0	; 0x0
33d07dd0:	e0822006 	add	r2, r2, r6
33d07dd4:	e5823004 	str	r3, [r2, #4]
	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
33d07dd8:	e59d200c 	ldr	r2, [sp, #12]
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
33d07ddc:	e1a0b001 	mov	fp, r1
	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
33d07de0:	e5c21010 	strb	r1, [r2, #16]
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
33d07de4:	aa000028 	bge	33d07e8c <search_bbt+0x168>
33d07de8:	e1a07009 	mov	r7, r9
			int actblock = startblock + dir * block;
			/* Read first page */
			nand_read_raw (mtd, buf, actblock << this->bbt_erase_shift, mtd->oobblock, mtd->oobsize);
33d07dec:	e5942070 	ldr	r2, [r4, #112]
33d07df0:	e285c010 	add	ip, r5, #16	; 0x10
33d07df4:	e89c5000 	ldm	ip, {ip, lr}
33d07df8:	e1a02217 	lsl	r2, r7, r2
33d07dfc:	e1a03fc2 	asr	r3, r2, #31
33d07e00:	e59d101c 	ldr	r1, [sp, #28]
33d07e04:	e1a00005 	mov	r0, r5
33d07e08:	e88d5000 	stm	sp, {ip, lr}
33d07e0c:	ebfff773 	bl	33d05be0 <nand_read_raw>
			if (!check_pattern(buf, scanlen, mtd->oobblock, td)) {
33d07e10:	e59d001c 	ldr	r0, [sp, #28]
33d07e14:	e59d1010 	ldr	r1, [sp, #16]
33d07e18:	e5952010 	ldr	r2, [r5, #16]
33d07e1c:	e1a03006 	mov	r3, r6
33d07e20:	ebfffe68 	bl	33d077c8 <check_pattern>
33d07e24:	e3500000 	cmp	r0, #0	; 0x0
	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
33d07e28:	e28bb001 	add	fp, fp, #1	; 0x1
			int actblock = startblock + dir * block;
			/* Read first page */
			nand_read_raw (mtd, buf, actblock << this->bbt_erase_shift, mtd->oobblock, mtd->oobsize);
			if (!check_pattern(buf, scanlen, mtd->oobblock, td)) {
33d07e2c:	1a000011 	bne	33d07e78 <search_bbt+0x154>
				td->pages[i] = actblock << (this->bbt_erase_shift - this->page_shift);
				if (td->options & NAND_BBT_VERSION) {
33d07e30:	e5961000 	ldr	r1, [r6]
		for (block = 0; block < td->maxblocks; block++) {
			int actblock = startblock + dir * block;
			/* Read first page */
			nand_read_raw (mtd, buf, actblock << this->bbt_erase_shift, mtd->oobblock, mtd->oobsize);
			if (!check_pattern(buf, scanlen, mtd->oobblock, td)) {
				td->pages[i] = actblock << (this->bbt_erase_shift - this->page_shift);
33d07e34:	e5943068 	ldr	r3, [r4, #104]
33d07e38:	e5942070 	ldr	r2, [r4, #112]
				if (td->options & NAND_BBT_VERSION) {
33d07e3c:	e3110c01 	tst	r1, #256	; 0x100
		for (block = 0; block < td->maxblocks; block++) {
			int actblock = startblock + dir * block;
			/* Read first page */
			nand_read_raw (mtd, buf, actblock << this->bbt_erase_shift, mtd->oobblock, mtd->oobsize);
			if (!check_pattern(buf, scanlen, mtd->oobblock, td)) {
				td->pages[i] = actblock << (this->bbt_erase_shift - this->page_shift);
33d07e40:	e59d1008 	ldr	r1, [sp, #8]
33d07e44:	e0632002 	rsb	r2, r3, r2
33d07e48:	e1a02217 	lsl	r2, r7, r2
33d07e4c:	e0813006 	add	r3, r1, r6
33d07e50:	e5832004 	str	r2, [r3, #4]
				if (td->options & NAND_BBT_VERSION) {
33d07e54:	0a00000c 	beq	33d07e8c <search_bbt+0x168>
					td->version[i] = buf[mtd->oobblock + td->veroffs];
33d07e58:	e5953010 	ldr	r3, [r5, #16]
33d07e5c:	e59d101c 	ldr	r1, [sp, #28]
33d07e60:	e596200c 	ldr	r2, [r6, #12]
33d07e64:	e0833001 	add	r3, r3, r1
33d07e68:	e7d33002 	ldrb	r3, [r3, r2]
33d07e6c:	e59d200c 	ldr	r2, [sp, #12]
33d07e70:	e5c23010 	strb	r3, [r2, #16]
				}
				break;
33d07e74:	ea000004 	b	33d07e8c <search_bbt+0x168>
	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
33d07e78:	e5963018 	ldr	r3, [r6, #24]
33d07e7c:	e15b0003 	cmp	fp, r3
33d07e80:	e59d3014 	ldr	r3, [sp, #20]
33d07e84:	e0877003 	add	r7, r7, r3
33d07e88:	baffffd7 	blt	33d07dec <search_bbt+0xc8>
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07e8c:	e59d1018 	ldr	r1, [sp, #24]
33d07e90:	e28aa001 	add	sl, sl, #1	; 0x1
					td->version[i] = buf[mtd->oobblock + td->veroffs];
				}
				break;
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
33d07e94:	e5942094 	ldr	r2, [r4, #148]
33d07e98:	e5943070 	ldr	r3, [r4, #112]
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07e9c:	e15a0001 	cmp	sl, r1
					td->version[i] = buf[mtd->oobblock + td->veroffs];
				}
				break;
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
33d07ea0:	e0899332 	add	r9, r9, r2, lsr r3
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
33d07ea4:	baffffc1 	blt	33d07db0 <search_bbt+0x8c>
33d07ea8:	e3a0a000 	mov	sl, #0	; 0x0
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
	}
	/* Check, if we found a bbt for each requested chip */
	for (i = 0; i < chips; i++) {
33d07eac:	e15a0001 	cmp	sl, r1
33d07eb0:	aa000010 	bge	33d07ef8 <search_bbt+0x1d4>
		if (td->pages[i] == -1)
33d07eb4:	e086310a 	add	r3, r6, sl, lsl #2
33d07eb8:	e5933004 	ldr	r3, [r3, #4]
33d07ebc:	e3730001 	cmn	r3, #1	; 0x1
			printk (KERN_WARNING "Bad block table not found for chip %d\n", i);
33d07ec0:	e59f003c 	ldr	r0, [pc, #60]	; 33d07f04 <search_bbt+0x1e0>
33d07ec4:	e1a0100a 	mov	r1, sl
		else
			printk (KERN_DEBUG "Bad block table found at page %d, version 0x%02X\n", td->pages[i], td->version[i]);
33d07ec8:	e08a2006 	add	r2, sl, r6
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
	}
	/* Check, if we found a bbt for each requested chip */
	for (i = 0; i < chips; i++) {
		if (td->pages[i] == -1)
33d07ecc:	1a000001 	bne	33d07ed8 <search_bbt+0x1b4>
			printk (KERN_WARNING "Bad block table not found for chip %d\n", i);
33d07ed0:	eb003c3c 	bl	33d16fc8 <printf>
33d07ed4:	ea000003 	b	33d07ee8 <search_bbt+0x1c4>
		else
			printk (KERN_DEBUG "Bad block table found at page %d, version 0x%02X\n", td->pages[i], td->version[i]);
33d07ed8:	e1a01003 	mov	r1, r3
33d07edc:	e5d22010 	ldrb	r2, [r2, #16]
33d07ee0:	e59f0020 	ldr	r0, [pc, #32]	; 33d07f08 <search_bbt+0x1e4>
33d07ee4:	eb003c37 	bl	33d16fc8 <printf>
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
	}
	/* Check, if we found a bbt for each requested chip */
	for (i = 0; i < chips; i++) {
33d07ee8:	e59d2018 	ldr	r2, [sp, #24]
33d07eec:	e28aa001 	add	sl, sl, #1	; 0x1
33d07ef0:	e15a0002 	cmp	sl, r2
33d07ef4:	eaffffed 	b	33d07eb0 <search_bbt+0x18c>
			printk (KERN_WARNING "Bad block table not found for chip %d\n", i);
		else
			printk (KERN_DEBUG "Bad block table found at page %d, version 0x%02X\n", td->pages[i], td->version[i]);
	}
	return 0;
}
33d07ef8:	e3a00000 	mov	r0, #0	; 0x0
33d07efc:	e28dd020 	add	sp, sp, #32	; 0x20
33d07f00:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d07f04:	33d264f4 	.word	0x33d264f4
33d07f08:	33d2651c 	.word	0x33d2651c

33d07f0c <write_bbt>:
 * (Re)write the bad block table
 *
*/
static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
33d07f0c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d07f10:	e24dde15 	sub	sp, sp, #336	; 0x150
33d07f14:	e58d004c 	str	r0, [sp, #76]
	struct erase_info einfo;
	int i, j, res, chip = 0;
	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
	int nrchips, bbtoffs, pageoffs;
	uint8_t msk[4];
	uint8_t rcode = td->reserved_block_code;
33d07f18:	e5d2001c 	ldrb	r0, [r2, #28]
 *
*/
static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
	struct nand_chip *this = mtd->priv;
33d07f1c:	e59dc04c 	ldr	ip, [sp, #76]
	uint8_t rcode = td->reserved_block_code;
	size_t retlen, len = 0;
	loff_t to;

	if (!rcode)
		rcode = 0xff;
33d07f20:	e3500000 	cmp	r0, #0	; 0x0
33d07f24:	03a000ff 	moveq	r0, #255	; 0xff
 *
*/
static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
	struct nand_chip *this = mtd->priv;
33d07f28:	e59c913c 	ldr	r9, [ip, #316]
 * (Re)write the bad block table
 *
*/
static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
33d07f2c:	e1a07002 	mov	r7, r2
	loff_t to;

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d07f30:	e5922000 	ldr	r2, [r2]
	uint8_t rcode = td->reserved_block_code;
	size_t retlen, len = 0;
	loff_t to;

	if (!rcode)
		rcode = 0xff;
33d07f34:	e58d0020 	str	r0, [sp, #32]
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
	struct nand_chip *this = mtd->priv;
	struct nand_oobinfo oobinfo;
	struct erase_info einfo;
	int i, j, res, chip = 0;
33d07f38:	e3a00000 	mov	r0, #0	; 0x0
 * (Re)write the bad block table
 *
*/
static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
33d07f3c:	e58d1048 	str	r1, [sp, #72]
33d07f40:	e58d3044 	str	r3, [sp, #68]
	struct nand_chip *this = mtd->priv;
	struct nand_oobinfo oobinfo;
	struct erase_info einfo;
	int i, j, res, chip = 0;
33d07f44:	e58d0040 	str	r0, [sp, #64]
	loff_t to;

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d07f48:	e3120080 	tst	r2, #128	; 0x80
 * (Re)write the bad block table
 *
*/
static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
{
33d07f4c:	e59d1170 	ldr	r1, [sp, #368]
33d07f50:	e5992070 	ldr	r2, [r9, #112]
	loff_t to;

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d07f54:	0a000012 	beq	33d07fa4 <write_bbt+0x98>
		numblocks = (int) (this->chipsize >> this->bbt_erase_shift);
33d07f58:	e5993094 	ldr	r3, [r9, #148]
33d07f5c:	e1a03233 	lsr	r3, r3, r2
33d07f60:	e58d3034 	str	r3, [sp, #52]
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
33d07f64:	e3710001 	cmn	r1, #1	; 0x1
			nrchips = this->numchips;
33d07f68:	05991090 	ldreq	r1, [r9, #144]
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
33d07f6c:	158d1040 	strne	r1, [sp, #64]
		numblocks = (int) (this->chipsize >> this->bbt_erase_shift);
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
			nrchips = this->numchips;
		} else {
			nrchips = chipsel + 1;
33d07f70:	12811001 	addne	r1, r1, #1	; 0x1
33d07f74:	e58d1028 	str	r1, [sp, #40]
			chip = chipsel;
33d07f78:	ea00000f 	b	33d07fbc <write_bbt+0xb0>
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
			len = 1 << this->bbt_erase_shift;
			res = mtd->read_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
			if (res < 0) {
				if (retlen != len) {
					printk (KERN_INFO "nand_bbt: Error reading block for writing the bad block table\n");
33d07f7c:	e59f0590 	ldr	r0, [pc, #1424]	; 33d08514 <write_bbt+0x608>
33d07f80:	eb003c10 	bl	33d16fc8 <printf>
33d07f84:	ea000004 	b	33d07f9c <write_bbt+0x90>
		einfo.mtd = mtd;
		einfo.addr = (unsigned long) to;
		einfo.len = 1 << this->bbt_erase_shift;
		res = nand_erase_nand (mtd, &einfo, 1);
		if (res < 0) {
			printk (KERN_WARNING "nand_bbt: Error during block erase: %d\n", res);
33d07f88:	e59f0588 	ldr	r0, [pc, #1416]	; 33d08518 <write_bbt+0x60c>
33d07f8c:	ea000000 	b	33d07f94 <write_bbt+0x88>
			return res;
		}

		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
		if (res < 0) {
			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
33d07f90:	e59f0584 	ldr	r0, [pc, #1412]	; 33d0851c <write_bbt+0x610>
33d07f94:	e1a01004 	mov	r1, r4
33d07f98:	eb003c0a 	bl	33d16fc8 <printf>
			return res;
33d07f9c:	e1a00004 	mov	r0, r4
33d07fa0:	ea000159 	b	33d0850c <write_bbt+0x600>
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
33d07fa4:	e59dc04c 	ldr	ip, [sp, #76]
33d07fa8:	e59c3008 	ldr	r3, [ip, #8]
		nrchips = 1;
33d07fac:	e3a00001 	mov	r0, #1	; 0x1
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
33d07fb0:	e1a03233 	lsr	r3, r3, r2
33d07fb4:	e58d3034 	str	r3, [sp, #52]
		nrchips = 1;
33d07fb8:	e58d0028 	str	r0, [sp, #40]
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d07fbc:	e59d1040 	ldr	r1, [sp, #64]
33d07fc0:	e59d2028 	ldr	r2, [sp, #40]
33d07fc4:	e1510002 	cmp	r1, r2
33d07fc8:	aa00014e 	bge	33d08508 <write_bbt+0x5fc>
33d07fcc:	e1a03101 	lsl	r3, r1, #2
33d07fd0:	e58d3018 	str	r3, [sp, #24]

		/* There was already a version of the table, reuse the page
		 * This applies for absolute placement too, as we have the
		 * page nr. in td->pages.
		 */
		if (td->pages[chip] != -1) {
33d07fd4:	e59dc018 	ldr	ip, [sp, #24]
33d07fd8:	e08c3007 	add	r3, ip, r7
33d07fdc:	e5930004 	ldr	r0, [r3, #4]
33d07fe0:	e3700001 	cmn	r0, #1	; 0x1
			page = td->pages[chip];
33d07fe4:	158d003c 	strne	r0, [sp, #60]

		/* There was already a version of the table, reuse the page
		 * This applies for absolute placement too, as we have the
		 * page nr. in td->pages.
		 */
		if (td->pages[chip] != -1) {
33d07fe8:	1a000030 	bne	33d080b0 <write_bbt+0x1a4>
			goto write;
		}

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
33d07fec:	e5973000 	ldr	r3, [r7]
33d07ff0:	e3130010 	tst	r3, #16	; 0x10
			startblock = numblocks * (chip + 1) - 1;
33d07ff4:	159d3034 	ldrne	r3, [sp, #52]
33d07ff8:	159d1040 	ldrne	r1, [sp, #64]
33d07ffc:	11a02003 	movne	r2, r3
33d08000:	10232391 	mlane	r3, r1, r3, r2
			dir = -1;
		} else {
			startblock = chip * numblocks;
33d08004:	059d3040 	ldreq	r3, [sp, #64]
33d08008:	059dc034 	ldreq	ip, [sp, #52]
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
33d0800c:	e5975018 	ldr	r5, [r7, #24]
33d08010:	e3a04000 	mov	r4, #0	; 0x0
		}

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
			startblock = numblocks * (chip + 1) - 1;
33d08014:	12433001 	subne	r3, r3, #1	; 0x1
			dir = -1;
		} else {
			startblock = chip * numblocks;
33d08018:	0003039c 	muleq	r3, ip, r3
			dir = 1;
33d0801c:	03a00001 	moveq	r0, #1	; 0x1
		}

		for (i = 0; i < td->maxblocks; i++) {
33d08020:	e1540005 	cmp	r4, r5
33d08024:	aa00001d 	bge	33d080a0 <write_bbt+0x194>
33d08028:	e1a0c003 	mov	ip, r3
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
33d0802c:	e59930a4 	ldr	r3, [r9, #164]
33d08030:	e7d3214c 	ldrb	r2, [r3, ip, asr #2]
33d08034:	e20c3003 	and	r3, ip, #3	; 0x3
33d08038:	e1a03083 	lsl	r3, r3, #1
33d0803c:	e1a02352 	asr	r2, r2, r3
33d08040:	e2022003 	and	r2, r2, #3	; 0x3
33d08044:	e3520001 	cmp	r2, #1	; 0x1
		} else {
			startblock = chip * numblocks;
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
33d08048:	e2844001 	add	r4, r4, #1	; 0x1
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
33d0804c:	0a000010 	beq	33d08094 <write_bbt+0x188>
			case 0x03:
				continue;
			}
			page = block << (this->bbt_erase_shift - this->page_shift);
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
33d08050:	e59d1018 	ldr	r1, [sp, #24]
33d08054:	e59d3044 	ldr	r3, [sp, #68]
		}

		for (i = 0; i < td->maxblocks; i++) {
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
33d08058:	e3520003 	cmp	r2, #3	; 0x3
			case 0x03:
				continue;
			}
			page = block << (this->bbt_erase_shift - this->page_shift);
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
33d0805c:	e081e003 	add	lr, r1, r3
		}

		for (i = 0; i < td->maxblocks; i++) {
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
33d08060:	0a00000b 	beq	33d08094 <write_bbt+0x188>
			case 0x01:
			case 0x03:
				continue;
			}
			page = block << (this->bbt_erase_shift - this->page_shift);
33d08064:	e5993070 	ldr	r3, [r9, #112]
33d08068:	e5992068 	ldr	r2, [r9, #104]
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
33d0806c:	e59d1044 	ldr	r1, [sp, #68]
			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
			case 0x01:
			case 0x03:
				continue;
			}
			page = block << (this->bbt_erase_shift - this->page_shift);
33d08070:	e0623003 	rsb	r3, r2, r3
33d08074:	e1a0331c 	lsl	r3, ip, r3
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
33d08078:	e3510000 	cmp	r1, #0	; 0x0
			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
			case 0x01:
			case 0x03:
				continue;
			}
			page = block << (this->bbt_erase_shift - this->page_shift);
33d0807c:	e58d303c 	str	r3, [sp, #60]
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
33d08080:	0a00000a 	beq	33d080b0 <write_bbt+0x1a4>
33d08084:	e59e3004 	ldr	r3, [lr, #4]
33d08088:	e59d203c 	ldr	r2, [sp, #60]
33d0808c:	e1530002 	cmp	r3, r2
33d08090:	1a000006 	bne	33d080b0 <write_bbt+0x1a4>
		} else {
			startblock = chip * numblocks;
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
33d08094:	e1540005 	cmp	r4, r5
33d08098:	e08cc000 	add	ip, ip, r0
33d0809c:	baffffe2 	blt	33d0802c <write_bbt+0x120>
			page = block << (this->bbt_erase_shift - this->page_shift);
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
				goto write;
		}
		printk (KERN_ERR "No space left to write bad block table\n");
33d080a0:	e59f0478 	ldr	r0, [pc, #1144]	; 33d08520 <write_bbt+0x614>
33d080a4:	eb003bc7 	bl	33d16fc8 <printf>
		return -ENOSPC;
33d080a8:	e3e0001b 	mvn	r0, #27	; 0x1b
33d080ac:	ea000116 	b	33d0850c <write_bbt+0x600>
write:

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
33d080b0:	e5973000 	ldr	r3, [r7]
33d080b4:	e203300f 	and	r3, r3, #15	; 0xf
		switch (bits) {
33d080b8:	e2433001 	sub	r3, r3, #1	; 0x1
33d080bc:	e3530007 	cmp	r3, #7	; 0x7
33d080c0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d080c4:	ea00003b 	b	33d081b8 <write_bbt+0x2ac>
33d080c8:	33d080e8 	.word	0x33d080e8
33d080cc:	33d0811c 	.word	0x33d0811c
33d080d0:	33d081b8 	.word	0x33d081b8
33d080d4:	33d08150 	.word	0x33d08150
33d080d8:	33d081b8 	.word	0x33d081b8
33d080dc:	33d081b8 	.word	0x33d081b8
33d080e0:	33d081b8 	.word	0x33d081b8
33d080e4:	33d08188 	.word	0x33d08188
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01; msk[2] = ~rcode; msk[3] = 0x01; break;
33d080e8:	e59d3020 	ldr	r3, [sp, #32]
33d080ec:	e3a01001 	mov	r1, #1	; 0x1
33d080f0:	e1e02003 	mvn	r2, r3
33d080f4:	e3a0c003 	mov	ip, #3	; 0x3
33d080f8:	e3a00007 	mov	r0, #7	; 0x7
33d080fc:	e3a03000 	mov	r3, #0	; 0x0
33d08100:	e58dc030 	str	ip, [sp, #48]
33d08104:	e58d002c 	str	r0, [sp, #44]
33d08108:	e5cd3054 	strb	r3, [sp, #84]
33d0810c:	e5cd2056 	strb	r2, [sp, #86]
33d08110:	e5cd1057 	strb	r1, [sp, #87]
33d08114:	e5cd1055 	strb	r1, [sp, #85]
33d08118:	ea000028 	b	33d081c0 <write_bbt+0x2b4>
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01; msk[2] = ~rcode; msk[3] = 0x03; break;
33d0811c:	e3a03002 	mov	r3, #2	; 0x2
33d08120:	e59d1020 	ldr	r1, [sp, #32]
33d08124:	e58d3030 	str	r3, [sp, #48]
33d08128:	e2433002 	sub	r3, r3, #2	; 0x2
33d0812c:	e5cd3054 	strb	r3, [sp, #84]
33d08130:	e2833001 	add	r3, r3, #1	; 0x1
33d08134:	e1e02001 	mvn	r2, r1
33d08138:	e3a0c006 	mov	ip, #6	; 0x6
33d0813c:	e5cd3055 	strb	r3, [sp, #85]
33d08140:	e2833002 	add	r3, r3, #2	; 0x2
33d08144:	e58dc02c 	str	ip, [sp, #44]
33d08148:	e5cd2056 	strb	r2, [sp, #86]
33d0814c:	ea00000b 	b	33d08180 <write_bbt+0x274>
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C; msk[2] = ~rcode; msk[3] = 0x0f; break;
33d08150:	e59d0020 	ldr	r0, [sp, #32]
33d08154:	e3a03004 	mov	r3, #4	; 0x4
33d08158:	e1e02000 	mvn	r2, r0
33d0815c:	e3a01001 	mov	r1, #1	; 0x1
33d08160:	e58d302c 	str	r3, [sp, #44]
33d08164:	e2433004 	sub	r3, r3, #4	; 0x4
33d08168:	e5cd3054 	strb	r3, [sp, #84]
33d0816c:	e58d1030 	str	r1, [sp, #48]
33d08170:	e283300c 	add	r3, r3, #12	; 0xc
33d08174:	e5cd2056 	strb	r2, [sp, #86]
33d08178:	e5cd3055 	strb	r3, [sp, #85]
33d0817c:	e2833003 	add	r3, r3, #3	; 0x3
33d08180:	e5cd3057 	strb	r3, [sp, #87]
33d08184:	ea00000d 	b	33d081c0 <write_bbt+0x2b4>
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F; msk[2] = ~rcode; msk[3] = 0xff; break;
33d08188:	e59d0020 	ldr	r0, [sp, #32]
33d0818c:	e1e03000 	mvn	r3, r0
33d08190:	e3a0c000 	mov	ip, #0	; 0x0
33d08194:	e3a0200f 	mov	r2, #15	; 0xf
33d08198:	e5cd3056 	strb	r3, [sp, #86]
33d0819c:	e3e03000 	mvn	r3, #0	; 0x0
33d081a0:	e58dc030 	str	ip, [sp, #48]
33d081a4:	e58dc02c 	str	ip, [sp, #44]
33d081a8:	e5cd2055 	strb	r2, [sp, #85]
33d081ac:	e5cd3057 	strb	r3, [sp, #87]
33d081b0:	e5cdc054 	strb	ip, [sp, #84]
33d081b4:	ea000001 	b	33d081c0 <write_bbt+0x2b4>
		default: return -EINVAL;
33d081b8:	e3e00015 	mvn	r0, #21	; 0x15
33d081bc:	ea0000d2 	b	33d0850c <write_bbt+0x600>
		}

		bbtoffs = chip * (numblocks >> 2);
33d081c0:	e59dc034 	ldr	ip, [sp, #52]
33d081c4:	e1a0314c 	asr	r3, ip, #2

		to = ((loff_t) page) << this->page_shift;
33d081c8:	e59dc03c 	ldr	ip, [sp, #60]
33d081cc:	e1a0000c 	mov	r0, ip
33d081d0:	e1a01fc0 	asr	r1, r0, #31
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C; msk[2] = ~rcode; msk[3] = 0x0f; break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F; msk[2] = ~rcode; msk[3] = 0xff; break;
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);
33d081d4:	e59dc040 	ldr	ip, [sp, #64]
33d081d8:	e00c0c93 	mul	ip, r3, ip

		to = ((loff_t) page) << this->page_shift;
33d081dc:	e5992068 	ldr	r2, [r9, #104]
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C; msk[2] = ~rcode; msk[3] = 0x0f; break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F; msk[2] = ~rcode; msk[3] = 0xff; break;
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);
33d081e0:	e58dc024 	str	ip, [sp, #36]

		to = ((loff_t) page) << this->page_shift;
33d081e4:	eb00590f 	bl	33d1e628 <__ashldi3>

		memcpy (&oobinfo, this->autooob, sizeof(oobinfo));
33d081e8:	e3a020c8 	mov	r2, #200	; 0xc8
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);

		to = ((loff_t) page) << this->page_shift;
33d081ec:	e1a0b001 	mov	fp, r1
33d081f0:	e1a0a000 	mov	sl, r0

		memcpy (&oobinfo, this->autooob, sizeof(oobinfo));
33d081f4:	e28d0088 	add	r0, sp, #136	; 0x88
33d081f8:	e59910a0 	ldr	r1, [r9, #160]
33d081fc:	eb004878 	bl	33d1a3e4 <memcpy>
		oobinfo.useecc = MTD_NANDECC_PLACEONLY;

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
33d08200:	e5973000 	ldr	r3, [r7]
33d08204:	e2134a02 	ands	r4, r3, #8192	; 0x2000
		bbtoffs = chip * (numblocks >> 2);

		to = ((loff_t) page) << this->page_shift;

		memcpy (&oobinfo, this->autooob, sizeof(oobinfo));
		oobinfo.useecc = MTD_NANDECC_PLACEONLY;
33d08208:	e3a03003 	mov	r3, #3	; 0x3
33d0820c:	e58d3088 	str	r3, [sp, #136]

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
33d08210:	0a000044 	beq	33d08328 <write_bbt+0x41c>
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
33d08214:	e5993070 	ldr	r3, [r9, #112]
33d08218:	e3a02001 	mov	r2, #1	; 0x1
33d0821c:	e1a02312 	lsl	r2, r2, r3
			len = 1 << this->bbt_erase_shift;
			res = mtd->read_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
33d08220:	e59d0048 	ldr	r0, [sp, #72]

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
			len = 1 << this->bbt_erase_shift;
33d08224:	e1a06002 	mov	r6, r2
			res = mtd->read_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
33d08228:	e59d1048 	ldr	r1, [sp, #72]
		oobinfo.useecc = MTD_NANDECC_PLACEONLY;

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
33d0822c:	e2422001 	sub	r2, r2, #1	; 0x1
			len = 1 << this->bbt_erase_shift;
			res = mtd->read_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
33d08230:	e0800006 	add	r0, r0, r6
		oobinfo.useecc = MTD_NANDECC_PLACEONLY;

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
33d08234:	e1caa002 	bic	sl, sl, r2
33d08238:	e1cbbfc2 	bic	fp, fp, r2, asr #31
			len = 1 << this->bbt_erase_shift;
			res = mtd->read_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
33d0823c:	e28d3050 	add	r3, sp, #80	; 0x50
33d08240:	e28d2088 	add	r2, sp, #136	; 0x88
33d08244:	e58d001c 	str	r0, [sp, #28]
33d08248:	e58d3000 	str	r3, [sp]
33d0824c:	e58d1004 	str	r1, [sp, #4]
33d08250:	e58d0008 	str	r0, [sp, #8]
33d08254:	e58d200c 	str	r2, [sp, #12]
33d08258:	e59d004c 	ldr	r0, [sp, #76]
33d0825c:	e1a0200b 	mov	r2, fp
33d08260:	e1a0100a 	mov	r1, sl
33d08264:	e1a03006 	mov	r3, r6
33d08268:	e1a0e00f 	mov	lr, pc
33d0826c:	e590f114 	ldr	pc, [r0, #276]
			if (res < 0) {
33d08270:	e2504000 	subs	r4, r0, #0	; 0x0
33d08274:	aa000004 	bge	33d0828c <write_bbt+0x380>
				if (retlen != len) {
33d08278:	e59d3050 	ldr	r3, [sp, #80]
33d0827c:	e1530006 	cmp	r3, r6
33d08280:	1affff3d 	bne	33d07f7c <write_bbt+0x70>
					printk (KERN_INFO "nand_bbt: Error reading block for writing the bad block table\n");
					return res;
				}
				printk (KERN_WARNING "nand_bbt: ECC error while reading block for writing bad block table\n");
33d08284:	e59f0298 	ldr	r0, [pc, #664]	; 33d08524 <write_bbt+0x618>
33d08288:	eb003b4e 	bl	33d16fc8 <printf>
			}
			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
33d0828c:	e5994068 	ldr	r4, [r9, #104]
33d08290:	e1a0100b 	mov	r1, fp
33d08294:	e1a0000a 	mov	r0, sl
33d08298:	e1a02004 	mov	r2, r4
33d0829c:	eb0058e8 	bl	33d1e644 <__ashrdi3>
33d082a0:	e59d303c 	ldr	r3, [sp, #60]
			offs = pageoffs << this->page_shift;
			/* Preset the bbt area with 0xff */
			memset (&buf[offs], 0xff, (size_t)(numblocks >> sft));
33d082a4:	e59dc034 	ldr	ip, [sp, #52]
					return res;
				}
				printk (KERN_WARNING "nand_bbt: ECC error while reading block for writing bad block table\n");
			}
			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
33d082a8:	e0605003 	rsb	r5, r0, r3
			offs = pageoffs << this->page_shift;
			/* Preset the bbt area with 0xff */
			memset (&buf[offs], 0xff, (size_t)(numblocks >> sft));
33d082ac:	e59d0030 	ldr	r0, [sp, #48]
33d082b0:	e59d3048 	ldr	r3, [sp, #72]
				}
				printk (KERN_WARNING "nand_bbt: ECC error while reading block for writing bad block table\n");
			}
			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
			offs = pageoffs << this->page_shift;
33d082b4:	e1a04415 	lsl	r4, r5, r4
			/* Preset the bbt area with 0xff */
			memset (&buf[offs], 0xff, (size_t)(numblocks >> sft));
33d082b8:	e1a0205c 	asr	r2, ip, r0
33d082bc:	e3a010ff 	mov	r1, #255	; 0xff
33d082c0:	e0830004 	add	r0, r3, r4
				}
				printk (KERN_WARNING "nand_bbt: ECC error while reading block for writing bad block table\n");
			}
			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
			offs = pageoffs << this->page_shift;
33d082c4:	e58d4038 	str	r4, [sp, #56]
			/* Preset the bbt area with 0xff */
			memset (&buf[offs], 0xff, (size_t)(numblocks >> sft));
33d082c8:	eb004831 	bl	33d1a394 <memset>
			/* Preset the bbt's oob area with 0xff */
			memset (&buf[len + pageoffs * mtd->oobsize], 0xff,
33d082cc:	e59dc04c 	ldr	ip, [sp, #76]
33d082d0:	e59c2014 	ldr	r2, [ip, #20]
33d082d4:	e0206592 	mla	r0, r2, r5, r6
33d082d8:	e5993068 	ldr	r3, [r9, #104]
33d082dc:	e59d1048 	ldr	r1, [sp, #72]
33d082e0:	e0653336 	rsb	r3, r5, r6, lsr r3
33d082e4:	e0020293 	mul	r2, r3, r2
33d082e8:	e0810000 	add	r0, r1, r0
33d082ec:	e3a010ff 	mov	r1, #255	; 0xff
33d082f0:	eb004827 	bl	33d1a394 <memset>
				((len >> this->page_shift) - pageoffs) * mtd->oobsize);
			if (td->options & NAND_BBT_VERSION) {
33d082f4:	e5973000 	ldr	r3, [r7]
33d082f8:	e3130c01 	tst	r3, #256	; 0x100
33d082fc:	0a00002a 	beq	33d083ac <write_bbt+0x4a0>
				buf[len + (pageoffs * mtd->oobsize) + td->veroffs] = td->version[chip];
33d08300:	e59d204c 	ldr	r2, [sp, #76]
33d08304:	e59d101c 	ldr	r1, [sp, #28]
33d08308:	e5923014 	ldr	r3, [r2, #20]
33d0830c:	e0211593 	mla	r1, r3, r5, r1
33d08310:	e59dc040 	ldr	ip, [sp, #64]
33d08314:	e08c3007 	add	r3, ip, r7
33d08318:	e5d32010 	ldrb	r2, [r3, #16]
33d0831c:	e597300c 	ldr	r3, [r7, #12]
33d08320:	e7c12003 	strb	r2, [r1, r3]
33d08324:	ea000020 	b	33d083ac <write_bbt+0x4a0>
			}
		} else {
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			/* Make it page aligned ! */
			len = (len + (mtd->oobblock-1)) & ~(mtd->oobblock-1);
33d08328:	e59d004c 	ldr	r0, [sp, #76]
33d0832c:	e59d1034 	ldr	r1, [sp, #52]
33d08330:	e5903010 	ldr	r3, [r0, #16]
33d08334:	e59dc030 	ldr	ip, [sp, #48]
33d08338:	e0832c51 	add	r2, r3, r1, asr ip
33d0833c:	e2422001 	sub	r2, r2, #1	; 0x1
33d08340:	e2633000 	rsb	r3, r3, #0	; 0x0
			/* Preset the buffer with 0xff */
			memset (buf, 0xff, len + (len >> this->page_shift) * mtd->oobsize);
33d08344:	e5991068 	ldr	r1, [r9, #104]
			}
		} else {
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			/* Make it page aligned ! */
			len = (len + (mtd->oobblock-1)) & ~(mtd->oobblock-1);
33d08348:	e0026003 	and	r6, r2, r3
			/* Preset the buffer with 0xff */
			memset (buf, 0xff, len + (len >> this->page_shift) * mtd->oobsize);
33d0834c:	e5903014 	ldr	r3, [r0, #20]
33d08350:	e1a01136 	lsr	r1, r6, r1
33d08354:	e0226193 	mla	r2, r3, r1, r6
33d08358:	e59d0048 	ldr	r0, [sp, #72]
33d0835c:	e3a010ff 	mov	r1, #255	; 0xff
33d08360:	eb00480b 	bl	33d1a394 <memset>
			offs = 0;
			/* Pattern is located in oob area of first page */
			memcpy (&buf[len + td->offs], td->pattern, td->len);
33d08364:	e5970008 	ldr	r0, [r7, #8]
33d08368:	e59d1048 	ldr	r1, [sp, #72]
33d0836c:	e0860000 	add	r0, r6, r0
33d08370:	e0810000 	add	r0, r1, r0
33d08374:	e5972014 	ldr	r2, [r7, #20]
33d08378:	e5971020 	ldr	r1, [r7, #32]
33d0837c:	eb004818 	bl	33d1a3e4 <memcpy>
			if (td->options & NAND_BBT_VERSION) {
33d08380:	e5973000 	ldr	r3, [r7]
33d08384:	e3130c01 	tst	r3, #256	; 0x100
			len = (size_t) (numblocks >> sft);
			/* Make it page aligned ! */
			len = (len + (mtd->oobblock-1)) & ~(mtd->oobblock-1);
			/* Preset the buffer with 0xff */
			memset (buf, 0xff, len + (len >> this->page_shift) * mtd->oobsize);
			offs = 0;
33d08388:	e58d4038 	str	r4, [sp, #56]
			/* Pattern is located in oob area of first page */
			memcpy (&buf[len + td->offs], td->pattern, td->len);
			if (td->options & NAND_BBT_VERSION) {
33d0838c:	0a000006 	beq	33d083ac <write_bbt+0x4a0>
				buf[len + td->veroffs] = td->version[chip];
33d08390:	e59d2040 	ldr	r2, [sp, #64]
33d08394:	e59dc048 	ldr	ip, [sp, #72]
33d08398:	e0823007 	add	r3, r2, r7
33d0839c:	e5d31010 	ldrb	r1, [r3, #16]
33d083a0:	e597200c 	ldr	r2, [r7, #12]
33d083a4:	e086300c 	add	r3, r6, ip
33d083a8:	e7c31002 	strb	r1, [r3, r2]
			}
		}

		/* walk through the memory table */
		for (i = 0; i < numblocks; ) {
33d083ac:	e59d0034 	ldr	r0, [sp, #52]
33d083b0:	e3a04000 	mov	r4, #0	; 0x0
33d083b4:	e1540000 	cmp	r4, r0
33d083b8:	aa00001e 	bge	33d08438 <write_bbt+0x52c>
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
33d083bc:	e59930a4 	ldr	r3, [r9, #164]
33d083c0:	e59d1024 	ldr	r1, [sp, #36]
33d083c4:	e0813003 	add	r3, r1, r3
33d083c8:	e7d3e144 	ldrb	lr, [r3, r4, asr #2]
33d083cc:	e3a05003 	mov	r5, #3	; 0x3
			for (j = 0; j < 4; j++ , i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
33d083d0:	e20e3003 	and	r3, lr, #3	; 0x3
33d083d4:	e28d2e15 	add	r2, sp, #336	; 0x150
33d083d8:	e0823003 	add	r3, r2, r3
33d083dc:	e59d0030 	ldr	r0, [sp, #48]
33d083e0:	e59d1038 	ldr	r1, [sp, #56]
33d083e4:	e59d2048 	ldr	r2, [sp, #72]
33d083e8:	e1a0c054 	asr	ip, r4, r0
33d083ec:	e0810002 	add	r0, r1, r2
33d083f0:	e55310fc 	ldrb	r1, [r3, #-252]
33d083f4:	e7d0300c 	ldrb	r3, [r0, ip]
		/* walk through the memory table */
		for (i = 0; i < numblocks; ) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++ , i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
33d083f8:	e59d2030 	ldr	r2, [sp, #48]
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
33d083fc:	e58d3010 	str	r3, [sp, #16]
		/* walk through the memory table */
		for (i = 0; i < numblocks; ) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++ , i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
33d08400:	e59d302c 	ldr	r3, [sp, #44]
33d08404:	e2622003 	rsb	r2, r2, #3	; 0x3
33d08408:	e0033214 	and	r3, r3, r4, lsl r2
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
33d0840c:	e59d2010 	ldr	r2, [sp, #16]
33d08410:	e2555001 	subs	r5, r5, #1	; 0x1
33d08414:	e1c21311 	bic	r1, r2, r1, lsl r3
		/* walk through the memory table */
		for (i = 0; i < numblocks; ) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++ , i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
33d08418:	e58d3014 	str	r3, [sp, #20]
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
				dat >>= 2;
33d0841c:	e1a0e12e 	lsr	lr, lr, #2
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++ , i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
33d08420:	e7c0100c 	strb	r1, [r0, ip]

		/* walk through the memory table */
		for (i = 0; i < numblocks; ) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++ , i++) {
33d08424:	e2844001 	add	r4, r4, #1	; 0x1
33d08428:	5affffe8 	bpl	33d083d0 <write_bbt+0x4c4>
				buf[len + td->veroffs] = td->version[chip];
			}
		}

		/* walk through the memory table */
		for (i = 0; i < numblocks; ) {
33d0842c:	e59d3034 	ldr	r3, [sp, #52]
33d08430:	e1540003 	cmp	r4, r3
33d08434:	eaffffdf 	b	33d083b8 <write_bbt+0x4ac>
				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
				dat >>= 2;
			}
		}

		memset (&einfo, 0, sizeof (einfo));
33d08438:	e28d4058 	add	r4, sp, #88	; 0x58
33d0843c:	e3a01000 	mov	r1, #0	; 0x0
33d08440:	e3a02030 	mov	r2, #48	; 0x30
33d08444:	e1a00004 	mov	r0, r4
33d08448:	eb0047d1 	bl	33d1a394 <memset>
		einfo.mtd = mtd;
33d0844c:	e59dc04c 	ldr	ip, [sp, #76]
		einfo.addr = (unsigned long) to;
33d08450:	e58da05c 	str	sl, [sp, #92]
				dat >>= 2;
			}
		}

		memset (&einfo, 0, sizeof (einfo));
		einfo.mtd = mtd;
33d08454:	e58dc058 	str	ip, [sp, #88]
		einfo.addr = (unsigned long) to;
		einfo.len = 1 << this->bbt_erase_shift;
33d08458:	e5993070 	ldr	r3, [r9, #112]
33d0845c:	e3a02001 	mov	r2, #1	; 0x1
33d08460:	e1a03312 	lsl	r3, r2, r3
		res = nand_erase_nand (mtd, &einfo, 1);
33d08464:	e1a01004 	mov	r1, r4
33d08468:	e1a0000c 	mov	r0, ip
		}

		memset (&einfo, 0, sizeof (einfo));
		einfo.mtd = mtd;
		einfo.addr = (unsigned long) to;
		einfo.len = 1 << this->bbt_erase_shift;
33d0846c:	e58d3060 	str	r3, [sp, #96]
		res = nand_erase_nand (mtd, &einfo, 1);
33d08470:	ebfff8f6 	bl	33d06850 <nand_erase_nand>
		if (res < 0) {
33d08474:	e2504000 	subs	r4, r0, #0	; 0x0
33d08478:	bafffec2 	blt	33d07f88 <write_bbt+0x7c>
			printk (KERN_WARNING "nand_bbt: Error during block erase: %d\n", res);
			return res;
		}

		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
33d0847c:	e59d0048 	ldr	r0, [sp, #72]
33d08480:	e28d3050 	add	r3, sp, #80	; 0x50
33d08484:	e0802006 	add	r2, r0, r6
33d08488:	e28d1088 	add	r1, sp, #136	; 0x88
33d0848c:	e58d3000 	str	r3, [sp]
33d08490:	e58d2008 	str	r2, [sp, #8]
33d08494:	e58d100c 	str	r1, [sp, #12]
33d08498:	e58d0004 	str	r0, [sp, #4]
33d0849c:	e1a03006 	mov	r3, r6
33d084a0:	e59d004c 	ldr	r0, [sp, #76]
33d084a4:	e1a0200b 	mov	r2, fp
33d084a8:	e1a0100a 	mov	r1, sl
33d084ac:	e1a0e00f 	mov	lr, pc
33d084b0:	e590f118 	ldr	pc, [r0, #280]
		if (res < 0) {
33d084b4:	e2504000 	subs	r4, r0, #0	; 0x0
33d084b8:	bafffeb4 	blt	33d07f90 <write_bbt+0x84>
			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
			return res;
		}
		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
33d084bc:	e59d2040 	ldr	r2, [sp, #64]
33d084c0:	e0823007 	add	r3, r2, r7
33d084c4:	e5d32010 	ldrb	r2, [r3, #16]
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d084c8:	e59d3040 	ldr	r3, [sp, #64]
		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
		if (res < 0) {
			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
			return res;
		}
		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
33d084cc:	e1a0100a 	mov	r1, sl
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d084d0:	e2833001 	add	r3, r3, #1	; 0x1
		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
		if (res < 0) {
			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
			return res;
		}
		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
33d084d4:	e59f004c 	ldr	r0, [pc, #76]	; 33d08528 <write_bbt+0x61c>
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d084d8:	e58d3040 	str	r3, [sp, #64]
		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
		if (res < 0) {
			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
			return res;
		}
		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
33d084dc:	eb003ab9 	bl	33d16fc8 <printf>
			(unsigned int) to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
33d084e0:	e59d1018 	ldr	r1, [sp, #24]
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d084e4:	e59dc040 	ldr	ip, [sp, #64]
33d084e8:	e59d0028 	ldr	r0, [sp, #40]
		}
		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
			(unsigned int) to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
33d084ec:	e59d203c 	ldr	r2, [sp, #60]
33d084f0:	e0813007 	add	r3, r1, r7
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d084f4:	e15c0000 	cmp	ip, r0
33d084f8:	e2811004 	add	r1, r1, #4	; 0x4
		}
		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
			(unsigned int) to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
33d084fc:	e5832004 	str	r2, [r3, #4]
33d08500:	e58d1018 	str	r1, [sp, #24]
		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
33d08504:	bafffeb2 	blt	33d07fd4 <write_bbt+0xc8>
			(unsigned int) to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
	}
	return 0;
33d08508:	e3a00000 	mov	r0, #0	; 0x0
}
33d0850c:	e28dde15 	add	sp, sp, #336	; 0x150
33d08510:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d08514:	33d26550 	.word	0x33d26550
33d08518:	33d26590 	.word	0x33d26590
33d0851c:	33d265b8 	.word	0x33d265b8
33d08520:	33d265ec 	.word	0x33d265ec
33d08524:	33d26614 	.word	0x33d26614
33d08528:	33d2665c 	.word	0x33d2665c

33d0852c <nand_update_bbt>:
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
{
33d0852c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
33d08530:	e590413c 	ldr	r4, [r0, #316]
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
{
33d08534:	e24dd010 	sub	sp, sp, #16	; 0x10
	struct nand_chip *this = mtd->priv;
	int len, res = 0, writeops = 0;
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
33d08538:	e28430a4 	add	r3, r4, #164	; 0xa4
33d0853c:	e8930408 	ldm	r3, {r3, sl}
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
{
33d08540:	e1a07002 	mov	r7, r2
33d08544:	e1a06001 	mov	r6, r1
	struct nand_chip *this = mtd->priv;
	int len, res = 0, writeops = 0;
33d08548:	e3a02000 	mov	r2, #0	; 0x0
33d0854c:	e58d200c 	str	r2, [sp, #12]
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	if (!this->bbt || !td)
33d08550:	e35a0000 	cmp	sl, #0	; 0x0
33d08554:	13530000 	cmpne	r3, #0	; 0x0
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
{
33d08558:	e1a09000 	mov	r9, r0
	struct nand_chip *this = mtd->priv;
	int len, res = 0, writeops = 0;
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
33d0855c:	e59450ac 	ldr	r5, [r4, #172]

	if (!this->bbt || !td)
		return -EINVAL;
33d08560:	03e00015 	mvneq	r0, #21	; 0x15
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	if (!this->bbt || !td)
33d08564:	0a000046 	beq	33d08684 <nand_update_bbt+0x158>
		return -EINVAL;

	len = mtd->size >> (this->bbt_erase_shift + 2);
33d08568:	e5941070 	ldr	r1, [r4, #112]
	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
	len += (len >> this->page_shift) * mtd->oobsize;
33d0856c:	e5942068 	ldr	r2, [r4, #104]
	if (!this->bbt || !td)
		return -EINVAL;

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
33d08570:	e3a03001 	mov	r3, #1	; 0x1
33d08574:	e1a03113 	lsl	r3, r3, r1
	len += (len >> this->page_shift) * mtd->oobsize;
33d08578:	e5991014 	ldr	r1, [r9, #20]
33d0857c:	e1a02253 	asr	r2, r3, r2
	buf = kmalloc (len, GFP_KERNEL);
33d08580:	e0203291 	mla	r0, r1, r2, r3
33d08584:	eb003c37 	bl	33d17668 <malloc>
	if (!buf) {
33d08588:	e250b000 	subs	fp, r0, #0	; 0x0
33d0858c:	1a000003 	bne	33d085a0 <nand_update_bbt+0x74>
		printk (KERN_ERR "nand_update_bbt: Out of memory\n");
33d08590:	e59f00f4 	ldr	r0, [pc, #244]	; 33d0868c <nand_update_bbt+0x160>
33d08594:	eb003a8b 	bl	33d16fc8 <printf>
		return -ENOMEM;
33d08598:	e3e0000b 	mvn	r0, #11	; 0xb
33d0859c:	ea000038 	b	33d08684 <nand_update_bbt+0x158>
	}

	writeops = md != NULL ? 0x03 : 0x01;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d085a0:	e59a3000 	ldr	r3, [sl]
	if (!buf) {
		printk (KERN_ERR "nand_update_bbt: Out of memory\n");
		return -ENOMEM;
	}

	writeops = md != NULL ? 0x03 : 0x01;
33d085a4:	e3550000 	cmp	r5, #0	; 0x0
33d085a8:	03a02001 	moveq	r2, #1	; 0x1
33d085ac:	13a02003 	movne	r2, #3	; 0x3

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d085b0:	e3130080 	tst	r3, #128	; 0x80
33d085b4:	e58d3004 	str	r3, [sp, #4]
	if (!buf) {
		printk (KERN_ERR "nand_update_bbt: Out of memory\n");
		return -ENOMEM;
	}

	writeops = md != NULL ? 0x03 : 0x01;
33d085b8:	e58d2008 	str	r2, [sp, #8]
	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chip = (int) (offs >> this->chip_shift);
		chipsel = chip;
	} else {
		chip = 0;
33d085bc:	059d000c 	ldreq	r0, [sp, #12]
		chipsel = -1;
33d085c0:	03e04000 	mvneq	r4, #0	; 0x0
	}

	writeops = md != NULL ? 0x03 : 0x01;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d085c4:	0a000004 	beq	33d085dc <nand_update_bbt+0xb0>
		chip = (int) (offs >> this->chip_shift);
33d085c8:	e5942074 	ldr	r2, [r4, #116]
33d085cc:	e1a01007 	mov	r1, r7
33d085d0:	e1a00006 	mov	r0, r6
33d085d4:	eb00581a 	bl	33d1e644 <__ashrdi3>
		chipsel = chip;
33d085d8:	e1a04000 	mov	r4, r0
	} else {
		chip = 0;
		chipsel = -1;
	}

	td->version[chip]++;
33d085dc:	e080200a 	add	r2, r0, sl
33d085e0:	e5d23010 	ldrb	r3, [r2, #16]
33d085e4:	e2833001 	add	r3, r3, #1	; 0x1
	if (md)
33d085e8:	e3550000 	cmp	r5, #0	; 0x0
	} else {
		chip = 0;
		chipsel = -1;
	}

	td->version[chip]++;
33d085ec:	e5c23010 	strb	r3, [r2, #16]
	if (md)
		md->version[chip]++;
33d085f0:	10802005 	addne	r2, r0, r5
33d085f4:	15d23010 	ldrbne	r3, [r2, #16]
33d085f8:	12833001 	addne	r3, r3, #1	; 0x1
33d085fc:	15c23010 	strbne	r3, [r2, #16]

	/* Write the bad block table to the device ? */
	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
33d08600:	e59d3008 	ldr	r3, [sp, #8]
33d08604:	e3130001 	tst	r3, #1	; 0x1
33d08608:	0a00000b 	beq	33d0863c <nand_update_bbt+0x110>
33d0860c:	e59d2004 	ldr	r2, [sp, #4]
33d08610:	e3120a01 	tst	r2, #4096	; 0x1000
33d08614:	0a000008 	beq	33d0863c <nand_update_bbt+0x110>
		res = write_bbt (mtd, buf, td, md, chipsel);
33d08618:	e1a00009 	mov	r0, r9
33d0861c:	e1a0100b 	mov	r1, fp
33d08620:	e1a0200a 	mov	r2, sl
33d08624:	e1a03005 	mov	r3, r5
33d08628:	e58d4000 	str	r4, [sp]
33d0862c:	ebfffe36 	bl	33d07f0c <write_bbt>
		if (res < 0)
33d08630:	e3500000 	cmp	r0, #0	; 0x0
33d08634:	e58d000c 	str	r0, [sp, #12]
33d08638:	ba00000e 	blt	33d08678 <nand_update_bbt+0x14c>
			goto out;
	}
	/* Write the mirror bad block table to the device ? */
	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
33d0863c:	e59d2008 	ldr	r2, [sp, #8]
33d08640:	e2553000 	subs	r3, r5, #0	; 0x0
33d08644:	13a03001 	movne	r3, #1	; 0x1
33d08648:	e01320a2 	ands	r2, r3, r2, lsr #1
33d0864c:	0a000009 	beq	33d08678 <nand_update_bbt+0x14c>
33d08650:	e5953000 	ldr	r3, [r5]
33d08654:	e3130a01 	tst	r3, #4096	; 0x1000
33d08658:	0a000006 	beq	33d08678 <nand_update_bbt+0x14c>
		res = write_bbt (mtd, buf, md, td, chipsel);
33d0865c:	e1a00009 	mov	r0, r9
33d08660:	e1a02005 	mov	r2, r5
33d08664:	e1a0300a 	mov	r3, sl
33d08668:	e1a0100b 	mov	r1, fp
33d0866c:	e58d4000 	str	r4, [sp]
33d08670:	ebfffe25 	bl	33d07f0c <write_bbt>
33d08674:	e58d000c 	str	r0, [sp, #12]
	}

out:
	kfree (buf);
33d08678:	e1a0000b 	mov	r0, fp
33d0867c:	eb003b74 	bl	33d17454 <free>
	return res;
33d08680:	e59d000c 	ldr	r0, [sp, #12]
}
33d08684:	e28dd010 	add	sp, sp, #16	; 0x10
33d08688:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0868c:	33d26690 	.word	0x33d26690

33d08690 <mark_bbt_region>:
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
{
33d08690:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d08694:	e5913000 	ldr	r3, [r1]
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	struct nand_chip *this = mtd->priv;
33d08698:	e590413c 	ldr	r4, [r0, #316]
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
33d0869c:	e3130080 	tst	r3, #128	; 0x80
33d086a0:	e5942070 	ldr	r2, [r4, #112]
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
33d086a4:	05903008 	ldreq	r3, [r0, #8]
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
{
33d086a8:	e1a05001 	mov	r5, r1
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
33d086ac:	15941090 	ldrne	r1, [r4, #144]
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
{
33d086b0:	e24dd008 	sub	sp, sp, #8	; 0x8
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
33d086b4:	01a0a233 	lsreq	sl, r3, r2
	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
	} else {
		chips = 1;
33d086b8:	03a02001 	moveq	r2, #1	; 0x1
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
33d086bc:	15943094 	ldrne	r3, [r4, #148]
	} else {
		chips = 1;
33d086c0:	058d2000 	streq	r2, [sp]
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
33d086c4:	158d1000 	strne	r1, [sp]
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
	}

	for (i = 0; i < chips; i++) {
33d086c8:	e59d1000 	ldr	r1, [sp]
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
33d086cc:	11a0a233 	lsrne	sl, r3, r2
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
	}

	for (i = 0; i < chips; i++) {
33d086d0:	e3a03000 	mov	r3, #0	; 0x0
33d086d4:	e1530001 	cmp	r3, r1
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
{
33d086d8:	e1a09000 	mov	r9, r0
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
	}

	for (i = 0; i < chips; i++) {
33d086dc:	e58d3004 	str	r3, [sp, #4]
33d086e0:	aa00004c 	bge	33d08818 <mark_bbt_region+0x188>
33d086e4:	e1a0b00a 	mov	fp, sl
		if ((td->options & NAND_BBT_ABSPAGE) ||
33d086e8:	e5953000 	ldr	r3, [r5]
33d086ec:	e2132020 	ands	r2, r3, #32	; 0x20
33d086f0:	1a000001 	bne	33d086fc <mark_bbt_region+0x6c>
33d086f4:	e3130a01 	tst	r3, #4096	; 0x1000
33d086f8:	1a00001a 	bne	33d08768 <mark_bbt_region+0xd8>
		    !(td->options & NAND_BBT_WRITE)) {
		    	if (td->pages[i] == -1) continue;
33d086fc:	e59d2004 	ldr	r2, [sp, #4]
33d08700:	e0853102 	add	r3, r5, r2, lsl #2
33d08704:	e5931004 	ldr	r1, [r3, #4]
33d08708:	e3710001 	cmn	r1, #1	; 0x1
33d0870c:	0a00003b 	beq	33d08800 <mark_bbt_region+0x170>
			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
33d08710:	e5942068 	ldr	r2, [r4, #104]
33d08714:	e5943070 	ldr	r3, [r4, #112]
33d08718:	e0623003 	rsb	r3, r2, r3
33d0871c:	e1a0c351 	asr	ip, r1, r3
			block <<= 1;
33d08720:	e1a0c08c 	lsl	ip, ip, #1
			oldval = this->bbt[(block >> 3)];
33d08724:	e59400a4 	ldr	r0, [r4, #164]
33d08728:	e1a011cc 	asr	r1, ip, #3
33d0872c:	e7d0e001 	ldrb	lr, [r0, r1]
			newval = oldval | (0x2 << (block & 0x06));
33d08730:	e20c2006 	and	r2, ip, #6	; 0x6
33d08734:	e3a03002 	mov	r3, #2	; 0x2
33d08738:	e18e3213 	orr	r3, lr, r3, lsl r2
33d0873c:	e20320ff 	and	r2, r3, #255	; 0xff
			this->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
33d08740:	e15e0002 	cmp	lr, r2
		    	if (td->pages[i] == -1) continue;
			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
			block <<= 1;
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
33d08744:	e7c02001 	strb	r2, [r0, r1]
			if ((oldval != newval) && td->reserved_block_code)
33d08748:	0a00002c 	beq	33d08800 <mark_bbt_region+0x170>
33d0874c:	e595301c 	ldr	r3, [r5, #28]
33d08750:	e3530000 	cmp	r3, #0	; 0x0
				nand_update_bbt(mtd, block << (this->bbt_erase_shift - 1));
33d08754:	15941070 	ldrne	r1, [r4, #112]
33d08758:	12411001 	subne	r1, r1, #1	; 0x1
33d0875c:	11a0111c 	lslne	r1, ip, r1
			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
			block <<= 1;
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
33d08760:	1a000023 	bne	33d087f4 <mark_bbt_region+0x164>
33d08764:	ea000025 	b	33d08800 <mark_bbt_region+0x170>
				nand_update_bbt(mtd, block << (this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
		if (td->options & NAND_BBT_LASTBLOCK)
33d08768:	e3130010 	tst	r3, #16	; 0x10
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
33d0876c:	059dc004 	ldreq	ip, [sp, #4]
33d08770:	000c0c9a 	muleq	ip, sl, ip
				nand_update_bbt(mtd, block << (this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
33d08774:	15953018 	ldrne	r3, [r5, #24]
33d08778:	1063c00b 	rsbne	ip, r3, fp
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
33d0877c:	e5953018 	ldr	r3, [r5, #24]
33d08780:	e3a06000 	mov	r6, #0	; 0x0
33d08784:	e1560003 	cmp	r6, r3
			this->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
				nand_update_bbt(mtd, block << (this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
33d08788:	e1a07002 	mov	r7, r2
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
33d0878c:	e1a0c08c 	lsl	ip, ip, #1
		for (j = 0; j < td->maxblocks; j++) {
33d08790:	aa00001a 	bge	33d08800 <mark_bbt_region+0x170>
			oldval = this->bbt[(block >> 3)];
33d08794:	e59400a4 	ldr	r0, [r4, #164]
33d08798:	e1a011cc 	asr	r1, ip, #3
33d0879c:	e7d0e001 	ldrb	lr, [r0, r1]
			newval = oldval | (0x2 << (block & 0x06));
33d087a0:	e20c2006 	and	r2, ip, #6	; 0x6
33d087a4:	e3a03002 	mov	r3, #2	; 0x2
33d087a8:	e18e3213 	orr	r3, lr, r3, lsl r2
33d087ac:	e20320ff 	and	r2, r3, #255	; 0xff
			this->bbt[(block >> 3)] = newval;
33d087b0:	e7c02001 	strb	r2, [r0, r1]
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
33d087b4:	e5953018 	ldr	r3, [r5, #24]
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
			if (oldval != newval) update = 1;
33d087b8:	e15e0002 	cmp	lr, r2
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
33d087bc:	e2866001 	add	r6, r6, #1	; 0x1
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
			if (oldval != newval) update = 1;
33d087c0:	13a07001 	movne	r7, #1	; 0x1
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
33d087c4:	e1560003 	cmp	r6, r3
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
			if (oldval != newval) update = 1;
			block += 2;
33d087c8:	e28cc002 	add	ip, ip, #2	; 0x2
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
33d087cc:	bafffff0 	blt	33d08794 <mark_bbt_region+0x104>
			block += 2;
		}
		/* If we want reserved blocks to be recorded to flash, and some
		   new ones have been marked, then we need to update the stored
		   bbts.  This should only happen once. */
		if (update && td->reserved_block_code)
33d087d0:	e3570000 	cmp	r7, #0	; 0x0
33d087d4:	0a000009 	beq	33d08800 <mark_bbt_region+0x170>
33d087d8:	e595301c 	ldr	r3, [r5, #28]
33d087dc:	e3530000 	cmp	r3, #0	; 0x0
33d087e0:	0a000006 	beq	33d08800 <mark_bbt_region+0x170>
			nand_update_bbt(mtd, (block - 2) << (this->bbt_erase_shift - 1));
33d087e4:	e5943070 	ldr	r3, [r4, #112]
33d087e8:	e24c1002 	sub	r1, ip, #2	; 0x2
33d087ec:	e2433001 	sub	r3, r3, #1	; 0x1
33d087f0:	e1a01311 	lsl	r1, r1, r3
33d087f4:	e1a02fc1 	asr	r2, r1, #31
33d087f8:	e1a00009 	mov	r0, r9
33d087fc:	ebffff4a 	bl	33d0852c <nand_update_bbt>
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
	}

	for (i = 0; i < chips; i++) {
33d08800:	e89d000a 	ldm	sp, {r1, r3}
33d08804:	e2833001 	add	r3, r3, #1	; 0x1
33d08808:	e1530001 	cmp	r3, r1
33d0880c:	e58d3004 	str	r3, [sp, #4]
33d08810:	e08bb00a 	add	fp, fp, sl
33d08814:	baffffb3 	blt	33d086e8 <mark_bbt_region+0x58>
33d08818:	e28dd008 	add	sp, sp, #8	; 0x8
33d0881c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d08820 <nand_scan_bbt>:
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
33d08820:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
33d08824:	e590413c 	ldr	r4, [r0, #316]
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
33d08828:	e24dd024 	sub	sp, sp, #36	; 0x24
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
33d0882c:	e5902008 	ldr	r2, [r0, #8]
33d08830:	e5943070 	ldr	r3, [r4, #112]
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
33d08834:	e58d1020 	str	r1, [sp, #32]
	struct nand_chip *this = mtd->priv;
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
33d08838:	e59410a8 	ldr	r1, [r4, #168]
33d0883c:	e58d101c 	str	r1, [sp, #28]
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
33d08840:	e2833002 	add	r3, r3, #2	; 0x2
33d08844:	e1a05332 	lsr	r5, r2, r3
{
	struct nand_chip *this = mtd->priv;
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
33d08848:	e59420ac 	ldr	r2, [r4, #172]
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
33d0884c:	e1a06000 	mov	r6, r0
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate memory (2bit per block) */
	this->bbt = kmalloc (len, GFP_KERNEL);
33d08850:	e1a00005 	mov	r0, r5
{
	struct nand_chip *this = mtd->priv;
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
33d08854:	e58d2018 	str	r2, [sp, #24]

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate memory (2bit per block) */
	this->bbt = kmalloc (len, GFP_KERNEL);
33d08858:	eb003b82 	bl	33d17668 <malloc>
	if (!this->bbt) {
33d0885c:	e3500000 	cmp	r0, #0	; 0x0
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate memory (2bit per block) */
	this->bbt = kmalloc (len, GFP_KERNEL);
33d08860:	e58400a4 	str	r0, [r4, #164]
	if (!this->bbt) {
33d08864:	1a000003 	bne	33d08878 <nand_scan_bbt+0x58>
		printk (KERN_ERR "nand_scan_bbt: Out of memory\n");
33d08868:	e59f03fc 	ldr	r0, [pc, #1020]	; 33d08c6c <nand_scan_bbt+0x44c>
33d0886c:	eb0039d5 	bl	33d16fc8 <printf>
		return -ENOMEM;
33d08870:	e3e0000b 	mvn	r0, #11	; 0xb
33d08874:	ea0000fa 	b	33d08c64 <nand_scan_bbt+0x444>
	}
	/* Clear the memory bad block table */
	memset (this->bbt, 0x00, len);
33d08878:	e3a01000 	mov	r1, #0	; 0x0
33d0887c:	e1a02005 	mov	r2, r5
33d08880:	eb0046c3 	bl	33d1a394 <memset>

	/* If no primary table decriptor is given, scan the device
	 * to build a memory based bad block table
	 */
	if (!td)
33d08884:	e59d301c 	ldr	r3, [sp, #28]
33d08888:	e3530000 	cmp	r3, #0	; 0x0
33d0888c:	1a00000a 	bne	33d088bc <nand_scan_bbt+0x9c>
static int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;

	/* Ensure that we only scan for the pattern and nothing else */
	bd->options = 0;
33d08890:	e28d101c 	add	r1, sp, #28	; 0x1c
33d08894:	e8911002 	ldm	r1, {r1, ip}
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
*/
static int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;
33d08898:	e596313c 	ldr	r3, [r6, #316]

	/* Ensure that we only scan for the pattern and nothing else */
	bd->options = 0;
33d0889c:	e58c1000 	str	r1, [ip]
	create_bbt (mtd, this->data_buf, bd, -1);
33d088a0:	e1a00006 	mov	r0, r6
33d088a4:	e5931078 	ldr	r1, [r3, #120]
33d088a8:	e59d2020 	ldr	r2, [sp, #32]
33d088ac:	e3e03000 	mvn	r3, #0	; 0x0
33d088b0:	ebfffcb0 	bl	33d07b78 <create_bbt>
 *
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
*/
static int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
33d088b4:	e59d001c 	ldr	r0, [sp, #28]
33d088b8:	ea0000e9 	b	33d08c64 <nand_scan_bbt+0x444>
	 */
	if (!td)
		return nand_memory_bbt(mtd, bd);

	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
33d088bc:	e5941070 	ldr	r1, [r4, #112]
	len += (len >> this->page_shift) * mtd->oobsize;
33d088c0:	e5942068 	ldr	r2, [r4, #104]
	 */
	if (!td)
		return nand_memory_bbt(mtd, bd);

	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
33d088c4:	e3a03001 	mov	r3, #1	; 0x1
33d088c8:	e1a05113 	lsl	r5, r3, r1
	len += (len >> this->page_shift) * mtd->oobsize;
33d088cc:	e5963014 	ldr	r3, [r6, #20]
33d088d0:	e1a02255 	asr	r2, r5, r2
	buf = kmalloc (len, GFP_KERNEL);
33d088d4:	e0205293 	mla	r0, r3, r2, r5
33d088d8:	eb003b62 	bl	33d17668 <malloc>
	if (!buf) {
33d088dc:	e250a000 	subs	sl, r0, #0	; 0x0
33d088e0:	1a000006 	bne	33d08900 <nand_scan_bbt+0xe0>
		printk (KERN_ERR "nand_bbt: Out of memory\n");
33d088e4:	e59f0384 	ldr	r0, [pc, #900]	; 33d08c70 <nand_scan_bbt+0x450>
33d088e8:	eb0039b6 	bl	33d16fc8 <printf>
		kfree (this->bbt);
33d088ec:	e59400a4 	ldr	r0, [r4, #164]
33d088f0:	eb003ad7 	bl	33d17454 <free>
		this->bbt = NULL;
		return -ENOMEM;
33d088f4:	e3e0000b 	mvn	r0, #11	; 0xb
	len += (len >> this->page_shift) * mtd->oobsize;
	buf = kmalloc (len, GFP_KERNEL);
	if (!buf) {
		printk (KERN_ERR "nand_bbt: Out of memory\n");
		kfree (this->bbt);
		this->bbt = NULL;
33d088f8:	e584a0a4 	str	sl, [r4, #164]
		return -ENOMEM;
33d088fc:	ea0000d8 	b	33d08c64 <nand_scan_bbt+0x444>
	}

	/* Is the bbt at a given page ? */
	if (td->options & NAND_BBT_ABSPAGE) {
33d08900:	e59d201c 	ldr	r2, [sp, #28]
33d08904:	e5923000 	ldr	r3, [r2]
33d08908:	e3130020 	tst	r3, #32	; 0x20
33d0890c:	0a000031 	beq	33d089d8 <nand_scan_bbt+0x1b8>
	struct nand_bbt_descr *md)
{
	struct nand_chip *this = mtd->priv;

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
33d08910:	e3130c01 	tst	r3, #256	; 0x100
 *
*/
static int read_abs_bbts (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td,
	struct nand_bbt_descr *md)
{
	struct nand_chip *this = mtd->priv;
33d08914:	e596413c 	ldr	r4, [r6, #316]

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
33d08918:	0a000013 	beq	33d0896c <nand_scan_bbt+0x14c>
		nand_read_raw (mtd, buf, td->pages[0] << this->page_shift, mtd->oobblock, mtd->oobsize);
33d0891c:	e5943068 	ldr	r3, [r4, #104]
33d08920:	e5922004 	ldr	r2, [r2, #4]
33d08924:	e286c010 	add	ip, r6, #16	; 0x10
33d08928:	e89c5000 	ldm	ip, {ip, lr}
33d0892c:	e1a02312 	lsl	r2, r2, r3
33d08930:	e1a03fc2 	asr	r3, r2, #31
33d08934:	e1a0100a 	mov	r1, sl
33d08938:	e1a00006 	mov	r0, r6
33d0893c:	e88d5000 	stm	sp, {ip, lr}
33d08940:	ebfff4a6 	bl	33d05be0 <nand_read_raw>
		td->version[0] = buf[mtd->oobblock + td->veroffs];
33d08944:	e59dc01c 	ldr	ip, [sp, #28]
33d08948:	e5963010 	ldr	r3, [r6, #16]
33d0894c:	e59c200c 	ldr	r2, [ip, #12]
33d08950:	e083300a 	add	r3, r3, sl
33d08954:	e7d33002 	ldrb	r3, [r3, r2]
33d08958:	e5cc3010 	strb	r3, [ip, #16]
		printk (KERN_DEBUG "Bad block table at page %d, version 0x%02X\n", td->pages[0], td->version[0]);
33d0895c:	e59f0310 	ldr	r0, [pc, #784]	; 33d08c74 <nand_scan_bbt+0x454>
33d08960:	e59c1004 	ldr	r1, [ip, #4]
33d08964:	e5dc2010 	ldrb	r2, [ip, #16]
33d08968:	eb003996 	bl	33d16fc8 <printf>
	}

	/* Read the mirror version, if available */
	if (md && (md->options & NAND_BBT_VERSION)) {
33d0896c:	e59d1018 	ldr	r1, [sp, #24]
33d08970:	e3510000 	cmp	r1, #0	; 0x0
33d08974:	0a000021 	beq	33d08a00 <nand_scan_bbt+0x1e0>
33d08978:	e5913000 	ldr	r3, [r1]
33d0897c:	e3130c01 	tst	r3, #256	; 0x100
33d08980:	0a00001e 	beq	33d08a00 <nand_scan_bbt+0x1e0>
		nand_read_raw (mtd, buf, md->pages[0] << this->page_shift, mtd->oobblock, mtd->oobsize);
33d08984:	e5943068 	ldr	r3, [r4, #104]
33d08988:	e5912004 	ldr	r2, [r1, #4]
33d0898c:	e286c010 	add	ip, r6, #16	; 0x10
33d08990:	e89c5000 	ldm	ip, {ip, lr}
33d08994:	e1a02312 	lsl	r2, r2, r3
33d08998:	e1a03fc2 	asr	r3, r2, #31
33d0899c:	e1a0100a 	mov	r1, sl
33d089a0:	e1a00006 	mov	r0, r6
33d089a4:	e88d5000 	stm	sp, {ip, lr}
33d089a8:	ebfff48c 	bl	33d05be0 <nand_read_raw>
		md->version[0] = buf[mtd->oobblock + md->veroffs];
33d089ac:	e59dc018 	ldr	ip, [sp, #24]
33d089b0:	e5963010 	ldr	r3, [r6, #16]
33d089b4:	e59c200c 	ldr	r2, [ip, #12]
33d089b8:	e083300a 	add	r3, r3, sl
33d089bc:	e7d33002 	ldrb	r3, [r3, r2]
33d089c0:	e5cc3010 	strb	r3, [ip, #16]
		printk (KERN_DEBUG "Bad block table at page %d, version 0x%02X\n", md->pages[0], md->version[0]);
33d089c4:	e59f02a8 	ldr	r0, [pc, #680]	; 33d08c74 <nand_scan_bbt+0x454>
33d089c8:	e59c1004 	ldr	r1, [ip, #4]
33d089cc:	e5dc2010 	ldrb	r2, [ip, #16]
33d089d0:	eb00397c 	bl	33d16fc8 <printf>
 * We assume that the bbt bits are in consecutive order.
 *
*/
static int read_abs_bbts (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td,
	struct nand_bbt_descr *md)
{
33d089d4:	ea000009 	b	33d08a00 <nand_scan_bbt+0x1e0>
*/
static int search_read_bbts (struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	/* Search the primary table */
	search_bbt (mtd, buf, td);
33d089d8:	e1a0100a 	mov	r1, sl
33d089dc:	e1a00006 	mov	r0, r6
33d089e0:	e59d201c 	ldr	r2, [sp, #28]
33d089e4:	ebfffcce 	bl	33d07d24 <search_bbt>

	/* Search the mirror table */
	if (md)
33d089e8:	e59d1018 	ldr	r1, [sp, #24]
33d089ec:	e3510000 	cmp	r1, #0	; 0x0
		search_bbt (mtd, buf, md);
33d089f0:	11a00006 	movne	r0, r6
33d089f4:	11a0100a 	movne	r1, sl
33d089f8:	159d2018 	ldrne	r2, [sp, #24]
33d089fc:	1bfffcc8 	blne	33d07d24 <search_bbt>
 * version nr. of one table is less than the other
*/
static int check_create (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
{
	int i, chips, writeops, chipsel, res;
	struct nand_chip *this = mtd->priv;
33d08a00:	e596213c 	ldr	r2, [r6, #316]
	struct nand_bbt_descr *td = this->bbt_td;
33d08a04:	e59240a8 	ldr	r4, [r2, #168]
	struct nand_bbt_descr *md = this->bbt_md;
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
33d08a08:	e5943000 	ldr	r3, [r4]
33d08a0c:	e3130080 	tst	r3, #128	; 0x80
static int check_create (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
{
	int i, chips, writeops, chipsel, res;
	struct nand_chip *this = mtd->priv;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
33d08a10:	e59250ac 	ldr	r5, [r2, #172]
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
33d08a14:	15922090 	ldrne	r2, [r2, #144]
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
33d08a18:	1a000003 	bne	33d08a2c <nand_scan_bbt+0x20c>
33d08a1c:	ea000001 	b	33d08a28 <nand_scan_bbt+0x208>
		}

		/* Write the mirror bad block table to the device ? */
		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
			res = write_bbt (mtd, buf, md, td, chipsel);
			if (res < 0)
33d08a20:	e1a04000 	mov	r4, r0
33d08a24:	ea000083 	b	33d08c38 <nand_scan_bbt+0x418>

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
	else
		chips = 1;
33d08a28:	e3a02001 	mov	r2, #1	; 0x1
33d08a2c:	e58d2010 	str	r2, [sp, #16]

	for (i = 0; i < chips; i++) {
33d08a30:	e59dc010 	ldr	ip, [sp, #16]
33d08a34:	e3a03000 	mov	r3, #0	; 0x0
33d08a38:	e153000c 	cmp	r3, ip
33d08a3c:	e58d3014 	str	r3, [sp, #20]
33d08a40:	aa00007b 	bge	33d08c34 <nand_scan_bbt+0x414>
33d08a44:	e1a09005 	mov	r9, r5
33d08a48:	e1a07004 	mov	r7, r4
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
33d08a4c:	e594c000 	ldr	ip, [r4]
33d08a50:	e59d1014 	ldr	r1, [sp, #20]
33d08a54:	e31c0080 	tst	ip, #128	; 0x80
33d08a58:	e59d3014 	ldr	r3, [sp, #20]
33d08a5c:	03e01000 	mvneq	r1, #0	; 0x0
		chips = this->numchips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
33d08a60:	e3a0b000 	mov	fp, #0	; 0x0
		rd = NULL;
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
		/* Mirrored table avilable ? */
		if (md) {
33d08a64:	e3550000 	cmp	r5, #0	; 0x0
	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
33d08a68:	e58d100c 	str	r1, [sp, #12]
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
33d08a6c:	e58db008 	str	fp, [sp, #8]
33d08a70:	e1a02103 	lsl	r2, r3, #2
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
		/* Mirrored table avilable ? */
		if (md) {
33d08a74:	0a00002a 	beq	33d08b24 <nand_scan_bbt+0x304>
			if (td->pages[i] == -1 && md->pages[i] == -1) {
33d08a78:	e0823004 	add	r3, r2, r4
33d08a7c:	e5933004 	ldr	r3, [r3, #4]
33d08a80:	e3730001 	cmn	r3, #1	; 0x1
33d08a84:	1a00000c 	bne	33d08abc <nand_scan_bbt+0x29c>
33d08a88:	e0823005 	add	r3, r2, r5
33d08a8c:	e5933004 	ldr	r3, [r3, #4]
33d08a90:	e3730001 	cmn	r3, #1	; 0x1
				writeops = 0x03;
33d08a94:	028bb003 	addeq	fp, fp, #3	; 0x3
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
		/* Mirrored table avilable ? */
		if (md) {
			if (td->pages[i] == -1 && md->pages[i] == -1) {
33d08a98:	0a000027 	beq	33d08b3c <nand_scan_bbt+0x31c>
				writeops = 0x03;
				goto create;
			}

			if (td->pages[i] == -1) {
33d08a9c:	e0823004 	add	r3, r2, r4
33d08aa0:	e5933004 	ldr	r3, [r3, #4]
33d08aa4:	e3730001 	cmn	r3, #1	; 0x1
				rd = md;
				td->version[i] = md->version[i];
33d08aa8:	05d93010 	ldrbeq	r3, [r9, #16]
				writeops = 0x03;
				goto create;
			}

			if (td->pages[i] == -1) {
				rd = md;
33d08aac:	01a02005 	moveq	r2, r5
				td->version[i] = md->version[i];
				writeops = 1;
33d08ab0:	03a0b001 	moveq	fp, #1	; 0x1
				goto create;
			}

			if (td->pages[i] == -1) {
				rd = md;
				td->version[i] = md->version[i];
33d08ab4:	05c73010 	strbeq	r3, [r7, #16]
			if (td->pages[i] == -1 && md->pages[i] == -1) {
				writeops = 0x03;
				goto create;
			}

			if (td->pages[i] == -1) {
33d08ab8:	0a00002b 	beq	33d08b6c <nand_scan_bbt+0x34c>
				td->version[i] = md->version[i];
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i] == -1) {
33d08abc:	e0823005 	add	r3, r2, r5
33d08ac0:	e5933004 	ldr	r3, [r3, #4]
33d08ac4:	e3730001 	cmn	r3, #1	; 0x1
				rd = td;
				md->version[i] = td->version[i];
33d08ac8:	05d73010 	ldrbeq	r3, [r7, #16]
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i] == -1) {
				rd = td;
33d08acc:	01a02004 	moveq	r2, r4
				md->version[i] = td->version[i];
				writeops = 2;
33d08ad0:	03a0b002 	moveq	fp, #2	; 0x2
				goto writecheck;
			}

			if (md->pages[i] == -1) {
				rd = td;
				md->version[i] = td->version[i];
33d08ad4:	05c93010 	strbeq	r3, [r9, #16]
				td->version[i] = md->version[i];
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i] == -1) {
33d08ad8:	0a000023 	beq	33d08b6c <nand_scan_bbt+0x34c>
				md->version[i] = td->version[i];
				writeops = 2;
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
33d08adc:	e5d70010 	ldrb	r0, [r7, #16]
33d08ae0:	e5d91010 	ldrb	r1, [r9, #16]
33d08ae4:	e1500001 	cmp	r0, r1
33d08ae8:	1a000003 	bne	33d08afc <nand_scan_bbt+0x2dc>
				rd = td;
				if (!(td->options & NAND_BBT_VERSION))
33d08aec:	e31c0c01 	tst	ip, #256	; 0x100
				writeops = 2;
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
				rd = td;
33d08af0:	e1a02004 	mov	r2, r4
				if (!(td->options & NAND_BBT_VERSION))
					rd2 = md;
33d08af4:	058d5008 	streq	r5, [sp, #8]
33d08af8:	ea00001b 	b	33d08b6c <nand_scan_bbt+0x34c>
				goto writecheck;
			}

			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
33d08afc:	e0613000 	rsb	r3, r1, r0
33d08b00:	e1a03c03 	lsl	r3, r3, #24
33d08b04:	e3530000 	cmp	r3, #0	; 0x0
				rd = td;
33d08b08:	c1a02004 	movgt	r2, r4
				md->version[i] = td->version[i];
				writeops = 2;
33d08b0c:	c3a0b002 	movgt	fp, #2	; 0x2
			} else {
				rd = md;
33d08b10:	d1a02005 	movle	r2, r5
				td->version[i] = md->version[i];
				writeops = 1;
33d08b14:	d3a0b001 	movle	fp, #1	; 0x1
				goto writecheck;
			}

			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
				rd = td;
				md->version[i] = td->version[i];
33d08b18:	c5c90010 	strbgt	r0, [r9, #16]
				writeops = 2;
			} else {
				rd = md;
				td->version[i] = md->version[i];
33d08b1c:	d5c71010 	strble	r1, [r7, #16]
				writeops = 1;
			}

			goto writecheck;
33d08b20:	ea000011 	b	33d08b6c <nand_scan_bbt+0x34c>

		} else {
			if (td->pages[i] == -1) {
33d08b24:	e0823004 	add	r3, r2, r4
33d08b28:	e5933004 	ldr	r3, [r3, #4]
33d08b2c:	e3730001 	cmn	r3, #1	; 0x1
				writeops = 0x01;
33d08b30:	03a0b001 	moveq	fp, #1	; 0x1
				goto create;
			}
			rd = td;
33d08b34:	11a02004 	movne	r2, r4
			goto writecheck;
33d08b38:	1a00000b 	bne	33d08b6c <nand_scan_bbt+0x34c>
		}
create:
		/* Create the bad block table by scanning the device ? */
		if (!(td->options & NAND_BBT_CREATE))
33d08b3c:	e31c0c02 	tst	ip, #512	; 0x200
33d08b40:	0a000033 	beq	33d08c14 <nand_scan_bbt+0x3f4>
			continue;

		/* Create the table in memory by scanning the chip(s) */
		create_bbt (mtd, buf, bd, chipsel);
33d08b44:	e59d300c 	ldr	r3, [sp, #12]
33d08b48:	e1a00006 	mov	r0, r6
33d08b4c:	e1a0100a 	mov	r1, sl
33d08b50:	e59d2020 	ldr	r2, [sp, #32]
33d08b54:	ebfffc07 	bl	33d07b78 <create_bbt>

		td->version[i] = 1;
33d08b58:	e3a03001 	mov	r3, #1	; 0x1
		if (md)
33d08b5c:	e3550000 	cmp	r5, #0	; 0x0
			continue;

		/* Create the table in memory by scanning the chip(s) */
		create_bbt (mtd, buf, bd, chipsel);

		td->version[i] = 1;
33d08b60:	e5c73010 	strb	r3, [r7, #16]
		if (md)
			md->version[i] = 1;
33d08b64:	15c93010 	strbne	r3, [r9, #16]
33d08b68:	ea00000b 	b	33d08b9c <nand_scan_bbt+0x37c>
writecheck:
		/* read back first ? */
		if (rd)
33d08b6c:	e3520000 	cmp	r2, #0	; 0x0
			read_abs_bbt (mtd, buf, rd, chipsel);
33d08b70:	11a00006 	movne	r0, r6
33d08b74:	11a0100a 	movne	r1, sl
33d08b78:	159d300c 	ldrne	r3, [sp, #12]
33d08b7c:	1bfffbc1 	blne	33d07a88 <read_abs_bbt>
		/* If they weren't versioned, read both. */
		if (rd2)
33d08b80:	e59dc008 	ldr	ip, [sp, #8]
33d08b84:	e35c0000 	cmp	ip, #0	; 0x0
			read_abs_bbt (mtd, buf, rd2, chipsel);
33d08b88:	11a0200c 	movne	r2, ip
33d08b8c:	11a00006 	movne	r0, r6
33d08b90:	11a0100a 	movne	r1, sl
33d08b94:	159d300c 	ldrne	r3, [sp, #12]
33d08b98:	1bfffbba 	blne	33d07a88 <read_abs_bbt>

		/* Write the bad block table to the device ? */
		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
33d08b9c:	e31b0001 	tst	fp, #1	; 0x1
33d08ba0:	0a00000b 	beq	33d08bd4 <nand_scan_bbt+0x3b4>
33d08ba4:	e5943000 	ldr	r3, [r4]
33d08ba8:	e3130a01 	tst	r3, #4096	; 0x1000
33d08bac:	0a000008 	beq	33d08bd4 <nand_scan_bbt+0x3b4>
			res = write_bbt (mtd, buf, td, md, chipsel);
33d08bb0:	e59dc00c 	ldr	ip, [sp, #12]
33d08bb4:	e1a00006 	mov	r0, r6
33d08bb8:	e1a0100a 	mov	r1, sl
33d08bbc:	e1a02004 	mov	r2, r4
33d08bc0:	e1a03005 	mov	r3, r5
33d08bc4:	e58dc000 	str	ip, [sp]
33d08bc8:	ebfffccf 	bl	33d07f0c <write_bbt>
			if (res < 0)
33d08bcc:	e3500000 	cmp	r0, #0	; 0x0
33d08bd0:	baffff92 	blt	33d08a20 <nand_scan_bbt+0x200>
				return res;
		}

		/* Write the mirror bad block table to the device ? */
		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
33d08bd4:	e2553000 	subs	r3, r5, #0	; 0x0
33d08bd8:	13a03001 	movne	r3, #1	; 0x1
33d08bdc:	e013b0ab 	ands	fp, r3, fp, lsr #1
33d08be0:	0a00000b 	beq	33d08c14 <nand_scan_bbt+0x3f4>
33d08be4:	e5953000 	ldr	r3, [r5]
33d08be8:	e3130a01 	tst	r3, #4096	; 0x1000
33d08bec:	0a000008 	beq	33d08c14 <nand_scan_bbt+0x3f4>
			res = write_bbt (mtd, buf, md, td, chipsel);
33d08bf0:	e59dc00c 	ldr	ip, [sp, #12]
33d08bf4:	e1a00006 	mov	r0, r6
33d08bf8:	e1a0100a 	mov	r1, sl
33d08bfc:	e1a02005 	mov	r2, r5
33d08c00:	e1a03004 	mov	r3, r4
33d08c04:	e58dc000 	str	ip, [sp]
33d08c08:	ebfffcbf 	bl	33d07f0c <write_bbt>
			if (res < 0)
33d08c0c:	e3500000 	cmp	r0, #0	; 0x0
33d08c10:	baffff82 	blt	33d08a20 <nand_scan_bbt+0x200>
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
33d08c14:	e59d1014 	ldr	r1, [sp, #20]
33d08c18:	e59d2010 	ldr	r2, [sp, #16]
33d08c1c:	e2811001 	add	r1, r1, #1	; 0x1
33d08c20:	e1510002 	cmp	r1, r2
33d08c24:	e58d1014 	str	r1, [sp, #20]
33d08c28:	e2877001 	add	r7, r7, #1	; 0x1
33d08c2c:	e2899001 	add	r9, r9, #1	; 0x1
33d08c30:	baffff85 	blt	33d08a4c <nand_scan_bbt+0x22c>
		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
			res = write_bbt (mtd, buf, md, td, chipsel);
			if (res < 0)
				return res;
		}
	}
33d08c34:	e3a04000 	mov	r4, #0	; 0x0

	if (res)
		res = check_create (mtd, buf, bd);

	/* Prevent the bbt regions from erasing / writing */
	mark_bbt_region (mtd, td);
33d08c38:	e59d101c 	ldr	r1, [sp, #28]
33d08c3c:	e1a00006 	mov	r0, r6
33d08c40:	ebfffe92 	bl	33d08690 <mark_bbt_region>
	if (md)
33d08c44:	e59d3018 	ldr	r3, [sp, #24]
33d08c48:	e3530000 	cmp	r3, #0	; 0x0
		mark_bbt_region (mtd, md);
33d08c4c:	11a00006 	movne	r0, r6
33d08c50:	11a01003 	movne	r1, r3
33d08c54:	1bfffe8d 	blne	33d08690 <mark_bbt_region>

	kfree (buf);
33d08c58:	e1a0000a 	mov	r0, sl
33d08c5c:	eb0039fc 	bl	33d17454 <free>
	return res;
33d08c60:	e1a00004 	mov	r0, r4
}
33d08c64:	e28dd024 	add	sp, sp, #36	; 0x24
33d08c68:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d08c6c:	33d266b0 	.word	0x33d266b0
33d08c70:	33d266d0 	.word	0x33d266d0
33d08c74:	33d266ec 	.word	0x33d266ec

33d08c78 <nand_default_bbt>:
 * This function selects the default bad block table
 * support for the device and calls the nand_scan_bbt function
 *
*/
int nand_default_bbt (struct mtd_info *mtd)
{
33d08c78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct nand_chip *this = mtd->priv;
33d08c7c:	e590c13c 	ldr	ip, [r0, #316]
	 * _good_ blocks. Erasing those blocks leads to loss
	 * of the good / bad information, so we _must_ store
	 * this information in a good / bad table during
	 * startup
	*/
	if (this->options & NAND_IS_AND) {
33d08c80:	e59c2088 	ldr	r2, [ip, #136]
33d08c84:	e3120020 	tst	r2, #32	; 0x20
 * This function selects the default bad block table
 * support for the device and calls the nand_scan_bbt function
 *
*/
int nand_default_bbt (struct mtd_info *mtd)
{
33d08c88:	e1a0e000 	mov	lr, r0
	 * _good_ blocks. Erasing those blocks leads to loss
	 * of the good / bad information, so we _must_ store
	 * this information in a good / bad table during
	 * startup
	*/
	if (this->options & NAND_IS_AND) {
33d08c8c:	0a000009 	beq	33d08cb8 <nand_default_bbt+0x40>
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
33d08c90:	e59c30a8 	ldr	r3, [ip, #168]
33d08c94:	e3530000 	cmp	r3, #0	; 0x0
			this->bbt_td = &bbt_main_descr;
33d08c98:	059f3090 	ldreq	r3, [pc, #144]	; 33d08d30 <nand_default_bbt+0xb8>
33d08c9c:	058c30a8 	streq	r3, [ip, #168]
			this->bbt_md = &bbt_mirror_descr;
33d08ca0:	059f308c 	ldreq	r3, [pc, #140]	; 33d08d34 <nand_default_bbt+0xbc>
		}
		this->options |= NAND_USE_FLASH_BBT;
		return nand_scan_bbt (mtd, &agand_flashbased);
33d08ca4:	e59f108c 	ldr	r1, [pc, #140]	; 33d08d38 <nand_default_bbt+0xc0>
	*/
	if (this->options & NAND_IS_AND) {
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
			this->bbt_td = &bbt_main_descr;
			this->bbt_md = &bbt_mirror_descr;
33d08ca8:	058c30ac 	streq	r3, [ip, #172]
		}
		this->options |= NAND_USE_FLASH_BBT;
33d08cac:	e3823801 	orr	r3, r2, #65536	; 0x10000
33d08cb0:	e58c3088 	str	r3, [ip, #136]
33d08cb4:	ea00001b 	b	33d08d28 <nand_default_bbt+0xb0>
		return nand_scan_bbt (mtd, &agand_flashbased);
	}


	/* Is a flash based bad block table requested ? */
	if (this->options & NAND_USE_FLASH_BBT) {
33d08cb8:	e2122801 	ands	r2, r2, #65536	; 0x10000
33d08cbc:	0a00000c 	beq	33d08cf4 <nand_default_bbt+0x7c>
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
33d08cc0:	e59c30a8 	ldr	r3, [ip, #168]
33d08cc4:	e3530000 	cmp	r3, #0	; 0x0
			this->bbt_td = &bbt_main_descr;
33d08cc8:	059f3060 	ldreq	r3, [pc, #96]	; 33d08d30 <nand_default_bbt+0xb8>
33d08ccc:	058c30a8 	streq	r3, [ip, #168]
			this->bbt_md = &bbt_mirror_descr;
33d08cd0:	059f305c 	ldreq	r3, [pc, #92]	; 33d08d34 <nand_default_bbt+0xbc>
33d08cd4:	058c30ac 	streq	r3, [ip, #172]
		}
		if (!this->badblock_pattern) {
33d08cd8:	e59c30b0 	ldr	r3, [ip, #176]
33d08cdc:	e3530000 	cmp	r3, #0	; 0x0
			this->badblock_pattern = (mtd->oobblock > 512) ?
33d08ce0:	05903010 	ldreq	r3, [r0, #16]
33d08ce4:	059f2050 	ldreq	r2, [pc, #80]	; 33d08d3c <nand_default_bbt+0xc4>
33d08ce8:	059f1050 	ldreq	r1, [pc, #80]	; 33d08d40 <nand_default_bbt+0xc8>
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
			this->bbt_td = &bbt_main_descr;
			this->bbt_md = &bbt_mirror_descr;
		}
		if (!this->badblock_pattern) {
33d08cec:	0a000008 	beq	33d08d14 <nand_default_bbt+0x9c>
33d08cf0:	ea00000a 	b	33d08d20 <nand_default_bbt+0xa8>
				&largepage_flashbased : &smallpage_flashbased;
		}
	} else {
		this->bbt_td = NULL;
		this->bbt_md = NULL;
		if (!this->badblock_pattern) {
33d08cf4:	e59c30b0 	ldr	r3, [ip, #176]
33d08cf8:	e3530000 	cmp	r3, #0	; 0x0
			this->badblock_pattern = (mtd->oobblock > 512) ?
				&largepage_flashbased : &smallpage_flashbased;
		}
	} else {
		this->bbt_td = NULL;
		this->bbt_md = NULL;
33d08cfc:	e58c20ac 	str	r2, [ip, #172]
		if (!this->badblock_pattern) {
			this->badblock_pattern = (mtd->oobblock > 512) ?
				&largepage_flashbased : &smallpage_flashbased;
		}
	} else {
		this->bbt_td = NULL;
33d08d00:	e58c20a8 	str	r2, [ip, #168]
		this->bbt_md = NULL;
		if (!this->badblock_pattern) {
33d08d04:	1a000005 	bne	33d08d20 <nand_default_bbt+0xa8>
			this->badblock_pattern = (mtd->oobblock > 512) ?
33d08d08:	e5903010 	ldr	r3, [r0, #16]
33d08d0c:	e59f2030 	ldr	r2, [pc, #48]	; 33d08d44 <nand_default_bbt+0xcc>
33d08d10:	e59f1030 	ldr	r1, [pc, #48]	; 33d08d48 <nand_default_bbt+0xd0>
33d08d14:	e3530c02 	cmp	r3, #512	; 0x200
33d08d18:	81a02001 	movhi	r2, r1
33d08d1c:	e58c20b0 	str	r2, [ip, #176]
				&largepage_memorybased : &smallpage_memorybased;
		}
	}
	return nand_scan_bbt (mtd, this->badblock_pattern);
33d08d20:	e59c10b0 	ldr	r1, [ip, #176]
33d08d24:	e1a0000e 	mov	r0, lr
}
33d08d28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
		if (!this->badblock_pattern) {
			this->badblock_pattern = (mtd->oobblock > 512) ?
				&largepage_memorybased : &smallpage_memorybased;
		}
	}
	return nand_scan_bbt (mtd, this->badblock_pattern);
33d08d2c:	eafffebb 	b	33d08820 <nand_scan_bbt>
33d08d30:	33d2e688 	.word	0x33d2e688
33d08d34:	33d2e660 	.word	0x33d2e660
33d08d38:	33d2e634 	.word	0x33d2e634
33d08d3c:	33d2e5ec 	.word	0x33d2e5ec
33d08d40:	33d2e610 	.word	0x33d2e610
33d08d44:	33d2e5a0 	.word	0x33d2e5a0
33d08d48:	33d2e5c8 	.word	0x33d2e5c8

33d08d4c <nand_isbad_bbt>:
 * @offs:	offset in the device
 * @allowbbt:	allow access to bad block table region
 *
 */
int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt)
{
33d08d4c:	e92d4030 	push	{r4, r5, lr}
	struct nand_chip *this = mtd->priv;
33d08d50:	e590413c 	ldr	r4, [r0, #316]
	int block;
	uint8_t	res;

	/* Get block number * 2 */
	block = (int) (offs >> (this->bbt_erase_shift - 1));
33d08d54:	e594c070 	ldr	ip, [r4, #112]
33d08d58:	e1a00001 	mov	r0, r1
33d08d5c:	e1a01002 	mov	r1, r2
33d08d60:	e24c2001 	sub	r2, ip, #1	; 0x1
 * @offs:	offset in the device
 * @allowbbt:	allow access to bad block table region
 *
 */
int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt)
{
33d08d64:	e1a05003 	mov	r5, r3
	struct nand_chip *this = mtd->priv;
	int block;
	uint8_t	res;

	/* Get block number * 2 */
	block = (int) (offs >> (this->bbt_erase_shift - 1));
33d08d68:	eb005635 	bl	33d1e644 <__ashrdi3>
	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
33d08d6c:	e59430a4 	ldr	r3, [r4, #164]
33d08d70:	e7d331c0 	ldrb	r3, [r3, r0, asr #3]
33d08d74:	e2000006 	and	r0, r0, #6	; 0x6
33d08d78:	e1a03053 	asr	r3, r3, r0
33d08d7c:	e2030003 	and	r0, r3, #3	; 0x3

	DEBUG (MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",
		(unsigned int)offs, res, block >> 1);

	switch ((int)res) {
33d08d80:	e3500001 	cmp	r0, #1	; 0x1
33d08d84:	08bd8030 	popeq	{r4, r5, pc}
33d08d88:	ca000002 	bgt	33d08d98 <nand_isbad_bbt+0x4c>
33d08d8c:	e3500000 	cmp	r0, #0	; 0x0
33d08d90:	08bd8030 	popeq	{r4, r5, pc}
33d08d94:	ea000004 	b	33d08dac <nand_isbad_bbt+0x60>
33d08d98:	e3500002 	cmp	r0, #2	; 0x2
33d08d9c:	1a000002 	bne	33d08dac <nand_isbad_bbt+0x60>
	case 0x00:	return 0;
	case 0x01:	return 1;
	case 0x02:	return allowbbt ? 0 : 1;
33d08da0:	e2750001 	rsbs	r0, r5, #1	; 0x1
33d08da4:	33a00000 	movcc	r0, #0	; 0x0
33d08da8:	e8bd8030 	pop	{r4, r5, pc}
	}
	return 1;
33d08dac:	e3a00001 	mov	r0, #1	; 0x1
}
33d08db0:	e8bd8030 	pop	{r4, r5, pc}

33d08db4 <embedsky_lcd_ClearScr>:
**************************************************************/
void embedsky_lcd_ClearScr( U32 c)
{
	unsigned int x,y ;

	for( y = 0 ; y < LCD_YSIZE_TFT ; y++ )
33d08db4:	e3a0c000 	mov	ip, #0	; 0x0

/**************************************************************
TFT LCD全屏填充特定颜色单元或清屏
**************************************************************/
void embedsky_lcd_ClearScr( U32 c)
{
33d08db8:	e92d4010 	push	{r4, lr}
33d08dbc:	e1a0e00c 	mov	lr, ip
	unsigned int x,y ;

	for( y = 0 ; y < LCD_YSIZE_TFT ; y++ )
	{
		for( x = 0 ; x < (SCR_XSIZE_TFT) ; x++ )
33d08dc0:	e59f4030 	ldr	r4, [pc, #48]	; 33d08df8 <embedsky_lcd_ClearScr+0x44>
33d08dc4:	e3a01000 	mov	r1, #0	; 0x0
33d08dc8:	e1a0208e 	lsl	r2, lr, #1
33d08dcc:	e2811001 	add	r1, r1, #1	; 0x1
		{
			embedsky_LCD_BUFFER[y][x] = c;
33d08dd0:	e59f3024 	ldr	r3, [pc, #36]	; 33d08dfc <embedsky_lcd_ClearScr+0x48>
{
	unsigned int x,y ;

	for( y = 0 ; y < LCD_YSIZE_TFT ; y++ )
	{
		for( x = 0 ; x < (SCR_XSIZE_TFT) ; x++ )
33d08dd4:	e1510004 	cmp	r1, r4
		{
			embedsky_LCD_BUFFER[y][x] = c;
33d08dd8:	e18200b3 	strh	r0, [r2, r3]
33d08ddc:	e2822002 	add	r2, r2, #2	; 0x2
{
	unsigned int x,y ;

	for( y = 0 ; y < LCD_YSIZE_TFT ; y++ )
	{
		for( x = 0 ; x < (SCR_XSIZE_TFT) ; x++ )
33d08de0:	9afffff9 	bls	33d08dcc <embedsky_lcd_ClearScr+0x18>
**************************************************************/
void embedsky_lcd_ClearScr( U32 c)
{
	unsigned int x,y ;

	for( y = 0 ; y < LCD_YSIZE_TFT ; y++ )
33d08de4:	e28cc001 	add	ip, ip, #1	; 0x1
33d08de8:	e35c00ef 	cmp	ip, #239	; 0xef
33d08dec:	e28eed05 	add	lr, lr, #320	; 0x140
33d08df0:	9afffff2 	bls	33d08dc0 <embedsky_lcd_ClearScr+0xc>
33d08df4:	e8bd8010 	pop	{r4, pc}
33d08df8:	0000013f 	.word	0x0000013f
33d08dfc:	33d39b2c 	.word	0x33d39b2c

33d08e00 <embedsky_lcd_ClearScr_Rectangle>:

/**************************************************************
TFT LCD指定大小的矩形填充特定颜色单元或清屏
**************************************************************/
void embedsky_lcd_ClearScr_Rectangle( int x0,int y0,int width,int height, U32 c)
{
33d08e00:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	unsigned int x,y ;
		
	for( y = y0 ; y < (y0 + height) ; y++ )
33d08e04:	e0814003 	add	r4, r1, r3
33d08e08:	e1510004 	cmp	r1, r4

/**************************************************************
TFT LCD指定大小的矩形填充特定颜色单元或清屏
**************************************************************/
void embedsky_lcd_ClearScr_Rectangle( int x0,int y0,int width,int height, U32 c)
{
33d08e0c:	e1a06000 	mov	r6, r0
33d08e10:	e1a05002 	mov	r5, r2
33d08e14:	e59d7014 	ldr	r7, [sp, #20]
	unsigned int x,y ;
		
	for( y = y0 ; y < (y0 + height) ; y++ )
33d08e18:	28bd80f0 	popcs	{r4, r5, r6, r7, pc}
33d08e1c:	e0813101 	add	r3, r1, r1, lsl #2
33d08e20:	e1a02303 	lsl	r2, r3, #6
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08e24:	e0850006 	add	r0, r5, r6
33d08e28:	e1560000 	cmp	r6, r0
33d08e2c:	e1a0c006 	mov	ip, r6
33d08e30:	2a000007 	bcs	33d08e54 <embedsky_lcd_ClearScr_Rectangle+0x54>
33d08e34:	e0863002 	add	r3, r6, r2
33d08e38:	e1a0e083 	lsl	lr, r3, #1
33d08e3c:	e28cc001 	add	ip, ip, #1	; 0x1
		{
			embedsky_LCD_BUFFER[y][x] = c;
33d08e40:	e59f3020 	ldr	r3, [pc, #32]	; 33d08e68 <embedsky_lcd_ClearScr_Rectangle+0x68>
{
	unsigned int x,y ;
		
	for( y = y0 ; y < (y0 + height) ; y++ )
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08e44:	e15c0000 	cmp	ip, r0
		{
			embedsky_LCD_BUFFER[y][x] = c;
33d08e48:	e18e70b3 	strh	r7, [lr, r3]
33d08e4c:	e28ee002 	add	lr, lr, #2	; 0x2
{
	unsigned int x,y ;
		
	for( y = y0 ; y < (y0 + height) ; y++ )
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08e50:	3afffff9 	bcc	33d08e3c <embedsky_lcd_ClearScr_Rectangle+0x3c>
**************************************************************/
void embedsky_lcd_ClearScr_Rectangle( int x0,int y0,int width,int height, U32 c)
{
	unsigned int x,y ;
		
	for( y = y0 ; y < (y0 + height) ; y++ )
33d08e54:	e2811001 	add	r1, r1, #1	; 0x1
33d08e58:	e1510004 	cmp	r1, r4
33d08e5c:	e2822d05 	add	r2, r2, #320	; 0x140
33d08e60:	3affffef 	bcc	33d08e24 <embedsky_lcd_ClearScr_Rectangle+0x24>
33d08e64:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d08e68:	33d39b2c 	.word	0x33d39b2c

33d08e6c <embedsky_paint_Bmp>:

/**************************************************************
在LCD屏幕上指定坐标点画一个指定大小的图片
**************************************************************/
void embedsky_paint_Bmp(int x0,int y0,int width,int height, unsigned char bmp[])
{
33d08e6c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int x, y ;
	U32 c ;
	int p = 0 ;

	for( y = y0 ; y < (height + y0) ; y++ )
33d08e70:	e0836001 	add	r6, r3, r1
33d08e74:	e1510006 	cmp	r1, r6

/**************************************************************
在LCD屏幕上指定坐标点画一个指定大小的图片
**************************************************************/
void embedsky_paint_Bmp(int x0,int y0,int width,int height, unsigned char bmp[])
{
33d08e78:	e1a0a000 	mov	sl, r0
33d08e7c:	e1a07002 	mov	r7, r2
33d08e80:	e59d901c 	ldr	r9, [sp, #28]
	int x, y ;
	U32 c ;
	int p = 0 ;
33d08e84:	e3a04000 	mov	r4, #0	; 0x0

	for( y = y0 ; y < (height + y0) ; y++ )
33d08e88:	a8bd86f0 	popge	{r4, r5, r6, r7, r9, sl, pc}
33d08e8c:	e0813101 	add	r3, r1, r1, lsl #2
33d08e90:	e1a00303 	lsl	r0, r3, #6
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08e94:	e087500a 	add	r5, r7, sl
33d08e98:	e15a0005 	cmp	sl, r5
33d08e9c:	e1a0c00a 	mov	ip, sl
33d08ea0:	aa00000e 	bge	33d08ee0 <embedsky_paint_Bmp+0x74>
33d08ea4:	e08a3000 	add	r3, sl, r0
33d08ea8:	e1a0e083 	lsl	lr, r3, #1
		{
			c = bmp[p+1] | (bmp[p] << 8) ;
33d08eac:	e0893004 	add	r3, r9, r4
33d08eb0:	e5d32001 	ldrb	r2, [r3, #1]
33d08eb4:	e7d93004 	ldrb	r3, [r9, r4]

			if ( ( x <= (SCR_XSIZE_TFT) ) && ( y <= LCD_YSIZE_TFT ) )
33d08eb8:	e35c0d05 	cmp	ip, #320	; 0x140
33d08ebc:	d35100f0 	cmple	r1, #240	; 0xf0

	for( y = y0 ; y < (height + y0) ; y++ )
	{
		for( x = x0 ; x < (width + x0) ; x++ )
		{
			c = bmp[p+1] | (bmp[p] << 8) ;
33d08ec0:	e1822403 	orr	r2, r2, r3, lsl #8

			if ( ( x <= (SCR_XSIZE_TFT) ) && ( y <= LCD_YSIZE_TFT ) )
				embedsky_LCD_BUFFER[y][x] = c;
33d08ec4:	d59f3028 	ldrle	r3, [pc, #40]	; 33d08ef4 <embedsky_paint_Bmp+0x88>
	U32 c ;
	int p = 0 ;

	for( y = y0 ; y < (height + y0) ; y++ )
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08ec8:	e28cc001 	add	ip, ip, #1	; 0x1
		{
			c = bmp[p+1] | (bmp[p] << 8) ;

			if ( ( x <= (SCR_XSIZE_TFT) ) && ( y <= LCD_YSIZE_TFT ) )
				embedsky_LCD_BUFFER[y][x] = c;
33d08ecc:	d18e20b3 	strhle	r2, [lr, r3]
	U32 c ;
	int p = 0 ;

	for( y = y0 ; y < (height + y0) ; y++ )
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08ed0:	e15c0005 	cmp	ip, r5
		{
			c = bmp[p+1] | (bmp[p] << 8) ;

			if ( ( x <= (SCR_XSIZE_TFT) ) && ( y <= LCD_YSIZE_TFT ) )
				embedsky_LCD_BUFFER[y][x] = c;
			p = p + 2 ;
33d08ed4:	e2844002 	add	r4, r4, #2	; 0x2
33d08ed8:	e28ee002 	add	lr, lr, #2	; 0x2
	U32 c ;
	int p = 0 ;

	for( y = y0 ; y < (height + y0) ; y++ )
	{
		for( x = x0 ; x < (width + x0) ; x++ )
33d08edc:	bafffff2 	blt	33d08eac <embedsky_paint_Bmp+0x40>
{
	int x, y ;
	U32 c ;
	int p = 0 ;

	for( y = y0 ; y < (height + y0) ; y++ )
33d08ee0:	e2811001 	add	r1, r1, #1	; 0x1
33d08ee4:	e1510006 	cmp	r1, r6
33d08ee8:	e2800d05 	add	r0, r0, #320	; 0x140
33d08eec:	baffffe8 	blt	33d08e94 <embedsky_paint_Bmp+0x28>
33d08ef0:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d08ef4:	33d39b2c 	.word	0x33d39b2c

33d08ef8 <putPixel>:
在LCD上指定位置画点
**************************************************************/
void putPixel(U32 x, U32 y, U32 c)
{
	if( (x < LCD_XSIZE_TFT) && (y < LCD_YSIZE_TFT))
		embedsky_LCD_BUFFER[y][x] = c;
33d08ef8:	e0813101 	add	r3, r1, r1, lsl #2
33d08efc:	e0803303 	add	r3, r0, r3, lsl #6
/**************************************************************
在LCD上指定位置画点
**************************************************************/
void putPixel(U32 x, U32 y, U32 c)
{
	if( (x < LCD_XSIZE_TFT) && (y < LCD_YSIZE_TFT))
33d08f00:	e35100ef 	cmp	r1, #239	; 0xef
33d08f04:	93500d05 	cmpls	r0, #320	; 0x140
		embedsky_LCD_BUFFER[y][x] = c;
33d08f08:	e1a0c083 	lsl	ip, r3, #1
33d08f0c:	359f3004 	ldrcc	r3, [pc, #4]	; 33d08f18 <putPixel+0x20>
33d08f10:	318c20b3 	strhcc	r2, [ip, r3]
33d08f14:	e1a0f00e 	mov	pc, lr
33d08f18:	33d39b2c 	.word	0x33d39b2c

33d08f1c <drawProcessBar>:
	U32 bar_base = LCD_YSIZE_TFT - bar_height;
	int i = (int) LCD_XSIZE_TFT / 8;
	U32 j;

	int pbcolor ;
	if(total != -1)
33d08f1c:	e3700001 	cmn	r0, #1	; 0x1
LCD滚动条的显示(在Nand Flash读取时调用)
current当前字节数，total总共的字节数，PBcolor滚动条的颜色
*******************************************************************/
U32 currWidth = 0;
void drawProcessBar(U32 total, U32 current )
{
33d08f20:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d08f24:	e1a07000 	mov	r7, r0
33d08f28:	e1a06001 	mov	r6, r1
	U32 bar_base = LCD_YSIZE_TFT - bar_height;
	int i = (int) LCD_XSIZE_TFT / 8;
	U32 j;

	int pbcolor ;
	if(total != -1)
33d08f2c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
	{
		j = 0;
		int bar_width = (int) LCD_XSIZE_TFT * ((current * 1.0) / total);
33d08f30:	e1a00001 	mov	r0, r1
33d08f34:	eb006b1e 	bl	33d23bb4 <__floatsidf>
33d08f38:	e3560000 	cmp	r6, #0	; 0x0
33d08f3c:	e1a05001 	mov	r5, r1
33d08f40:	e1a04000 	mov	r4, r0
	U32 j;

	int pbcolor ;
	if(total != -1)
	{
		j = 0;
33d08f44:	e3a06000 	mov	r6, #0	; 0x0
		int bar_width = (int) LCD_XSIZE_TFT * ((current * 1.0) / total);
33d08f48:	aa000004 	bge	33d08f60 <drawProcessBar+0x44>
33d08f4c:	e28f20dc 	add	r2, pc, #220	; 0xdc
33d08f50:	e892000c 	ldm	r2, {r2, r3}
33d08f54:	eb006a53 	bl	33d238a8 <__adddf3>
33d08f58:	e1a05001 	mov	r5, r1
33d08f5c:	e1a04000 	mov	r4, r0
33d08f60:	e1a00007 	mov	r0, r7
33d08f64:	eb006b12 	bl	33d23bb4 <__floatsidf>
33d08f68:	e3570000 	cmp	r7, #0	; 0x0
33d08f6c:	b28f20bc 	addlt	r2, pc, #188	; 0xbc
33d08f70:	b892000c 	ldmlt	r2, {r2, r3}
33d08f74:	bb006a4b 	bllt	33d238a8 <__adddf3>
33d08f78:	e1a03001 	mov	r3, r1
33d08f7c:	e1a02000 	mov	r2, r0
33d08f80:	e1a01005 	mov	r1, r5
33d08f84:	e1a00004 	mov	r0, r4
33d08f88:	eb006bec 	bl	33d23f40 <__divdf3>
33d08f8c:	e28f20a4 	add	r2, pc, #164	; 0xa4
33d08f90:	e892000c 	ldm	r2, {r2, r3}
33d08f94:	eb006b24 	bl	33d23c2c <__muldf3>
33d08f98:	eb006c83 	bl	33d241ac <__fixdfsi>
		if (bar_width <= i)
33d08f9c:	e3500028 	cmp	r0, #40	; 0x28

	int pbcolor ;
	if(total != -1)
	{
		j = 0;
		int bar_width = (int) LCD_XSIZE_TFT * ((current * 1.0) / total);
33d08fa0:	e1a04000 	mov	r4, r0
		if (bar_width <= i)
			pbcolor = 0x7FF;					//sky blue
33d08fa4:	d59fa094 	ldrle	sl, [pc, #148]	; 33d09040 <drawProcessBar+0x124>
	int pbcolor ;
	if(total != -1)
	{
		j = 0;
		int bar_width = (int) LCD_XSIZE_TFT * ((current * 1.0) / total);
		if (bar_width <= i)
33d08fa8:	da000013 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0x7FF;					//sky blue
		else if((bar_width > i) && (bar_width <= i * 2))
33d08fac:	e3500050 	cmp	r0, #80	; 0x50
			pbcolor = 0x1F;						//blue
33d08fb0:	d3a0a01f 	movle	sl, #31	; 0x1f
	{
		j = 0;
		int bar_width = (int) LCD_XSIZE_TFT * ((current * 1.0) / total);
		if (bar_width <= i)
			pbcolor = 0x7FF;					//sky blue
		else if((bar_width > i) && (bar_width <= i * 2))
33d08fb4:	da000010 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0x1F;						//blue
		else if((bar_width > i * 2) && (bar_width <= i * 3))
33d08fb8:	e3500078 	cmp	r0, #120	; 0x78
			pbcolor = 0x0;						//black
33d08fbc:	d1a0a006 	movle	sl, r6
		int bar_width = (int) LCD_XSIZE_TFT * ((current * 1.0) / total);
		if (bar_width <= i)
			pbcolor = 0x7FF;					//sky blue
		else if((bar_width > i) && (bar_width <= i * 2))
			pbcolor = 0x1F;						//blue
		else if((bar_width > i * 2) && (bar_width <= i * 3))
33d08fc0:	da00000d 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0x0;						//black
		else if((bar_width > i * 3) && (bar_width <= i * 4))
33d08fc4:	e35000a0 	cmp	r0, #160	; 0xa0
			pbcolor = 0xF81F;					//purple
33d08fc8:	d59fa074 	ldrle	sl, [pc, #116]	; 33d09044 <drawProcessBar+0x128>
			pbcolor = 0x7FF;					//sky blue
		else if((bar_width > i) && (bar_width <= i * 2))
			pbcolor = 0x1F;						//blue
		else if((bar_width > i * 2) && (bar_width <= i * 3))
			pbcolor = 0x0;						//black
		else if((bar_width > i * 3) && (bar_width <= i * 4))
33d08fcc:	da00000a 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0xF81F;					//purple
		else if((bar_width > i * 4) && (bar_width <= i * 5))
33d08fd0:	e35000c8 	cmp	r0, #200	; 0xc8
			pbcolor = 0xFFFF;					//white
33d08fd4:	d59fa06c 	ldrle	sl, [pc, #108]	; 33d09048 <drawProcessBar+0x12c>
			pbcolor = 0x1F;						//blue
		else if((bar_width > i * 2) && (bar_width <= i * 3))
			pbcolor = 0x0;						//black
		else if((bar_width > i * 3) && (bar_width <= i * 4))
			pbcolor = 0xF81F;					//purple
		else if((bar_width > i * 4) && (bar_width <= i * 5))
33d08fd8:	da000007 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0xFFFF;					//white
		else if((bar_width > i * 5) && (bar_width <= i * 6))
33d08fdc:	e35000f0 	cmp	r0, #240	; 0xf0
			pbcolor = 0xF800;					//red
33d08fe0:	d3a0ab3e 	movle	sl, #63488	; 0xf800
			pbcolor = 0x0;						//black
		else if((bar_width > i * 3) && (bar_width <= i * 4))
			pbcolor = 0xF81F;					//purple
		else if((bar_width > i * 4) && (bar_width <= i * 5))
			pbcolor = 0xFFFF;					//white
		else if((bar_width > i * 5) && (bar_width <= i * 6))
33d08fe4:	da000004 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0xF800;					//red
		else if((bar_width > i * 6) && (bar_width <= i * 7))
33d08fe8:	e3500f46 	cmp	r0, #280	; 0x118
			pbcolor = 0xFFE0;					//yellow
33d08fec:	d59fa058 	ldrle	sl, [pc, #88]	; 33d0904c <drawProcessBar+0x130>
			pbcolor = 0xF81F;					//purple
		else if((bar_width > i * 4) && (bar_width <= i * 5))
			pbcolor = 0xFFFF;					//white
		else if((bar_width > i * 5) && (bar_width <= i * 6))
			pbcolor = 0xF800;					//red
		else if((bar_width > i * 6) && (bar_width <= i * 7))
33d08ff0:	da000001 	ble	33d08ffc <drawProcessBar+0xe0>
			pbcolor = 0xFFE0;					//yellow
		else if((bar_width > i * 7) && (bar_width <= i * 8))
			pbcolor = 0x7E0;					//green
33d08ff4:	e3500d05 	cmp	r0, #320	; 0x140
33d08ff8:	d3a0ae7e 	movle	sl, #2016	; 0x7e0

		if(bar_width > currWidth)
33d08ffc:	e59f504c 	ldr	r5, [pc, #76]	; 33d09050 <drawProcessBar+0x134>
33d09000:	e5953000 	ldr	r3, [r5]
33d09004:	e1540003 	cmp	r4, r3
33d09008:	98bd84f0 	popls	{r4, r5, r6, r7, sl, pc}
		{
			for ( ; j < bar_height; j++)
			{
				putPixel(bar_width, j + bar_base, pbcolor);
33d0900c:	e28610e8 	add	r1, r6, #232	; 0xe8
33d09010:	e1a00004 	mov	r0, r4
		else if((bar_width > i * 7) && (bar_width <= i * 8))
			pbcolor = 0x7E0;					//green

		if(bar_width > currWidth)
		{
			for ( ; j < bar_height; j++)
33d09014:	e2866001 	add	r6, r6, #1	; 0x1
			{
				putPixel(bar_width, j + bar_base, pbcolor);
33d09018:	e1a0200a 	mov	r2, sl
33d0901c:	ebffffb5 	bl	33d08ef8 <putPixel>
		else if((bar_width > i * 7) && (bar_width <= i * 8))
			pbcolor = 0x7E0;					//green

		if(bar_width > currWidth)
		{
			for ( ; j < bar_height; j++)
33d09020:	e3560007 	cmp	r6, #7	; 0x7
33d09024:	9afffff8 	bls	33d0900c <drawProcessBar+0xf0>
			{
				putPixel(bar_width, j + bar_base, pbcolor);
			}
			currWidth = bar_width;
33d09028:	e5854000 	str	r4, [r5]
33d0902c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d09030:	41f00000 	.word	0x41f00000
33d09034:	00000000 	.word	0x00000000
33d09038:	40740000 	.word	0x40740000
33d0903c:	00000000 	.word	0x00000000
33d09040:	000007ff 	.word	0x000007ff
33d09044:	0000f81f 	.word	0x0000f81f
33d09048:	0000ffff 	.word	0x0000ffff
33d0904c:	0000ffe0 	.word	0x0000ffe0
33d09050:	33d39b28 	.word	0x33d39b28

33d09054 <embedsky_lcd_PowerEnable>:
{
    return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
}
static inline S3C24X0_GPIO * const S3C24X0_GetBase_GPIO(void)
{
    return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
33d09054:	e3a02456 	mov	r2, #1442840576	; 0x56000000
void embedsky_lcd_PowerEnable(int invpwren , int pwren)
{
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO() ;
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;
										//GPG4 is setted as LCD_PWREN
	gpio -> GPGUP = gpio -> GPGUP & (( ~( 1 << 4) ) | ( 1 << 4) );		// Pull-up disable
33d09058:	e5923068 	ldr	r3, [r2, #104]
33d0905c:	e5823068 	str	r3, [r2, #104]
	gpio -> GPGCON = gpio -> GPGCON & (( ~( 3 << 8) ) | ( 3 << 8) );		//GPG4=LCD_PWREN
33d09060:	e5923060 	ldr	r3, [r2, #96]
33d09064:	e5823060 	str	r3, [r2, #96]
	gpio -> GPGDAT = gpio -> GPGDAT | (1 << 4 ) ;
33d09068:	e5923064 	ldr	r3, [r2, #100]
33d0906c:	e3833010 	orr	r3, r3, #16	; 0x10
33d09070:	e5823064 	str	r3, [r2, #100]
{
    return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
}
static inline S3C24X0_LCD * const S3C24X0_GetBase_LCD(void)
{
    return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
33d09074:	e3a0c44d 	mov	ip, #1291845632	; 0x4d000000
										//invpwren=pwren;
										//Enable LCD POWER ENABLE Function
	lcd -> LCDCON5 = lcd -> LCDCON5 & (( ~( 1 << 3 ) ) | ( pwren << 3 ) );	// PWREN
33d09078:	e59c2010 	ldr	r2, [ip, #16]
33d0907c:	e3e03008 	mvn	r3, #8	; 0x8
33d09080:	e1833181 	orr	r3, r3, r1, lsl #3
33d09084:	e0022003 	and	r2, r2, r3
33d09088:	e58c2010 	str	r2, [ip, #16]
	lcd -> LCDCON5 = lcd -> LCDCON5 & (( ~( 1 << 5 ) ) | ( invpwren << 5 ) );	// INVPWREN
33d0908c:	e3e03020 	mvn	r3, #32	; 0x20
33d09090:	e59c2010 	ldr	r2, [ip, #16]
33d09094:	e1833280 	orr	r3, r3, r0, lsl #5
33d09098:	e0022003 	and	r2, r2, r3
33d0909c:	e58c2010 	str	r2, [ip, #16]
33d090a0:	e1a0f00e 	mov	pc, lr

33d090a4 <embedsky_lcd_EnvidOnOff>:
**************************************************************/
void embedsky_lcd_EnvidOnOff(int onoff)
{
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	if( onoff == 1 )
33d090a4:	e3500001 	cmp	r0, #1	; 0x1
33d090a8:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
		lcd -> LCDCON1 |= 1 ;						// ENVID=ON
	else
		lcd -> LCDCON1 = lcd -> LCDCON1 & 0x3fffe ;			// ENVID Off
33d090ac:	15923000 	ldrne	r3, [r2]
void embedsky_lcd_EnvidOnOff(int onoff)
{
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	if( onoff == 1 )
		lcd -> LCDCON1 |= 1 ;						// ENVID=ON
33d090b0:	05923000 	ldreq	r3, [r2]
	else
		lcd -> LCDCON1 = lcd -> LCDCON1 & 0x3fffe ;			// ENVID Off
33d090b4:	13c3337f 	bicne	r3, r3, #-67108863	; 0xfc000001
void embedsky_lcd_EnvidOnOff(int onoff)
{
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	if( onoff == 1 )
		lcd -> LCDCON1 |= 1 ;						// ENVID=ON
33d090b8:	03833001 	orreq	r3, r3, #1	; 0x1
	else
		lcd -> LCDCON1 = lcd -> LCDCON1 & 0x3fffe ;			// ENVID Off
33d090bc:	13c337ff 	bicne	r3, r3, #66846720	; 0x3fc0000
33d090c0:	e5823000 	str	r3, [r2]
33d090c4:	e1a0f00e 	mov	pc, lr

33d090c8 <embedsky_lcd_Init>:
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO() ;
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
33d090c8:	e59f1224 	ldr	r1, [pc, #548]	; 33d092f4 <embedsky_lcd_Init+0x22c>
33d090cc:	e1a030a1 	lsr	r3, r1, #1
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
33d090d0:	e2812b96 	add	r2, r1, #153600	; 0x25800
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO() ;
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
33d090d4:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
33d090d8:	e1a01b21 	lsr	r1, r1, #22
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
33d090dc:	e1a020a2 	lsr	r2, r2, #1
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO() ;
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
33d090e0:	e3c3360e 	bic	r3, r3, #14680064	; 0xe00000

/**************************************************************
LCD初始化程序(在board/EmbedSky/目录下的boot_init.c文件的60行左右,调用的)
**************************************************************/
void embedsky_lcd_Init(void)
{
33d090e4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO() ;
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
33d090e8:	e1833a81 	orr	r3, r3, r1, lsl #21
33d090ec:	e3a0444d 	mov	r4, #1291845632	; 0x4d000000
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
33d090f0:	e3c224ff 	bic	r2, r2, #-16777216	; 0xff000000
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO() ;
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
33d090f4:	e5843014 	str	r3, [r4, #20]
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
33d090f8:	e3c2260e 	bic	r2, r2, #14680064	; 0xe00000
	lcd -> LCDSADDR3 = ( ( ( SCR_XSIZE_TFT - LCD_XSIZE_TFT ) / 1 ) << 11 ) | ( LCD_XSIZE_TFT /1 ) ;
33d090fc:	e3a03d05 	mov	r3, #320	; 0x140
	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD() ;

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
33d09100:	e5842018 	str	r2, [r4, #24]
	lcd -> LCDSADDR3 = ( ( ( SCR_XSIZE_TFT - LCD_XSIZE_TFT ) / 1 ) << 11 ) | ( LCD_XSIZE_TFT /1 ) ;

	s_lcd = getenv ("dwVBPD");
33d09104:	e59f01ec 	ldr	r0, [pc, #492]	; 33d092f8 <embedsky_lcd_Init+0x230>

	char *s_lcd;

	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
	lcd -> LCDSADDR3 = ( ( ( SCR_XSIZE_TFT - LCD_XSIZE_TFT ) / 1 ) << 11 ) | ( LCD_XSIZE_TFT /1 ) ;
33d09108:	e584301c 	str	r3, [r4, #28]

	s_lcd = getenv ("dwVBPD");
33d0910c:	eb0031cf 	bl	33d15850 <getenv>
	vbpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VBPD;
33d09110:	e3500000 	cmp	r0, #0	; 0x0
{
    return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
}
static inline S3C24X0_GPIO * const S3C24X0_GetBase_GPIO(void)
{
    return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
33d09114:	e3a06456 	mov	r6, #1442840576	; 0x56000000
33d09118:	03a0300c 	moveq	r3, #12	; 0xc
33d0911c:	0a000003 	beq	33d09130 <embedsky_lcd_Init+0x68>
33d09120:	e3a01000 	mov	r1, #0	; 0x0
33d09124:	e3a0200a 	mov	r2, #10	; 0xa
33d09128:	eb004538 	bl	33d1a610 <simple_strtol>
33d0912c:	e1a03000 	mov	r3, r0
33d09130:	e59f21c4 	ldr	r2, [pc, #452]	; 33d092fc <embedsky_lcd_Init+0x234>

	s_lcd = getenv ("dwVFPD");
33d09134:	e59f01c4 	ldr	r0, [pc, #452]	; 33d09300 <embedsky_lcd_Init+0x238>
	lcd -> LCDSADDR1 = ( ( ( U32 ) embedsky_LCD_BUFFER >> 22 ) << 21 ) | M5D ( ( U32 ) embedsky_LCD_BUFFER >> 1 ) ;
	lcd -> LCDSADDR2 = M5D( ( ( U32) embedsky_LCD_BUFFER + ( SCR_XSIZE_TFT * LCD_YSIZE_TFT * 2 ) ) >> 1 ) ;
	lcd -> LCDSADDR3 = ( ( ( SCR_XSIZE_TFT - LCD_XSIZE_TFT ) / 1 ) << 11 ) | ( LCD_XSIZE_TFT /1 ) ;

	s_lcd = getenv ("dwVBPD");
	vbpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VBPD;
33d09138:	e5c23000 	strb	r3, [r2]

	s_lcd = getenv ("dwVFPD");
33d0913c:	eb0031c3 	bl	33d15850 <getenv>
	vfpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VFPD;
33d09140:	e3500000 	cmp	r0, #0	; 0x0
33d09144:	03a03004 	moveq	r3, #4	; 0x4
33d09148:	0a000003 	beq	33d0915c <embedsky_lcd_Init+0x94>
33d0914c:	e3a01000 	mov	r1, #0	; 0x0
33d09150:	e3a0200a 	mov	r2, #10	; 0xa
33d09154:	eb00452d 	bl	33d1a610 <simple_strtol>
33d09158:	e1a03000 	mov	r3, r0
33d0915c:	e59f21a0 	ldr	r2, [pc, #416]	; 33d09304 <embedsky_lcd_Init+0x23c>

	s_lcd = getenv ("dwVSPW");
33d09160:	e59f01a0 	ldr	r0, [pc, #416]	; 33d09308 <embedsky_lcd_Init+0x240>

	s_lcd = getenv ("dwVBPD");
	vbpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VBPD;

	s_lcd = getenv ("dwVFPD");
	vfpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VFPD;
33d09164:	e5c23000 	strb	r3, [r2]

	s_lcd = getenv ("dwVSPW");
33d09168:	eb0031b8 	bl	33d15850 <getenv>
	vspw = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VSPW;
33d0916c:	e3500000 	cmp	r0, #0	; 0x0
33d09170:	e59fb194 	ldr	fp, [pc, #404]	; 33d0930c <embedsky_lcd_Init+0x244>
33d09174:	03a03005 	moveq	r3, #5	; 0x5
33d09178:	0a000003 	beq	33d0918c <embedsky_lcd_Init+0xc4>
33d0917c:	e3a01000 	mov	r1, #0	; 0x0
33d09180:	e3a0200a 	mov	r2, #10	; 0xa
33d09184:	eb004521 	bl	33d1a610 <simple_strtol>
33d09188:	e1a03000 	mov	r3, r0
33d0918c:	e5cb3000 	strb	r3, [fp]

	s_lcd = getenv ("dwHBPD");
33d09190:	e59f0178 	ldr	r0, [pc, #376]	; 33d09310 <embedsky_lcd_Init+0x248>
33d09194:	eb0031ad 	bl	33d15850 <getenv>
	hbpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HBPD;
33d09198:	e3500000 	cmp	r0, #0	; 0x0
33d0919c:	e59f9170 	ldr	r9, [pc, #368]	; 33d09314 <embedsky_lcd_Init+0x24c>
33d091a0:	03a03015 	moveq	r3, #21	; 0x15
33d091a4:	0a000003 	beq	33d091b8 <embedsky_lcd_Init+0xf0>
33d091a8:	e3a01000 	mov	r1, #0	; 0x0
33d091ac:	e3a0200a 	mov	r2, #10	; 0xa
33d091b0:	eb004516 	bl	33d1a610 <simple_strtol>
33d091b4:	e1a03000 	mov	r3, r0

	s_lcd = getenv ("dwHFPD");
33d091b8:	e59f0158 	ldr	r0, [pc, #344]	; 33d09318 <embedsky_lcd_Init+0x250>

	s_lcd = getenv ("dwVSPW");
	vspw = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_VSPW;

	s_lcd = getenv ("dwHBPD");
	hbpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HBPD;
33d091bc:	e5c93000 	strb	r3, [r9]

	s_lcd = getenv ("dwHFPD");
33d091c0:	eb0031a2 	bl	33d15850 <getenv>
	hfpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HFPD;
33d091c4:	e3500000 	cmp	r0, #0	; 0x0
33d091c8:	e59fa14c 	ldr	sl, [pc, #332]	; 33d0931c <embedsky_lcd_Init+0x254>
33d091cc:	03a03020 	moveq	r3, #32	; 0x20
33d091d0:	0a000003 	beq	33d091e4 <embedsky_lcd_Init+0x11c>
33d091d4:	e3a01000 	mov	r1, #0	; 0x0
33d091d8:	e3a0200a 	mov	r2, #10	; 0xa
33d091dc:	eb00450b 	bl	33d1a610 <simple_strtol>
33d091e0:	e1a03000 	mov	r3, r0

	s_lcd = getenv ("dwHSPW");
33d091e4:	e59f0134 	ldr	r0, [pc, #308]	; 33d09320 <embedsky_lcd_Init+0x258>

	s_lcd = getenv ("dwHBPD");
	hbpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HBPD;

	s_lcd = getenv ("dwHFPD");
	hfpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HFPD;
33d091e8:	e5ca3000 	strb	r3, [sl]

	s_lcd = getenv ("dwHSPW");
33d091ec:	eb003197 	bl	33d15850 <getenv>
	hspw = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HSPW;
33d091f0:	e3500000 	cmp	r0, #0	; 0x0
33d091f4:	e59f7128 	ldr	r7, [pc, #296]	; 33d09324 <embedsky_lcd_Init+0x25c>
33d091f8:	03a0302c 	moveq	r3, #44	; 0x2c
33d091fc:	0a000003 	beq	33d09210 <embedsky_lcd_Init+0x148>
33d09200:	e3a01000 	mov	r1, #0	; 0x0
33d09204:	e3a0200a 	mov	r2, #10	; 0xa
33d09208:	eb004500 	bl	33d1a610 <simple_strtol>
33d0920c:	e1a03000 	mov	r3, r0

	s_lcd = getenv ("dwCLKVAL");
33d09210:	e59f0110 	ldr	r0, [pc, #272]	; 33d09328 <embedsky_lcd_Init+0x260>

	s_lcd = getenv ("dwHFPD");
	hfpd = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HFPD;

	s_lcd = getenv ("dwHSPW");
	hspw = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HSPW;
33d09214:	e5c73000 	strb	r3, [r7]

	s_lcd = getenv ("dwCLKVAL");
33d09218:	eb00318c 	bl	33d15850 <getenv>
	clkval_tft = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_CLKVAL;
33d0921c:	e3500000 	cmp	r0, #0	; 0x0
33d09220:	e59f5104 	ldr	r5, [pc, #260]	; 33d0932c <embedsky_lcd_Init+0x264>
33d09224:	03a03006 	moveq	r3, #6	; 0x6
33d09228:	0a000003 	beq	33d0923c <embedsky_lcd_Init+0x174>
33d0922c:	e3a01000 	mov	r1, #0	; 0x0
33d09230:	e3a0200a 	mov	r2, #10	; 0xa
33d09234:	eb0044f5 	bl	33d1a610 <simple_strtol>
33d09238:	e1a03000 	mov	r3, r0

	embedsky_lcd_ClearScr( 0x0 ) ;
33d0923c:	e3a00000 	mov	r0, #0	; 0x0

	s_lcd = getenv ("dwHSPW");
	hspw = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_HSPW;

	s_lcd = getenv ("dwCLKVAL");
	clkval_tft = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_CLKVAL;
33d09240:	e5c53000 	strb	r3, [r5]

	embedsky_lcd_ClearScr( 0x0 ) ;
33d09244:	ebfffeda 	bl	33d08db4 <embedsky_lcd_ClearScr>

	gpio -> GPCUP  = 0xffffffff ;
	gpio -> GPCCON = 0xaaaaaaaa ;						//Initialize VD[0:7]	 
33d09248:	e59f20e0 	ldr	r2, [pc, #224]	; 33d09330 <embedsky_lcd_Init+0x268>
	s_lcd = getenv ("dwCLKVAL");
	clkval_tft = s_lcd ? (int)simple_strtol(s_lcd, NULL, 10) : CONFIG_EMBEDSKY_LCD_CLKVAL;

	embedsky_lcd_ClearScr( 0x0 ) ;

	gpio -> GPCUP  = 0xffffffff ;
33d0924c:	e3e03000 	mvn	r3, #0	; 0x0
33d09250:	e5863028 	str	r3, [r6, #40]
	gpio -> GPCCON = 0xaaaaaaaa ;						//Initialize VD[0:7]	 
33d09254:	e5862020 	str	r2, [r6, #32]
	 
	gpio -> GPDUP  = 0xffffffff ;
33d09258:	e5863038 	str	r3, [r6, #56]
	gpio -> GPDCON = 0xaaaaaaaa ;						//Initialize VD[15:8]
33d0925c:	e5862030 	str	r2, [r6, #48]

	lcd -> LCDCON1 = ( clkval_tft << 8 ) | ( MVAL_USED << 7 ) | (3 << 5 ) | ( 12 << 1 ) | 0 ;
33d09260:	e5d53000 	ldrb	r3, [r5]
33d09264:	e1a03403 	lsl	r3, r3, #8
33d09268:	e3833078 	orr	r3, r3, #120	; 0x78
33d0926c:	e5843000 	str	r3, [r4]
										// TFT LCD panel,16bpp TFT,ENVID=off
	lcd -> LCDCON2 = ( vbpd << 24 ) | ( LINEVAL_TFT << 14 ) | ( vfpd << 6 ) | ( vspw ) ;
33d09270:	e59f208c 	ldr	r2, [pc, #140]	; 33d09304 <embedsky_lcd_Init+0x23c>
33d09274:	e59f3080 	ldr	r3, [pc, #128]	; 33d092fc <embedsky_lcd_Init+0x234>
33d09278:	e5d31000 	ldrb	r1, [r3]
33d0927c:	e5d23000 	ldrb	r3, [r2]
33d09280:	e5db2000 	ldrb	r2, [fp]
33d09284:	e1a03303 	lsl	r3, r3, #6
33d09288:	e1833c01 	orr	r3, r3, r1, lsl #24
33d0928c:	e1833002 	orr	r3, r3, r2
33d09290:	e38339ef 	orr	r3, r3, #3915776	; 0x3bc000
33d09294:	e5843004 	str	r3, [r4, #4]
	lcd -> LCDCON3 = ( hbpd << 19 ) | ( HOZVAL_TFT << 8 ) | ( hfpd ) ;
33d09298:	e5d92000 	ldrb	r2, [r9]
33d0929c:	e5da3000 	ldrb	r3, [sl]
33d092a0:	e1833982 	orr	r3, r3, r2, lsl #19
33d092a4:	e3833b4f 	orr	r3, r3, #80896	; 0x13c00
33d092a8:	e3833c03 	orr	r3, r3, #768	; 0x300
33d092ac:	e5843008 	str	r3, [r4, #8]
	lcd -> LCDCON4 = ( MVAL << 8 ) | ( hspw ) ;
33d092b0:	e5d73000 	ldrb	r3, [r7]
33d092b4:	e3833c0d 	orr	r3, r3, #3328	; 0xd00
33d092b8:	e584300c 	str	r3, [r4, #12]
#if( LCD_TFT == VGA1024768 )
	lcd -> LCDCON5 = ( 1 << 11) | ( HWSWP ) ;
#else
	lcd -> LCDCON5 = ( 1 << 11) | ( 0 << 10 ) | ( 1 << 9 ) | ( 1 << 8 ) | ( 0 << 7 ) | ( 0 << 6 ) | ( 1 << 3 ) | ( BSWP << 1 ) | ( HWSWP ) ;
33d092bc:	e59f3070 	ldr	r3, [pc, #112]	; 33d09334 <embedsky_lcd_Init+0x26c>
33d092c0:	e5843010 	str	r3, [r4, #16]
#endif

	lcd -> LCDINTMSK |= (3) ;						// MASK LCD Sub Interrupt
33d092c4:	e594305c 	ldr	r3, [r4, #92]
33d092c8:	e3833003 	orr	r3, r3, #3	; 0x3
33d092cc:	e584305c 	str	r3, [r4, #92]
#if( LCD_TFT == VGA1024768 )
	lcd -> LPCSEL &= 0xf82;
#else
	lcd -> LPCSEL &= ( ~7 ) ;						// Disable LPC3480
33d092d0:	e5943060 	ldr	r3, [r4, #96]
#endif
	lcd -> TPAL = 0x0 ;							// Disable Temp Palette
33d092d4:	e3a02000 	mov	r2, #0	; 0x0

	lcd -> LCDINTMSK |= (3) ;						// MASK LCD Sub Interrupt
#if( LCD_TFT == VGA1024768 )
	lcd -> LPCSEL &= 0xf82;
#else
	lcd -> LPCSEL &= ( ~7 ) ;						// Disable LPC3480
33d092d8:	e3c33007 	bic	r3, r3, #7	; 0x7
#endif
	lcd -> TPAL = 0x0 ;							// Disable Temp Palette

	embedsky_lcd_PowerEnable( 0, 1 ) ;
33d092dc:	e1a00002 	mov	r0, r2
33d092e0:	e3a01001 	mov	r1, #1	; 0x1

	lcd -> LCDINTMSK |= (3) ;						// MASK LCD Sub Interrupt
#if( LCD_TFT == VGA1024768 )
	lcd -> LPCSEL &= 0xf82;
#else
	lcd -> LPCSEL &= ( ~7 ) ;						// Disable LPC3480
33d092e4:	e5843060 	str	r3, [r4, #96]
#endif
	lcd -> TPAL = 0x0 ;							// Disable Temp Palette
33d092e8:	e5842050 	str	r2, [r4, #80]

	embedsky_lcd_PowerEnable( 0, 1 ) ;
33d092ec:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
33d092f0:	eaffff57 	b	33d09054 <embedsky_lcd_PowerEnable>
33d092f4:	33d39b2c 	.word	0x33d39b2c
33d092f8:	33d26718 	.word	0x33d26718
33d092fc:	33d2e6b6 	.word	0x33d2e6b6
33d09300:	33d26720 	.word	0x33d26720
33d09304:	33d2e6b5 	.word	0x33d2e6b5
33d09308:	33d26728 	.word	0x33d26728
33d0930c:	33d2e6b4 	.word	0x33d2e6b4
33d09310:	33d26730 	.word	0x33d26730
33d09314:	33d2e6b3 	.word	0x33d2e6b3
33d09318:	33d26738 	.word	0x33d26738
33d0931c:	33d2e6b2 	.word	0x33d2e6b2
33d09320:	33d26740 	.word	0x33d26740
33d09324:	33d2e6b1 	.word	0x33d2e6b1
33d09328:	33d26748 	.word	0x33d26748
33d0932c:	33d2e6b0 	.word	0x33d2e6b0
33d09330:	aaaaaaaa 	.word	0xaaaaaaaa
33d09334:	00000b09 	.word	0x00000b09

33d09338 <embedsky_tq_logo>:

/****************************************************************
LCD显示天嵌科技下载logo程序(在common/目录下的main.c文件的277行左右调用的)
****************************************************************/
void embedsky_tq_logo(void)
{
33d09338:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if(1)
	{
		embedsky_paint_Bmp((LCD_XSIZE_TFT-170) / 2, LCD_YSIZE_TFT / 8, 170, 48, logo_tqkj) ;
33d0933c:	e59fc060 	ldr	ip, [pc, #96]	; 33d093a4 <embedsky_tq_logo+0x6c>

/****************************************************************
LCD显示天嵌科技下载logo程序(在common/目录下的main.c文件的277行左右调用的)
****************************************************************/
void embedsky_tq_logo(void)
{
33d09340:	e24dd004 	sub	sp, sp, #4	; 0x4
	if(1)
	{
		embedsky_paint_Bmp((LCD_XSIZE_TFT-170) / 2, LCD_YSIZE_TFT / 8, 170, 48, logo_tqkj) ;
33d09344:	e3a0004b 	mov	r0, #75	; 0x4b
33d09348:	e3a0101e 	mov	r1, #30	; 0x1e
33d0934c:	e3a020aa 	mov	r2, #170	; 0xaa
33d09350:	e3a03030 	mov	r3, #48	; 0x30
33d09354:	e58dc000 	str	ip, [sp]
33d09358:	ebfffec3 	bl	33d08e6c <embedsky_paint_Bmp>
		embedsky_paint_Bmp((LCD_XSIZE_TFT-170) / 2, LCD_YSIZE_TFT / 8 + 50, 170, 22, logo_net) ;
33d0935c:	e59fc044 	ldr	ip, [pc, #68]	; 33d093a8 <embedsky_tq_logo+0x70>
33d09360:	e3a0004b 	mov	r0, #75	; 0x4b
33d09364:	e3a01050 	mov	r1, #80	; 0x50
33d09368:	e3a020aa 	mov	r2, #170	; 0xaa
33d0936c:	e3a03016 	mov	r3, #22	; 0x16
33d09370:	e58dc000 	str	ip, [sp]
33d09374:	ebfffebc 	bl	33d08e6c <embedsky_paint_Bmp>
		embedsky_paint_Bmp((LCD_XSIZE_TFT -180) / 2, LCD_YSIZE_TFT / 8 + 120, 180, 20, down_mode);	//显示进入下载模式，中间
33d09378:	e59fc02c 	ldr	ip, [pc, #44]	; 33d093ac <embedsky_tq_logo+0x74>
33d0937c:	e3a00046 	mov	r0, #70	; 0x46
33d09380:	e3a01096 	mov	r1, #150	; 0x96
33d09384:	e3a020b4 	mov	r2, #180	; 0xb4
33d09388:	e3a03014 	mov	r3, #20	; 0x14
33d0938c:	e58dc000 	str	ip, [sp]
33d09390:	ebfffeb5 	bl	33d08e6c <embedsky_paint_Bmp>
	}
	else
		embedsky_paint_Bmp((LCD_XSIZE_TFT -180) / 2, (LCD_YSIZE_TFT -20) / 2, 180, 20, down_mode);		//显示进入下载模式，中间	

	embedsky_lcd_EnvidOnOff ( 1 ) ;
33d09394:	e3a00001 	mov	r0, #1	; 0x1
33d09398:	e28dd004 	add	sp, sp, #4	; 0x4
33d0939c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d093a0:	eaffff3f 	b	33d090a4 <embedsky_lcd_EnvidOnOff>
33d093a4:	33d302d7 	.word	0x33d302d7
33d093a8:	33d34297 	.word	0x33d34297
33d093ac:	33d2e6b7 	.word	0x33d2e6b7

33d093b0 <embedsky_user_logo>:

/****************************************************************
LCD显示用户开机logo程序(在common/目录下的main.c文件的277行左右调用的)
****************************************************************/
void embedsky_user_logo(void)
{
33d093b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d093b4:	e24dd004 	sub	sp, sp, #4	; 0x4
	size_t retlen = SCR_YSIZE_TFT * SCR_XSIZE_TFT * (16 >> 3);

if (NF_ReadID() == 0x76)
33d093b8:	ebffdc65 	bl	33d00554 <NF_ReadID>
33d093bc:	e3500076 	cmp	r0, #118	; 0x76
	nand_read_ll(embedsky_LCD_BUFFER, 0x70000, retlen);
#else
#if( LCD_TFT == VGA1024768 )
	nand_read_ll(embedsky_LCD_BUFFER, 0x0C0000, retlen);
#else
	nand_read_ll(embedsky_LCD_BUFFER, 0x100000, retlen);
33d093c0:	e3a01601 	mov	r1, #1048576	; 0x100000
33d093c4:	e3a02b96 	mov	r2, #153600	; 0x25800
33d093c8:	e59f0044 	ldr	r0, [pc, #68]	; 33d09414 <embedsky_user_logo+0x64>
****************************************************************/
void embedsky_user_logo(void)
{
	size_t retlen = SCR_YSIZE_TFT * SCR_XSIZE_TFT * (16 >> 3);

if (NF_ReadID() == 0x76)
33d093cc:	1a000001 	bne	33d093d8 <embedsky_user_logo+0x28>
	nand_read_ll(embedsky_LCD_BUFFER, 0x70000, retlen);
#else
#if( LCD_TFT == VGA1024768 )
	nand_read_ll(embedsky_LCD_BUFFER, 0x0C0000, retlen);
#else
	nand_read_ll(embedsky_LCD_BUFFER, 0x100000, retlen);
33d093d0:	ebffdc79 	bl	33d005bc <nand_read_ll>
33d093d4:	ea000003 	b	33d093e8 <embedsky_user_logo+0x38>
	if(( retlen % 0x800) != 0)				//HJ_add 20090709
		retlen = (retlen / 0x800) * 0x800 + 0x800;	//HJ_add 20090709
#if( LCD_TFT == VGA1024768 )
	nand_read_ll_lp(embedsky_LCD_BUFFER, 0xC0000, retlen);
#else
	nand_read_ll_lp(embedsky_LCD_BUFFER, 0x100000, retlen);
33d093d8:	e3a01601 	mov	r1, #1048576	; 0x100000
33d093dc:	e3a02b96 	mov	r2, #153600	; 0x25800
33d093e0:	e59f002c 	ldr	r0, [pc, #44]	; 33d09414 <embedsky_user_logo+0x64>
33d093e4:	ebffdcca 	bl	33d00714 <nand_read_ll_lp>
#endif
}
	embedsky_lcd_ClearScr_Rectangle(0, LCD_YSIZE_TFT-8, LCD_XSIZE_TFT, 8, 0xFFFF);
33d093e8:	e59fc028 	ldr	ip, [pc, #40]	; 33d09418 <embedsky_user_logo+0x68>
33d093ec:	e3a00000 	mov	r0, #0	; 0x0
33d093f0:	e3a010e8 	mov	r1, #232	; 0xe8
33d093f4:	e3a02d05 	mov	r2, #320	; 0x140
33d093f8:	e3a03008 	mov	r3, #8	; 0x8
33d093fc:	e58dc000 	str	ip, [sp]
33d09400:	ebfffe7e 	bl	33d08e00 <embedsky_lcd_ClearScr_Rectangle>

	embedsky_lcd_EnvidOnOff ( 1 ) ;
33d09404:	e3a00001 	mov	r0, #1	; 0x1
33d09408:	e28dd004 	add	sp, sp, #4	; 0x4
33d0940c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d09410:	eaffff23 	b	33d090a4 <embedsky_lcd_EnvidOnOff>
33d09414:	33d39b2c 	.word	0x33d39b2c
33d09418:	0000ffff 	.word	0x0000ffff

33d0941c <EmbedSky_wait_idle>:
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;

	while(!(*p & 1))
	for(i=0; i<10; i++);
33d0941c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d09420:	e5d33020 	ldrb	r3, [r3, #32]
33d09424:	e3130001 	tst	r3, #1	; 0x1
/* 等待NAND Flash就绪 */
static void EmbedSky_wait_idle(void)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;
33d09428:	e59f201c 	ldr	r2, [pc, #28]	; 33d0944c <EmbedSky_wait_idle+0x30>

	while(!(*p & 1))
	for(i=0; i<10; i++);
33d0942c:	11a0f00e 	movne	pc, lr
33d09430:	e3a03009 	mov	r3, #9	; 0x9
33d09434:	e2533001 	subs	r3, r3, #1	; 0x1
33d09438:	5afffffd 	bpl	33d09434 <EmbedSky_wait_idle+0x18>
33d0943c:	e5d23000 	ldrb	r3, [r2]
33d09440:	e3130001 	tst	r3, #1	; 0x1
33d09444:	0afffff9 	beq	33d09430 <EmbedSky_wait_idle+0x14>
33d09448:	e1a0f00e 	mov	pc, lr
33d0944c:	4e000020 	.word	0x4e000020

33d09450 <EmbedSky_nand_select_chip>:

/* 发出片选信号 */
static void EmbedSky_nand_select_chip(void)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
33d09450:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000

	s3c2440nand->NFCONT &= ~(1<<1);
33d09454:	e5923004 	ldr	r3, [r2, #4]
33d09458:	e3c33002 	bic	r3, r3, #2	; 0x2
33d0945c:	e5823004 	str	r3, [r2, #4]
	for(i=0; i<10; i++);
}

/* 发出片选信号 */
static void EmbedSky_nand_select_chip(void)
{
33d09460:	e3a03009 	mov	r3, #9	; 0x9
33d09464:	e2533001 	subs	r3, r3, #1	; 0x1
33d09468:	5afffffd 	bpl	33d09464 <EmbedSky_nand_select_chip+0x14>
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

	s3c2440nand->NFCONT &= ~(1<<1);
	for(i=0; i<10; i++);
33d0946c:	e1a0f00e 	mov	pc, lr

33d09470 <EmbedSky_nand_deselect_chip>:
}

/* 取消片选信号 */
static void EmbedSky_nand_deselect_chip(void)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
33d09470:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000

	s3c2440nand->NFCONT |= (1<<1);
33d09474:	e5923004 	ldr	r3, [r2, #4]
33d09478:	e3833002 	orr	r3, r3, #2	; 0x2
33d0947c:	e5823004 	str	r3, [r2, #4]
33d09480:	e1a0f00e 	mov	pc, lr

33d09484 <EmbedSky_write_cmd>:
static void EmbedSky_write_cmd(int cmd)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;

	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
	*p = cmd;
33d09484:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d09488:	e5c30008 	strb	r0, [r3, #8]
33d0948c:	e1a0f00e 	mov	pc, lr

33d09490 <EmbedSky_read_data>:
/* 读取数据 */
static unsigned char EmbedSky_read_data(void)
{
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFDATA;
	return *p;
33d09490:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d09494:	e5d30010 	ldrb	r0, [r3, #16]
}
33d09498:	e1a0f00e 	mov	pc, lr

33d0949c <nand_read_ll_lcd>:


	int current = 0;				//HJ_add 滚动条，当前的字节数
	int total = 0;				//HJ_add 滚动条

	if ((start_addr & 511) || (size & 511))
33d0949c:	e1a03b81 	lsl	r3, r1, #23
33d094a0:	e1a03ba3 	lsr	r3, r3, #23
33d094a4:	e3530000 	cmp	r3, #0	; 0x0
}


/* 读函数 添加了LCD的滚动条 */
int nand_read_ll_lcd(unsigned char *buf, unsigned long start_addr, int size)
{
33d094a8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d094ac:	e1a0b000 	mov	fp, r0
33d094b0:	e1a06002 	mov	r6, r2
	int i, j;
	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
33d094b4:	e59f7158 	ldr	r7, [pc, #344]	; 33d09614 <nand_read_ll_lcd+0x178>


	int current = 0;				//HJ_add 滚动条，当前的字节数
33d094b8:	e3a0a000 	mov	sl, #0	; 0x0
	int total = 0;				//HJ_add 滚动条

	if ((start_addr & 511) || (size & 511))
33d094bc:	1a000003 	bne	33d094d0 <nand_read_ll_lcd+0x34>
33d094c0:	e1a03b82 	lsl	r3, r2, #23
33d094c4:	e1a03ba3 	lsr	r3, r3, #23
33d094c8:	e153000a 	cmp	r3, sl
33d094cc:	0a000001 	beq	33d094d8 <nand_read_ll_lcd+0x3c>
	{
		return -1;		/* 地址或长度不对齐 */
33d094d0:	e3e00000 	mvn	r0, #0	; 0x0
33d094d4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* 选中芯片 */
	EmbedSky_nand_select_chip();

	total = size;			//HJ_add 滚动条

	for(i=start_addr; i < (start_addr + size);)
33d094d8:	e1a05001 	mov	r5, r1
33d094dc:	e0819002 	add	r9, r1, r2
	{
		return -1;		/* 地址或长度不对齐 */
	}

	/* 选中芯片 */
	EmbedSky_nand_select_chip();
33d094e0:	ebffffda 	bl	33d09450 <EmbedSky_nand_select_chip>

	total = size;			//HJ_add 滚动条

	for(i=start_addr; i < (start_addr + size);)
33d094e4:	e1550009 	cmp	r5, r9
33d094e8:	2a000046 	bcs	33d09608 <nand_read_ll_lcd+0x16c>
	{
if(1){
/* Check Bad Block */
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0x50);
33d094ec:	e3a00050 	mov	r0, #80	; 0x50
33d094f0:	ebffffe3 	bl	33d09484 <EmbedSky_write_cmd>

		*p = 5;
33d094f4:	e3a03005 	mov	r3, #5	; 0x5
33d094f8:	e5c73000 	strb	r3, [r7]
33d094fc:	e3a04009 	mov	r4, #9	; 0x9
33d09500:	e2544001 	subs	r4, r4, #1	; 0x1
33d09504:	5afffffd 	bpl	33d09500 <nand_read_ll_lcd+0x64>
		for(j=0; j<10; j++);
		*p = (i >> 9) & 0xff;
33d09508:	e1a034c5 	asr	r3, r5, #9
33d0950c:	e5c73000 	strb	r3, [r7]
33d09510:	e3a04009 	mov	r4, #9	; 0x9
33d09514:	e2544001 	subs	r4, r4, #1	; 0x1
33d09518:	5afffffd 	bpl	33d09514 <nand_read_ll_lcd+0x78>
		for(j=0; j<10; j++);
		*p = (i >> 17) & 0xff;
33d0951c:	e1a038c5 	asr	r3, r5, #17
33d09520:	e5c73000 	strb	r3, [r7]
33d09524:	e3a04009 	mov	r4, #9	; 0x9
33d09528:	e2544001 	subs	r4, r4, #1	; 0x1
33d0952c:	5afffffd 	bpl	33d09528 <nand_read_ll_lcd+0x8c>
		for(j=0; j<10; j++);
		*p = (i >> 25) & 0xff;
33d09530:	e1a03cc5 	asr	r3, r5, #25
33d09534:	e5c73000 	strb	r3, [r7]
33d09538:	e3a04009 	mov	r4, #9	; 0x9
33d0953c:	e2544001 	subs	r4, r4, #1	; 0x1
33d09540:	5afffffd 	bpl	33d0953c <nand_read_ll_lcd+0xa0>
		for(j=0; j<10; j++);
		EmbedSky_wait_idle();
33d09544:	ebffffb4 	bl	33d0941c <EmbedSky_wait_idle>

		dat = EmbedSky_read_data();
33d09548:	ebffffd0 	bl	33d09490 <EmbedSky_read_data>
33d0954c:	e1a04000 	mov	r4, r0
33d09550:	e20440ff 	and	r4, r4, #255	; 0xff
		EmbedSky_write_cmd(0);
33d09554:	e3a00000 	mov	r0, #0	; 0x0
33d09558:	ebffffc9 	bl	33d09484 <EmbedSky_write_cmd>
		
		/* 取消片选信号 */
		EmbedSky_nand_deselect_chip();
33d0955c:	ebffffc3 	bl	33d09470 <EmbedSky_nand_deselect_chip>
		if(dat != 0xff)
33d09560:	e35400ff 	cmp	r4, #255	; 0xff
		{
			i += 16384;		// 1 Block = 512*32= 16384
33d09564:	12855901 	addne	r5, r5, #16384	; 0x4000
			printf("\nBad block at 0x%lx ,will be skipped\n",i);
33d09568:	159f00a8 	ldrne	r0, [pc, #168]	; 33d09618 <nand_read_ll_lcd+0x17c>
33d0956c:	11a01005 	movne	r1, r5
33d09570:	1b003694 	blne	33d16fc8 <printf>
		}
/* Read Page */
		/* 选中芯片 */
		EmbedSky_nand_select_chip();
33d09574:	ebffffb5 	bl	33d09450 <EmbedSky_nand_select_chip>
}
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0);
33d09578:	e3a00000 	mov	r0, #0	; 0x0
33d0957c:	ebffffc0 	bl	33d09484 <EmbedSky_write_cmd>
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

	*p = addr & 0xff;
33d09580:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
/* 发出地址 */
static void EmbedSky_write_addr(unsigned int addr)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
33d09584:	e59f2088 	ldr	r2, [pc, #136]	; 33d09614 <nand_read_ll_lcd+0x178>

	*p = addr & 0xff;
33d09588:	e5c3500c 	strb	r5, [r3, #12]
33d0958c:	e3a03009 	mov	r3, #9	; 0x9
33d09590:	e2533001 	subs	r3, r3, #1	; 0x1
33d09594:	5afffffd 	bpl	33d09590 <nand_read_ll_lcd+0xf4>
	for(i=0; i<10; i++);
	*p = (addr >> 9) & 0xff;
33d09598:	e1a034a5 	lsr	r3, r5, #9
33d0959c:	e5c23000 	strb	r3, [r2]
33d095a0:	e3a03009 	mov	r3, #9	; 0x9
33d095a4:	e2533001 	subs	r3, r3, #1	; 0x1
33d095a8:	5afffffd 	bpl	33d095a4 <nand_read_ll_lcd+0x108>
	for(i=0; i<10; i++);
	*p = (addr >> 17) & 0xff;
33d095ac:	e1a038a5 	lsr	r3, r5, #17
33d095b0:	e5c23000 	strb	r3, [r2]
33d095b4:	e3a03009 	mov	r3, #9	; 0x9
33d095b8:	e2533001 	subs	r3, r3, #1	; 0x1
33d095bc:	5afffffd 	bpl	33d095b8 <nand_read_ll_lcd+0x11c>
	for(i=0; i<10; i++);
	*p = (addr >> 25) & 0xff;
33d095c0:	e1a03ca5 	lsr	r3, r5, #25
33d095c4:	e5c23000 	strb	r3, [r2]
33d095c8:	e3a03009 	mov	r3, #9	; 0x9
33d095cc:	e2533001 	subs	r3, r3, #1	; 0x1
33d095d0:	5afffffd 	bpl	33d095cc <nand_read_ll_lcd+0x130>
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0);

		/* Write Address */
		EmbedSky_write_addr(i);
		EmbedSky_wait_idle();
33d095d4:	ebffff90 	bl	33d0941c <EmbedSky_wait_idle>

		for(j=0; j < 512; j++, i++)
33d095d8:	e3a04000 	mov	r4, #0	; 0x0
		{
			*buf = EmbedSky_read_data();
33d095dc:	ebffffab 	bl	33d09490 <EmbedSky_read_data>

		/* Write Address */
		EmbedSky_write_addr(i);
		EmbedSky_wait_idle();

		for(j=0; j < 512; j++, i++)
33d095e0:	e2844001 	add	r4, r4, #1	; 0x1
33d095e4:	e3540c02 	cmp	r4, #512	; 0x200
		{
			*buf = EmbedSky_read_data();
33d095e8:	e4cb0001 	strb	r0, [fp], #1

		/* Write Address */
		EmbedSky_write_addr(i);
		EmbedSky_wait_idle();

		for(j=0; j < 512; j++, i++)
33d095ec:	e2855001 	add	r5, r5, #1	; 0x1
33d095f0:	bafffff9 	blt	33d095dc <nand_read_ll_lcd+0x140>
		{
			*buf = EmbedSky_read_data();
			buf++;
		}

		current += 512 ;					//HJ_add 滚动条
33d095f4:	e28aac02 	add	sl, sl, #512	; 0x200
		drawProcessBar(total, current );			//HJ_add 滚动条
33d095f8:	e1a00006 	mov	r0, r6
33d095fc:	e1a0100a 	mov	r1, sl
33d09600:	ebfffe45 	bl	33d08f1c <drawProcessBar>
33d09604:	eaffffb6 	b	33d094e4 <nand_read_ll_lcd+0x48>
	}

	/* 取消片选信号 */
	EmbedSky_nand_deselect_chip();
33d09608:	ebffff98 	bl	33d09470 <EmbedSky_nand_deselect_chip>

	return 0;
33d0960c:	e3a00000 	mov	r0, #0	; 0x0
}
33d09610:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d09614:	4e00000c 	.word	0x4e00000c
33d09618:	33d26754 	.word	0x33d26754

33d0961c <nand_read_ll_lp_lcd>:

/* 读函数 添加了LCD的滚动条 */
int nand_read_ll_lp_lcd(unsigned char *buf, unsigned long start_addr, int size)
{
33d0961c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

	if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP))
33d09620:	e1a03a81 	lsl	r3, r1, #21
33d09624:	e1a03aa3 	lsr	r3, r3, #21
	return 0;
}

/* 读函数 添加了LCD的滚动条 */
int nand_read_ll_lp_lcd(unsigned char *buf, unsigned long start_addr, int size)
{
33d09628:	e24dd004 	sub	sp, sp, #4	; 0x4

	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;

	if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP))
33d0962c:	e3530000 	cmp	r3, #0	; 0x0
	return 0;
}

/* 读函数 添加了LCD的滚动条 */
int nand_read_ll_lp_lcd(unsigned char *buf, unsigned long start_addr, int size)
{
33d09630:	e58d0000 	str	r0, [sp]
33d09634:	e1a07002 	mov	r7, r2
	int i, j;
	int current = 0;				//HJ_add 滚动条，当前的字节数
33d09638:	e3a09000 	mov	r9, #0	; 0x0
	int total = 0;				//HJ_add 滚动条

	char dat;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
33d0963c:	e59fa1ac 	ldr	sl, [pc, #428]	; 33d097f0 <nand_read_ll_lp_lcd+0x1d4>

	if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP))
33d09640:	1a000003 	bne	33d09654 <nand_read_ll_lp_lcd+0x38>
33d09644:	e1a03a82 	lsl	r3, r2, #21
33d09648:	e1a03aa3 	lsr	r3, r3, #21
33d0964c:	e1530009 	cmp	r3, r9
33d09650:	0a000001 	beq	33d0965c <nand_read_ll_lp_lcd+0x40>
	{
		return -1;    /* 地址或长度不对齐 */
33d09654:	e3e00000 	mvn	r0, #0	; 0x0
33d09658:	ea000062 	b	33d097e8 <nand_read_ll_lp_lcd+0x1cc>
	/* 选中芯片 */
	EmbedSky_nand_select_chip();

	total = size;			//HJ_add 滚动条

	for(i=start_addr; i < (start_addr + size);)
33d0965c:	e1a05001 	mov	r5, r1
33d09660:	e081b002 	add	fp, r1, r2
	{
		return -1;    /* 地址或长度不对齐 */
	}

	/* 选中芯片 */
	EmbedSky_nand_select_chip();
33d09664:	ebffff79 	bl	33d09450 <EmbedSky_nand_select_chip>

	total = size;			//HJ_add 滚动条

	for(i=start_addr; i < (start_addr + size);)
33d09668:	e155000b 	cmp	r5, fp
33d0966c:	2a00005b 	bcs	33d097e0 <nand_read_ll_lp_lcd+0x1c4>
/* Check Bad Block */
if(1){
		int col, page;

		col = i & NAND_BLOCK_MASK_LP;
		page = i / NAND_SECTOR_SIZE_LP;
33d09670:	e1a03fc5 	asr	r3, r5, #31
33d09674:	e0853aa3 	add	r3, r5, r3, lsr #21
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0x00);
33d09678:	e3a00000 	mov	r0, #0	; 0x0
/* Check Bad Block */
if(1){
		int col, page;

		col = i & NAND_BLOCK_MASK_LP;
		page = i / NAND_SECTOR_SIZE_LP;
33d0967c:	e1a065c3 	asr	r6, r3, #11
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0x00);
33d09680:	ebffff7f 	bl	33d09484 <EmbedSky_write_cmd>

		*p = 5;
33d09684:	e3a03005 	mov	r3, #5	; 0x5
33d09688:	e5ca3000 	strb	r3, [sl]
33d0968c:	e3a04009 	mov	r4, #9	; 0x9
33d09690:	e2544001 	subs	r4, r4, #1	; 0x1
33d09694:	5afffffd 	bpl	33d09690 <nand_read_ll_lp_lcd+0x74>
		for(j=0; j<10; j++);
		*p = 8;
33d09698:	e3a03008 	mov	r3, #8	; 0x8
33d0969c:	e5ca3000 	strb	r3, [sl]
33d096a0:	e3a04009 	mov	r4, #9	; 0x9
33d096a4:	e2544001 	subs	r4, r4, #1	; 0x1
33d096a8:	5afffffd 	bpl	33d096a4 <nand_read_ll_lp_lcd+0x88>
		for(j=0; j<10; j++);
		*p = page & 0xff;		/* Row Address A12~A19 */
33d096ac:	e5ca6000 	strb	r6, [sl]
33d096b0:	e3a04009 	mov	r4, #9	; 0x9
33d096b4:	e2544001 	subs	r4, r4, #1	; 0x1
33d096b8:	5afffffd 	bpl	33d096b4 <nand_read_ll_lp_lcd+0x98>
		for(j=0; j<10; j++);
		*p = (page >> 8) & 0xff;		/* Row Address A20~A27 */
33d096bc:	e1a03446 	asr	r3, r6, #8
33d096c0:	e5ca3000 	strb	r3, [sl]
33d096c4:	e3a04009 	mov	r4, #9	; 0x9
33d096c8:	e2544001 	subs	r4, r4, #1	; 0x1
33d096cc:	5afffffd 	bpl	33d096c8 <nand_read_ll_lp_lcd+0xac>
		for(j=0; j<10; j++);
#if (b128MB== 0)
		*p = (page >> 16) & 0x03;		/* Row Address A28~A29 */
33d096d0:	e1a03846 	asr	r3, r6, #16
33d096d4:	e2033003 	and	r3, r3, #3	; 0x3
33d096d8:	e5ca3000 	strb	r3, [sl]
33d096dc:	e3a04009 	mov	r4, #9	; 0x9
33d096e0:	e2544001 	subs	r4, r4, #1	; 0x1
33d096e4:	5afffffd 	bpl	33d096e0 <nand_read_ll_lp_lcd+0xc4>
		for(j=0; j<10; j++);
#endif
		EmbedSky_write_cmd(0x30);
33d096e8:	e3a00030 	mov	r0, #48	; 0x30
33d096ec:	ebffff64 	bl	33d09484 <EmbedSky_write_cmd>
		EmbedSky_wait_idle();
33d096f0:	ebffff49 	bl	33d0941c <EmbedSky_wait_idle>

		dat = EmbedSky_read_data();
33d096f4:	ebffff65 	bl	33d09490 <EmbedSky_read_data>
33d096f8:	e1a04000 	mov	r4, r0
33d096fc:	e20440ff 	and	r4, r4, #255	; 0xff
		
		/* 取消片选信号 */
		EmbedSky_nand_deselect_chip();
33d09700:	ebffff5a 	bl	33d09470 <EmbedSky_nand_deselect_chip>
		if(dat != 0xff)
33d09704:	e35400ff 	cmp	r4, #255	; 0xff
		{
			i += 131072;		// 1 Block = 2048*64= 131072
33d09708:	12855802 	addne	r5, r5, #131072	; 0x20000
			printf("\nBad block at 0x%lx ,will be skipped\n",i);
33d0970c:	159f00e0 	ldrne	r0, [pc, #224]	; 33d097f4 <nand_read_ll_lp_lcd+0x1d8>
33d09710:	11a01005 	movne	r1, r5
33d09714:	1b00362b 	blne	33d16fc8 <printf>
		}
/* Read Page */
		/* 选中芯片 */
		EmbedSky_nand_select_chip();
33d09718:	ebffff4c 	bl	33d09450 <EmbedSky_nand_select_chip>
}
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0);
33d0971c:	e3a00000 	mov	r0, #0	; 0x0
33d09720:	ebffff57 	bl	33d09484 <EmbedSky_write_cmd>
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
	int col, page;

	col = addr & NAND_BLOCK_MASK_LP;
33d09724:	e1a01a85 	lsl	r1, r5, #21
33d09728:	e1a01aa1 	lsr	r1, r1, #21
	page = addr / NAND_SECTOR_SIZE_LP;
	
	*p = col & 0xff;			/* Column Address A0~A7 */
33d0972c:	e3c12000 	bic	r2, r1, #0	; 0x0
33d09730:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
/* 发出地址 */
static void EmbedSky_write_addr_lp(unsigned int addr)
{
	int i;
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
33d09734:	e59f00b4 	ldr	r0, [pc, #180]	; 33d097f0 <nand_read_ll_lp_lcd+0x1d4>
	int col, page;

	col = addr & NAND_BLOCK_MASK_LP;
	page = addr / NAND_SECTOR_SIZE_LP;
	
	*p = col & 0xff;			/* Column Address A0~A7 */
33d09738:	e5c3200c 	strb	r2, [r3, #12]
	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
	int col, page;

	col = addr & NAND_BLOCK_MASK_LP;
	page = addr / NAND_SECTOR_SIZE_LP;
33d0973c:	e1a025a5 	lsr	r2, r5, #11
33d09740:	e3a03009 	mov	r3, #9	; 0x9
33d09744:	e2533001 	subs	r3, r3, #1	; 0x1
33d09748:	5afffffd 	bpl	33d09744 <nand_read_ll_lp_lcd+0x128>
	
	*p = col & 0xff;			/* Column Address A0~A7 */
	for(i=0; i<10; i++);
	*p = (col >> 8) & 0x0f;		/* Column Address A8~A11 */
33d0974c:	e1a03421 	lsr	r3, r1, #8
33d09750:	e5c03000 	strb	r3, [r0]
33d09754:	e3a03009 	mov	r3, #9	; 0x9
33d09758:	e2533001 	subs	r3, r3, #1	; 0x1
33d0975c:	5afffffd 	bpl	33d09758 <nand_read_ll_lp_lcd+0x13c>
	for(i=0; i<10; i++);
	*p = page & 0xff;			/* Row Address A12~A19 */
33d09760:	e5c02000 	strb	r2, [r0]
33d09764:	e3a03009 	mov	r3, #9	; 0x9
33d09768:	e2533001 	subs	r3, r3, #1	; 0x1
33d0976c:	5afffffd 	bpl	33d09768 <nand_read_ll_lp_lcd+0x14c>
	for(i=0; i<10; i++);
	*p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
33d09770:	e1a03442 	asr	r3, r2, #8
33d09774:	e5c03000 	strb	r3, [r0]
33d09778:	e3a03009 	mov	r3, #9	; 0x9
33d0977c:	e2533001 	subs	r3, r3, #1	; 0x1
33d09780:	5afffffd 	bpl	33d0977c <nand_read_ll_lp_lcd+0x160>
	for(i=0; i<10; i++);
#if (b128MB == 0)
	*p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
33d09784:	e1a03842 	asr	r3, r2, #16
33d09788:	e2033003 	and	r3, r3, #3	; 0x3
33d0978c:	e5c03000 	strb	r3, [r0]
33d09790:	e3a03009 	mov	r3, #9	; 0x9
33d09794:	e2533001 	subs	r3, r3, #1	; 0x1
33d09798:	5afffffd 	bpl	33d09794 <nand_read_ll_lp_lcd+0x178>
		/* 发出READ0命令 */
		EmbedSky_write_cmd(0);

		/* Write Address */
		EmbedSky_write_addr_lp(i);
		EmbedSky_write_cmd(0x30);
33d0979c:	e3a00030 	mov	r0, #48	; 0x30
33d097a0:	ebffff37 	bl	33d09484 <EmbedSky_write_cmd>
		EmbedSky_wait_idle();
33d097a4:	ebffff1c 	bl	33d0941c <EmbedSky_wait_idle>

		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
33d097a8:	e3a04000 	mov	r4, #0	; 0x0
		{
			*buf = EmbedSky_read_data();
33d097ac:	ebffff37 	bl	33d09490 <EmbedSky_read_data>
33d097b0:	e59d3000 	ldr	r3, [sp]
		/* Write Address */
		EmbedSky_write_addr_lp(i);
		EmbedSky_write_cmd(0x30);
		EmbedSky_wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
33d097b4:	e2844001 	add	r4, r4, #1	; 0x1
		{
			*buf = EmbedSky_read_data();
33d097b8:	e4c30001 	strb	r0, [r3], #1
		/* Write Address */
		EmbedSky_write_addr_lp(i);
		EmbedSky_write_cmd(0x30);
		EmbedSky_wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
33d097bc:	e3540b02 	cmp	r4, #2048	; 0x800
		{
			*buf = EmbedSky_read_data();
33d097c0:	e58d3000 	str	r3, [sp]
		/* Write Address */
		EmbedSky_write_addr_lp(i);
		EmbedSky_write_cmd(0x30);
		EmbedSky_wait_idle();

		for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++)
33d097c4:	e2855001 	add	r5, r5, #1	; 0x1
33d097c8:	bafffff7 	blt	33d097ac <nand_read_ll_lp_lcd+0x190>
		{
			*buf = EmbedSky_read_data();
			buf++;
		}

		current += 2048 ;				//HJ_add 滚动条
33d097cc:	e2899b02 	add	r9, r9, #2048	; 0x800
		drawProcessBar(total, current );			//HJ_add 滚动条
33d097d0:	e1a00007 	mov	r0, r7
33d097d4:	e1a01009 	mov	r1, r9
33d097d8:	ebfffdcf 	bl	33d08f1c <drawProcessBar>
33d097dc:	eaffffa1 	b	33d09668 <nand_read_ll_lp_lcd+0x4c>

	}

	/* 取消片选信号 */
	EmbedSky_nand_deselect_chip();
33d097e0:	ebffff22 	bl	33d09470 <EmbedSky_nand_deselect_chip>

	return 0;
33d097e4:	e3a00000 	mov	r0, #0	; 0x0
}
33d097e8:	e28dd004 	add	sp, sp, #4	; 0x4
33d097ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d097f0:	4e00000c 	.word	0x4e00000c
33d097f4:	33d26754 	.word	0x33d26754

33d097f8 <UsbdMain>:
33d097f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d097fc:	eb0003f8 	bl	33d0a7e4 <InitDescriptorTable>
33d09800:	eb000654 	bl	33d0b158 <ConfigUsbd>
33d09804:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d09808:	ea0005c6 	b	33d0af28 <PrepareEp1Fifo>

33d0980c <DbgPrintf>:
33d0980c:	e92d000f 	push	{r0, r1, r2, r3}
33d09810:	e28dd010 	add	sp, sp, #16	; 0x10
33d09814:	e1a0f00e 	mov	pc, lr

33d09818 <IsrUsbd>:
33d09818:	e92d4070 	push	{r4, r5, r6, lr}
33d0981c:	e59f50b8 	ldr	r5, [pc, #184]	; 33d098dc <IsrUsbd+0xc4>
33d09820:	e5952000 	ldr	r2, [r5]
33d09824:	e5d23038 	ldrb	r3, [r2, #56]
33d09828:	e5d21018 	ldrb	r1, [r2, #24]
33d0982c:	e3110001 	tst	r1, #1	; 0x1
33d09830:	e20360ff 	and	r6, r3, #255	; 0xff
33d09834:	13a03001 	movne	r3, #1	; 0x1
33d09838:	e5d24008 	ldrb	r4, [r2, #8]
33d0983c:	15c23018 	strbne	r3, [r2, #24]
33d09840:	e3110002 	tst	r1, #2	; 0x2
33d09844:	15952000 	ldrne	r2, [r5]
33d09848:	13a03002 	movne	r3, #2	; 0x2
33d0984c:	15c23018 	strbne	r3, [r2, #24]
33d09850:	e3110004 	tst	r1, #4	; 0x4
33d09854:	0a000004 	beq	33d0986c <IsrUsbd+0x54>
33d09858:	eb0005e8 	bl	33d0b000 <ReconfigUsbd>
33d0985c:	e5952000 	ldr	r2, [r5]
33d09860:	e3a03004 	mov	r3, #4	; 0x4
33d09864:	e5c23018 	strb	r3, [r2, #24]
33d09868:	eb0005ae 	bl	33d0af28 <PrepareEp1Fifo>
33d0986c:	e3140001 	tst	r4, #1	; 0x1
33d09870:	15952000 	ldrne	r2, [r5]
33d09874:	13a03001 	movne	r3, #1	; 0x1
33d09878:	15c23008 	strbne	r3, [r2, #8]
33d0987c:	1b000126 	blne	33d09d1c <Ep0Handler>
33d09880:	e3140002 	tst	r4, #2	; 0x2
33d09884:	15952000 	ldrne	r2, [r5]
33d09888:	13a03002 	movne	r3, #2	; 0x2
33d0988c:	15c23008 	strbne	r3, [r2, #8]
33d09890:	1b0005bf 	blne	33d0af94 <Ep1Handler>
33d09894:	e3140004 	tst	r4, #4	; 0x4
33d09898:	15952000 	ldrne	r2, [r5]
33d0989c:	13a03004 	movne	r3, #4	; 0x4
33d098a0:	15c23008 	strbne	r3, [r2, #8]
33d098a4:	e3140008 	tst	r4, #8	; 0x8
33d098a8:	15952000 	ldrne	r2, [r5]
33d098ac:	13a03008 	movne	r3, #8	; 0x8
33d098b0:	15c23008 	strbne	r3, [r2, #8]
33d098b4:	1b00002a 	blne	33d09964 <Ep3Handler>
33d098b8:	e3140010 	tst	r4, #16	; 0x10
33d098bc:	15952000 	ldrne	r2, [r5]
33d098c0:	13a03010 	movne	r3, #16	; 0x10
33d098c4:	15c23008 	strbne	r3, [r2, #8]
33d098c8:	e3a00402 	mov	r0, #33554432	; 0x2000000
33d098cc:	ebffdd94 	bl	33d00f24 <ClearPending>
33d098d0:	e5953000 	ldr	r3, [r5]
33d098d4:	e5c36038 	strb	r6, [r3, #56]
33d098d8:	e8bd8070 	pop	{r4, r5, r6, pc}
33d098dc:	33d60410 	.word	0x33d60410

33d098e0 <_WrDbgStrFifo>:
33d098e0:	e59f1024 	ldr	r1, [pc, #36]	; 33d0990c <_WrDbgStrFifo+0x2c>
33d098e4:	e59f2024 	ldr	r2, [pc, #36]	; 33d09910 <_WrDbgStrFifo+0x30>
33d098e8:	e5913000 	ldr	r3, [r1]
33d098ec:	e7c30002 	strb	r0, [r3, r2]
33d098f0:	e2833001 	add	r3, r3, #1	; 0x1
33d098f4:	e5813000 	str	r3, [r1]
33d098f8:	e5913000 	ldr	r3, [r1]
33d098fc:	e3530a01 	cmp	r3, #4096	; 0x1000
33d09900:	02433a01 	subeq	r3, r3, #4096	; 0x1000
33d09904:	05813000 	streq	r3, [r1]
33d09908:	e1a0f00e 	mov	pc, lr
33d0990c:	33d5f32c 	.word	0x33d5f32c
33d09910:	33d5f334 	.word	0x33d5f334

33d09914 <RdPktEp3_CheckSum>:
33d09914:	e3a0c000 	mov	ip, #0	; 0x0
33d09918:	e15c0001 	cmp	ip, r1
33d0991c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d09920:	e1a0e001 	mov	lr, r1
33d09924:	a49df004 	popge	{pc}		; (ldrge pc, [sp], #4)
33d09928:	e59f302c 	ldr	r3, [pc, #44]	; 33d0995c <RdPktEp3_CheckSum+0x48>
33d0992c:	e5933000 	ldr	r3, [r3]
33d09930:	e5d3308c 	ldrb	r3, [r3, #140]
33d09934:	e59f1024 	ldr	r1, [pc, #36]	; 33d09960 <RdPktEp3_CheckSum+0x4c>
33d09938:	e7c0300c 	strb	r3, [r0, ip]
33d0993c:	e7d0200c 	ldrb	r2, [r0, ip]
33d09940:	e1d130b0 	ldrh	r3, [r1]
33d09944:	e28cc001 	add	ip, ip, #1	; 0x1
33d09948:	e0833002 	add	r3, r3, r2
33d0994c:	e15c000e 	cmp	ip, lr
33d09950:	e1c130b0 	strh	r3, [r1]
33d09954:	bafffff3 	blt	33d09928 <RdPktEp3_CheckSum+0x14>
33d09958:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d0995c:	33d60410 	.word	0x33d60410
33d09960:	33d60430 	.word	0x33d60430

33d09964 <Ep3Handler>:
33d09964:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d09968:	e59f6170 	ldr	r6, [pc, #368]	; 33d09ae0 <Ep3Handler+0x17c>
33d0996c:	e5963000 	ldr	r3, [r6]
33d09970:	e3a02003 	mov	r2, #3	; 0x3
33d09974:	e5c32038 	strb	r2, [r3, #56]
33d09978:	e5963000 	ldr	r3, [r6]
33d0997c:	e5d34050 	ldrb	r4, [r3, #80]
33d09980:	e59f015c 	ldr	r0, [pc, #348]	; 33d09ae4 <Ep3Handler+0x180>
33d09984:	e1a01004 	mov	r1, r4
33d09988:	ebffff9f 	bl	33d0980c <DbgPrintf>
33d0998c:	e3140001 	tst	r4, #1	; 0x1
33d09990:	e59fa150 	ldr	sl, [pc, #336]	; 33d09ae8 <Ep3Handler+0x184>
33d09994:	0a000049 	beq	33d09ac0 <Ep3Handler+0x15c>
33d09998:	e5963000 	ldr	r3, [r6]
33d0999c:	e5d32058 	ldrb	r2, [r3, #88]
33d099a0:	e59a3000 	ldr	r3, [sl]
33d099a4:	e3530000 	cmp	r3, #0	; 0x0
33d099a8:	e59f013c 	ldr	r0, [pc, #316]	; 33d09aec <Ep3Handler+0x188>
33d099ac:	e3a01008 	mov	r1, #8	; 0x8
33d099b0:	e20270ff 	and	r7, r2, #255	; 0xff
33d099b4:	e59f5134 	ldr	r5, [pc, #308]	; 33d09af0 <Ep3Handler+0x18c>
33d099b8:	1a000035 	bne	33d09a94 <Ep3Handler+0x130>
33d099bc:	e5950000 	ldr	r0, [r5]
33d099c0:	eb00061d 	bl	33d0b23c <RdPktEp3>
33d099c4:	e59f3128 	ldr	r3, [pc, #296]	; 33d09af4 <Ep3Handler+0x190>
33d099c8:	e5933000 	ldr	r3, [r3]
33d099cc:	e3530000 	cmp	r3, #0	; 0x0
33d099d0:	059f3120 	ldreq	r3, [pc, #288]	; 33d09af8 <Ep3Handler+0x194>
33d099d4:	e59fc120 	ldr	ip, [pc, #288]	; 33d09afc <Ep3Handler+0x198>
33d099d8:	05933000 	ldreq	r3, [r3]
33d099dc:	e1a04005 	mov	r4, r5
33d099e0:	058c3000 	streq	r3, [ip]
33d099e4:	0a00000e 	beq	33d09a24 <Ep3Handler+0xc0>
33d099e8:	e5952000 	ldr	r2, [r5]
33d099ec:	e5d23000 	ldrb	r3, [r2]
33d099f0:	e5d21001 	ldrb	r1, [r2, #1]
33d099f4:	e5d20002 	ldrb	r0, [r2, #2]
33d099f8:	e0833401 	add	r3, r3, r1, lsl #8
33d099fc:	e5d22003 	ldrb	r2, [r2, #3]
33d09a00:	e0833800 	add	r3, r3, r0, lsl #16
33d09a04:	e0833c02 	add	r3, r3, r2, lsl #24
33d09a08:	e58c3000 	str	r3, [ip]
33d09a0c:	e59f30ec 	ldr	r3, [pc, #236]	; 33d09b00 <Ep3Handler+0x19c>
33d09a10:	e59c2000 	ldr	r2, [ip]
33d09a14:	e5832000 	str	r2, [r3]
33d09a18:	e59f30e4 	ldr	r3, [pc, #228]	; 33d09b04 <Ep3Handler+0x1a0>
33d09a1c:	e59c2000 	ldr	r2, [ip]
33d09a20:	e5832000 	str	r2, [r3]
33d09a24:	e5942000 	ldr	r2, [r4]
33d09a28:	e5d20005 	ldrb	r0, [r2, #5]
33d09a2c:	e5d23004 	ldrb	r3, [r2, #4]
33d09a30:	e5d2c006 	ldrb	ip, [r2, #6]
33d09a34:	e0833400 	add	r3, r3, r0, lsl #8
33d09a38:	e5d22007 	ldrb	r2, [r2, #7]
33d09a3c:	e083380c 	add	r3, r3, ip, lsl #16
33d09a40:	e0833c02 	add	r3, r3, r2, lsl #24
33d09a44:	e58a3000 	str	r3, [sl]
33d09a48:	e59f30b8 	ldr	r3, [pc, #184]	; 33d09b08 <Ep3Handler+0x1a4>
33d09a4c:	e3a02000 	mov	r2, #0	; 0x0
33d09a50:	e1c320b0 	strh	r2, [r3]
33d09a54:	e59f30a0 	ldr	r3, [pc, #160]	; 33d09afc <Ep3Handler+0x198>
33d09a58:	e5933000 	ldr	r3, [r3]
33d09a5c:	e2471008 	sub	r1, r7, #8	; 0x8
33d09a60:	e1a00003 	mov	r0, r3
33d09a64:	e5843000 	str	r3, [r4]
33d09a68:	ebffffa9 	bl	33d09914 <RdPktEp3_CheckSum>
33d09a6c:	e5943000 	ldr	r3, [r4]
33d09a70:	e0833007 	add	r3, r3, r7
33d09a74:	e2433008 	sub	r3, r3, #8	; 0x8
33d09a78:	e5843000 	str	r3, [r4]
33d09a7c:	e59f3088 	ldr	r3, [pc, #136]	; 33d09b0c <Ep3Handler+0x1a8>
33d09a80:	e5932000 	ldr	r2, [r3]
33d09a84:	e5923008 	ldr	r3, [r2, #8]
33d09a88:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
33d09a8c:	e5823008 	str	r3, [r2, #8]
33d09a90:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d09a94:	eb00354b 	bl	33d16fc8 <printf>
33d09a98:	e1a01007 	mov	r1, r7
33d09a9c:	e5950000 	ldr	r0, [r5]
33d09aa0:	ebffff9b 	bl	33d09914 <RdPktEp3_CheckSum>
33d09aa4:	e5953000 	ldr	r3, [r5]
33d09aa8:	e5961000 	ldr	r1, [r6]
33d09aac:	e0833007 	add	r3, r3, r7
33d09ab0:	e204204e 	and	r2, r4, #78	; 0x4e
33d09ab4:	e5853000 	str	r3, [r5]
33d09ab8:	e5c12050 	strb	r2, [r1, #80]
33d09abc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d09ac0:	e3140040 	tst	r4, #64	; 0x40
33d09ac4:	e59f0044 	ldr	r0, [pc, #68]	; 33d09b10 <Ep3Handler+0x1ac>
33d09ac8:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
33d09acc:	ebffff4e 	bl	33d0980c <DbgPrintf>
33d09ad0:	e5962000 	ldr	r2, [r6]
33d09ad4:	e204300f 	and	r3, r4, #15	; 0xf
33d09ad8:	e5c23050 	strb	r3, [r2, #80]
33d09adc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d09ae0:	33d60410 	.word	0x33d60410
33d09ae4:	33d2677c 	.word	0x33d2677c
33d09ae8:	33d6042c 	.word	0x33d6042c
33d09aec:	33d26784 	.word	0x33d26784
33d09af0:	33d60428 	.word	0x33d60428
33d09af4:	33d60404 	.word	0x33d60404
33d09af8:	33d6043c 	.word	0x33d6043c
33d09afc:	33d60420 	.word	0x33d60420
33d09b00:	33d60440 	.word	0x33d60440
33d09b04:	33d60444 	.word	0x33d60444
33d09b08:	33d60430 	.word	0x33d60430
33d09b0c:	33d37248 	.word	0x33d37248
33d09b10:	33d2678c 	.word	0x33d2678c

33d09b14 <IsrDma2>:
33d09b14:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d09b18:	e59f9168 	ldr	r9, [pc, #360]	; 33d09c88 <IsrDma2+0x174>
33d09b1c:	e5992000 	ldr	r2, [r9]
33d09b20:	e3a03003 	mov	r3, #3	; 0x3
33d09b24:	e5d21038 	ldrb	r1, [r2, #56]
33d09b28:	e5c23038 	strb	r3, [r2, #56]
33d09b2c:	e5993000 	ldr	r3, [r9]
33d09b30:	e59f5154 	ldr	r5, [pc, #340]	; 33d09c8c <IsrDma2+0x178>
33d09b34:	e5d33050 	ldrb	r3, [r3, #80]
33d09b38:	e24dd004 	sub	sp, sp, #4	; 0x4
33d09b3c:	e20110ff 	and	r1, r1, #255	; 0xff
33d09b40:	e3a00702 	mov	r0, #524288	; 0x80000
33d09b44:	e58d1000 	str	r1, [sp]
33d09b48:	e203b0ff 	and	fp, r3, #255	; 0xff
33d09b4c:	ebffdcf4 	bl	33d00f24 <ClearPending>
33d09b50:	e5953000 	ldr	r3, [r5]
33d09b54:	e59f2134 	ldr	r2, [pc, #308]	; 33d09c90 <IsrDma2+0x17c>
33d09b58:	e3530000 	cmp	r3, #0	; 0x0
33d09b5c:	15953000 	ldrne	r3, [r5]
33d09b60:	05923000 	ldreq	r3, [r2]
33d09b64:	15922000 	ldrne	r2, [r2]
33d09b68:	02833020 	addeq	r3, r3, #32	; 0x20
33d09b6c:	10833002 	addne	r3, r3, r2
33d09b70:	e5853000 	str	r3, [r5]
33d09b74:	e59fa118 	ldr	sl, [pc, #280]	; 33d09c94 <IsrDma2+0x180>
33d09b78:	e59f6110 	ldr	r6, [pc, #272]	; 33d09c90 <IsrDma2+0x17c>
33d09b7c:	e59f4114 	ldr	r4, [pc, #276]	; 33d09c98 <IsrDma2+0x184>
33d09b80:	e59a0000 	ldr	r0, [sl]
33d09b84:	e5963000 	ldr	r3, [r6]
33d09b88:	e59f710c 	ldr	r7, [pc, #268]	; 33d09c9c <IsrDma2+0x188>
33d09b8c:	e5942000 	ldr	r2, [r4]
33d09b90:	e0800003 	add	r0, r0, r3
33d09b94:	e5971000 	ldr	r1, [r7]
33d09b98:	e0620000 	rsb	r0, r2, r0
33d09b9c:	eb00533f 	bl	33d1e8a0 <__umodsi3>
33d09ba0:	e5943000 	ldr	r3, [r4]
33d09ba4:	e0800003 	add	r0, r0, r3
33d09ba8:	e58a0000 	str	r0, [sl]
33d09bac:	e59f10ec 	ldr	r1, [pc, #236]	; 33d09ca0 <IsrDma2+0x18c>
33d09bb0:	e5952000 	ldr	r2, [r5]
33d09bb4:	e5913000 	ldr	r3, [r1]
33d09bb8:	e1520003 	cmp	r2, r3
33d09bbc:	e59f00c8 	ldr	r0, [pc, #200]	; 33d09c8c <IsrDma2+0x178>
33d09bc0:	3a000010 	bcc	33d09c08 <IsrDma2+0xf4>
33d09bc4:	e5913000 	ldr	r3, [r1]
33d09bc8:	e5853000 	str	r3, [r5]
33d09bcc:	eb0005f0 	bl	33d0b394 <ConfigEp3IntMode>
33d09bd0:	e31b0001 	tst	fp, #1	; 0x1
33d09bd4:	15992000 	ldrne	r2, [r9]
33d09bd8:	120b304e 	andne	r3, fp, #78	; 0x4e
33d09bdc:	15c23050 	strbne	r3, [r2, #80]
33d09be0:	e59f10bc 	ldr	r1, [pc, #188]	; 33d09ca4 <IsrDma2+0x190>
33d09be4:	e5912000 	ldr	r2, [r1]
33d09be8:	e5923008 	ldr	r3, [r2, #8]
33d09bec:	e3833702 	orr	r3, r3, #524288	; 0x80000
33d09bf0:	e5823008 	str	r3, [r2, #8]
33d09bf4:	e5912000 	ldr	r2, [r1]
33d09bf8:	e5923008 	ldr	r3, [r2, #8]
33d09bfc:	e3c33402 	bic	r3, r3, #33554432	; 0x2000000
33d09c00:	e5823008 	str	r3, [r2, #8]
33d09c04:	ea000019 	b	33d09c70 <IsrDma2+0x15c>
33d09c08:	e5903000 	ldr	r3, [r0]
33d09c0c:	e5912000 	ldr	r2, [r1]
33d09c10:	e2833702 	add	r3, r3, #524288	; 0x80000
33d09c14:	e1530002 	cmp	r3, r2
33d09c18:	25913000 	ldrcs	r3, [r1]
33d09c1c:	25902000 	ldrcs	r2, [r0]
33d09c20:	33a03702 	movcc	r3, #524288	; 0x80000
33d09c24:	20623003 	rsbcs	r3, r2, r3
33d09c28:	e5863000 	str	r3, [r6]
33d09c2c:	e59f3074 	ldr	r3, [pc, #116]	; 33d09ca8 <IsrDma2+0x194>
33d09c30:	e5930000 	ldr	r0, [r3]
33d09c34:	e59a3000 	ldr	r3, [sl]
33d09c38:	e5972000 	ldr	r2, [r7]
33d09c3c:	e0630000 	rsb	r0, r3, r0
33d09c40:	e0800002 	add	r0, r0, r2
33d09c44:	e5971000 	ldr	r1, [r7]
33d09c48:	e2400001 	sub	r0, r0, #1	; 0x1
33d09c4c:	eb005313 	bl	33d1e8a0 <__umodsi3>
33d09c50:	e5963000 	ldr	r3, [r6]
33d09c54:	e1500003 	cmp	r0, r3
33d09c58:	359f304c 	ldrcc	r3, [pc, #76]	; 33d09cac <IsrDma2+0x198>
33d09c5c:	33a02001 	movcc	r2, #1	; 0x1
33d09c60:	35832000 	strcc	r2, [r3]
33d09c64:	259a0000 	ldrcs	r0, [sl]
33d09c68:	25961000 	ldrcs	r1, [r6]
33d09c6c:	2b00058a 	blcs	33d0b29c <ConfigEp3DmaMode>
33d09c70:	e59f3010 	ldr	r3, [pc, #16]	; 33d09c88 <IsrDma2+0x174>
33d09c74:	e59d2000 	ldr	r2, [sp]
33d09c78:	e5933000 	ldr	r3, [r3]
33d09c7c:	e5c32038 	strb	r2, [r3, #56]
33d09c80:	e28dd004 	add	sp, sp, #4	; 0x4
33d09c84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d09c88:	33d60410 	.word	0x33d60410
33d09c8c:	33d60434 	.word	0x33d60434
33d09c90:	33d60448 	.word	0x33d60448
33d09c94:	33d60444 	.word	0x33d60444
33d09c98:	33d60450 	.word	0x33d60450
33d09c9c:	33d60454 	.word	0x33d60454
33d09ca0:	33d6042c 	.word	0x33d6042c
33d09ca4:	33d37248 	.word	0x33d37248
33d09ca8:	33d60440 	.word	0x33d60440
33d09cac:	33d6044c 	.word	0x33d6044c

33d09cb0 <ClearEp3OutPktReady>:
33d09cb0:	e59f101c 	ldr	r1, [pc, #28]	; 33d09cd4 <ClearEp3OutPktReady+0x24>
33d09cb4:	e5912000 	ldr	r2, [r1]
33d09cb8:	e3a03003 	mov	r3, #3	; 0x3
33d09cbc:	e5c23038 	strb	r3, [r2, #56]
33d09cc0:	e5912000 	ldr	r2, [r1]
33d09cc4:	e5d23050 	ldrb	r3, [r2, #80]
33d09cc8:	e203304e 	and	r3, r3, #78	; 0x4e
33d09ccc:	e5c23050 	strb	r3, [r2, #80]
33d09cd0:	e1a0f00e 	mov	pc, lr
33d09cd4:	33d60410 	.word	0x33d60410

33d09cd8 <PrintEp0Pkt>:
33d09cd8:	e92d4030 	push	{r4, r5, lr}
33d09cdc:	e1a05000 	mov	r5, r0
33d09ce0:	e59f0028 	ldr	r0, [pc, #40]	; 33d09d10 <PrintEp0Pkt+0x38>
33d09ce4:	ebfffec8 	bl	33d0980c <DbgPrintf>
33d09ce8:	e3a04000 	mov	r4, #0	; 0x0
33d09cec:	e7d51004 	ldrb	r1, [r5, r4]
33d09cf0:	e59f001c 	ldr	r0, [pc, #28]	; 33d09d14 <PrintEp0Pkt+0x3c>
33d09cf4:	e2844001 	add	r4, r4, #1	; 0x1
33d09cf8:	ebfffec3 	bl	33d0980c <DbgPrintf>
33d09cfc:	e3540007 	cmp	r4, #7	; 0x7
33d09d00:	dafffff9 	ble	33d09cec <PrintEp0Pkt+0x14>
33d09d04:	e59f000c 	ldr	r0, [pc, #12]	; 33d09d18 <PrintEp0Pkt+0x40>
33d09d08:	e8bd4030 	pop	{r4, r5, lr}
33d09d0c:	eafffebe 	b	33d0980c <DbgPrintf>
33d09d10:	33d26794 	.word	0x33d26794
33d09d14:	33d2679c 	.word	0x33d2679c
33d09d18:	33d267f0 	.word	0x33d267f0

33d09d1c <Ep0Handler>:
33d09d1c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d09d20:	e59f79c8 	ldr	r7, [pc, #2504]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d09d24:	e5973000 	ldr	r3, [r7]
33d09d28:	e3a02000 	mov	r2, #0	; 0x0
33d09d2c:	e5c32038 	strb	r2, [r3, #56]
33d09d30:	e5973000 	ldr	r3, [r7]
33d09d34:	e5d34044 	ldrb	r4, [r3, #68]
33d09d38:	e20460ff 	and	r6, r4, #255	; 0xff
33d09d3c:	e59f09b0 	ldr	r0, [pc, #2480]	; 33d0a6f4 <Ep0Handler+0x9d8>
33d09d40:	e1a01006 	mov	r1, r6
33d09d44:	ebfffeb0 	bl	33d0980c <DbgPrintf>
33d09d48:	e214a010 	ands	sl, r4, #16	; 0x10
33d09d4c:	0a000016 	beq	33d09dac <Ep0Handler+0x90>
33d09d50:	e59f09a0 	ldr	r0, [pc, #2464]	; 33d0a6f8 <Ep0Handler+0x9dc>
33d09d54:	ebfffeac 	bl	33d0980c <DbgPrintf>
33d09d58:	e204303f 	and	r3, r4, #63	; 0x3f
33d09d5c:	e1e03c83 	mvn	r3, r3, lsl #25
33d09d60:	e5972000 	ldr	r2, [r7]
33d09d64:	e1e03ca3 	mvn	r3, r3, lsr #25
33d09d68:	e3140001 	tst	r4, #1	; 0x1
33d09d6c:	e5c23044 	strb	r3, [r2, #68]
33d09d70:	0a000009 	beq	33d09d9c <Ep0Handler+0x80>
33d09d74:	e5970000 	ldr	r0, [r7]
33d09d78:	e5d03058 	ldrb	r3, [r0, #88]
33d09d7c:	e3530000 	cmp	r3, #0	; 0x0
33d09d80:	15d03080 	ldrbne	r3, [r0, #128]
33d09d84:	1afffffb 	bne	33d09d78 <Ep0Handler+0x5c>
33d09d88:	e59f2960 	ldr	r2, [pc, #2400]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d09d8c:	e206303f 	and	r3, r6, #63	; 0x3f
33d09d90:	e5922000 	ldr	r2, [r2]
33d09d94:	e3833040 	orr	r3, r3, #64	; 0x40
33d09d98:	e5c23044 	strb	r3, [r2, #68]
33d09d9c:	e59f3958 	ldr	r3, [pc, #2392]	; 33d0a6fc <Ep0Handler+0x9e0>
33d09da0:	e3a02000 	mov	r2, #0	; 0x0
33d09da4:	e5832000 	str	r2, [r3]
33d09da8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d09dac:	e3140004 	tst	r4, #4	; 0x4
33d09db0:	e2045001 	and	r5, r4, #1	; 0x1
33d09db4:	0a00000c 	beq	33d09dec <Ep0Handler+0xd0>
33d09db8:	e59f0940 	ldr	r0, [pc, #2368]	; 33d0a700 <Ep0Handler+0x9e4>
33d09dbc:	ebfffe92 	bl	33d0980c <DbgPrintf>
33d09dc0:	e5972000 	ldr	r2, [r7]
33d09dc4:	e204303b 	and	r3, r4, #59	; 0x3b
33d09dc8:	e5c23044 	strb	r3, [r2, #68]
33d09dcc:	e3550000 	cmp	r5, #0	; 0x0
33d09dd0:	1204303f 	andne	r3, r4, #63	; 0x3f
33d09dd4:	15972000 	ldrne	r2, [r7]
33d09dd8:	13833040 	orrne	r3, r3, #64	; 0x40
33d09ddc:	15c23044 	strbne	r3, [r2, #68]
33d09de0:	e59f3914 	ldr	r3, [pc, #2324]	; 33d0a6fc <Ep0Handler+0x9e0>
33d09de4:	e583a000 	str	sl, [r3]
33d09de8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d09dec:	e3550000 	cmp	r5, #0	; 0x0
33d09df0:	0a000119 	beq	33d0a25c <Ep0Handler+0x540>
33d09df4:	e59f4908 	ldr	r4, [pc, #2312]	; 33d0a704 <Ep0Handler+0x9e8>
33d09df8:	e3a01008 	mov	r1, #8	; 0x8
33d09dfc:	e1a00004 	mov	r0, r4
33d09e00:	eb0004dd 	bl	33d0b17c <RdPktEp0>
33d09e04:	e1a00004 	mov	r0, r4
33d09e08:	ebffffb2 	bl	33d09cd8 <PrintEp0Pkt>
33d09e0c:	e5d43001 	ldrb	r3, [r4, #1]
33d09e10:	e59f58e4 	ldr	r5, [pc, #2276]	; 33d0a6fc <Ep0Handler+0x9e0>
33d09e14:	e353000c 	cmp	r3, #12	; 0xc
33d09e18:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d09e1c:	ea000105 	b	33d0a238 <Ep0Handler+0x51c>
33d09e20:	33d0a0b4 	.word	0x33d0a0b4
33d09e24:	33d0a01c 	.word	0x33d0a01c
33d09e28:	33d0a238 	.word	0x33d0a238
33d09e2c:	33d0a180 	.word	0x33d0a180
33d09e30:	33d0a238 	.word	0x33d0a238
33d09e34:	33d09fb0 	.word	0x33d09fb0
33d09e38:	33d09e54 	.word	0x33d09e54
33d09e3c:	33d0a244 	.word	0x33d0a244
33d09e40:	33d0a084 	.word	0x33d0a084
33d09e44:	33d09fe4 	.word	0x33d09fe4
33d09e48:	33d0a09c 	.word	0x33d0a09c
33d09e4c:	33d0a218 	.word	0x33d0a218
33d09e50:	33d0a254 	.word	0x33d0a254
33d09e54:	e5d43003 	ldrb	r3, [r4, #3]
33d09e58:	e2433001 	sub	r3, r3, #1	; 0x1
33d09e5c:	e59f5898 	ldr	r5, [pc, #2200]	; 33d0a6fc <Ep0Handler+0x9e0>
33d09e60:	e3530004 	cmp	r3, #4	; 0x4
33d09e64:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d09e68:	ea00004d 	b	33d09fa4 <Ep0Handler+0x288>
33d09e6c:	33d09e80 	.word	0x33d09e80
33d09e70:	33d09ea0 	.word	0x33d09ea0
33d09e74:	33d09ed8 	.word	0x33d09ed8
33d09e78:	33d09f48 	.word	0x33d09f48
33d09e7c:	33d09f68 	.word	0x33d09f68
33d09e80:	e59f0880 	ldr	r0, [pc, #2176]	; 33d0a708 <Ep0Handler+0x9ec>
33d09e84:	ebfffe60 	bl	33d0980c <DbgPrintf>
33d09e88:	e5973000 	ldr	r3, [r7]
33d09e8c:	e206203f 	and	r2, r6, #63	; 0x3f
33d09e90:	e3822040 	orr	r2, r2, #64	; 0x40
33d09e94:	e5c32044 	strb	r2, [r3, #68]
33d09e98:	e3a0300a 	mov	r3, #10	; 0xa
33d09e9c:	ea0000ed 	b	33d0a258 <Ep0Handler+0x53c>
33d09ea0:	e59f0864 	ldr	r0, [pc, #2148]	; 33d0a70c <Ep0Handler+0x9f0>
33d09ea4:	ebfffe58 	bl	33d0980c <DbgPrintf>
33d09ea8:	e5972000 	ldr	r2, [r7]
33d09eac:	e206303f 	and	r3, r6, #63	; 0x3f
33d09eb0:	e3833040 	orr	r3, r3, #64	; 0x40
33d09eb4:	e5c23044 	strb	r3, [r2, #68]
33d09eb8:	e5d42007 	ldrb	r2, [r4, #7]
33d09ebc:	e5d43006 	ldrb	r3, [r4, #6]
33d09ec0:	e0833402 	add	r3, r3, r2, lsl #8
33d09ec4:	e3530009 	cmp	r3, #9	; 0x9
33d09ec8:	e59f582c 	ldr	r5, [pc, #2092]	; 33d0a6fc <Ep0Handler+0x9e0>
33d09ecc:	c3a03014 	movgt	r3, #20	; 0x14
33d09ed0:	d3a03028 	movle	r3, #40	; 0x28
33d09ed4:	ea0000df 	b	33d0a258 <Ep0Handler+0x53c>
33d09ed8:	e59f0830 	ldr	r0, [pc, #2096]	; 33d0a710 <Ep0Handler+0x9f4>
33d09edc:	ebfffe4a 	bl	33d0980c <DbgPrintf>
33d09ee0:	e5972000 	ldr	r2, [r7]
33d09ee4:	e206303f 	and	r3, r6, #63	; 0x3f
33d09ee8:	e3833040 	orr	r3, r3, #64	; 0x40
33d09eec:	e5c23044 	strb	r3, [r2, #68]
33d09ef0:	e5d40002 	ldrb	r0, [r4, #2]
33d09ef4:	e3500001 	cmp	r0, #1	; 0x1
33d09ef8:	0a000007 	beq	33d09f1c <Ep0Handler+0x200>
33d09efc:	ca000003 	bgt	33d09f10 <Ep0Handler+0x1f4>
33d09f00:	e3500000 	cmp	r0, #0	; 0x0
33d09f04:	03a0201e 	moveq	r2, #30	; 0x1e
33d09f08:	0a000006 	beq	33d09f28 <Ep0Handler+0x20c>
33d09f0c:	ea000008 	b	33d09f34 <Ep0Handler+0x218>
33d09f10:	e3500002 	cmp	r0, #2	; 0x2
33d09f14:	0a000002 	beq	33d09f24 <Ep0Handler+0x208>
33d09f18:	ea000005 	b	33d09f34 <Ep0Handler+0x218>
33d09f1c:	e3a0201f 	mov	r2, #31	; 0x1f
33d09f20:	ea000000 	b	33d09f28 <Ep0Handler+0x20c>
33d09f24:	e3a02020 	mov	r2, #32	; 0x20
33d09f28:	e59f37cc 	ldr	r3, [pc, #1996]	; 33d0a6fc <Ep0Handler+0x9e0>
33d09f2c:	e5832000 	str	r2, [r3]
33d09f30:	ea000001 	b	33d09f3c <Ep0Handler+0x220>
33d09f34:	e59f07d8 	ldr	r0, [pc, #2008]	; 33d0a714 <Ep0Handler+0x9f8>
33d09f38:	ebfffe33 	bl	33d0980c <DbgPrintf>
33d09f3c:	e59f37d4 	ldr	r3, [pc, #2004]	; 33d0a718 <Ep0Handler+0x9fc>
33d09f40:	e3a02000 	mov	r2, #0	; 0x0
33d09f44:	ea0000b1 	b	33d0a210 <Ep0Handler+0x4f4>
33d09f48:	e59f07cc 	ldr	r0, [pc, #1996]	; 33d0a71c <Ep0Handler+0xa00>
33d09f4c:	ebfffe2e 	bl	33d0980c <DbgPrintf>
33d09f50:	e5973000 	ldr	r3, [r7]
33d09f54:	e206203f 	and	r2, r6, #63	; 0x3f
33d09f58:	e3822040 	orr	r2, r2, #64	; 0x40
33d09f5c:	e5c32044 	strb	r2, [r3, #68]
33d09f60:	e3a0302a 	mov	r3, #42	; 0x2a
33d09f64:	ea0000bb 	b	33d0a258 <Ep0Handler+0x53c>
33d09f68:	e59f07b0 	ldr	r0, [pc, #1968]	; 33d0a720 <Ep0Handler+0xa04>
33d09f6c:	ebfffe26 	bl	33d0980c <DbgPrintf>
33d09f70:	e5973000 	ldr	r3, [r7]
33d09f74:	e206203f 	and	r2, r6, #63	; 0x3f
33d09f78:	e3822040 	orr	r2, r2, #64	; 0x40
33d09f7c:	e5c32044 	strb	r2, [r3, #68]
33d09f80:	e5d43002 	ldrb	r3, [r4, #2]
33d09f84:	e213300f 	ands	r3, r3, #15	; 0xf
33d09f88:	03a0202c 	moveq	r2, #44	; 0x2c
33d09f8c:	0a00009e 	beq	33d0a20c <Ep0Handler+0x4f0>
33d09f90:	e3530001 	cmp	r3, #1	; 0x1
33d09f94:	03a0202d 	moveq	r2, #45	; 0x2d
33d09f98:	0a00009b 	beq	33d0a20c <Ep0Handler+0x4f0>
33d09f9c:	e59f0780 	ldr	r0, [pc, #1920]	; 33d0a724 <Ep0Handler+0xa08>
33d09fa0:	ea000000 	b	33d09fa8 <Ep0Handler+0x28c>
33d09fa4:	e59f077c 	ldr	r0, [pc, #1916]	; 33d0a728 <Ep0Handler+0xa0c>
33d09fa8:	ebfffe17 	bl	33d0980c <DbgPrintf>
33d09fac:	ea0000aa 	b	33d0a25c <Ep0Handler+0x540>
33d09fb0:	e59f0774 	ldr	r0, [pc, #1908]	; 33d0a72c <Ep0Handler+0xa10>
33d09fb4:	e5d41002 	ldrb	r1, [r4, #2]
33d09fb8:	ebfffe13 	bl	33d0980c <DbgPrintf>
33d09fbc:	e5d43002 	ldrb	r3, [r4, #2]
33d09fc0:	e5972000 	ldr	r2, [r7]
33d09fc4:	e1e03c83 	mvn	r3, r3, lsl #25
33d09fc8:	e1e03ca3 	mvn	r3, r3, lsr #25
33d09fcc:	e5c23000 	strb	r3, [r2]
33d09fd0:	e206303f 	and	r3, r6, #63	; 0x3f
33d09fd4:	e5972000 	ldr	r2, [r7]
33d09fd8:	e3833048 	orr	r3, r3, #72	; 0x48
33d09fdc:	e5c23044 	strb	r3, [r2, #68]
33d09fe0:	ea00009b 	b	33d0a254 <Ep0Handler+0x538>
33d09fe4:	e59f0744 	ldr	r0, [pc, #1860]	; 33d0a730 <Ep0Handler+0xa14>
33d09fe8:	ebfffe07 	bl	33d0980c <DbgPrintf>
33d09fec:	e5d41002 	ldrb	r1, [r4, #2]
33d09ff0:	e59f273c 	ldr	r2, [pc, #1852]	; 33d0a734 <Ep0Handler+0xa18>
33d09ff4:	e5970000 	ldr	r0, [r7]
33d09ff8:	e206303f 	and	r3, r6, #63	; 0x3f
33d09ffc:	e3833048 	orr	r3, r3, #72	; 0x48
33d0a000:	e5c21000 	strb	r1, [r2]
33d0a004:	e5c03044 	strb	r3, [r0, #68]
33d0a008:	e3a03000 	mov	r3, #0	; 0x0
33d0a00c:	e5853000 	str	r3, [r5]
33d0a010:	e59f3720 	ldr	r3, [pc, #1824]	; 33d0a738 <Ep0Handler+0xa1c>
33d0a014:	e3a02001 	mov	r2, #1	; 0x1
33d0a018:	ea00007c 	b	33d0a210 <Ep0Handler+0x4f4>
33d0a01c:	e5d40000 	ldrb	r0, [r4]
33d0a020:	e3500000 	cmp	r0, #0	; 0x0
33d0a024:	e59f36d8 	ldr	r3, [pc, #1752]	; 33d0a704 <Ep0Handler+0x9e8>
33d0a028:	0a000002 	beq	33d0a038 <Ep0Handler+0x31c>
33d0a02c:	e3500002 	cmp	r0, #2	; 0x2
33d0a030:	0a000005 	beq	33d0a04c <Ep0Handler+0x330>
33d0a034:	ea00006f 	b	33d0a1f8 <Ep0Handler+0x4dc>
33d0a038:	e5d33002 	ldrb	r3, [r3, #2]
33d0a03c:	e3530001 	cmp	r3, #1	; 0x1
33d0a040:	059f36f4 	ldreq	r3, [pc, #1780]	; 33d0a73c <Ep0Handler+0xa20>
33d0a044:	05c30000 	strbeq	r0, [r3]
33d0a048:	ea00006a 	b	33d0a1f8 <Ep0Handler+0x4dc>
33d0a04c:	e5d32002 	ldrb	r2, [r3, #2]
33d0a050:	e3520000 	cmp	r2, #0	; 0x0
33d0a054:	1a000067 	bne	33d0a1f8 <Ep0Handler+0x4dc>
33d0a058:	e5d31004 	ldrb	r1, [r3, #4]
33d0a05c:	e311007f 	tst	r1, #127	; 0x7f
33d0a060:	059f36d8 	ldreq	r3, [pc, #1752]	; 33d0a740 <Ep0Handler+0xa24>
33d0a064:	e201108f 	and	r1, r1, #143	; 0x8f
33d0a068:	05c32002 	strbeq	r2, [r3, #2]
33d0a06c:	e3510081 	cmp	r1, #129	; 0x81
33d0a070:	059f36c8 	ldreq	r3, [pc, #1736]	; 33d0a740 <Ep0Handler+0xa24>
33d0a074:	05c32003 	strbeq	r2, [r3, #3]
33d0a078:	e3510003 	cmp	r1, #3	; 0x3
33d0a07c:	1a00005d 	bne	33d0a1f8 <Ep0Handler+0x4dc>
33d0a080:	ea00005a 	b	33d0a1f0 <Ep0Handler+0x4d4>
33d0a084:	e5973000 	ldr	r3, [r7]
33d0a088:	e206203f 	and	r2, r6, #63	; 0x3f
33d0a08c:	e3822040 	orr	r2, r2, #64	; 0x40
33d0a090:	e5c32044 	strb	r2, [r3, #68]
33d0a094:	e3a03021 	mov	r3, #33	; 0x21
33d0a098:	ea00006e 	b	33d0a258 <Ep0Handler+0x53c>
33d0a09c:	e5973000 	ldr	r3, [r7]
33d0a0a0:	e206203f 	and	r2, r6, #63	; 0x3f
33d0a0a4:	e3822040 	orr	r2, r2, #64	; 0x40
33d0a0a8:	e5c32044 	strb	r2, [r3, #68]
33d0a0ac:	e3a0302e 	mov	r3, #46	; 0x2e
33d0a0b0:	ea000068 	b	33d0a258 <Ep0Handler+0x53c>
33d0a0b4:	e5d40000 	ldrb	r0, [r4]
33d0a0b8:	e3500081 	cmp	r0, #129	; 0x81
33d0a0bc:	0a000013 	beq	33d0a110 <Ep0Handler+0x3f4>
33d0a0c0:	ca000002 	bgt	33d0a0d0 <Ep0Handler+0x3b4>
33d0a0c4:	e3500080 	cmp	r0, #128	; 0x80
33d0a0c8:	0a000003 	beq	33d0a0dc <Ep0Handler+0x3c0>
33d0a0cc:	ea000062 	b	33d0a25c <Ep0Handler+0x540>
33d0a0d0:	e3500082 	cmp	r0, #130	; 0x82
33d0a0d4:	0a000016 	beq	33d0a134 <Ep0Handler+0x418>
33d0a0d8:	ea00005f 	b	33d0a25c <Ep0Handler+0x540>
33d0a0dc:	e5972000 	ldr	r2, [r7]
33d0a0e0:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a0e4:	e3833040 	orr	r3, r3, #64	; 0x40
33d0a0e8:	e5c23044 	strb	r3, [r2, #68]
33d0a0ec:	e59f3648 	ldr	r3, [pc, #1608]	; 33d0a73c <Ep0Handler+0xa20>
33d0a0f0:	e5d32000 	ldrb	r2, [r3]
33d0a0f4:	e59f3648 	ldr	r3, [pc, #1608]	; 33d0a744 <Ep0Handler+0xa28>
33d0a0f8:	e5d33000 	ldrb	r3, [r3]
33d0a0fc:	e1833082 	orr	r3, r3, r2, lsl #1
33d0a100:	e59f2638 	ldr	r2, [pc, #1592]	; 33d0a740 <Ep0Handler+0xa24>
33d0a104:	e5c23000 	strb	r3, [r2]
33d0a108:	e3a02023 	mov	r2, #35	; 0x23
33d0a10c:	ea00003e 	b	33d0a20c <Ep0Handler+0x4f0>
33d0a110:	e5972000 	ldr	r2, [r7]
33d0a114:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a118:	e3833040 	orr	r3, r3, #64	; 0x40
33d0a11c:	e5c23044 	strb	r3, [r2, #68]
33d0a120:	e59f3618 	ldr	r3, [pc, #1560]	; 33d0a740 <Ep0Handler+0xa24>
33d0a124:	e3a02000 	mov	r2, #0	; 0x0
33d0a128:	e5c32001 	strb	r2, [r3, #1]
33d0a12c:	e2822024 	add	r2, r2, #36	; 0x24
33d0a130:	ea000035 	b	33d0a20c <Ep0Handler+0x4f0>
33d0a134:	e5973000 	ldr	r3, [r7]
33d0a138:	e206203f 	and	r2, r6, #63	; 0x3f
33d0a13c:	e3822040 	orr	r2, r2, #64	; 0x40
33d0a140:	e5c32044 	strb	r2, [r3, #68]
33d0a144:	e59f35b8 	ldr	r3, [pc, #1464]	; 33d0a704 <Ep0Handler+0x9e8>
33d0a148:	e5d31004 	ldrb	r1, [r3, #4]
33d0a14c:	e311007f 	tst	r1, #127	; 0x7f
33d0a150:	059f35a4 	ldreq	r3, [pc, #1444]	; 33d0a6fc <Ep0Handler+0x9e0>
33d0a154:	03a02025 	moveq	r2, #37	; 0x25
33d0a158:	e201108f 	and	r1, r1, #143	; 0x8f
33d0a15c:	05832000 	streq	r2, [r3]
33d0a160:	e3510081 	cmp	r1, #129	; 0x81
33d0a164:	059f3590 	ldreq	r3, [pc, #1424]	; 33d0a6fc <Ep0Handler+0x9e0>
33d0a168:	03a02026 	moveq	r2, #38	; 0x26
33d0a16c:	05832000 	streq	r2, [r3]
33d0a170:	e3510003 	cmp	r1, #3	; 0x3
33d0a174:	03a02027 	moveq	r2, #39	; 0x27
33d0a178:	0a000023 	beq	33d0a20c <Ep0Handler+0x4f0>
33d0a17c:	ea000036 	b	33d0a25c <Ep0Handler+0x540>
33d0a180:	e5d40000 	ldrb	r0, [r4]
33d0a184:	e3500000 	cmp	r0, #0	; 0x0
33d0a188:	e59f2574 	ldr	r2, [pc, #1396]	; 33d0a704 <Ep0Handler+0x9e8>
33d0a18c:	0a000002 	beq	33d0a19c <Ep0Handler+0x480>
33d0a190:	e3500002 	cmp	r0, #2	; 0x2
33d0a194:	0a000005 	beq	33d0a1b0 <Ep0Handler+0x494>
33d0a198:	ea000016 	b	33d0a1f8 <Ep0Handler+0x4dc>
33d0a19c:	e5d22002 	ldrb	r2, [r2, #2]
33d0a1a0:	e3520001 	cmp	r2, #1	; 0x1
33d0a1a4:	059f3590 	ldreq	r3, [pc, #1424]	; 33d0a73c <Ep0Handler+0xa20>
33d0a1a8:	05c32000 	strbeq	r2, [r3]
33d0a1ac:	ea000011 	b	33d0a1f8 <Ep0Handler+0x4dc>
33d0a1b0:	e5d23002 	ldrb	r3, [r2, #2]
33d0a1b4:	e3530000 	cmp	r3, #0	; 0x0
33d0a1b8:	1a00000e 	bne	33d0a1f8 <Ep0Handler+0x4dc>
33d0a1bc:	e5d21004 	ldrb	r1, [r2, #4]
33d0a1c0:	e311007f 	tst	r1, #127	; 0x7f
33d0a1c4:	059f3574 	ldreq	r3, [pc, #1396]	; 33d0a740 <Ep0Handler+0xa24>
33d0a1c8:	03a02001 	moveq	r2, #1	; 0x1
33d0a1cc:	e201108f 	and	r1, r1, #143	; 0x8f
33d0a1d0:	05c32002 	strbeq	r2, [r3, #2]
33d0a1d4:	e3510081 	cmp	r1, #129	; 0x81
33d0a1d8:	059f3560 	ldreq	r3, [pc, #1376]	; 33d0a740 <Ep0Handler+0xa24>
33d0a1dc:	03a02001 	moveq	r2, #1	; 0x1
33d0a1e0:	05c32003 	strbeq	r2, [r3, #3]
33d0a1e4:	e3510003 	cmp	r1, #3	; 0x3
33d0a1e8:	1a000002 	bne	33d0a1f8 <Ep0Handler+0x4dc>
33d0a1ec:	e3a02001 	mov	r2, #1	; 0x1
33d0a1f0:	e59f3548 	ldr	r3, [pc, #1352]	; 33d0a740 <Ep0Handler+0xa24>
33d0a1f4:	e5c32004 	strb	r2, [r3, #4]
33d0a1f8:	e5972000 	ldr	r2, [r7]
33d0a1fc:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a200:	e3833048 	orr	r3, r3, #72	; 0x48
33d0a204:	e5c23044 	strb	r3, [r2, #68]
33d0a208:	e3a02000 	mov	r2, #0	; 0x0
33d0a20c:	e59f34e8 	ldr	r3, [pc, #1256]	; 33d0a6fc <Ep0Handler+0x9e0>
33d0a210:	e5832000 	str	r2, [r3]
33d0a214:	ea000010 	b	33d0a25c <Ep0Handler+0x540>
33d0a218:	e5d41002 	ldrb	r1, [r4, #2]
33d0a21c:	e5970000 	ldr	r0, [r7]
33d0a220:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a224:	e59f251c 	ldr	r2, [pc, #1308]	; 33d0a748 <Ep0Handler+0xa2c>
33d0a228:	e3833048 	orr	r3, r3, #72	; 0x48
33d0a22c:	e5c21000 	strb	r1, [r2]
33d0a230:	e5c03044 	strb	r3, [r0, #68]
33d0a234:	ea000006 	b	33d0a254 <Ep0Handler+0x538>
33d0a238:	e5d41001 	ldrb	r1, [r4, #1]
33d0a23c:	e59f0508 	ldr	r0, [pc, #1288]	; 33d0a74c <Ep0Handler+0xa30>
33d0a240:	ebfffd71 	bl	33d0980c <DbgPrintf>
33d0a244:	e5973000 	ldr	r3, [r7]
33d0a248:	e206203f 	and	r2, r6, #63	; 0x3f
33d0a24c:	e3822048 	orr	r2, r2, #72	; 0x48
33d0a250:	e5c32044 	strb	r2, [r3, #68]
33d0a254:	e3a03000 	mov	r3, #0	; 0x0
33d0a258:	e5853000 	str	r3, [r5]
33d0a25c:	e59f7498 	ldr	r7, [pc, #1176]	; 33d0a6fc <Ep0Handler+0x9e0>
33d0a260:	e5973000 	ldr	r3, [r7]
33d0a264:	e353002e 	cmp	r3, #46	; 0x2e
33d0a268:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d0a26c:	ea00011b 	b	33d0a6e0 <Ep0Handler+0x9c4>
33d0a270:	33d0a6ec 	.word	0x33d0a6ec
33d0a274:	33d0a6e0 	.word	0x33d0a6e0
33d0a278:	33d0a6e0 	.word	0x33d0a6e0
33d0a27c:	33d0a6e0 	.word	0x33d0a6e0
33d0a280:	33d0a6e0 	.word	0x33d0a6e0
33d0a284:	33d0a6e0 	.word	0x33d0a6e0
33d0a288:	33d0a6e0 	.word	0x33d0a6e0
33d0a28c:	33d0a6e0 	.word	0x33d0a6e0
33d0a290:	33d0a6e0 	.word	0x33d0a6e0
33d0a294:	33d0a6e0 	.word	0x33d0a6e0
33d0a298:	33d0a32c 	.word	0x33d0a32c
33d0a29c:	33d0a35c 	.word	0x33d0a35c
33d0a2a0:	33d0a390 	.word	0x33d0a390
33d0a2a4:	33d0a6e0 	.word	0x33d0a6e0
33d0a2a8:	33d0a6e0 	.word	0x33d0a6e0
33d0a2ac:	33d0a6e0 	.word	0x33d0a6e0
33d0a2b0:	33d0a6e0 	.word	0x33d0a6e0
33d0a2b4:	33d0a6e0 	.word	0x33d0a6e0
33d0a2b8:	33d0a6e0 	.word	0x33d0a6e0
33d0a2bc:	33d0a6e0 	.word	0x33d0a6e0
33d0a2c0:	33d0a3a4 	.word	0x33d0a3a4
33d0a2c4:	33d0a3d4 	.word	0x33d0a3d4
33d0a2c8:	33d0a410 	.word	0x33d0a410
33d0a2cc:	33d0a44c 	.word	0x33d0a44c
33d0a2d0:	33d0a488 	.word	0x33d0a488
33d0a2d4:	33d0a6e0 	.word	0x33d0a6e0
33d0a2d8:	33d0a6e0 	.word	0x33d0a6e0
33d0a2dc:	33d0a6e0 	.word	0x33d0a6e0
33d0a2e0:	33d0a6e0 	.word	0x33d0a6e0
33d0a2e4:	33d0a6e0 	.word	0x33d0a6e0
33d0a2e8:	33d0a540 	.word	0x33d0a540
33d0a2ec:	33d0a578 	.word	0x33d0a578
33d0a2f0:	33d0a5f8 	.word	0x33d0a5f8
33d0a2f4:	33d0a690 	.word	0x33d0a690
33d0a2f8:	33d0a6e0 	.word	0x33d0a6e0
33d0a2fc:	33d0a698 	.word	0x33d0a698
33d0a300:	33d0a6a0 	.word	0x33d0a6a0
33d0a304:	33d0a6a8 	.word	0x33d0a6a8
33d0a308:	33d0a6b0 	.word	0x33d0a6b0
33d0a30c:	33d0a6b8 	.word	0x33d0a6b8
33d0a310:	33d0a494 	.word	0x33d0a494
33d0a314:	33d0a4c4 	.word	0x33d0a4c4
33d0a318:	33d0a4d4 	.word	0x33d0a4d4
33d0a31c:	33d0a504 	.word	0x33d0a504
33d0a320:	33d0a514 	.word	0x33d0a514
33d0a324:	33d0a524 	.word	0x33d0a524
33d0a328:	33d0a538 	.word	0x33d0a538
33d0a32c:	e59f041c 	ldr	r0, [pc, #1052]	; 33d0a750 <Ep0Handler+0xa34>
33d0a330:	ebfffd35 	bl	33d0980c <DbgPrintf>
33d0a334:	e59f0418 	ldr	r0, [pc, #1048]	; 33d0a754 <Ep0Handler+0xa38>
33d0a338:	e3a01008 	mov	r1, #8	; 0x8
33d0a33c:	eb00039a 	bl	33d0b1ac <WrPktEp0>
33d0a340:	e59f23a8 	ldr	r2, [pc, #936]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a344:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a348:	e5922000 	ldr	r2, [r2]
33d0a34c:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a350:	e5c23044 	strb	r3, [r2, #68]
33d0a354:	e3a0300b 	mov	r3, #11	; 0xb
33d0a358:	ea00000a 	b	33d0a388 <Ep0Handler+0x66c>
33d0a35c:	e59f03f4 	ldr	r0, [pc, #1012]	; 33d0a758 <Ep0Handler+0xa3c>
33d0a360:	ebfffd29 	bl	33d0980c <DbgPrintf>
33d0a364:	e59f03f0 	ldr	r0, [pc, #1008]	; 33d0a75c <Ep0Handler+0xa40>
33d0a368:	e3a01008 	mov	r1, #8	; 0x8
33d0a36c:	eb00038e 	bl	33d0b1ac <WrPktEp0>
33d0a370:	e59f2378 	ldr	r2, [pc, #888]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a374:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a378:	e5922000 	ldr	r2, [r2]
33d0a37c:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a380:	e5c23044 	strb	r3, [r2, #68]
33d0a384:	e3a0300c 	mov	r3, #12	; 0xc
33d0a388:	e5873000 	str	r3, [r7]
33d0a38c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0a390:	e59f03c8 	ldr	r0, [pc, #968]	; 33d0a760 <Ep0Handler+0xa44>
33d0a394:	ebfffd1c 	bl	33d0980c <DbgPrintf>
33d0a398:	e59f03c4 	ldr	r0, [pc, #964]	; 33d0a764 <Ep0Handler+0xa48>
33d0a39c:	e3a01002 	mov	r1, #2	; 0x2
33d0a3a0:	ea0000c6 	b	33d0a6c0 <Ep0Handler+0x9a4>
33d0a3a4:	e59f03bc 	ldr	r0, [pc, #956]	; 33d0a768 <Ep0Handler+0xa4c>
33d0a3a8:	ebfffd17 	bl	33d0980c <DbgPrintf>
33d0a3ac:	e59f03b8 	ldr	r0, [pc, #952]	; 33d0a76c <Ep0Handler+0xa50>
33d0a3b0:	e3a01008 	mov	r1, #8	; 0x8
33d0a3b4:	eb00037c 	bl	33d0b1ac <WrPktEp0>
33d0a3b8:	e59f2330 	ldr	r2, [pc, #816]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a3bc:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a3c0:	e5922000 	ldr	r2, [r2]
33d0a3c4:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a3c8:	e5c23044 	strb	r3, [r2, #68]
33d0a3cc:	e3a03015 	mov	r3, #21	; 0x15
33d0a3d0:	eaffffec 	b	33d0a388 <Ep0Handler+0x66c>
33d0a3d4:	e59f0394 	ldr	r0, [pc, #916]	; 33d0a770 <Ep0Handler+0xa54>
33d0a3d8:	ebfffd0b 	bl	33d0980c <DbgPrintf>
33d0a3dc:	e59f0390 	ldr	r0, [pc, #912]	; 33d0a774 <Ep0Handler+0xa58>
33d0a3e0:	e3a01001 	mov	r1, #1	; 0x1
33d0a3e4:	eb000370 	bl	33d0b1ac <WrPktEp0>
33d0a3e8:	e59f0388 	ldr	r0, [pc, #904]	; 33d0a778 <Ep0Handler+0xa5c>
33d0a3ec:	e3a01007 	mov	r1, #7	; 0x7
33d0a3f0:	eb00036d 	bl	33d0b1ac <WrPktEp0>
33d0a3f4:	e59f22f4 	ldr	r2, [pc, #756]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a3f8:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a3fc:	e5922000 	ldr	r2, [r2]
33d0a400:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a404:	e5c23044 	strb	r3, [r2, #68]
33d0a408:	e3a03016 	mov	r3, #22	; 0x16
33d0a40c:	eaffffdd 	b	33d0a388 <Ep0Handler+0x66c>
33d0a410:	e59f0364 	ldr	r0, [pc, #868]	; 33d0a77c <Ep0Handler+0xa60>
33d0a414:	ebfffcfc 	bl	33d0980c <DbgPrintf>
33d0a418:	e59f0360 	ldr	r0, [pc, #864]	; 33d0a780 <Ep0Handler+0xa64>
33d0a41c:	e3a01002 	mov	r1, #2	; 0x2
33d0a420:	eb000361 	bl	33d0b1ac <WrPktEp0>
33d0a424:	e59f0358 	ldr	r0, [pc, #856]	; 33d0a784 <Ep0Handler+0xa68>
33d0a428:	e3a01006 	mov	r1, #6	; 0x6
33d0a42c:	eb00035e 	bl	33d0b1ac <WrPktEp0>
33d0a430:	e59f22b8 	ldr	r2, [pc, #696]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a434:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a438:	e5922000 	ldr	r2, [r2]
33d0a43c:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a440:	e5c23044 	strb	r3, [r2, #68]
33d0a444:	e3a03017 	mov	r3, #23	; 0x17
33d0a448:	eaffffce 	b	33d0a388 <Ep0Handler+0x66c>
33d0a44c:	e59f0334 	ldr	r0, [pc, #820]	; 33d0a788 <Ep0Handler+0xa6c>
33d0a450:	ebfffced 	bl	33d0980c <DbgPrintf>
33d0a454:	e59f0330 	ldr	r0, [pc, #816]	; 33d0a78c <Ep0Handler+0xa70>
33d0a458:	e3a01001 	mov	r1, #1	; 0x1
33d0a45c:	eb000352 	bl	33d0b1ac <WrPktEp0>
33d0a460:	e59f0328 	ldr	r0, [pc, #808]	; 33d0a790 <Ep0Handler+0xa74>
33d0a464:	e3a01007 	mov	r1, #7	; 0x7
33d0a468:	eb00034f 	bl	33d0b1ac <WrPktEp0>
33d0a46c:	e59f227c 	ldr	r2, [pc, #636]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a470:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a474:	e5922000 	ldr	r2, [r2]
33d0a478:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a47c:	e5c23044 	strb	r3, [r2, #68]
33d0a480:	e3a03018 	mov	r3, #24	; 0x18
33d0a484:	eaffffbf 	b	33d0a388 <Ep0Handler+0x66c>
33d0a488:	e59f0304 	ldr	r0, [pc, #772]	; 33d0a794 <Ep0Handler+0xa78>
33d0a48c:	ebfffcde 	bl	33d0980c <DbgPrintf>
33d0a490:	ea00008b 	b	33d0a6c4 <Ep0Handler+0x9a8>
33d0a494:	e59f02fc 	ldr	r0, [pc, #764]	; 33d0a798 <Ep0Handler+0xa7c>
33d0a498:	ebfffcdb 	bl	33d0980c <DbgPrintf>
33d0a49c:	e59f02c8 	ldr	r0, [pc, #712]	; 33d0a76c <Ep0Handler+0xa50>
33d0a4a0:	e3a01008 	mov	r1, #8	; 0x8
33d0a4a4:	eb000340 	bl	33d0b1ac <WrPktEp0>
33d0a4a8:	e59f2240 	ldr	r2, [pc, #576]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a4ac:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a4b0:	e5922000 	ldr	r2, [r2]
33d0a4b4:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a4b8:	e5c23044 	strb	r3, [r2, #68]
33d0a4bc:	e3a03029 	mov	r3, #41	; 0x29
33d0a4c0:	eaffffb0 	b	33d0a388 <Ep0Handler+0x66c>
33d0a4c4:	e59f02d0 	ldr	r0, [pc, #720]	; 33d0a79c <Ep0Handler+0xa80>
33d0a4c8:	ebfffccf 	bl	33d0980c <DbgPrintf>
33d0a4cc:	e59f02a0 	ldr	r0, [pc, #672]	; 33d0a774 <Ep0Handler+0xa58>
33d0a4d0:	ea000079 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a4d4:	e59f02c4 	ldr	r0, [pc, #708]	; 33d0a7a0 <Ep0Handler+0xa84>
33d0a4d8:	ebfffccb 	bl	33d0980c <DbgPrintf>
33d0a4dc:	e59f0294 	ldr	r0, [pc, #660]	; 33d0a778 <Ep0Handler+0xa5c>
33d0a4e0:	e3a01008 	mov	r1, #8	; 0x8
33d0a4e4:	eb000330 	bl	33d0b1ac <WrPktEp0>
33d0a4e8:	e59f2200 	ldr	r2, [pc, #512]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a4ec:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a4f0:	e5922000 	ldr	r2, [r2]
33d0a4f4:	e3833002 	orr	r3, r3, #2	; 0x2
33d0a4f8:	e5c23044 	strb	r3, [r2, #68]
33d0a4fc:	e3a0302b 	mov	r3, #43	; 0x2b
33d0a500:	eaffffa0 	b	33d0a388 <Ep0Handler+0x66c>
33d0a504:	e59f0298 	ldr	r0, [pc, #664]	; 33d0a7a4 <Ep0Handler+0xa88>
33d0a508:	ebfffcbf 	bl	33d0980c <DbgPrintf>
33d0a50c:	e59f0294 	ldr	r0, [pc, #660]	; 33d0a7a8 <Ep0Handler+0xa8c>
33d0a510:	ea000069 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a514:	e59f0290 	ldr	r0, [pc, #656]	; 33d0a7ac <Ep0Handler+0xa90>
33d0a518:	ebfffcbb 	bl	33d0980c <DbgPrintf>
33d0a51c:	e59f0260 	ldr	r0, [pc, #608]	; 33d0a784 <Ep0Handler+0xa68>
33d0a520:	ea000002 	b	33d0a530 <Ep0Handler+0x814>
33d0a524:	e59f0284 	ldr	r0, [pc, #644]	; 33d0a7b0 <Ep0Handler+0xa94>
33d0a528:	ebfffcb7 	bl	33d0980c <DbgPrintf>
33d0a52c:	e59f025c 	ldr	r0, [pc, #604]	; 33d0a790 <Ep0Handler+0xa74>
33d0a530:	e3a01007 	mov	r1, #7	; 0x7
33d0a534:	ea000061 	b	33d0a6c0 <Ep0Handler+0x9a4>
33d0a538:	e59f0208 	ldr	r0, [pc, #520]	; 33d0a748 <Ep0Handler+0xa2c>
33d0a53c:	ea00005e 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a540:	e59f026c 	ldr	r0, [pc, #620]	; 33d0a7b4 <Ep0Handler+0xa98>
33d0a544:	ebfffcb0 	bl	33d0980c <DbgPrintf>
33d0a548:	e3a01004 	mov	r1, #4	; 0x4
33d0a54c:	e59f0264 	ldr	r0, [pc, #612]	; 33d0a7b8 <Ep0Handler+0xa9c>
33d0a550:	eb000315 	bl	33d0b1ac <WrPktEp0>
33d0a554:	e59f3194 	ldr	r3, [pc, #404]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a558:	e206203f 	and	r2, r6, #63	; 0x3f
33d0a55c:	e5933000 	ldr	r3, [r3]
33d0a560:	e382200a 	orr	r2, r2, #10	; 0xa
33d0a564:	e5c32044 	strb	r2, [r3, #68]
33d0a568:	e59f31a8 	ldr	r3, [pc, #424]	; 33d0a718 <Ep0Handler+0x9fc>
33d0a56c:	e3a01000 	mov	r1, #0	; 0x0
33d0a570:	e5831000 	str	r1, [r3]
33d0a574:	ea00001d 	b	33d0a5f0 <Ep0Handler+0x8d4>
33d0a578:	e59f5198 	ldr	r5, [pc, #408]	; 33d0a718 <Ep0Handler+0x9fc>
33d0a57c:	e59f0238 	ldr	r0, [pc, #568]	; 33d0a7bc <Ep0Handler+0xaa0>
33d0a580:	e5951000 	ldr	r1, [r5]
33d0a584:	ebfffca0 	bl	33d0980c <DbgPrintf>
33d0a588:	e5953000 	ldr	r3, [r5]
33d0a58c:	e1a02183 	lsl	r2, r3, #3
33d0a590:	e2823008 	add	r3, r2, #8	; 0x8
33d0a594:	e3530015 	cmp	r3, #21	; 0x15
33d0a598:	e206403f 	and	r4, r6, #63	; 0x3f
33d0a59c:	e59fa14c 	ldr	sl, [pc, #332]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a5a0:	e59f3218 	ldr	r3, [pc, #536]	; 33d0a7c0 <Ep0Handler+0xaa4>
33d0a5a4:	8a000009 	bhi	33d0a5d0 <Ep0Handler+0x8b4>
33d0a5a8:	e0820003 	add	r0, r2, r3
33d0a5ac:	e3a01008 	mov	r1, #8	; 0x8
33d0a5b0:	eb0002fd 	bl	33d0b1ac <WrPktEp0>
33d0a5b4:	e59a2000 	ldr	r2, [sl]
33d0a5b8:	e3843002 	orr	r3, r4, #2	; 0x2
33d0a5bc:	e5c23044 	strb	r3, [r2, #68]
33d0a5c0:	e5953000 	ldr	r3, [r5]
33d0a5c4:	e3a0201f 	mov	r2, #31	; 0x1f
33d0a5c8:	e2833001 	add	r3, r3, #1	; 0x1
33d0a5cc:	ea00001e 	b	33d0a64c <Ep0Handler+0x930>
33d0a5d0:	e0820003 	add	r0, r2, r3
33d0a5d4:	e2621016 	rsb	r1, r2, #22	; 0x16
33d0a5d8:	eb0002f3 	bl	33d0b1ac <WrPktEp0>
33d0a5dc:	e59a3000 	ldr	r3, [sl]
33d0a5e0:	e384200a 	orr	r2, r4, #10	; 0xa
33d0a5e4:	e3a01000 	mov	r1, #0	; 0x0
33d0a5e8:	e5c32044 	strb	r2, [r3, #68]
33d0a5ec:	e5851000 	str	r1, [r5]
33d0a5f0:	e5871000 	str	r1, [r7]
33d0a5f4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0a5f8:	e59f5118 	ldr	r5, [pc, #280]	; 33d0a718 <Ep0Handler+0x9fc>
33d0a5fc:	e59f01c0 	ldr	r0, [pc, #448]	; 33d0a7c4 <Ep0Handler+0xaa8>
33d0a600:	e5951000 	ldr	r1, [r5]
33d0a604:	ebfffc80 	bl	33d0980c <DbgPrintf>
33d0a608:	e5953000 	ldr	r3, [r5]
33d0a60c:	e1a00183 	lsl	r0, r3, #3
33d0a610:	e2803008 	add	r3, r0, #8	; 0x8
33d0a614:	e353002b 	cmp	r3, #43	; 0x2b
33d0a618:	e206403f 	and	r4, r6, #63	; 0x3f
33d0a61c:	e59fa0cc 	ldr	sl, [pc, #204]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a620:	e59f61a0 	ldr	r6, [pc, #416]	; 33d0a7c8 <Ep0Handler+0xaac>
33d0a624:	8a00000b 	bhi	33d0a658 <Ep0Handler+0x93c>
33d0a628:	e0800006 	add	r0, r0, r6
33d0a62c:	e3a01008 	mov	r1, #8	; 0x8
33d0a630:	eb0002dd 	bl	33d0b1ac <WrPktEp0>
33d0a634:	e59a2000 	ldr	r2, [sl]
33d0a638:	e3843002 	orr	r3, r4, #2	; 0x2
33d0a63c:	e5c23044 	strb	r3, [r2, #68]
33d0a640:	e5953000 	ldr	r3, [r5]
33d0a644:	e3a02020 	mov	r2, #32	; 0x20
33d0a648:	e2833001 	add	r3, r3, #1	; 0x1
33d0a64c:	e5872000 	str	r2, [r7]
33d0a650:	e5853000 	str	r3, [r5]
33d0a654:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0a658:	e59f016c 	ldr	r0, [pc, #364]	; 33d0a7cc <Ep0Handler+0xab0>
33d0a65c:	ebfffc6a 	bl	33d0980c <DbgPrintf>
33d0a660:	e5951000 	ldr	r1, [r5]
33d0a664:	e1a01181 	lsl	r1, r1, #3
33d0a668:	e0810006 	add	r0, r1, r6
33d0a66c:	e261102c 	rsb	r1, r1, #44	; 0x2c
33d0a670:	eb0002cd 	bl	33d0b1ac <WrPktEp0>
33d0a674:	e59a1000 	ldr	r1, [sl]
33d0a678:	e3a02000 	mov	r2, #0	; 0x0
33d0a67c:	e384300a 	orr	r3, r4, #10	; 0xa
33d0a680:	e5c13044 	strb	r3, [r1, #68]
33d0a684:	e5852000 	str	r2, [r5]
33d0a688:	e5872000 	str	r2, [r7]
33d0a68c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0a690:	e59f009c 	ldr	r0, [pc, #156]	; 33d0a734 <Ep0Handler+0xa18>
33d0a694:	ea000008 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a698:	e59f00a0 	ldr	r0, [pc, #160]	; 33d0a740 <Ep0Handler+0xa24>
33d0a69c:	ea000006 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a6a0:	e59f0128 	ldr	r0, [pc, #296]	; 33d0a7d0 <Ep0Handler+0xab4>
33d0a6a4:	ea000004 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a6a8:	e59f0124 	ldr	r0, [pc, #292]	; 33d0a7d4 <Ep0Handler+0xab8>
33d0a6ac:	ea000002 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a6b0:	e59f0120 	ldr	r0, [pc, #288]	; 33d0a7d8 <Ep0Handler+0xabc>
33d0a6b4:	ea000000 	b	33d0a6bc <Ep0Handler+0x9a0>
33d0a6b8:	e59f011c 	ldr	r0, [pc, #284]	; 33d0a7dc <Ep0Handler+0xac0>
33d0a6bc:	e3a01001 	mov	r1, #1	; 0x1
33d0a6c0:	eb0002b9 	bl	33d0b1ac <WrPktEp0>
33d0a6c4:	e59f2024 	ldr	r2, [pc, #36]	; 33d0a6f0 <Ep0Handler+0x9d4>
33d0a6c8:	e206303f 	and	r3, r6, #63	; 0x3f
33d0a6cc:	e5922000 	ldr	r2, [r2]
33d0a6d0:	e383300a 	orr	r3, r3, #10	; 0xa
33d0a6d4:	e5c23044 	strb	r3, [r2, #68]
33d0a6d8:	e3a03000 	mov	r3, #0	; 0x0
33d0a6dc:	eaffff29 	b	33d0a388 <Ep0Handler+0x66c>
33d0a6e0:	e59f00f8 	ldr	r0, [pc, #248]	; 33d0a7e0 <Ep0Handler+0xac4>
33d0a6e4:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
33d0a6e8:	eafffc47 	b	33d0980c <DbgPrintf>
33d0a6ec:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0a6f0:	33d60410 	.word	0x33d60410
33d0a6f4:	33d267a0 	.word	0x33d267a0
33d0a6f8:	33d267a8 	.word	0x33d267a8
33d0a6fc:	33d60398 	.word	0x33d60398
33d0a700:	33d2678c 	.word	0x33d2678c
33d0a704:	33d603a8 	.word	0x33d603a8
33d0a708:	33d267b4 	.word	0x33d267b4
33d0a70c:	33d267bc 	.word	0x33d267bc
33d0a710:	33d267c4 	.word	0x33d267c4
33d0a714:	33d267cc 	.word	0x33d267cc
33d0a718:	33d603fc 	.word	0x33d603fc
33d0a71c:	33d267d8 	.word	0x33d267d8
33d0a720:	33d267e0 	.word	0x33d267e0
33d0a724:	33d267e8 	.word	0x33d267e8
33d0a728:	33d267f4 	.word	0x33d267f4
33d0a72c:	33d26800 	.word	0x33d26800
33d0a730:	33d26808 	.word	0x33d26808
33d0a734:	33d603ec 	.word	0x33d603ec
33d0a738:	33d60438 	.word	0x33d60438
33d0a73c:	33d603a0 	.word	0x33d603a0
33d0a740:	33d603f4 	.word	0x33d603f4
33d0a744:	33d35fcf 	.word	0x33d35fcf
33d0a748:	33d603f0 	.word	0x33d603f0
33d0a74c:	33d26810 	.word	0x33d26810
33d0a750:	33d26820 	.word	0x33d26820
33d0a754:	33d603b0 	.word	0x33d603b0
33d0a758:	33d26828 	.word	0x33d26828
33d0a75c:	33d603b8 	.word	0x33d603b8
33d0a760:	33d26830 	.word	0x33d26830
33d0a764:	33d603c0 	.word	0x33d603c0
33d0a768:	33d26838 	.word	0x33d26838
33d0a76c:	33d603c4 	.word	0x33d603c4
33d0a770:	33d26840 	.word	0x33d26840
33d0a774:	33d603cc 	.word	0x33d603cc
33d0a778:	33d603d0 	.word	0x33d603d0
33d0a77c:	33d26848 	.word	0x33d26848
33d0a780:	33d603d7 	.word	0x33d603d7
33d0a784:	33d603dc 	.word	0x33d603dc
33d0a788:	33d26850 	.word	0x33d26850
33d0a78c:	33d603e2 	.word	0x33d603e2
33d0a790:	33d603e4 	.word	0x33d603e4
33d0a794:	33d26858 	.word	0x33d26858
33d0a798:	33d26860 	.word	0x33d26860
33d0a79c:	33d26868 	.word	0x33d26868
33d0a7a0:	33d26870 	.word	0x33d26870
33d0a7a4:	33d26878 	.word	0x33d26878
33d0a7a8:	33d603d8 	.word	0x33d603d8
33d0a7ac:	33d26880 	.word	0x33d26880
33d0a7b0:	33d26888 	.word	0x33d26888
33d0a7b4:	33d26890 	.word	0x33d26890
33d0a7b8:	33d2497e 	.word	0x33d2497e
33d0a7bc:	33d2689c 	.word	0x33d2689c
33d0a7c0:	33d24968 	.word	0x33d24968
33d0a7c4:	33d268a8 	.word	0x33d268a8
33d0a7c8:	33d2493c 	.word	0x33d2493c
33d0a7cc:	33d268b4 	.word	0x33d268b4
33d0a7d0:	33d603f5 	.word	0x33d603f5
33d0a7d4:	33d603f6 	.word	0x33d603f6
33d0a7d8:	33d603f7 	.word	0x33d603f7
33d0a7dc:	33d603f8 	.word	0x33d603f8
33d0a7e0:	33d268b8 	.word	0x33d268b8

33d0a7e4 <InitDescriptorTable>:
33d0a7e4:	e59f0130 	ldr	r0, [pc, #304]	; 33d0a91c <InitDescriptorTable+0x138>
33d0a7e8:	e59f2130 	ldr	r2, [pc, #304]	; 33d0a920 <InitDescriptorTable+0x13c>
33d0a7ec:	e3a03019 	mov	r3, #25	; 0x19
33d0a7f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0a7f4:	e5c03008 	strb	r3, [r0, #8]
33d0a7f8:	e2433009 	sub	r3, r3, #9	; 0x9
33d0a7fc:	e5c23002 	strb	r3, [r2, #2]
33d0a800:	e2433008 	sub	r3, r3, #8	; 0x8
33d0a804:	e5c23007 	strb	r3, [r2, #7]
33d0a808:	e283303d 	add	r3, r3, #61	; 0x3d
33d0a80c:	e5c23008 	strb	r3, [r2, #8]
33d0a810:	e283300e 	add	r3, r3, #14	; 0xe
33d0a814:	e5c23009 	strb	r3, [r2, #9]
33d0a818:	e243301f 	sub	r3, r3, #31	; 0x1f
33d0a81c:	e59fe100 	ldr	lr, [pc, #256]	; 33d0a924 <InitDescriptorTable+0x140>
33d0a820:	e5c2300a 	strb	r3, [r2, #10]
33d0a824:	e2433074 	sub	r3, r3, #116	; 0x74
33d0a828:	e59f40f8 	ldr	r4, [pc, #248]	; 33d0a928 <InitDescriptorTable+0x144>
33d0a82c:	e5c03007 	strb	r3, [r0, #7]
33d0a830:	e2833044 	add	r3, r3, #68	; 0x44
33d0a834:	e3a01000 	mov	r1, #0	; 0x0
33d0a838:	e59f50ec 	ldr	r5, [pc, #236]	; 33d0a92c <InitDescriptorTable+0x148>
33d0a83c:	e3a0c001 	mov	ip, #1	; 0x1
33d0a840:	e3a06002 	mov	r6, #2	; 0x2
33d0a844:	e3a07020 	mov	r7, #32	; 0x20
33d0a848:	e3a0a012 	mov	sl, #18	; 0x12
33d0a84c:	e3e09000 	mvn	r9, #0	; 0x0
33d0a850:	e3a0b009 	mov	fp, #9	; 0x9
33d0a854:	e5ce3001 	strb	r3, [lr, #1]
33d0a858:	e2433083 	sub	r3, r3, #131	; 0x83
33d0a85c:	e5c2a00b 	strb	sl, [r2, #11]
33d0a860:	e5c2c011 	strb	ip, [r2, #17]
33d0a864:	e5c0c005 	strb	ip, [r0, #5]
33d0a868:	e5ceb000 	strb	fp, [lr]
33d0a86c:	e5ce9005 	strb	r9, [lr, #5]
33d0a870:	e5c2a000 	strb	sl, [r2]
33d0a874:	e5c2c001 	strb	ip, [r2, #1]
33d0a878:	e5c2c003 	strb	ip, [r2, #3]
33d0a87c:	e5c29004 	strb	r9, [r2, #4]
33d0a880:	e5c21005 	strb	r1, [r2, #5]
33d0a884:	e5c21006 	strb	r1, [r2, #6]
33d0a888:	e5c2100c 	strb	r1, [r2, #12]
33d0a88c:	e5c2c00d 	strb	ip, [r2, #13]
33d0a890:	e5c2c00e 	strb	ip, [r2, #14]
33d0a894:	e5c2600f 	strb	r6, [r2, #15]
33d0a898:	e5c21010 	strb	r1, [r2, #16]
33d0a89c:	e5c0b000 	strb	fp, [r0]
33d0a8a0:	e5c06001 	strb	r6, [r0, #1]
33d0a8a4:	e5c07002 	strb	r7, [r0, #2]
33d0a8a8:	e5c01003 	strb	r1, [r0, #3]
33d0a8ac:	e5c0c004 	strb	ip, [r0, #4]
33d0a8b0:	e5c01006 	strb	r1, [r0, #6]
33d0a8b4:	e5ce1002 	strb	r1, [lr, #2]
33d0a8b8:	e5ce1003 	strb	r1, [lr, #3]
33d0a8bc:	e5ce6004 	strb	r6, [lr, #4]
33d0a8c0:	e5c43002 	strb	r3, [r4, #2]
33d0a8c4:	e3a03007 	mov	r3, #7	; 0x7
33d0a8c8:	e5c53000 	strb	r3, [r5]
33d0a8cc:	e3a03005 	mov	r3, #5	; 0x5
33d0a8d0:	e5c53001 	strb	r3, [r5, #1]
33d0a8d4:	e3a03003 	mov	r3, #3	; 0x3
33d0a8d8:	e5c53002 	strb	r3, [r5, #2]
33d0a8dc:	e3a03007 	mov	r3, #7	; 0x7
33d0a8e0:	e5c43000 	strb	r3, [r4]
33d0a8e4:	e3a03005 	mov	r3, #5	; 0x5
33d0a8e8:	e5ce1006 	strb	r1, [lr, #6]
33d0a8ec:	e5c51006 	strb	r1, [r5, #6]
33d0a8f0:	e5ce1008 	strb	r1, [lr, #8]
33d0a8f4:	e5c41006 	strb	r1, [r4, #6]
33d0a8f8:	e5c56003 	strb	r6, [r5, #3]
33d0a8fc:	e5c57004 	strb	r7, [r5, #4]
33d0a900:	e5ce1007 	strb	r1, [lr, #7]
33d0a904:	e5c43001 	strb	r3, [r4, #1]
33d0a908:	e5c46003 	strb	r6, [r4, #3]
33d0a90c:	e5c47004 	strb	r7, [r4, #4]
33d0a910:	e5c41005 	strb	r1, [r4, #5]
33d0a914:	e5c51005 	strb	r1, [r5, #5]
33d0a918:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0a91c:	33d603c4 	.word	0x33d603c4
33d0a920:	33d603b0 	.word	0x33d603b0
33d0a924:	33d603d0 	.word	0x33d603d0
33d0a928:	33d603dc 	.word	0x33d603dc
33d0a92c:	33d603e4 	.word	0x33d603e4

33d0a930 <awaitkey>:
33d0a930:	e3700001 	cmn	r0, #1	; 0x1
33d0a934:	e92d4070 	push	{r4, r5, r6, lr}
33d0a938:	e1a04000 	mov	r4, r0
33d0a93c:	e1a06001 	mov	r6, r1
33d0a940:	13a05000 	movne	r5, #0	; 0x0
33d0a944:	1a000003 	bne	33d0a958 <awaitkey+0x28>
33d0a948:	eb003187 	bl	33d16f6c <tstc>
33d0a94c:	e3500000 	cmp	r0, #0	; 0x0
33d0a950:	0afffffc 	beq	33d0a948 <awaitkey+0x18>
33d0a954:	ea000006 	b	33d0a974 <awaitkey+0x44>
33d0a958:	e1550004 	cmp	r5, r4
33d0a95c:	2a000009 	bcs	33d0a988 <awaitkey+0x58>
33d0a960:	eb003181 	bl	33d16f6c <tstc>
33d0a964:	e3500000 	cmp	r0, #0	; 0x0
33d0a968:	e2855001 	add	r5, r5, #1	; 0x1
33d0a96c:	e59f0028 	ldr	r0, [pc, #40]	; 33d0a99c <awaitkey+0x6c>
33d0a970:	0a000002 	beq	33d0a980 <awaitkey+0x50>
33d0a974:	eb003176 	bl	33d16f54 <getc>
33d0a978:	e20000ff 	and	r0, r0, #255	; 0xff
33d0a97c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d0a980:	ebffd921 	bl	33d00e0c <udelay>
33d0a984:	eafffff3 	b	33d0a958 <awaitkey+0x28>
33d0a988:	e3560000 	cmp	r6, #0	; 0x0
33d0a98c:	13e03000 	mvnne	r3, #0	; 0x0
33d0a990:	e3a00000 	mov	r0, #0	; 0x0
33d0a994:	15863000 	strne	r3, [r6]
33d0a998:	e8bd8070 	pop	{r4, r5, r6, pc}
33d0a99c:	00002710 	.word	0x00002710

33d0a9a0 <Port_Init>:
33d0a9a0:	e59f104c 	ldr	r1, [pc, #76]	; 33d0a9f4 <Port_Init+0x54>
33d0a9a4:	e5912000 	ldr	r2, [r1]
33d0a9a8:	e5923060 	ldr	r3, [r2, #96]
33d0a9ac:	e3c33403 	bic	r3, r3, #50331648	; 0x3000000
33d0a9b0:	e5823060 	str	r3, [r2, #96]
33d0a9b4:	e5912000 	ldr	r2, [r1]
33d0a9b8:	e5923060 	ldr	r3, [r2, #96]
33d0a9bc:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
33d0a9c0:	e5823060 	str	r3, [r2, #96]
33d0a9c4:	e5912000 	ldr	r2, [r1]
33d0a9c8:	e5923064 	ldr	r3, [r2, #100]
33d0a9cc:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
33d0a9d0:	e5823064 	str	r3, [r2, #100]
33d0a9d4:	e59f201c 	ldr	r2, [pc, #28]	; 33d0a9f8 <Port_Init+0x58>
33d0a9d8:	e5913000 	ldr	r3, [r1]
33d0a9dc:	e5832088 	str	r2, [r3, #136]
33d0a9e0:	e5913000 	ldr	r3, [r1]
33d0a9e4:	e583208c 	str	r2, [r3, #140]
33d0a9e8:	e5913000 	ldr	r3, [r1]
33d0a9ec:	e5832090 	str	r2, [r3, #144]
33d0a9f0:	e1a0f00e 	mov	pc, lr
33d0a9f4:	33d6041c 	.word	0x33d6041c
33d0a9f8:	22222222 	.word	0x22222222

33d0a9fc <Clk0_Disable>:
33d0a9fc:	e59f3010 	ldr	r3, [pc, #16]	; 33d0aa14 <Clk0_Disable+0x18>
33d0aa00:	e5932000 	ldr	r2, [r3]
33d0aa04:	e5923070 	ldr	r3, [r2, #112]
33d0aa08:	e3c33703 	bic	r3, r3, #786432	; 0xc0000
33d0aa0c:	e5823070 	str	r3, [r2, #112]
33d0aa10:	e1a0f00e 	mov	pc, lr
33d0aa14:	33d6041c 	.word	0x33d6041c

33d0aa18 <Clk1_Disable>:
33d0aa18:	e59f3010 	ldr	r3, [pc, #16]	; 33d0aa30 <Clk1_Disable+0x18>
33d0aa1c:	e5932000 	ldr	r2, [r3]
33d0aa20:	e5923070 	ldr	r3, [r2, #112]
33d0aa24:	e3c33603 	bic	r3, r3, #3145728	; 0x300000
33d0aa28:	e5823070 	str	r3, [r2, #112]
33d0aa2c:	e1a0f00e 	mov	pc, lr
33d0aa30:	33d6041c 	.word	0x33d6041c

33d0aa34 <usb_init>:
33d0aa34:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d0aa38:	e59f2148 	ldr	r2, [pc, #328]	; 33d0ab88 <usb_init+0x154>
33d0aa3c:	e59f3148 	ldr	r3, [pc, #328]	; 33d0ab8c <usb_init+0x158>
33d0aa40:	e5832000 	str	r2, [r3]
33d0aa44:	e59f3144 	ldr	r3, [pc, #324]	; 33d0ab90 <usb_init+0x15c>
33d0aa48:	e3a0244b 	mov	r2, #1258291200	; 0x4b000000
33d0aa4c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
33d0aa50:	e5832000 	str	r2, [r3]
33d0aa54:	e3a03045 	mov	r3, #69	; 0x45
33d0aa58:	e5cd3010 	strb	r3, [sp, #16]
33d0aa5c:	e2833028 	add	r3, r3, #40	; 0x28
33d0aa60:	e5cd3011 	strb	r3, [sp, #17]
33d0aa64:	e243300b 	sub	r3, r3, #11	; 0xb
33d0aa68:	e5cd3012 	strb	r3, [sp, #18]
33d0aa6c:	e2833003 	add	r3, r3, #3	; 0x3
33d0aa70:	e5cd3013 	strb	r3, [sp, #19]
33d0aa74:	e2433001 	sub	r3, r3, #1	; 0x1
33d0aa78:	e5cd3014 	strb	r3, [sp, #20]
33d0aa7c:	e2833007 	add	r3, r3, #7	; 0x7
33d0aa80:	e5cd3016 	strb	r3, [sp, #22]
33d0aa84:	e283300e 	add	r3, r3, #14	; 0xe
33d0aa88:	e5cd3017 	strb	r3, [sp, #23]
33d0aa8c:	e243302e 	sub	r3, r3, #46	; 0x2e
33d0aa90:	e5cd3001 	strb	r3, [sp, #1]
33d0aa94:	e283300e 	add	r3, r3, #14	; 0xe
33d0aa98:	e5cd3002 	strb	r3, [sp, #2]
33d0aa9c:	e243302a 	sub	r3, r3, #42	; 0x2a
33d0aaa0:	e5cd3007 	strb	r3, [sp, #7]
33d0aaa4:	e2833025 	add	r3, r3, #37	; 0x25
33d0aaa8:	e59f70e4 	ldr	r7, [pc, #228]	; 33d0ab94 <usb_init+0x160>
33d0aaac:	e59fa0e4 	ldr	sl, [pc, #228]	; 33d0ab98 <usb_init+0x164>
33d0aab0:	e5cd3008 	strb	r3, [sp, #8]
33d0aab4:	e2433003 	sub	r3, r3, #3	; 0x3
33d0aab8:	e59f40dc 	ldr	r4, [pc, #220]	; 33d0ab9c <usb_init+0x168>
33d0aabc:	e5cd3009 	strb	r3, [sp, #9]
33d0aac0:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
33d0aac4:	e3a01034 	mov	r1, #52	; 0x34
33d0aac8:	e3a0c053 	mov	ip, #83	; 0x53
33d0aacc:	e3a0e032 	mov	lr, #50	; 0x32
33d0aad0:	e1a00007 	mov	r0, r7
33d0aad4:	e3a05000 	mov	r5, #0	; 0x0
33d0aad8:	e3a06030 	mov	r6, #48	; 0x30
33d0aadc:	e58a3000 	str	r3, [sl]
33d0aae0:	e283340a 	add	r3, r3, #167772160	; 0xa000000
33d0aae4:	e5cdc000 	strb	ip, [sp]
33d0aae8:	e5cde00a 	strb	lr, [sp, #10]
33d0aaec:	e5cd100c 	strb	r1, [sp, #12]
33d0aaf0:	e5cdc015 	strb	ip, [sp, #21]
33d0aaf4:	e5cde003 	strb	lr, [sp, #3]
33d0aaf8:	e5cd1004 	strb	r1, [sp, #4]
33d0aafc:	e5cd1005 	strb	r1, [sp, #5]
33d0ab00:	e5cd100b 	strb	r1, [sp, #11]
33d0ab04:	e5843000 	str	r3, [r4]
33d0ab08:	e5cd600d 	strb	r6, [sp, #13]
33d0ab0c:	e5cd5018 	strb	r5, [sp, #24]
33d0ab10:	e5cd6006 	strb	r6, [sp, #6]
33d0ab14:	e5cd500e 	strb	r5, [sp, #14]
33d0ab18:	ebffd8bb 	bl	33d00e0c <udelay>
33d0ab1c:	ebffff9f 	bl	33d0a9a0 <Port_Init>
33d0ab20:	ebffd972 	bl	33d010f0 <Isr_Init>
33d0ab24:	e5942000 	ldr	r2, [r4]
33d0ab28:	e5923080 	ldr	r3, [r2, #128]
33d0ab2c:	e3c33008 	bic	r3, r3, #8	; 0x8
33d0ab30:	e5823080 	str	r3, [r2, #128]
33d0ab34:	e5942000 	ldr	r2, [r4]
33d0ab38:	e5923080 	ldr	r3, [r2, #128]
33d0ab3c:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
33d0ab40:	e5823080 	str	r3, [r2, #128]
33d0ab44:	e59f3054 	ldr	r3, [pc, #84]	; 33d0aba0 <usb_init+0x16c>
33d0ab48:	e5835000 	str	r5, [r3]
33d0ab4c:	ebfffb29 	bl	33d097f8 <UsbdMain>
33d0ab50:	e1a00007 	mov	r0, r7
33d0ab54:	ebffd8ac 	bl	33d00e0c <udelay>
33d0ab58:	e5942000 	ldr	r2, [r4]
33d0ab5c:	e5923064 	ldr	r3, [r2, #100]
33d0ab60:	e3833a01 	orr	r3, r3, #4096	; 0x1000
33d0ab64:	e5823064 	str	r3, [r2, #100]
33d0ab68:	ebffffa3 	bl	33d0a9fc <Clk0_Disable>
33d0ab6c:	ebffffa9 	bl	33d0aa18 <Clk1_Disable>
33d0ab70:	e59a3000 	ldr	r3, [sl]
33d0ab74:	e5933004 	ldr	r3, [r3, #4]
33d0ab78:	e59f3024 	ldr	r3, [pc, #36]	; 33d0aba4 <usb_init+0x170>
33d0ab7c:	e5835000 	str	r5, [r3]
33d0ab80:	e28dd01c 	add	sp, sp, #28	; 0x1c
33d0ab84:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0ab88:	52000140 	.word	0x52000140
33d0ab8c:	33d60410 	.word	0x33d60410
33d0ab90:	33d60414 	.word	0x33d60414
33d0ab94:	000186a0 	.word	0x000186a0
33d0ab98:	33d60418 	.word	0x33d60418
33d0ab9c:	33d6041c 	.word	0x33d6041c
33d0aba0:	33d60438 	.word	0x33d60438
33d0aba4:	33d60404 	.word	0x33d60404

33d0aba8 <usb_receive>:
33d0aba8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0abac:	e59fc264 	ldr	ip, [pc, #612]	; 33d0ae18 <usb_receive+0x270>
33d0abb0:	e59f3264 	ldr	r3, [pc, #612]	; 33d0ae1c <usb_receive+0x274>
33d0abb4:	e59c0000 	ldr	r0, [ip]
33d0abb8:	e5830000 	str	r0, [r3]
33d0abbc:	e59fa25c 	ldr	sl, [pc, #604]	; 33d0ae20 <usb_receive+0x278>
33d0abc0:	e59c3000 	ldr	r3, [ip]
33d0abc4:	e58a3000 	str	r3, [sl]
33d0abc8:	e59f3254 	ldr	r3, [pc, #596]	; 33d0ae24 <usb_receive+0x27c>
33d0abcc:	e3a04000 	mov	r4, #0	; 0x0
33d0abd0:	e5834000 	str	r4, [r3]
33d0abd4:	e59f624c 	ldr	r6, [pc, #588]	; 33d0ae28 <usb_receive+0x280>
33d0abd8:	e59c0000 	ldr	r0, [ip]
33d0abdc:	e59f3248 	ldr	r3, [pc, #584]	; 33d0ae2c <usb_receive+0x284>
33d0abe0:	e24dd010 	sub	sp, sp, #16	; 0x10
33d0abe4:	e5830000 	str	r0, [r3]
33d0abe8:	e59f5240 	ldr	r5, [pc, #576]	; 33d0ae30 <usb_receive+0x288>
33d0abec:	e586d000 	str	sp, [r6]
33d0abf0:	e59f923c 	ldr	r9, [pc, #572]	; 33d0ae34 <usb_receive+0x28c>
33d0abf4:	e5960000 	ldr	r0, [r6]
33d0abf8:	e5854000 	str	r4, [r5]
33d0abfc:	e5993000 	ldr	r3, [r9]
33d0ac00:	e1530004 	cmp	r3, r4
33d0ac04:	e59f322c 	ldr	r3, [pc, #556]	; 33d0ae38 <usb_receive+0x290>
33d0ac08:	e1a07001 	mov	r7, r1
33d0ac0c:	e5830000 	str	r0, [r3]
33d0ac10:	e1a0b002 	mov	fp, r2
33d0ac14:	e2844001 	add	r4, r4, #1	; 0x1
33d0ac18:	059f021c 	ldreq	r0, [pc, #540]	; 33d0ae3c <usb_receive+0x294>
33d0ac1c:	0b0030e9 	bleq	33d16fc8 <printf>
33d0ac20:	e5953000 	ldr	r3, [r5]
33d0ac24:	e3530000 	cmp	r3, #0	; 0x0
33d0ac28:	1a00000d 	bne	33d0ac64 <usb_receive+0xbc>
33d0ac2c:	e3540001 	cmp	r4, #1	; 0x1
33d0ac30:	1a000004 	bne	33d0ac48 <usb_receive+0xa0>
33d0ac34:	e5993000 	ldr	r3, [r9]
33d0ac38:	e3530000 	cmp	r3, #0	; 0x0
33d0ac3c:	e59f01fc 	ldr	r0, [pc, #508]	; 33d0ae40 <usb_receive+0x298>
33d0ac40:	12444001 	subne	r4, r4, #1	; 0x1
33d0ac44:	1b0030df 	blne	33d16fc8 <printf>
33d0ac48:	e3a00001 	mov	r0, #1	; 0x1
33d0ac4c:	e3a01000 	mov	r1, #0	; 0x0
33d0ac50:	ebffff36 	bl	33d0a930 <awaitkey>
33d0ac54:	e200007f 	and	r0, r0, #127	; 0x7f
33d0ac58:	e3500003 	cmp	r0, #3	; 0x3
33d0ac5c:	0a00002d 	beq	33d0ad18 <usb_receive+0x170>
33d0ac60:	eaffffee 	b	33d0ac20 <usb_receive+0x78>
33d0ac64:	e59f41c4 	ldr	r4, [pc, #452]	; 33d0ae30 <usb_receive+0x288>
33d0ac68:	e5943000 	ldr	r3, [r4]
33d0ac6c:	e243300a 	sub	r3, r3, #10	; 0xa
33d0ac70:	e1530007 	cmp	r3, r7
33d0ac74:	9a000005 	bls	33d0ac90 <usb_receive+0xe8>
33d0ac78:	e5941000 	ldr	r1, [r4]
33d0ac7c:	e1a02007 	mov	r2, r7
33d0ac80:	e241100a 	sub	r1, r1, #10	; 0xa
33d0ac84:	e59f01b8 	ldr	r0, [pc, #440]	; 33d0ae44 <usb_receive+0x29c>
33d0ac88:	eb0030ce 	bl	33d16fc8 <printf>
33d0ac8c:	ea000023 	b	33d0ad20 <usb_receive+0x178>
33d0ac90:	ebffd8aa 	bl	33d00f40 <Timer_InitEx>
33d0ac94:	ebffd8be 	bl	33d00f94 <Timer_StartEx>
33d0ac98:	e59f31a8 	ldr	r3, [pc, #424]	; 33d0ae48 <usb_receive+0x2a0>
33d0ac9c:	e5932000 	ldr	r2, [r3]
33d0aca0:	e5923008 	ldr	r3, [r2, #8]
33d0aca4:	e3c33702 	bic	r3, r3, #524288	; 0x80000
33d0aca8:	e5823008 	str	r3, [r2, #8]
33d0acac:	ebfffbff 	bl	33d09cb0 <ClearEp3OutPktReady>
33d0acb0:	e5943000 	ldr	r3, [r4]
33d0acb4:	e3530020 	cmp	r3, #32	; 0x20
33d0acb8:	9a00001a 	bls	33d0ad28 <usb_receive+0x180>
33d0acbc:	e5943000 	ldr	r3, [r4]
33d0acc0:	e2433020 	sub	r3, r3, #32	; 0x20
33d0acc4:	e3530702 	cmp	r3, #524288	; 0x80000
33d0acc8:	95963000 	ldrls	r3, [r6]
33d0accc:	92833018 	addls	r3, r3, #24	; 0x18
33d0acd0:	85963000 	ldrhi	r3, [r6]
33d0acd4:	958a3000 	strls	r3, [sl]
33d0acd8:	82833018 	addhi	r3, r3, #24	; 0x18
33d0acdc:	95943000 	ldrls	r3, [r4]
33d0ace0:	858a3000 	strhi	r3, [sl]
33d0ace4:	e59f2160 	ldr	r2, [pc, #352]	; 33d0ae4c <usb_receive+0x2a4>
33d0ace8:	859f3160 	ldrhi	r3, [pc, #352]	; 33d0ae50 <usb_receive+0x2a8>
33d0acec:	92433020 	subls	r3, r3, #32	; 0x20
33d0acf0:	e5823000 	str	r3, [r2]
33d0acf4:	e59f3158 	ldr	r3, [pc, #344]	; 33d0ae54 <usb_receive+0x2ac>
33d0acf8:	e3a02000 	mov	r2, #0	; 0x0
33d0acfc:	e5832000 	str	r2, [r3]
33d0ad00:	e59f3118 	ldr	r3, [pc, #280]	; 33d0ae20 <usb_receive+0x278>
33d0ad04:	e5930000 	ldr	r0, [r3]
33d0ad08:	e59f313c 	ldr	r3, [pc, #316]	; 33d0ae4c <usb_receive+0x2a4>
33d0ad0c:	e5931000 	ldr	r1, [r3]
33d0ad10:	eb000161 	bl	33d0b29c <ConfigEp3DmaMode>
33d0ad14:	ea00000b 	b	33d0ad48 <usb_receive+0x1a0>
33d0ad18:	e59f0138 	ldr	r0, [pc, #312]	; 33d0ae58 <usb_receive+0x2b0>
33d0ad1c:	eb0030a9 	bl	33d16fc8 <printf>
33d0ad20:	e3a00000 	mov	r0, #0	; 0x0
33d0ad24:	ea000039 	b	33d0ae10 <usb_receive+0x268>
33d0ad28:	e5963000 	ldr	r3, [r6]
33d0ad2c:	e5942000 	ldr	r2, [r4]
33d0ad30:	e0833002 	add	r3, r3, r2
33d0ad34:	e2433008 	sub	r3, r3, #8	; 0x8
33d0ad38:	e58a3000 	str	r3, [sl]
33d0ad3c:	e59f3110 	ldr	r3, [pc, #272]	; 33d0ae54 <usb_receive+0x2ac>
33d0ad40:	e5942000 	ldr	r2, [r4]
33d0ad44:	e5832000 	str	r2, [r3]
33d0ad48:	e59f30d8 	ldr	r3, [pc, #216]	; 33d0ae28 <usb_receive+0x280>
33d0ad4c:	e59f0108 	ldr	r0, [pc, #264]	; 33d0ae5c <usb_receive+0x2b4>
33d0ad50:	e5931000 	ldr	r1, [r3]
33d0ad54:	e5942000 	ldr	r2, [r4]
33d0ad58:	eb00309a 	bl	33d16fc8 <printf>
33d0ad5c:	e35b0000 	cmp	fp, #0	; 0x0
33d0ad60:	0a000027 	beq	33d0ae04 <usb_receive+0x25c>
33d0ad64:	e59f50e8 	ldr	r5, [pc, #232]	; 33d0ae54 <usb_receive+0x2ac>
33d0ad68:	e3a01000 	mov	r1, #0	; 0x0
33d0ad6c:	e59f00ec 	ldr	r0, [pc, #236]	; 33d0ae60 <usb_receive+0x2b8>
33d0ad70:	eb003094 	bl	33d16fc8 <printf>
33d0ad74:	e5951000 	ldr	r1, [r5]
33d0ad78:	e5952000 	ldr	r2, [r5]
33d0ad7c:	e5943000 	ldr	r3, [r4]
33d0ad80:	e281c801 	add	ip, r1, #65536	; 0x10000
33d0ad84:	e1520003 	cmp	r2, r3
33d0ad88:	0a00000c 	beq	33d0adc0 <usb_receive+0x218>
33d0ad8c:	e5953000 	ldr	r3, [r5]
33d0ad90:	e153000c 	cmp	r3, ip
33d0ad94:	e1a0100c 	mov	r1, ip
33d0ad98:	e59f00c4 	ldr	r0, [pc, #196]	; 33d0ae64 <usb_receive+0x2bc>
33d0ad9c:	9a000002 	bls	33d0adac <usb_receive+0x204>
33d0ada0:	eb003088 	bl	33d16fc8 <printf>
33d0ada4:	e5953000 	ldr	r3, [r5]
33d0ada8:	e283c801 	add	ip, r3, #65536	; 0x10000
33d0adac:	e59f50a0 	ldr	r5, [pc, #160]	; 33d0ae54 <usb_receive+0x2ac>
33d0adb0:	e5952000 	ldr	r2, [r5]
33d0adb4:	e5943000 	ldr	r3, [r4]
33d0adb8:	e1520003 	cmp	r2, r3
33d0adbc:	eafffff1 	b	33d0ad88 <usb_receive+0x1e0>
33d0adc0:	e59f308c 	ldr	r3, [pc, #140]	; 33d0ae54 <usb_receive+0x2ac>
33d0adc4:	e59f009c 	ldr	r0, [pc, #156]	; 33d0ae68 <usb_receive+0x2c0>
33d0adc8:	e5931000 	ldr	r1, [r3]
33d0adcc:	eb00307d 	bl	33d16fc8 <printf>
33d0add0:	ebffd886 	bl	33d00ff0 <Timer_StopEx>
33d0add4:	e59f3054 	ldr	r3, [pc, #84]	; 33d0ae30 <usb_receive+0x288>
33d0add8:	e3500000 	cmp	r0, #0	; 0x0
33d0addc:	e5933000 	ldr	r3, [r3]
33d0ade0:	11a04000 	movne	r4, r0
33d0ade4:	03a04001 	moveq	r4, #1	; 0x1
33d0ade8:	e1a01004 	mov	r1, r4
33d0adec:	e1a00003 	mov	r0, r3
33d0adf0:	ebffd97a 	bl	33d013e0 <__udivsi3>
33d0adf4:	e1a02004 	mov	r2, r4
33d0adf8:	e1a01520 	lsr	r1, r0, #10
33d0adfc:	e59f0068 	ldr	r0, [pc, #104]	; 33d0ae6c <usb_receive+0x2c4>
33d0ae00:	eb003070 	bl	33d16fc8 <printf>
33d0ae04:	e59f3024 	ldr	r3, [pc, #36]	; 33d0ae30 <usb_receive+0x288>
33d0ae08:	e5933000 	ldr	r3, [r3]
33d0ae0c:	e243000a 	sub	r0, r3, #10	; 0xa
33d0ae10:	e28dd010 	add	sp, sp, #16	; 0x10
33d0ae14:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0ae18:	33d60450 	.word	0x33d60450
33d0ae1c:	33d60440 	.word	0x33d60440
33d0ae20:	33d60444 	.word	0x33d60444
33d0ae24:	33d6044c 	.word	0x33d6044c
33d0ae28:	33d60420 	.word	0x33d60420
33d0ae2c:	33d6043c 	.word	0x33d6043c
33d0ae30:	33d6042c 	.word	0x33d6042c
33d0ae34:	33d60438 	.word	0x33d60438
33d0ae38:	33d60428 	.word	0x33d60428
33d0ae3c:	33d268c0 	.word	0x33d268c0
33d0ae40:	33d268e0 	.word	0x33d268e0
33d0ae44:	33d2690c 	.word	0x33d2690c
33d0ae48:	33d37248 	.word	0x33d37248
33d0ae4c:	33d60448 	.word	0x33d60448
33d0ae50:	0007ffe8 	.word	0x0007ffe8
33d0ae54:	33d60434 	.word	0x33d60434
33d0ae58:	33d26934 	.word	0x33d26934
33d0ae5c:	33d26948 	.word	0x33d26948
33d0ae60:	33d26974 	.word	0x33d26974
33d0ae64:	33d2698c 	.word	0x33d2698c
33d0ae68:	33d26998 	.word	0x33d26998
33d0ae6c:	33d269a8 	.word	0x33d269a8

33d0ae70 <HaltUndef>:
33d0ae70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0ae74:	e59f0004 	ldr	r0, [pc, #4]	; 33d0ae80 <HaltUndef+0x10>
33d0ae78:	eb003052 	bl	33d16fc8 <printf>
33d0ae7c:	eafffffe 	b	33d0ae7c <HaltUndef+0xc>
33d0ae80:	33d269b8 	.word	0x33d269b8

33d0ae84 <HaltSwi>:
33d0ae84:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0ae88:	e59f0004 	ldr	r0, [pc, #4]	; 33d0ae94 <HaltSwi+0x10>
33d0ae8c:	eb00304d 	bl	33d16fc8 <printf>
33d0ae90:	eafffffe 	b	33d0ae90 <HaltSwi+0xc>
33d0ae94:	33d269dc 	.word	0x33d269dc

33d0ae98 <HaltPabort>:
33d0ae98:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0ae9c:	e59f0004 	ldr	r0, [pc, #4]	; 33d0aea8 <HaltPabort+0x10>
33d0aea0:	eb003048 	bl	33d16fc8 <printf>
33d0aea4:	eafffffe 	b	33d0aea4 <HaltPabort+0xc>
33d0aea8:	33d269f0 	.word	0x33d269f0

33d0aeac <HaltDabort>:
33d0aeac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0aeb0:	e59f0004 	ldr	r0, [pc, #4]	; 33d0aebc <HaltDabort+0x10>
33d0aeb4:	eb003043 	bl	33d16fc8 <printf>
33d0aeb8:	eafffffe 	b	33d0aeb8 <HaltDabort+0xc>
33d0aebc:	33d26a08 	.word	0x33d26a08

33d0aec0 <Clk0_Enable>:
33d0aec0:	e59f1028 	ldr	r1, [pc, #40]	; 33d0aef0 <Clk0_Enable+0x30>
33d0aec4:	e5912000 	ldr	r2, [r1]
33d0aec8:	e5923080 	ldr	r3, [r2, #128]
33d0aecc:	e3c33070 	bic	r3, r3, #112	; 0x70
33d0aed0:	e1833200 	orr	r3, r3, r0, lsl #4
33d0aed4:	e5823080 	str	r3, [r2, #128]
33d0aed8:	e5912000 	ldr	r2, [r1]
33d0aedc:	e5923070 	ldr	r3, [r2, #112]
33d0aee0:	e3c33703 	bic	r3, r3, #786432	; 0xc0000
33d0aee4:	e3833702 	orr	r3, r3, #524288	; 0x80000
33d0aee8:	e5823070 	str	r3, [r2, #112]
33d0aeec:	e1a0f00e 	mov	pc, lr
33d0aef0:	33d6041c 	.word	0x33d6041c

33d0aef4 <Clk1_Enable>:
33d0aef4:	e59f1028 	ldr	r1, [pc, #40]	; 33d0af24 <Clk1_Enable+0x30>
33d0aef8:	e5912000 	ldr	r2, [r1]
33d0aefc:	e5923080 	ldr	r3, [r2, #128]
33d0af00:	e3c33c07 	bic	r3, r3, #1792	; 0x700
33d0af04:	e1833400 	orr	r3, r3, r0, lsl #8
33d0af08:	e5823080 	str	r3, [r2, #128]
33d0af0c:	e5912000 	ldr	r2, [r1]
33d0af10:	e5923070 	ldr	r3, [r2, #112]
33d0af14:	e3c33603 	bic	r3, r3, #3145728	; 0x300000
33d0af18:	e3833602 	orr	r3, r3, #2097152	; 0x200000
33d0af1c:	e5823070 	str	r3, [r2, #112]
33d0af20:	e1a0f00e 	mov	pc, lr
33d0af24:	33d6041c 	.word	0x33d6041c

33d0af28 <PrepareEp1Fifo>:
33d0af28:	e92d4030 	push	{r4, r5, lr}
33d0af2c:	e59f4054 	ldr	r4, [pc, #84]	; 33d0af88 <PrepareEp1Fifo+0x60>
33d0af30:	e5942000 	ldr	r2, [r4]
33d0af34:	e3a03001 	mov	r3, #1	; 0x1
33d0af38:	e5c23038 	strb	r3, [r2, #56]
33d0af3c:	e5943000 	ldr	r3, [r4]
33d0af40:	e5d33044 	ldrb	r3, [r3, #68]
33d0af44:	e3a02000 	mov	r2, #0	; 0x0
33d0af48:	e20350ff 	and	r5, r3, #255	; 0xff
33d0af4c:	e59f3038 	ldr	r3, [pc, #56]	; 33d0af8c <PrepareEp1Fifo+0x64>
33d0af50:	e5933000 	ldr	r3, [r3]
33d0af54:	e59f0034 	ldr	r0, [pc, #52]	; 33d0af90 <PrepareEp1Fifo+0x68>
33d0af58:	e0833002 	add	r3, r3, r2
33d0af5c:	e7c03002 	strb	r3, [r0, r2]
33d0af60:	e2822001 	add	r2, r2, #1	; 0x1
33d0af64:	e352001f 	cmp	r2, #31	; 0x1f
33d0af68:	dafffff7 	ble	33d0af4c <PrepareEp1Fifo+0x24>
33d0af6c:	e3a01020 	mov	r1, #32	; 0x20
33d0af70:	eb000099 	bl	33d0b1dc <WrPktEp1>
33d0af74:	e5942000 	ldr	r2, [r4]
33d0af78:	e3c53049 	bic	r3, r5, #73	; 0x49
33d0af7c:	e3833001 	orr	r3, r3, #1	; 0x1
33d0af80:	e5c23044 	strb	r3, [r2, #68]
33d0af84:	e8bd8030 	pop	{r4, r5, pc}
33d0af88:	33d60410 	.word	0x33d60410
33d0af8c:	33d6045c 	.word	0x33d6045c
33d0af90:	33d60460 	.word	0x33d60460

33d0af94 <Ep1Handler>:
33d0af94:	e92d4030 	push	{r4, r5, lr}
33d0af98:	e59f5054 	ldr	r5, [pc, #84]	; 33d0aff4 <Ep1Handler+0x60>
33d0af9c:	e5953000 	ldr	r3, [r5]
33d0afa0:	e3a02001 	mov	r2, #1	; 0x1
33d0afa4:	e5c32038 	strb	r2, [r3, #56]
33d0afa8:	e5953000 	ldr	r3, [r5]
33d0afac:	e5d34044 	ldrb	r4, [r3, #68]
33d0afb0:	e3140020 	tst	r4, #32	; 0x20
33d0afb4:	03a0301f 	moveq	r3, #31	; 0x1f
33d0afb8:	0a000005 	beq	33d0afd4 <Ep1Handler+0x40>
33d0afbc:	e59f0034 	ldr	r0, [pc, #52]	; 33d0aff8 <Ep1Handler+0x64>
33d0afc0:	ebfffa11 	bl	33d0980c <DbgPrintf>
33d0afc4:	e5952000 	ldr	r2, [r5]
33d0afc8:	e2043096 	and	r3, r4, #150	; 0x96
33d0afcc:	e5c23044 	strb	r3, [r2, #68]
33d0afd0:	e8bd8030 	pop	{r4, r5, pc}
33d0afd4:	e2533001 	subs	r3, r3, #1	; 0x1
33d0afd8:	5afffffd 	bpl	33d0afd4 <Ep1Handler+0x40>
33d0afdc:	e59f2018 	ldr	r2, [pc, #24]	; 33d0affc <Ep1Handler+0x68>
33d0afe0:	e5923000 	ldr	r3, [r2]
33d0afe4:	e2833001 	add	r3, r3, #1	; 0x1
33d0afe8:	e5823000 	str	r3, [r2]
33d0afec:	e8bd4030 	pop	{r4, r5, lr}
33d0aff0:	eaffffcc 	b	33d0af28 <PrepareEp1Fifo>
33d0aff4:	33d60410 	.word	0x33d60410
33d0aff8:	33d2678c 	.word	0x33d2678c
33d0affc:	33d6045c 	.word	0x33d6045c

33d0b000 <ReconfigUsbd>:
33d0b000:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d0b004:	e59f3144 	ldr	r3, [pc, #324]	; 33d0b150 <ReconfigUsbd+0x150>
33d0b008:	e5932000 	ldr	r2, [r3]
33d0b00c:	e3a07000 	mov	r7, #0	; 0x0
33d0b010:	e5c27004 	strb	r7, [r2, #4]
33d0b014:	e5932000 	ldr	r2, [r3]
33d0b018:	e5c27038 	strb	r7, [r2, #56]
33d0b01c:	e5932000 	ldr	r2, [r3]
33d0b020:	e3a00001 	mov	r0, #1	; 0x1
33d0b024:	e5c20040 	strb	r0, [r2, #64]
33d0b028:	e5931000 	ldr	r1, [r3]
33d0b02c:	e3e0203f 	mvn	r2, #63	; 0x3f
33d0b030:	e5c12044 	strb	r2, [r1, #68]
33d0b034:	e5932000 	ldr	r2, [r3]
33d0b038:	e5c20038 	strb	r0, [r2, #56]
33d0b03c:	e5932000 	ldr	r2, [r3]
33d0b040:	e3a05004 	mov	r5, #4	; 0x4
33d0b044:	e5c25040 	strb	r5, [r2, #64]
33d0b048:	e5932000 	ldr	r2, [r3]
33d0b04c:	e3a0e048 	mov	lr, #72	; 0x48
33d0b050:	e5c2e044 	strb	lr, [r2, #68]
33d0b054:	e5932000 	ldr	r2, [r3]
33d0b058:	e3a04030 	mov	r4, #48	; 0x30
33d0b05c:	e5c24048 	strb	r4, [r2, #72]
33d0b060:	e5932000 	ldr	r2, [r3]
33d0b064:	e3e0c07f 	mvn	ip, #127	; 0x7f
33d0b068:	e5c2c050 	strb	ip, [r2, #80]
33d0b06c:	e5932000 	ldr	r2, [r3]
33d0b070:	e280001f 	add	r0, r0, #31	; 0x1f
33d0b074:	e5c20054 	strb	r0, [r2, #84]
33d0b078:	e5931000 	ldr	r1, [r3]
33d0b07c:	e3a02002 	mov	r2, #2	; 0x2
33d0b080:	e5c12038 	strb	r2, [r1, #56]
33d0b084:	e5932000 	ldr	r2, [r3]
33d0b088:	e3a06008 	mov	r6, #8	; 0x8
33d0b08c:	e5c26040 	strb	r6, [r2, #64]
33d0b090:	e5932000 	ldr	r2, [r3]
33d0b094:	e5c2e044 	strb	lr, [r2, #68]
33d0b098:	e5932000 	ldr	r2, [r3]
33d0b09c:	e5c24048 	strb	r4, [r2, #72]
33d0b0a0:	e5932000 	ldr	r2, [r3]
33d0b0a4:	e5c2c050 	strb	ip, [r2, #80]
33d0b0a8:	e5932000 	ldr	r2, [r3]
33d0b0ac:	e5c20054 	strb	r0, [r2, #84]
33d0b0b0:	e5931000 	ldr	r1, [r3]
33d0b0b4:	e3a02003 	mov	r2, #3	; 0x3
33d0b0b8:	e5c12038 	strb	r2, [r1, #56]
33d0b0bc:	e5932000 	ldr	r2, [r3]
33d0b0c0:	e5c25040 	strb	r5, [r2, #64]
33d0b0c4:	e5932000 	ldr	r2, [r3]
33d0b0c8:	e5c2e044 	strb	lr, [r2, #68]
33d0b0cc:	e5932000 	ldr	r2, [r3]
33d0b0d0:	e3a01010 	mov	r1, #16	; 0x10
33d0b0d4:	e5c21048 	strb	r1, [r2, #72]
33d0b0d8:	e5932000 	ldr	r2, [r3]
33d0b0dc:	e5c2c050 	strb	ip, [r2, #80]
33d0b0e0:	e5932000 	ldr	r2, [r3]
33d0b0e4:	e5c20054 	strb	r0, [r2, #84]
33d0b0e8:	e5932000 	ldr	r2, [r3]
33d0b0ec:	e5c25038 	strb	r5, [r2, #56]
33d0b0f0:	e5932000 	ldr	r2, [r3]
33d0b0f4:	e5c26040 	strb	r6, [r2, #64]
33d0b0f8:	e5932000 	ldr	r2, [r3]
33d0b0fc:	e5c2e044 	strb	lr, [r2, #68]
33d0b100:	e5932000 	ldr	r2, [r3]
33d0b104:	e5c21048 	strb	r1, [r2, #72]
33d0b108:	e5932000 	ldr	r2, [r3]
33d0b10c:	e5c2c050 	strb	ip, [r2, #80]
33d0b110:	e5932000 	ldr	r2, [r3]
33d0b114:	e5c20054 	strb	r0, [r2, #84]
33d0b118:	e5931000 	ldr	r1, [r3]
33d0b11c:	e3a0201f 	mov	r2, #31	; 0x1f
33d0b120:	e5c12008 	strb	r2, [r1, #8]
33d0b124:	e5931000 	ldr	r1, [r3]
33d0b128:	e2422018 	sub	r2, r2, #24	; 0x18
33d0b12c:	e5c12018 	strb	r2, [r1, #24]
33d0b130:	e5931000 	ldr	r1, [r3]
33d0b134:	e0822005 	add	r2, r2, r5
33d0b138:	e5c1201c 	strb	r2, [r1, #28]
33d0b13c:	e5933000 	ldr	r3, [r3]
33d0b140:	e5c3502c 	strb	r5, [r3, #44]
33d0b144:	e59f3008 	ldr	r3, [pc, #8]	; 33d0b154 <ReconfigUsbd+0x154>
33d0b148:	e5837000 	str	r7, [r3]
33d0b14c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0b150:	33d60410 	.word	0x33d60410
33d0b154:	33d60398 	.word	0x33d60398

33d0b158 <ConfigUsbd>:
33d0b158:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0b15c:	ebffffa7 	bl	33d0b000 <ReconfigUsbd>
33d0b160:	e59f3010 	ldr	r3, [pc, #16]	; 33d0b178 <ConfigUsbd+0x20>
33d0b164:	e5932000 	ldr	r2, [r3]
33d0b168:	e5923008 	ldr	r3, [r2, #8]
33d0b16c:	e3c33402 	bic	r3, r3, #33554432	; 0x2000000
33d0b170:	e5823008 	str	r3, [r2, #8]
33d0b174:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d0b178:	33d37248 	.word	0x33d37248

33d0b17c <RdPktEp0>:
33d0b17c:	e3a02000 	mov	r2, #0	; 0x0
33d0b180:	e1520001 	cmp	r2, r1
33d0b184:	a1a0f00e 	movge	pc, lr
33d0b188:	e59f3018 	ldr	r3, [pc, #24]	; 33d0b1a8 <RdPktEp0+0x2c>
33d0b18c:	e5933000 	ldr	r3, [r3]
33d0b190:	e5d33080 	ldrb	r3, [r3, #128]
33d0b194:	e7c03002 	strb	r3, [r0, r2]
33d0b198:	e2822001 	add	r2, r2, #1	; 0x1
33d0b19c:	e1520001 	cmp	r2, r1
33d0b1a0:	bafffff8 	blt	33d0b188 <RdPktEp0+0xc>
33d0b1a4:	e1a0f00e 	mov	pc, lr
33d0b1a8:	33d60410 	.word	0x33d60410

33d0b1ac <WrPktEp0>:
33d0b1ac:	e3a0c000 	mov	ip, #0	; 0x0
33d0b1b0:	e15c0001 	cmp	ip, r1
33d0b1b4:	a1a0f00e 	movge	pc, lr
33d0b1b8:	e59f3018 	ldr	r3, [pc, #24]	; 33d0b1d8 <WrPktEp0+0x2c>
33d0b1bc:	e5932000 	ldr	r2, [r3]
33d0b1c0:	e7d0300c 	ldrb	r3, [r0, ip]
33d0b1c4:	e28cc001 	add	ip, ip, #1	; 0x1
33d0b1c8:	e15c0001 	cmp	ip, r1
33d0b1cc:	e5c23080 	strb	r3, [r2, #128]
33d0b1d0:	bafffff8 	blt	33d0b1b8 <WrPktEp0+0xc>
33d0b1d4:	e1a0f00e 	mov	pc, lr
33d0b1d8:	33d60410 	.word	0x33d60410

33d0b1dc <WrPktEp1>:
33d0b1dc:	e3a0c000 	mov	ip, #0	; 0x0
33d0b1e0:	e15c0001 	cmp	ip, r1
33d0b1e4:	a1a0f00e 	movge	pc, lr
33d0b1e8:	e59f3018 	ldr	r3, [pc, #24]	; 33d0b208 <WrPktEp1+0x2c>
33d0b1ec:	e5932000 	ldr	r2, [r3]
33d0b1f0:	e7d0300c 	ldrb	r3, [r0, ip]
33d0b1f4:	e28cc001 	add	ip, ip, #1	; 0x1
33d0b1f8:	e15c0001 	cmp	ip, r1
33d0b1fc:	e5c23084 	strb	r3, [r2, #132]
33d0b200:	bafffff8 	blt	33d0b1e8 <WrPktEp1+0xc>
33d0b204:	e1a0f00e 	mov	pc, lr
33d0b208:	33d60410 	.word	0x33d60410

33d0b20c <WrPktEp2>:
33d0b20c:	e3a0c000 	mov	ip, #0	; 0x0
33d0b210:	e15c0001 	cmp	ip, r1
33d0b214:	a1a0f00e 	movge	pc, lr
33d0b218:	e59f3018 	ldr	r3, [pc, #24]	; 33d0b238 <WrPktEp2+0x2c>
33d0b21c:	e5932000 	ldr	r2, [r3]
33d0b220:	e7d0300c 	ldrb	r3, [r0, ip]
33d0b224:	e28cc001 	add	ip, ip, #1	; 0x1
33d0b228:	e15c0001 	cmp	ip, r1
33d0b22c:	e5c23088 	strb	r3, [r2, #136]
33d0b230:	bafffff8 	blt	33d0b218 <WrPktEp2+0xc>
33d0b234:	e1a0f00e 	mov	pc, lr
33d0b238:	33d60410 	.word	0x33d60410

33d0b23c <RdPktEp3>:
33d0b23c:	e3a02000 	mov	r2, #0	; 0x0
33d0b240:	e1520001 	cmp	r2, r1
33d0b244:	a1a0f00e 	movge	pc, lr
33d0b248:	e59f3018 	ldr	r3, [pc, #24]	; 33d0b268 <RdPktEp3+0x2c>
33d0b24c:	e5933000 	ldr	r3, [r3]
33d0b250:	e5d3308c 	ldrb	r3, [r3, #140]
33d0b254:	e7c03002 	strb	r3, [r0, r2]
33d0b258:	e2822001 	add	r2, r2, #1	; 0x1
33d0b25c:	e1520001 	cmp	r2, r1
33d0b260:	bafffff8 	blt	33d0b248 <RdPktEp3+0xc>
33d0b264:	e1a0f00e 	mov	pc, lr
33d0b268:	33d60410 	.word	0x33d60410

33d0b26c <RdPktEp4>:
33d0b26c:	e3a02000 	mov	r2, #0	; 0x0
33d0b270:	e1520001 	cmp	r2, r1
33d0b274:	a1a0f00e 	movge	pc, lr
33d0b278:	e59f3018 	ldr	r3, [pc, #24]	; 33d0b298 <RdPktEp4+0x2c>
33d0b27c:	e5933000 	ldr	r3, [r3]
33d0b280:	e5d33090 	ldrb	r3, [r3, #144]
33d0b284:	e7c03002 	strb	r3, [r0, r2]
33d0b288:	e2822001 	add	r2, r2, #1	; 0x1
33d0b28c:	e1520001 	cmp	r2, r1
33d0b290:	bafffff8 	blt	33d0b278 <RdPktEp4+0xc>
33d0b294:	e1a0f00e 	mov	pc, lr
33d0b298:	33d60410 	.word	0x33d60410

33d0b29c <ConfigEp3DmaMode>:
33d0b29c:	e59fc0e4 	ldr	ip, [pc, #228]	; 33d0b388 <ConfigEp3DmaMode+0xec>
33d0b2a0:	e59c3000 	ldr	r3, [ip]
33d0b2a4:	e3a02003 	mov	r2, #3	; 0x3
33d0b2a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0b2ac:	e5c32038 	strb	r2, [r3, #56]
33d0b2b0:	e59fe0d4 	ldr	lr, [pc, #212]	; 33d0b38c <ConfigEp3DmaMode+0xf0>
33d0b2b4:	e59e3000 	ldr	r3, [lr]
33d0b2b8:	e5832084 	str	r2, [r3, #132]
33d0b2bc:	e59f30cc 	ldr	r3, [pc, #204]	; 33d0b390 <ConfigEp3DmaMode+0xf4>
33d0b2c0:	e59e2000 	ldr	r2, [lr]
33d0b2c4:	e5823080 	str	r3, [r2, #128]
33d0b2c8:	e59e2000 	ldr	r2, [lr]
33d0b2cc:	e3a03000 	mov	r3, #0	; 0x0
33d0b2d0:	e582308c 	str	r3, [r2, #140]
33d0b2d4:	e59e3000 	ldr	r3, [lr]
33d0b2d8:	e3c114ff 	bic	r1, r1, #-16777216	; 0xff000000
33d0b2dc:	e5830088 	str	r0, [r3, #136]
33d0b2e0:	e3c1160f 	bic	r1, r1, #15728640	; 0xf00000
33d0b2e4:	e59e3000 	ldr	r3, [lr]
33d0b2e8:	e3811329 	orr	r1, r1, #-1543503872	; 0xa4000000
33d0b2ec:	e3811503 	orr	r1, r1, #12582912	; 0xc00000
33d0b2f0:	e5831090 	str	r1, [r3, #144]
33d0b2f4:	e59e2000 	ldr	r2, [lr]
33d0b2f8:	e3a03002 	mov	r3, #2	; 0x2
33d0b2fc:	e58230a0 	str	r3, [r2, #160]
33d0b300:	e59c2000 	ldr	r2, [ip]
33d0b304:	e3e01000 	mvn	r1, #0	; 0x0
33d0b308:	e3a03f43 	mov	r3, #268	; 0x10c
33d0b30c:	e7c21003 	strb	r1, [r2, r3]
33d0b310:	e59c2000 	ldr	r2, [ip]
33d0b314:	e2833004 	add	r3, r3, #4	; 0x4
33d0b318:	e7c21003 	strb	r1, [r2, r3]
33d0b31c:	e59c1000 	ldr	r1, [ip]
33d0b320:	e3a0200f 	mov	r2, #15	; 0xf
33d0b324:	e2833004 	add	r3, r3, #4	; 0x4
33d0b328:	e7c12003 	strb	r2, [r1, r3]
33d0b32c:	e59c2000 	ldr	r2, [ip]
33d0b330:	e5d23054 	ldrb	r3, [r2, #84]
33d0b334:	e1e03003 	mvn	r3, r3
33d0b338:	e203305f 	and	r3, r3, #95	; 0x5f
33d0b33c:	e1e03003 	mvn	r3, r3
33d0b340:	e5c23054 	strb	r3, [r2, #84]
33d0b344:	e59c1000 	ldr	r1, [ip]
33d0b348:	e3a02001 	mov	r2, #1	; 0x1
33d0b34c:	e3a03f41 	mov	r3, #260	; 0x104
33d0b350:	e7c12003 	strb	r2, [r1, r3]
33d0b354:	e59c1000 	ldr	r1, [ip]
33d0b358:	e28220ff 	add	r2, r2, #255	; 0xff
33d0b35c:	e24330ff 	sub	r3, r3, #255	; 0xff
33d0b360:	e7c13002 	strb	r3, [r1, r2]
33d0b364:	e59c3000 	ldr	r3, [ip]
33d0b368:	e7d33002 	ldrb	r3, [r3, r2]
33d0b36c:	e3a03009 	mov	r3, #9	; 0x9
33d0b370:	e2533001 	subs	r3, r3, #1	; 0x1
33d0b374:	5afffffd 	bpl	33d0b370 <ConfigEp3DmaMode+0xd4>
33d0b378:	e59e2000 	ldr	r2, [lr]
33d0b37c:	e3a03002 	mov	r3, #2	; 0x2
33d0b380:	e58230e0 	str	r3, [r2, #224]
33d0b384:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d0b388:	33d60410 	.word	0x33d60410
33d0b38c:	33d60414 	.word	0x33d60414
33d0b390:	520001cc 	.word	0x520001cc

33d0b394 <ConfigEp3IntMode>:
33d0b394:	e59f0050 	ldr	r0, [pc, #80]	; 33d0b3ec <ConfigEp3IntMode+0x58>
33d0b398:	e5902000 	ldr	r2, [r0]
33d0b39c:	e3a03003 	mov	r3, #3	; 0x3
33d0b3a0:	e5c23038 	strb	r3, [r2, #56]
33d0b3a4:	e59f3044 	ldr	r3, [pc, #68]	; 33d0b3f0 <ConfigEp3IntMode+0x5c>
33d0b3a8:	e5933000 	ldr	r3, [r3]
33d0b3ac:	e3a0c000 	mov	ip, #0	; 0x0
33d0b3b0:	e583c0a0 	str	ip, [r3, #160]
33d0b3b4:	e5902000 	ldr	r2, [r0]
33d0b3b8:	e5d23054 	ldrb	r3, [r2, #84]
33d0b3bc:	e203307f 	and	r3, r3, #127	; 0x7f
33d0b3c0:	e5c23054 	strb	r3, [r2, #84]
33d0b3c4:	e5901000 	ldr	r1, [r0]
33d0b3c8:	e3a02001 	mov	r2, #1	; 0x1
33d0b3cc:	e3a03f41 	mov	r3, #260	; 0x104
33d0b3d0:	e7c12003 	strb	r2, [r1, r3]
33d0b3d4:	e5903000 	ldr	r3, [r0]
33d0b3d8:	e28220ff 	add	r2, r2, #255	; 0xff
33d0b3dc:	e7c3c002 	strb	ip, [r3, r2]
33d0b3e0:	e5903000 	ldr	r3, [r0]
33d0b3e4:	e7d33002 	ldrb	r3, [r3, r2]
33d0b3e8:	e1a0f00e 	mov	pc, lr
33d0b3ec:	33d60410 	.word	0x33d60410
33d0b3f0:	33d60414 	.word	0x33d60414

33d0b3f4 <ClearFreeMem>:
33d0b3f4:	e59f3020 	ldr	r3, [pc, #32]	; 33d0b41c <ClearFreeMem+0x28>
33d0b3f8:	e5931000 	ldr	r1, [r3]
33d0b3fc:	e3a02203 	mov	r2, #805306368	; 0x30000000
33d0b400:	e1520001 	cmp	r2, r1
33d0b404:	21a0f00e 	movcs	pc, lr
33d0b408:	e3a03000 	mov	r3, #0	; 0x0
33d0b40c:	e4823004 	str	r3, [r2], #4
33d0b410:	e1520001 	cmp	r2, r1
33d0b414:	3afffffb 	bcc	33d0b408 <ClearFreeMem+0x14>
33d0b418:	e1a0f00e 	mov	pc, lr
33d0b41c:	33d00050 	.word	0x33d00050

33d0b420 <do_eboot>:
33d0b420:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0b424:	ebfffff2 	bl	33d0b3f4 <ClearFreeMem>
33d0b428:	e3a00001 	mov	r0, #1	; 0x1
33d0b42c:	eb000285 	bl	33d0be48 <ReadImageFromNand>
33d0b430:	e2502000 	subs	r2, r0, #0	; 0x0
33d0b434:	e59f1028 	ldr	r1, [pc, #40]	; 33d0b464 <do_eboot+0x44>
33d0b438:	e59f0028 	ldr	r0, [pc, #40]	; 33d0b468 <do_eboot+0x48>
33d0b43c:	0a000001 	beq	33d0b448 <do_eboot+0x28>
33d0b440:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d0b444:	ea002edf 	b	33d16fc8 <printf>
33d0b448:	e59f301c 	ldr	r3, [pc, #28]	; 33d0b46c <do_eboot+0x4c>
33d0b44c:	e5930000 	ldr	r0, [r3]
33d0b450:	ebffd3b2 	bl	33d00320 <Launch>
33d0b454:	e59f0014 	ldr	r0, [pc, #20]	; 33d0b470 <do_eboot+0x50>
33d0b458:	e59f1004 	ldr	r1, [pc, #4]	; 33d0b464 <do_eboot+0x44>
33d0b45c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d0b460:	ea002ed8 	b	33d16fc8 <printf>
33d0b464:	33d24984 	.word	0x33d24984
33d0b468:	33d26ae0 	.word	0x33d26ae0
33d0b46c:	33d60480 	.word	0x33d60480
33d0b470:	33d26b0c 	.word	0x33d26b0c

33d0b474 <do_wince>:
33d0b474:	e3520002 	cmp	r2, #2	; 0x2
33d0b478:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0b47c:	e59f105c 	ldr	r1, [pc, #92]	; 33d0b4e0 <do_wince+0x6c>
33d0b480:	1a000007 	bne	33d0b4a4 <do_wince+0x30>
33d0b484:	e5930004 	ldr	r0, [r3, #4]
33d0b488:	eb003af6 	bl	33d1a068 <strcmp>
33d0b48c:	e3500000 	cmp	r0, #0	; 0x0
33d0b490:	1a000003 	bne	33d0b4a4 <do_wince+0x30>
33d0b494:	eb000336 	bl	33d0c174 <GetLauchAddrFrmRam>
33d0b498:	e3500000 	cmp	r0, #0	; 0x0
33d0b49c:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
33d0b4a0:	ea000009 	b	33d0b4cc <do_wince+0x58>
33d0b4a4:	e3a00002 	mov	r0, #2	; 0x2
33d0b4a8:	eb000266 	bl	33d0be48 <ReadImageFromNand>
33d0b4ac:	e2502000 	subs	r2, r0, #0	; 0x0
33d0b4b0:	059f302c 	ldreq	r3, [pc, #44]	; 33d0b4e4 <do_wince+0x70>
33d0b4b4:	e59f002c 	ldr	r0, [pc, #44]	; 33d0b4e8 <do_wince+0x74>
33d0b4b8:	e59f102c 	ldr	r1, [pc, #44]	; 33d0b4ec <do_wince+0x78>
33d0b4bc:	05930000 	ldreq	r0, [r3]
33d0b4c0:	0a000001 	beq	33d0b4cc <do_wince+0x58>
33d0b4c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d0b4c8:	ea002ebe 	b	33d16fc8 <printf>
33d0b4cc:	ebffd393 	bl	33d00320 <Launch>
33d0b4d0:	e59f0018 	ldr	r0, [pc, #24]	; 33d0b4f0 <do_wince+0x7c>
33d0b4d4:	e59f1010 	ldr	r1, [pc, #16]	; 33d0b4ec <do_wince+0x78>
33d0b4d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d0b4dc:	ea002eb9 	b	33d16fc8 <printf>
33d0b4e0:	33d26b24 	.word	0x33d26b24
33d0b4e4:	33d60480 	.word	0x33d60480
33d0b4e8:	33d26b28 	.word	0x33d26b28
33d0b4ec:	33d24990 	.word	0x33d24990
33d0b4f0:	33d26b58 	.word	0x33d26b58

33d0b4f4 <MarkReservedBlocksUnused>:
33d0b4f4:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d0b4f8:	e59f3120 	ldr	r3, [pc, #288]	; 33d0b620 <MarkReservedBlocksUnused+0x12c>
33d0b4fc:	e5933000 	ldr	r3, [r3]
33d0b500:	e0832103 	add	r2, r3, r3, lsl #2
33d0b504:	e0833182 	add	r3, r3, r2, lsl #3
33d0b508:	e59f1114 	ldr	r1, [pc, #276]	; 33d0b624 <MarkReservedBlocksUnused+0x130>
33d0b50c:	e24dd028 	sub	sp, sp, #40	; 0x28
33d0b510:	e1a02183 	lsl	r2, r3, #3
33d0b514:	e3a00000 	mov	r0, #0	; 0x0
33d0b518:	e28d9018 	add	r9, sp, #24	; 0x18
33d0b51c:	e0925001 	adds	r5, r2, r1
33d0b520:	e3a03010 	mov	r3, #16	; 0x10
33d0b524:	e58d000c 	str	r0, [sp, #12]
33d0b528:	e1a0a000 	mov	sl, r0
33d0b52c:	e58d3010 	str	r3, [sp, #16]
33d0b530:	e58d9014 	str	r9, [sp, #20]
33d0b534:	059f00ec 	ldreq	r0, [pc, #236]	; 33d0b628 <MarkReservedBlocksUnused+0x134>
33d0b538:	0a000003 	beq	33d0b54c <MarkReservedBlocksUnused+0x58>
33d0b53c:	e7d23001 	ldrb	r3, [r2, r1]
33d0b540:	e3530004 	cmp	r3, #4	; 0x4
33d0b544:	0a000002 	beq	33d0b554 <MarkReservedBlocksUnused+0x60>
33d0b548:	e59f00dc 	ldr	r0, [pc, #220]	; 33d0b62c <MarkReservedBlocksUnused+0x138>
33d0b54c:	eb002e9d 	bl	33d16fc8 <printf>
33d0b550:	ea000008 	b	33d0b578 <MarkReservedBlocksUnused+0x84>
33d0b554:	e5951014 	ldr	r1, [r5, #20]
33d0b558:	e3510010 	cmp	r1, #16	; 0x10
33d0b55c:	1a000002 	bne	33d0b56c <MarkReservedBlocksUnused+0x78>
33d0b560:	e5953010 	ldr	r3, [r5, #16]
33d0b564:	e3530c02 	cmp	r3, #512	; 0x200
33d0b568:	0a000004 	beq	33d0b580 <MarkReservedBlocksUnused+0x8c>
33d0b56c:	e5952010 	ldr	r2, [r5, #16]
33d0b570:	e59f00b8 	ldr	r0, [pc, #184]	; 33d0b630 <MarkReservedBlocksUnused+0x13c>
33d0b574:	eb002e93 	bl	33d16fc8 <printf>
33d0b578:	e3e00000 	mvn	r0, #0	; 0x0
33d0b57c:	ea000025 	b	33d0b618 <MarkReservedBlocksUnused+0x124>
33d0b580:	e595300c 	ldr	r3, [r5, #12]
33d0b584:	e0633283 	rsb	r3, r3, r3, lsl #5
33d0b588:	e1500103 	cmp	r0, r3, lsl #2
33d0b58c:	2a000020 	bcs	33d0b614 <MarkReservedBlocksUnused+0x120>
33d0b590:	e1a0600a 	mov	r6, sl
33d0b594:	e3a0701f 	mov	r7, #31	; 0x1f
33d0b598:	e3a04000 	mov	r4, #0	; 0x0
33d0b59c:	e1a01004 	mov	r1, r4
33d0b5a0:	e3a02010 	mov	r2, #16	; 0x10
33d0b5a4:	e1a00009 	mov	r0, r9
33d0b5a8:	eb003b79 	bl	33d1a394 <memset>
33d0b5ac:	e3a02083 	mov	r2, #131	; 0x83
33d0b5b0:	e3a03010 	mov	r3, #16	; 0x10
33d0b5b4:	e5cd2018 	strb	r2, [sp, #24]
33d0b5b8:	e28d2008 	add	r2, sp, #8	; 0x8
33d0b5bc:	e58d2000 	str	r2, [sp]
33d0b5c0:	e58d600c 	str	r6, [sp, #12]
33d0b5c4:	e1a01006 	mov	r1, r6
33d0b5c8:	e3a02000 	mov	r2, #0	; 0x0
33d0b5cc:	e5cd401d 	strb	r4, [sp, #29]
33d0b5d0:	e5cd4019 	strb	r4, [sp, #25]
33d0b5d4:	e5cd401a 	strb	r4, [sp, #26]
33d0b5d8:	e5cd401b 	strb	r4, [sp, #27]
33d0b5dc:	e58d3010 	str	r3, [sp, #16]
33d0b5e0:	e58d9014 	str	r9, [sp, #20]
33d0b5e4:	e58d9004 	str	r9, [sp, #4]
33d0b5e8:	e1a00005 	mov	r0, r5
33d0b5ec:	e1a0e00f 	mov	lr, pc
33d0b5f0:	e595f120 	ldr	pc, [r5, #288]
33d0b5f4:	e2577001 	subs	r7, r7, #1	; 0x1
33d0b5f8:	e2866c02 	add	r6, r6, #512	; 0x200
33d0b5fc:	5affffe5 	bpl	33d0b598 <MarkReservedBlocksUnused+0xa4>
33d0b600:	e595300c 	ldr	r3, [r5, #12]
33d0b604:	e08aa003 	add	sl, sl, r3
33d0b608:	e0633283 	rsb	r3, r3, r3, lsl #5
33d0b60c:	e15a0103 	cmp	sl, r3, lsl #2
33d0b610:	eaffffdd 	b	33d0b58c <MarkReservedBlocksUnused+0x98>
33d0b614:	e3a00000 	mov	r0, #0	; 0x0
33d0b618:	e28dd028 	add	sp, sp, #40	; 0x28
33d0b61c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d0b620:	33d2ddbc 	.word	0x33d2ddbc
33d0b624:	33d39920 	.word	0x33d39920
33d0b628:	33d26b70 	.word	0x33d26b70
33d0b62c:	33d26b94 	.word	0x33d26b94
33d0b630:	33d26bac 	.word	0x33d26bac

33d0b634 <download_nkbin_to_flash>:
33d0b634:	e92d4010 	push	{r4, lr}
33d0b638:	ebffff6d 	bl	33d0b3f4 <ClearFreeMem>
33d0b63c:	e3a00001 	mov	r0, #1	; 0x1
33d0b640:	eb000200 	bl	33d0be48 <ReadImageFromNand>
33d0b644:	e1a03000 	mov	r3, r0
33d0b648:	e3530000 	cmp	r3, #0	; 0x0
33d0b64c:	e1a02000 	mov	r2, r0
33d0b650:	e59fc088 	ldr	ip, [pc, #136]	; 33d0b6e0 <download_nkbin_to_flash+0xac>
33d0b654:	e3e01000 	mvn	r1, #0	; 0x0
33d0b658:	e59f0084 	ldr	r0, [pc, #132]	; 33d0b6e4 <download_nkbin_to_flash+0xb0>
33d0b65c:	e1a04003 	mov	r4, r3
33d0b660:	0a000002 	beq	33d0b670 <download_nkbin_to_flash+0x3c>
33d0b664:	e59f107c 	ldr	r1, [pc, #124]	; 33d0b6e8 <download_nkbin_to_flash+0xb4>
33d0b668:	e8bd4010 	pop	{r4, lr}
33d0b66c:	ea002e55 	b	33d16fc8 <printf>
33d0b670:	e59f3074 	ldr	r3, [pc, #116]	; 33d0b6ec <download_nkbin_to_flash+0xb8>
33d0b674:	e58c3000 	str	r3, [ip]
33d0b678:	e59f3070 	ldr	r3, [pc, #112]	; 33d0b6f0 <download_nkbin_to_flash+0xbc>
33d0b67c:	e3a02706 	mov	r2, #1572864	; 0x180000
33d0b680:	e5832000 	str	r2, [r3]
33d0b684:	e59f3068 	ldr	r3, [pc, #104]	; 33d0b6f4 <download_nkbin_to_flash+0xc0>
33d0b688:	e59c0000 	ldr	r0, [ip]
33d0b68c:	e1a02004 	mov	r2, r4
33d0b690:	e5834000 	str	r4, [r3]
33d0b694:	ebfffd43 	bl	33d0aba8 <usb_receive>
33d0b698:	e59f3058 	ldr	r3, [pc, #88]	; 33d0b6f8 <download_nkbin_to_flash+0xc4>
33d0b69c:	e5830000 	str	r0, [r3]
33d0b6a0:	ebffff93 	bl	33d0b4f4 <MarkReservedBlocksUnused>
33d0b6a4:	eb00037b 	bl	33d0c498 <ExtractImgFrmUSBBuf>
33d0b6a8:	e1a03000 	mov	r3, r0
33d0b6ac:	e21330ff 	ands	r3, r3, #255	; 0xff
33d0b6b0:	e1a00004 	mov	r0, r4
33d0b6b4:	e1a01003 	mov	r1, r3
33d0b6b8:	059f003c 	ldreq	r0, [pc, #60]	; 33d0b6fc <download_nkbin_to_flash+0xc8>
33d0b6bc:	0a000005 	beq	33d0b6d8 <download_nkbin_to_flash+0xa4>
33d0b6c0:	ebfff677 	bl	33d090a4 <embedsky_lcd_EnvidOnOff>
33d0b6c4:	e59f3034 	ldr	r3, [pc, #52]	; 33d0b700 <download_nkbin_to_flash+0xcc>
33d0b6c8:	e5930000 	ldr	r0, [r3]
33d0b6cc:	ebffd313 	bl	33d00320 <Launch>
33d0b6d0:	e59f002c 	ldr	r0, [pc, #44]	; 33d0b704 <download_nkbin_to_flash+0xd0>
33d0b6d4:	e59f100c 	ldr	r1, [pc, #12]	; 33d0b6e8 <download_nkbin_to_flash+0xb4>
33d0b6d8:	e8bd4010 	pop	{r4, lr}
33d0b6dc:	ea002e39 	b	33d16fc8 <printf>
33d0b6e0:	33d60450 	.word	0x33d60450
33d0b6e4:	33d26ae0 	.word	0x33d26ae0
33d0b6e8:	33d2499c 	.word	0x33d2499c
33d0b6ec:	30058000 	.word	0x30058000
33d0b6f0:	33d60454 	.word	0x33d60454
33d0b6f4:	33d60404 	.word	0x33d60404
33d0b6f8:	33d60c10 	.word	0x33d60c10
33d0b6fc:	33d26be0 	.word	0x33d26be0
33d0b700:	33d60480 	.word	0x33d60480
33d0b704:	33d26b0c 	.word	0x33d26b0c

33d0b708 <Load_nknb0_to_flash>:
33d0b708:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0b70c:	e59f3284 	ldr	r3, [pc, #644]	; 33d0b998 <Load_nknb0_to_flash+0x290>
33d0b710:	e5933000 	ldr	r3, [r3]
33d0b714:	e0832103 	add	r2, r3, r3, lsl #2
33d0b718:	e0833182 	add	r3, r3, r2, lsl #3
33d0b71c:	e59fc278 	ldr	ip, [pc, #632]	; 33d0b99c <Load_nknb0_to_flash+0x294>
33d0b720:	e24dd078 	sub	sp, sp, #120	; 0x78
33d0b724:	e1a02183 	lsl	r2, r3, #3
33d0b728:	e3a03010 	mov	r3, #16	; 0x10
33d0b72c:	e3a07000 	mov	r7, #0	; 0x0
33d0b730:	e092400c 	adds	r4, r2, ip
33d0b734:	e58d3060 	str	r3, [sp, #96]
33d0b738:	e28d3068 	add	r3, sp, #104	; 0x68
33d0b73c:	e58d000c 	str	r0, [sp, #12]
33d0b740:	e58d7010 	str	r7, [sp, #16]
33d0b744:	e58d1018 	str	r1, [sp, #24]
33d0b748:	e58d705c 	str	r7, [sp, #92]
33d0b74c:	e58d3064 	str	r3, [sp, #100]
33d0b750:	059f0248 	ldreq	r0, [pc, #584]	; 33d0b9a0 <Load_nknb0_to_flash+0x298>
33d0b754:	0a000012 	beq	33d0b7a4 <Load_nknb0_to_flash+0x9c>
33d0b758:	e7d2300c 	ldrb	r3, [r2, ip]
33d0b75c:	e3530004 	cmp	r3, #4	; 0x4
33d0b760:	159f023c 	ldrne	r0, [pc, #572]	; 33d0b9a4 <Load_nknb0_to_flash+0x29c>
33d0b764:	1a00000e 	bne	33d0b7a4 <Load_nknb0_to_flash+0x9c>
33d0b768:	e59dc00c 	ldr	ip, [sp, #12]
33d0b76c:	e35c0000 	cmp	ip, #0	; 0x0
33d0b770:	059f0230 	ldreq	r0, [pc, #560]	; 33d0b9a8 <Load_nknb0_to_flash+0x2a0>
33d0b774:	0a00000a 	beq	33d0b7a4 <Load_nknb0_to_flash+0x9c>
33d0b778:	e5941014 	ldr	r1, [r4, #20]
33d0b77c:	e3510010 	cmp	r1, #16	; 0x10
33d0b780:	1a000002 	bne	33d0b790 <Load_nknb0_to_flash+0x88>
33d0b784:	e5943010 	ldr	r3, [r4, #16]
33d0b788:	e3530c02 	cmp	r3, #512	; 0x200
33d0b78c:	0a000007 	beq	33d0b7b0 <Load_nknb0_to_flash+0xa8>
33d0b790:	e5942010 	ldr	r2, [r4, #16]
33d0b794:	e59f0210 	ldr	r0, [pc, #528]	; 33d0b9ac <Load_nknb0_to_flash+0x2a4>
33d0b798:	eb002e0a 	bl	33d16fc8 <printf>
33d0b79c:	ea000001 	b	33d0b7a8 <Load_nknb0_to_flash+0xa0>
33d0b7a0:	e59f0208 	ldr	r0, [pc, #520]	; 33d0b9b0 <Load_nknb0_to_flash+0x2a8>
33d0b7a4:	eb002e07 	bl	33d16fc8 <printf>
33d0b7a8:	e3e00000 	mvn	r0, #0	; 0x0
33d0b7ac:	ea000077 	b	33d0b990 <Load_nknb0_to_flash+0x288>
33d0b7b0:	e5943008 	ldr	r3, [r4, #8]
33d0b7b4:	e3a0781f 	mov	r7, #2031616	; 0x1f0000
33d0b7b8:	e1570003 	cmp	r7, r3
33d0b7bc:	e243381f 	sub	r3, r3, #2031616	; 0x1f0000
33d0b7c0:	e58d3014 	str	r3, [sp, #20]
33d0b7c4:	2a00005d 	bcs	33d0b940 <Load_nknb0_to_flash+0x238>
33d0b7c8:	e1a00004 	mov	r0, r4
33d0b7cc:	e1a01007 	mov	r1, r7
33d0b7d0:	e3a02000 	mov	r2, #0	; 0x0
33d0b7d4:	e1a0e00f 	mov	lr, pc
33d0b7d8:	e594f134 	ldr	pc, [r4, #308]
33d0b7dc:	e3500000 	cmp	r0, #0	; 0x0
33d0b7e0:	0a000003 	beq	33d0b7f4 <Load_nknb0_to_flash+0xec>
33d0b7e4:	e3a03064 	mov	r3, #100	; 0x64
33d0b7e8:	e2533001 	subs	r3, r3, #1	; 0x1
33d0b7ec:	2afffffd 	bcs	33d0b7e8 <Load_nknb0_to_flash+0xe0>
33d0b7f0:	ea00004c 	b	33d0b928 <Load_nknb0_to_flash+0x220>
33d0b7f4:	e594300c 	ldr	r3, [r4, #12]
33d0b7f8:	e1a00004 	mov	r0, r4
33d0b7fc:	e58d3034 	str	r3, [sp, #52]
33d0b800:	e58d7030 	str	r7, [sp, #48]
33d0b804:	e28d102c 	add	r1, sp, #44	; 0x2c
33d0b808:	e1a0e00f 	mov	lr, pc
33d0b80c:	e594f100 	ldr	pc, [r4, #256]
33d0b810:	e3500000 	cmp	r0, #0	; 0x0
33d0b814:	e58d0028 	str	r0, [sp, #40]
33d0b818:	1affffe0 	bne	33d0b7a0 <Load_nknb0_to_flash+0x98>
33d0b81c:	e594300c 	ldr	r3, [r4, #12]
33d0b820:	e1a09000 	mov	r9, r0
33d0b824:	e1590003 	cmp	r9, r3
33d0b828:	2a00003e 	bcs	33d0b928 <Load_nknb0_to_flash+0x220>
33d0b82c:	e59de010 	ldr	lr, [sp, #16]
33d0b830:	e59dc018 	ldr	ip, [sp, #24]
33d0b834:	e0875009 	add	r5, r7, r9
33d0b838:	e1a0a005 	mov	sl, r5
33d0b83c:	e3a0b000 	mov	fp, #0	; 0x0
33d0b840:	e3a03c02 	mov	r3, #512	; 0x200
33d0b844:	e15e000c 	cmp	lr, ip
33d0b848:	e1a0200b 	mov	r2, fp
33d0b84c:	e1a0100a 	mov	r1, sl
33d0b850:	e1a00004 	mov	r0, r4
33d0b854:	e3e06000 	mvn	r6, #0	; 0x0
33d0b858:	e0899003 	add	r9, r9, r3
33d0b85c:	aa00002f 	bge	33d0b920 <Load_nknb0_to_flash+0x218>
33d0b860:	e59de00c 	ldr	lr, [sp, #12]
33d0b864:	e58de004 	str	lr, [sp, #4]
33d0b868:	e59de010 	ldr	lr, [sp, #16]
33d0b86c:	e28dc024 	add	ip, sp, #36	; 0x24
33d0b870:	e08ee003 	add	lr, lr, r3
33d0b874:	e58dc008 	str	ip, [sp, #8]
33d0b878:	e28dc028 	add	ip, sp, #40	; 0x28
33d0b87c:	e58dc000 	str	ip, [sp]
33d0b880:	e58de010 	str	lr, [sp, #16]
33d0b884:	e58d505c 	str	r5, [sp, #92]
33d0b888:	ebffeb09 	bl	33d064b4 <nand_write_calmecc>
33d0b88c:	e3a0c000 	mov	ip, #0	; 0x0
33d0b890:	e3a03002 	mov	r3, #2	; 0x2
33d0b894:	e28d101c 	add	r1, sp, #28	; 0x1c
33d0b898:	e3a02008 	mov	r2, #8	; 0x8
33d0b89c:	e28d0068 	add	r0, sp, #104	; 0x68
33d0b8a0:	e5cd3020 	strb	r3, [sp, #32]
33d0b8a4:	e1cdc2b2 	strh	ip, [sp, #34]
33d0b8a8:	e58dc01c 	str	ip, [sp, #28]
33d0b8ac:	e5cd6021 	strb	r6, [sp, #33]
33d0b8b0:	eb003acb 	bl	33d1a3e4 <memcpy>
33d0b8b4:	e59d1024 	ldr	r1, [sp, #36]
33d0b8b8:	e59dc00c 	ldr	ip, [sp, #12]
33d0b8bc:	e1a00821 	lsr	r0, r1, #16
33d0b8c0:	e1a02421 	lsr	r2, r1, #8
33d0b8c4:	e3a03010 	mov	r3, #16	; 0x10
33d0b8c8:	e5cd2071 	strb	r2, [sp, #113]
33d0b8cc:	e5cd0072 	strb	r0, [sp, #114]
33d0b8d0:	e28d2068 	add	r2, sp, #104	; 0x68
33d0b8d4:	e28d0028 	add	r0, sp, #40	; 0x28
33d0b8d8:	e28ccc02 	add	ip, ip, #512	; 0x200
33d0b8dc:	e58d0000 	str	r0, [sp]
33d0b8e0:	e5cd1070 	strb	r1, [sp, #112]
33d0b8e4:	e58d2064 	str	r2, [sp, #100]
33d0b8e8:	e58d2004 	str	r2, [sp, #4]
33d0b8ec:	e5cd6077 	strb	r6, [sp, #119]
33d0b8f0:	e58d505c 	str	r5, [sp, #92]
33d0b8f4:	e5cd6073 	strb	r6, [sp, #115]
33d0b8f8:	e5cd6074 	strb	r6, [sp, #116]
33d0b8fc:	e5cd6075 	strb	r6, [sp, #117]
33d0b900:	e5cd6076 	strb	r6, [sp, #118]
33d0b904:	e58d3060 	str	r3, [sp, #96]
33d0b908:	e1a0200b 	mov	r2, fp
33d0b90c:	e1a0100a 	mov	r1, sl
33d0b910:	e58dc00c 	str	ip, [sp, #12]
33d0b914:	e1a00004 	mov	r0, r4
33d0b918:	e1a0e00f 	mov	lr, pc
33d0b91c:	e594f120 	ldr	pc, [r4, #288]
33d0b920:	e594300c 	ldr	r3, [r4, #12]
33d0b924:	eaffffbe 	b	33d0b824 <Load_nknb0_to_flash+0x11c>
33d0b928:	e594300c 	ldr	r3, [r4, #12]
33d0b92c:	e59de014 	ldr	lr, [sp, #20]
33d0b930:	e0877003 	add	r7, r7, r3
33d0b934:	e28e381f 	add	r3, lr, #2031616	; 0x1f0000
33d0b938:	e1570003 	cmp	r7, r3
33d0b93c:	eaffffa0 	b	33d0b7c4 <Load_nknb0_to_flash+0xbc>
33d0b940:	e3a04000 	mov	r4, #0	; 0x0
33d0b944:	eb00001d 	bl	33d0b9c0 <TOC_Read>
33d0b948:	e3a01001 	mov	r1, #1	; 0x1
33d0b94c:	e1a02004 	mov	r2, r4
33d0b950:	e1a03004 	mov	r3, r4
33d0b954:	e1a00004 	mov	r0, r4
33d0b958:	e58d4000 	str	r4, [sp]
33d0b95c:	eb0000aa 	bl	33d0bc0c <TOC_Init>
33d0b960:	e59fc04c 	ldr	ip, [pc, #76]	; 33d0b9b4 <Load_nknb0_to_flash+0x2ac>
33d0b964:	e59d3018 	ldr	r3, [sp, #24]
33d0b968:	e3a01002 	mov	r1, #2	; 0x2
33d0b96c:	e59f2044 	ldr	r2, [pc, #68]	; 33d0b9b8 <Load_nknb0_to_flash+0x2b0>
33d0b970:	e3a00001 	mov	r0, #1	; 0x1
33d0b974:	e58dc000 	str	ip, [sp]
33d0b978:	eb0000a3 	bl	33d0bc0c <TOC_Init>
33d0b97c:	eb00005c 	bl	33d0baf4 <TOC_Write>
33d0b980:	e31000ff 	tst	r0, #255	; 0xff
33d0b984:	159f0030 	ldrne	r0, [pc, #48]	; 33d0b9bc <Load_nknb0_to_flash+0x2b4>
33d0b988:	1b002d8e 	blne	33d16fc8 <printf>
33d0b98c:	e1a00004 	mov	r0, r4
33d0b990:	e28dd078 	add	sp, sp, #120	; 0x78
33d0b994:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0b998:	33d2ddbc 	.word	0x33d2ddbc
33d0b99c:	33d39920 	.word	0x33d39920
33d0b9a0:	33d26b70 	.word	0x33d26b70
33d0b9a4:	33d26c08 	.word	0x33d26c08
33d0b9a8:	33d26c44 	.word	0x33d26c44
33d0b9ac:	33d26bac 	.word	0x33d26bac
33d0b9b0:	33d26c58 	.word	0x33d26c58
33d0b9b4:	8c201000 	.word	0x8c201000
33d0b9b8:	8c200000 	.word	0x8c200000
33d0b9bc:	33d26c68 	.word	0x33d26c68

33d0b9c0 <TOC_Read>:
33d0b9c0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d0b9c4:	e59f30b0 	ldr	r3, [pc, #176]	; 33d0ba7c <TOC_Read+0xbc>
33d0b9c8:	e5933000 	ldr	r3, [r3]
33d0b9cc:	e59f40ac 	ldr	r4, [pc, #172]	; 33d0ba80 <TOC_Read+0xc0>
33d0b9d0:	e0832103 	add	r2, r3, r3, lsl #2
33d0b9d4:	e24ddf67 	sub	sp, sp, #412	; 0x19c
33d0b9d8:	e0833182 	add	r3, r3, r2, lsl #3
33d0b9dc:	e0844183 	add	r4, r4, r3, lsl #3
33d0b9e0:	e28d600c 	add	r6, sp, #12	; 0xc
33d0b9e4:	e284502c 	add	r5, r4, #44	; 0x2c
33d0b9e8:	e28d70d4 	add	r7, sp, #212	; 0xd4
33d0b9ec:	e1a00006 	mov	r0, r6
33d0b9f0:	e3a01000 	mov	r1, #0	; 0x0
33d0b9f4:	e3a020c8 	mov	r2, #200	; 0xc8
33d0b9f8:	eb003a65 	bl	33d1a394 <memset>
33d0b9fc:	e1a01005 	mov	r1, r5
33d0ba00:	e3a020c8 	mov	r2, #200	; 0xc8
33d0ba04:	e1a00007 	mov	r0, r7
33d0ba08:	eb003a75 	bl	33d1a3e4 <memcpy>
33d0ba0c:	e1a01006 	mov	r1, r6
33d0ba10:	e3a020c8 	mov	r2, #200	; 0xc8
33d0ba14:	e1a00005 	mov	r0, r5
33d0ba18:	e59f6064 	ldr	r6, [pc, #100]	; 33d0ba84 <TOC_Read+0xc4>
33d0ba1c:	eb003a70 	bl	33d1a3e4 <memcpy>
33d0ba20:	e28d3008 	add	r3, sp, #8	; 0x8
33d0ba24:	e3a02000 	mov	r2, #0	; 0x0
33d0ba28:	e3a01913 	mov	r1, #311296	; 0x4c000
33d0ba2c:	e88d0048 	stm	sp, {r3, r6}
33d0ba30:	e3a03c02 	mov	r3, #512	; 0x200
33d0ba34:	e1a00004 	mov	r0, r4
33d0ba38:	e1a0e00f 	mov	lr, pc
33d0ba3c:	e594f10c 	ldr	pc, [r4, #268]
33d0ba40:	e1a00005 	mov	r0, r5
33d0ba44:	e1a01007 	mov	r1, r7
33d0ba48:	e3a020c8 	mov	r2, #200	; 0xc8
33d0ba4c:	eb003a64 	bl	33d1a3e4 <memcpy>
33d0ba50:	e59d3008 	ldr	r3, [sp, #8]
33d0ba54:	e3530c02 	cmp	r3, #512	; 0x200
33d0ba58:	e3a000ff 	mov	r0, #255	; 0xff
33d0ba5c:	1a000004 	bne	33d0ba74 <TOC_Read+0xb4>
33d0ba60:	e5962000 	ldr	r2, [r6]
33d0ba64:	e59f301c 	ldr	r3, [pc, #28]	; 33d0ba88 <TOC_Read+0xc8>
33d0ba68:	e1520003 	cmp	r2, r3
33d0ba6c:	13a000ff 	movne	r0, #255	; 0xff
33d0ba70:	03a00000 	moveq	r0, #0	; 0x0
33d0ba74:	e28ddf67 	add	sp, sp, #412	; 0x19c
33d0ba78:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0ba7c:	33d2ddbc 	.word	0x33d2ddbc
33d0ba80:	33d39920 	.word	0x33d39920
33d0ba84:	33d60484 	.word	0x33d60484
33d0ba88:	434f544e 	.word	0x434f544e

33d0ba8c <TOC_Erase>:
33d0ba8c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0ba90:	e59f3050 	ldr	r3, [pc, #80]	; 33d0bae8 <TOC_Erase+0x5c>
33d0ba94:	e5933000 	ldr	r3, [r3]
33d0ba98:	e0832103 	add	r2, r3, r3, lsl #2
33d0ba9c:	e0833182 	add	r3, r3, r2, lsl #3
33d0baa0:	e59f2044 	ldr	r2, [pc, #68]	; 33d0baec <TOC_Erase+0x60>
33d0baa4:	e082c183 	add	ip, r2, r3, lsl #3
33d0baa8:	e24dd030 	sub	sp, sp, #48	; 0x30
33d0baac:	e25c0000 	subs	r0, ip, #0	; 0x0
33d0bab0:	e1a0100d 	mov	r1, sp
33d0bab4:	0a000006 	beq	33d0bad4 <TOC_Erase+0x48>
33d0bab8:	e59c300c 	ldr	r3, [ip, #12]
33d0babc:	e3a02913 	mov	r2, #311296	; 0x4c000
33d0bac0:	e98d000c 	stmib	sp, {r2, r3}
33d0bac4:	e1a0e00f 	mov	lr, pc
33d0bac8:	e59cf100 	ldr	pc, [ip, #256]
33d0bacc:	e3500000 	cmp	r0, #0	; 0x0
33d0bad0:	0a000002 	beq	33d0bae0 <TOC_Erase+0x54>
33d0bad4:	e59f0014 	ldr	r0, [pc, #20]	; 33d0baf0 <TOC_Erase+0x64>
33d0bad8:	eb002d3a 	bl	33d16fc8 <printf>
33d0badc:	e3a000ff 	mov	r0, #255	; 0xff
33d0bae0:	e28dd030 	add	sp, sp, #48	; 0x30
33d0bae4:	e8bd8000 	pop	{pc}
33d0bae8:	33d2ddbc 	.word	0x33d2ddbc
33d0baec:	33d39920 	.word	0x33d39920
33d0baf0:	33d26c80 	.word	0x33d26c80

33d0baf4 <TOC_Write>:
33d0baf4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d0baf8:	e59f30f8 	ldr	r3, [pc, #248]	; 33d0bbf8 <TOC_Write+0x104>
33d0bafc:	e5932000 	ldr	r2, [r3]
33d0bb00:	e59f60f4 	ldr	r6, [pc, #244]	; 33d0bbfc <TOC_Write+0x108>
33d0bb04:	e0823102 	add	r3, r2, r2, lsl #2
33d0bb08:	e596c000 	ldr	ip, [r6]
33d0bb0c:	e0822183 	add	r2, r2, r3, lsl #3
33d0bb10:	e59f30e8 	ldr	r3, [pc, #232]	; 33d0bc00 <TOC_Write+0x10c>
33d0bb14:	e15c0003 	cmp	ip, r3
33d0bb18:	e59f30e4 	ldr	r3, [pc, #228]	; 33d0bc04 <TOC_Write+0x110>
33d0bb1c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
33d0bb20:	e59f00e0 	ldr	r0, [pc, #224]	; 33d0bc08 <TOC_Write+0x114>
33d0bb24:	e1a0100c 	mov	r1, ip
33d0bb28:	e0835182 	add	r5, r3, r2, lsl #3
33d0bb2c:	0a000002 	beq	33d0bb3c <TOC_Write+0x48>
33d0bb30:	eb002d24 	bl	33d16fc8 <printf>
33d0bb34:	e3a0c0ff 	mov	ip, #255	; 0xff
33d0bb38:	ea00002b 	b	33d0bbec <TOC_Write+0xf8>
33d0bb3c:	ebffffd2 	bl	33d0ba8c <TOC_Erase>
33d0bb40:	e1a0c000 	mov	ip, r0
33d0bb44:	e21c40ff 	ands	r4, ip, #255	; 0xff
33d0bb48:	e3a02000 	mov	r2, #0	; 0x0
33d0bb4c:	e3a01913 	mov	r1, #311296	; 0x4c000
33d0bb50:	e3a03c02 	mov	r3, #512	; 0x200
33d0bb54:	e28d7010 	add	r7, sp, #16	; 0x10
33d0bb58:	e28da01c 	add	sl, sp, #28	; 0x1c
33d0bb5c:	e1a00005 	mov	r0, r5
33d0bb60:	e3a0c0ff 	mov	ip, #255	; 0xff
33d0bb64:	1a000020 	bne	33d0bbec <TOC_Write+0xf8>
33d0bb68:	e3a0c003 	mov	ip, #3	; 0x3
33d0bb6c:	e5cdc018 	strb	ip, [sp, #24]
33d0bb70:	e28dc00c 	add	ip, sp, #12	; 0xc
33d0bb74:	e98d1040 	stmib	sp, {r6, ip}
33d0bb78:	e58d4014 	str	r4, [sp, #20]
33d0bb7c:	e5cd4019 	strb	r4, [sp, #25]
33d0bb80:	e1cd41ba 	strh	r4, [sp, #26]
33d0bb84:	e58d7000 	str	r7, [sp]
33d0bb88:	ebffea49 	bl	33d064b4 <nand_write_calmecc>
33d0bb8c:	e28d1014 	add	r1, sp, #20	; 0x14
33d0bb90:	e3a02008 	mov	r2, #8	; 0x8
33d0bb94:	e1a0000a 	mov	r0, sl
33d0bb98:	eb003a11 	bl	33d1a3e4 <memcpy>
33d0bb9c:	e59d100c 	ldr	r1, [sp, #12]
33d0bba0:	e3e02000 	mvn	r2, #0	; 0x0
33d0bba4:	e1a00821 	lsr	r0, r1, #16
33d0bba8:	e1a03421 	lsr	r3, r1, #8
33d0bbac:	e5cd3025 	strb	r3, [sp, #37]
33d0bbb0:	e5cd0026 	strb	r0, [sp, #38]
33d0bbb4:	e5cd202b 	strb	r2, [sp, #43]
33d0bbb8:	e5cd1024 	strb	r1, [sp, #36]
33d0bbbc:	e5cd2027 	strb	r2, [sp, #39]
33d0bbc0:	e5cd2028 	strb	r2, [sp, #40]
33d0bbc4:	e5cd2029 	strb	r2, [sp, #41]
33d0bbc8:	e5cd202a 	strb	r2, [sp, #42]
33d0bbcc:	e88d0480 	stm	sp, {r7, sl}
33d0bbd0:	e1a00005 	mov	r0, r5
33d0bbd4:	e3a02000 	mov	r2, #0	; 0x0
33d0bbd8:	e3a01913 	mov	r1, #311296	; 0x4c000
33d0bbdc:	e3a03010 	mov	r3, #16	; 0x10
33d0bbe0:	e1a0e00f 	mov	lr, pc
33d0bbe4:	e595f120 	ldr	pc, [r5, #288]
33d0bbe8:	e1a0c004 	mov	ip, r4
33d0bbec:	e1a0000c 	mov	r0, ip
33d0bbf0:	e28dd02c 	add	sp, sp, #44	; 0x2c
33d0bbf4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0bbf8:	33d2ddbc 	.word	0x33d2ddbc
33d0bbfc:	33d60484 	.word	0x33d60484
33d0bc00:	434f544e 	.word	0x434f544e
33d0bc04:	33d39920 	.word	0x33d39920
33d0bc08:	33d26c8c 	.word	0x33d26c8c

33d0bc0c <TOC_Init>:
33d0bc0c:	e3510002 	cmp	r1, #2	; 0x2
33d0bc10:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0bc14:	e1a06001 	mov	r6, r1
33d0bc18:	e1a05000 	mov	r5, r0
33d0bc1c:	e1a0b002 	mov	fp, r2
33d0bc20:	e1a09003 	mov	r9, r3
33d0bc24:	0a000008 	beq	33d0bc4c <TOC_Init+0x40>
33d0bc28:	8a000002 	bhi	33d0bc38 <TOC_Init+0x2c>
33d0bc2c:	e3510001 	cmp	r1, #1	; 0x1
33d0bc30:	0a000003 	beq	33d0bc44 <TOC_Init+0x38>
33d0bc34:	ea000008 	b	33d0bc5c <TOC_Init+0x50>
33d0bc38:	e3510006 	cmp	r1, #6	; 0x6
33d0bc3c:	0a000004 	beq	33d0bc54 <TOC_Init+0x48>
33d0bc40:	ea000005 	b	33d0bc5c <TOC_Init+0x50>
33d0bc44:	e59f7134 	ldr	r7, [pc, #308]	; 33d0bd80 <TOC_Init+0x174>
33d0bc48:	ea000008 	b	33d0bc70 <TOC_Init+0x64>
33d0bc4c:	e59f7130 	ldr	r7, [pc, #304]	; 33d0bd84 <TOC_Init+0x178>
33d0bc50:	ea000006 	b	33d0bc70 <TOC_Init+0x64>
33d0bc54:	e59f712c 	ldr	r7, [pc, #300]	; 33d0bd88 <TOC_Init+0x17c>
33d0bc58:	ea000004 	b	33d0bc70 <TOC_Init+0x64>
33d0bc5c:	e59f0128 	ldr	r0, [pc, #296]	; 33d0bd8c <TOC_Init+0x180>
33d0bc60:	e1a01006 	mov	r1, r6
33d0bc64:	eb002cd7 	bl	33d16fc8 <printf>
33d0bc68:	e3a000ff 	mov	r0, #255	; 0xff
33d0bc6c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0bc70:	e59f4118 	ldr	r4, [pc, #280]	; 33d0bd90 <TOC_Init+0x184>
33d0bc74:	e59fa118 	ldr	sl, [pc, #280]	; 33d0bd94 <TOC_Init+0x188>
33d0bc78:	e5943000 	ldr	r3, [r4]
33d0bc7c:	e153000a 	cmp	r3, sl
33d0bc80:	0a000004 	beq	33d0bc98 <TOC_Init+0x8c>
33d0bc84:	e1a00004 	mov	r0, r4
33d0bc88:	e3a01000 	mov	r1, #0	; 0x0
33d0bc8c:	e3a02c02 	mov	r2, #512	; 0x200
33d0bc90:	eb0039bf 	bl	33d1a394 <memset>
33d0bc94:	e584a000 	str	sl, [r4]
33d0bc98:	e3550000 	cmp	r5, #0	; 0x0
33d0bc9c:	1a000012 	bne	33d0bcec <TOC_Init+0xe0>
33d0bca0:	e59f30f0 	ldr	r3, [pc, #240]	; 33d0bd98 <TOC_Init+0x18c>
33d0bca4:	e5843020 	str	r3, [r4, #32]
33d0bca8:	e59f30d0 	ldr	r3, [pc, #208]	; 33d0bd80 <TOC_Init+0x174>
33d0bcac:	e59f10e8 	ldr	r1, [pc, #232]	; 33d0bd9c <TOC_Init+0x190>
33d0bcb0:	e3a0200b 	mov	r2, #11	; 0xb
33d0bcb4:	e2840028 	add	r0, r4, #40	; 0x28
33d0bcb8:	e5843024 	str	r3, [r4, #36]
33d0bcbc:	eb0039c8 	bl	33d1a3e4 <memcpy>
33d0bcc0:	e59f20d8 	ldr	r2, [pc, #216]	; 33d0bda0 <TOC_Init+0x194>
33d0bcc4:	e3a03002 	mov	r3, #2	; 0x2
33d0bcc8:	e3a01c01 	mov	r1, #256	; 0x100
33d0bccc:	e5843038 	str	r3, [r4, #56]
33d0bcd0:	e3a03d0a 	mov	r3, #640	; 0x280
33d0bcd4:	e584104c 	str	r1, [r4, #76]
33d0bcd8:	e5842044 	str	r2, [r4, #68]
33d0bcdc:	e5843048 	str	r3, [r4, #72]
33d0bce0:	e5842040 	str	r2, [r4, #64]
33d0bce4:	e584103c 	str	r1, [r4, #60]
33d0bce8:	ea000022 	b	33d0bd78 <TOC_Init+0x16c>
33d0bcec:	e1a0a105 	lsl	sl, r5, #2
33d0bcf0:	e08a3005 	add	r3, sl, r5
33d0bcf4:	e0653183 	rsb	r3, r5, r3, lsl #3
33d0bcf8:	e1a00103 	lsl	r0, r3, #2
33d0bcfc:	e59f3080 	ldr	r3, [pc, #128]	; 33d0bd84 <TOC_Init+0x178>
33d0bd00:	e0802004 	add	r2, r0, r4
33d0bd04:	e1570003 	cmp	r7, r3
33d0bd08:	e3a03001 	mov	r3, #1	; 0x1
33d0bd0c:	e5823020 	str	r3, [r2, #32]
33d0bd10:	e2843028 	add	r3, r4, #40	; 0x28
33d0bd14:	00800003 	addeq	r0, r0, r3
33d0bd18:	059f1084 	ldreq	r1, [pc, #132]	; 33d0bda4 <TOC_Init+0x198>
33d0bd1c:	10800003 	addne	r0, r0, r3
33d0bd20:	159f1080 	ldrne	r1, [pc, #128]	; 33d0bda8 <TOC_Init+0x19c>
33d0bd24:	e5827024 	str	r7, [r2, #36]
33d0bd28:	e3a02008 	mov	r2, #8	; 0x8
33d0bd2c:	eb0039ac 	bl	33d1a3e4 <memcpy>
33d0bd30:	e1a01b89 	lsl	r1, r9, #23
33d0bd34:	e08a3005 	add	r3, sl, r5
33d0bd38:	e1a01ba1 	lsr	r1, r1, #23
33d0bd3c:	e0653183 	rsb	r3, r5, r3, lsl #3
33d0bd40:	e2511000 	subs	r1, r1, #0	; 0x0
33d0bd44:	13a01001 	movne	r1, #1	; 0x1
33d0bd48:	e0843103 	add	r3, r4, r3, lsl #2
33d0bd4c:	e08114a9 	add	r1, r1, r9, lsr #9
33d0bd50:	e583104c 	str	r1, [r3, #76]
33d0bd54:	e5836038 	str	r6, [r3, #56]
33d0bd58:	e583b040 	str	fp, [r3, #64]
33d0bd5c:	e59d2020 	ldr	r2, [sp, #32]
33d0bd60:	e5832044 	str	r2, [r3, #68]
33d0bd64:	e3a02000 	mov	r2, #0	; 0x0
33d0bd68:	e58320b8 	str	r2, [r3, #184]
33d0bd6c:	e2822d3e 	add	r2, r2, #3968	; 0xf80
33d0bd70:	e5832048 	str	r2, [r3, #72]
33d0bd74:	e583103c 	str	r1, [r3, #60]
33d0bd78:	e3a00000 	mov	r0, #0	; 0x0
33d0bd7c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0bd80:	45424f54 	.word	0x45424f54
33d0bd84:	43465348 	.word	0x43465348
33d0bd88:	43465349 	.word	0x43465349
33d0bd8c:	33d26cbc 	.word	0x33d26cbc
33d0bd90:	33d60484 	.word	0x33d60484
33d0bd94:	434f544e 	.word	0x434f544e
33d0bd98:	00010002 	.word	0x00010002
33d0bd9c:	33d26cec 	.word	0x33d26cec
33d0bda0:	8c038000 	.word	0x8c038000
33d0bda4:	33d26cf8 	.word	0x33d26cf8
33d0bda8:	33d26d00 	.word	0x33d26d00

33d0bdac <ID_Print>:
33d0bdac:	e3a01000 	mov	r1, #0	; 0x0
33d0bdb0:	e0803100 	add	r3, r0, r0, lsl #2
33d0bdb4:	e0603183 	rsb	r3, r0, r3, lsl #3
33d0bdb8:	e1a03103 	lsl	r3, r3, #2
33d0bdbc:	e59f2020 	ldr	r2, [pc, #32]	; 33d0bde4 <ID_Print+0x38>
33d0bdc0:	e0833181 	add	r3, r3, r1, lsl #3
33d0bdc4:	e0833002 	add	r3, r3, r2
33d0bdc8:	e593304c 	ldr	r3, [r3, #76]
33d0bdcc:	e3530000 	cmp	r3, #0	; 0x0
33d0bdd0:	e2811001 	add	r1, r1, #1	; 0x1
33d0bdd4:	01a0f00e 	moveq	pc, lr
33d0bdd8:	e351000d 	cmp	r1, #13	; 0xd
33d0bddc:	9afffff3 	bls	33d0bdb0 <ID_Print+0x4>
33d0bde0:	e1a0f00e 	mov	pc, lr
33d0bde4:	33d60484 	.word	0x33d60484

33d0bde8 <TOC_Print>:
33d0bde8:	e92d4030 	push	{r4, r5, lr}
33d0bdec:	e59f5048 	ldr	r5, [pc, #72]	; 33d0be3c <TOC_Print+0x54>
33d0bdf0:	e3a04000 	mov	r4, #0	; 0x0
33d0bdf4:	e3550000 	cmp	r5, #0	; 0x0
33d0bdf8:	e1a00004 	mov	r0, r4
33d0bdfc:	e2844001 	add	r4, r4, #1	; 0x1
33d0be00:	08bd8030 	popeq	{r4, r5, pc}
33d0be04:	e5951004 	ldr	r1, [r5, #4]
33d0be08:	e59f2030 	ldr	r2, [pc, #48]	; 33d0be40 <TOC_Print+0x58>
33d0be0c:	e59f3030 	ldr	r3, [pc, #48]	; 33d0be44 <TOC_Print+0x5c>
33d0be10:	e1510002 	cmp	r1, r2
33d0be14:	11510003 	cmpne	r1, r3
33d0be18:	e285509c 	add	r5, r5, #156	; 0x9c
33d0be1c:	0a000002 	beq	33d0be2c <TOC_Print+0x44>
33d0be20:	e2833001 	add	r3, r3, #1	; 0x1
33d0be24:	e1510003 	cmp	r1, r3
33d0be28:	18bd8030 	popne	{r4, r5, pc}
33d0be2c:	ebffffde 	bl	33d0bdac <ID_Print>
33d0be30:	e3540002 	cmp	r4, #2	; 0x2
33d0be34:	daffffee 	ble	33d0bdf4 <TOC_Print+0xc>
33d0be38:	e8bd8030 	pop	{r4, r5, pc}
33d0be3c:	33d604a4 	.word	0x33d604a4
33d0be40:	45424f54 	.word	0x45424f54
33d0be44:	43465348 	.word	0x43465348

33d0be48 <ReadImageFromNand>:
33d0be48:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0be4c:	e59f32f0 	ldr	r3, [pc, #752]	; 33d0c144 <ReadImageFromNand+0x2fc>
33d0be50:	e593c000 	ldr	ip, [r3]
33d0be54:	e24ddf76 	sub	sp, sp, #472	; 0x1d8
33d0be58:	e08c310c 	add	r3, ip, ip, lsl #2
33d0be5c:	e08cc183 	add	ip, ip, r3, lsl #3
33d0be60:	e28d4048 	add	r4, sp, #72	; 0x48
33d0be64:	e59f32dc 	ldr	r3, [pc, #732]	; 33d0c148 <ReadImageFromNand+0x300>
33d0be68:	e1a0e000 	mov	lr, r0
33d0be6c:	e3a01000 	mov	r1, #0	; 0x0
33d0be70:	e20ee0ff 	and	lr, lr, #255	; 0xff
33d0be74:	e3a020c8 	mov	r2, #200	; 0xc8
33d0be78:	e1a00004 	mov	r0, r4
33d0be7c:	e083718c 	add	r7, r3, ip, lsl #3
33d0be80:	e58de024 	str	lr, [sp, #36]
33d0be84:	eb003942 	bl	33d1a394 <memset>
33d0be88:	e3a03010 	mov	r3, #16	; 0x10
33d0be8c:	e3a0e000 	mov	lr, #0	; 0x0
33d0be90:	e58d3030 	str	r3, [sp, #48]
33d0be94:	e28d3038 	add	r3, sp, #56	; 0x38
33d0be98:	e58de02c 	str	lr, [sp, #44]
33d0be9c:	e58d3034 	str	r3, [sp, #52]
33d0bea0:	e597313c 	ldr	r3, [r7, #316]
33d0bea4:	e283106c 	add	r1, r3, #108	; 0x6c
33d0bea8:	e8111002 	ldmda	r1, {r1, ip}
33d0beac:	e04cc001 	sub	ip, ip, r1
33d0beb0:	e287202c 	add	r2, r7, #44	; 0x2c
33d0beb4:	e3a03001 	mov	r3, #1	; 0x1
33d0beb8:	e1a03c13 	lsl	r3, r3, ip
33d0bebc:	e1a01002 	mov	r1, r2
33d0bec0:	e58d2010 	str	r2, [sp, #16]
33d0bec4:	e28d0e11 	add	r0, sp, #272	; 0x110
33d0bec8:	e3a020c8 	mov	r2, #200	; 0xc8
33d0becc:	e58d301c 	str	r3, [sp, #28]
33d0bed0:	e58de018 	str	lr, [sp, #24]
33d0bed4:	e59f5270 	ldr	r5, [pc, #624]	; 33d0c14c <ReadImageFromNand+0x304>
33d0bed8:	eb003941 	bl	33d1a3e4 <memcpy>
33d0bedc:	e1a01004 	mov	r1, r4
33d0bee0:	e3a020c8 	mov	r2, #200	; 0xc8
33d0bee4:	e59d0010 	ldr	r0, [sp, #16]
33d0bee8:	eb00393d 	bl	33d1a3e4 <memcpy>
33d0beec:	e28d3028 	add	r3, sp, #40	; 0x28
33d0bef0:	e88d0028 	stm	sp, {r3, r5}
33d0bef4:	e3a03c02 	mov	r3, #512	; 0x200
33d0bef8:	e1a00007 	mov	r0, r7
33d0befc:	e3a02000 	mov	r2, #0	; 0x0
33d0bf00:	e3a01913 	mov	r1, #311296	; 0x4c000
33d0bf04:	e1a0e00f 	mov	lr, pc
33d0bf08:	e597f10c 	ldr	pc, [r7, #268]
33d0bf0c:	e59d3028 	ldr	r3, [sp, #40]
33d0bf10:	e3530c02 	cmp	r3, #512	; 0x200
33d0bf14:	1a000083 	bne	33d0c128 <ReadImageFromNand+0x2e0>
33d0bf18:	e59d1024 	ldr	r1, [sp, #36]
33d0bf1c:	e59f222c 	ldr	r2, [pc, #556]	; 33d0c150 <ReadImageFromNand+0x308>
33d0bf20:	e5953000 	ldr	r3, [r5]
33d0bf24:	e0533002 	subs	r3, r3, r2
33d0bf28:	13a03001 	movne	r3, #1	; 0x1
33d0bf2c:	e3510002 	cmp	r1, #2	; 0x2
33d0bf30:	13a03000 	movne	r3, #0	; 0x0
33d0bf34:	e251b001 	subs	fp, r1, #1	; 0x1
33d0bf38:	13a0b001 	movne	fp, #1	; 0x1
33d0bf3c:	e3530000 	cmp	r3, #0	; 0x0
33d0bf40:	11a02001 	movne	r2, r1
33d0bf44:	159f0208 	ldrne	r0, [pc, #520]	; 33d0c154 <ReadImageFromNand+0x30c>
33d0bf48:	1a000018 	bne	33d0bfb0 <ReadImageFromNand+0x168>
33d0bf4c:	e59d2024 	ldr	r2, [sp, #36]
33d0bf50:	e3520001 	cmp	r2, #1	; 0x1
33d0bf54:	1a00000d 	bne	33d0bf90 <ReadImageFromNand+0x148>
33d0bf58:	e59f31f8 	ldr	r3, [pc, #504]	; 33d0c158 <ReadImageFromNand+0x310>
33d0bf5c:	e5853020 	str	r3, [r5, #32]
33d0bf60:	e59f31f4 	ldr	r3, [pc, #500]	; 33d0c15c <ReadImageFromNand+0x314>
33d0bf64:	e59f21f4 	ldr	r2, [pc, #500]	; 33d0c160 <ReadImageFromNand+0x318>
33d0bf68:	e5853024 	str	r3, [r5, #36]
33d0bf6c:	e3a03002 	mov	r3, #2	; 0x2
33d0bf70:	e3a01c01 	mov	r1, #256	; 0x100
33d0bf74:	e5853038 	str	r3, [r5, #56]
33d0bf78:	e3a03d0a 	mov	r3, #640	; 0x280
33d0bf7c:	e5852044 	str	r2, [r5, #68]
33d0bf80:	e5853048 	str	r3, [r5, #72]
33d0bf84:	e585104c 	str	r1, [r5, #76]
33d0bf88:	e5852040 	str	r2, [r5, #64]
33d0bf8c:	e585103c 	str	r1, [r5, #60]
33d0bf90:	e35b0000 	cmp	fp, #0	; 0x0
33d0bf94:	13a0309c 	movne	r3, #156	; 0x9c
33d0bf98:	03a03000 	moveq	r3, #0	; 0x0
33d0bf9c:	e0831005 	add	r1, r3, r5
33d0bfa0:	e5912038 	ldr	r2, [r1, #56]
33d0bfa4:	e3120002 	tst	r2, #2	; 0x2
33d0bfa8:	1a000003 	bne	33d0bfbc <ReadImageFromNand+0x174>
33d0bfac:	e59f01b0 	ldr	r0, [pc, #432]	; 33d0c164 <ReadImageFromNand+0x31c>
33d0bfb0:	e59f11b0 	ldr	r1, [pc, #432]	; 33d0c168 <ReadImageFromNand+0x320>
33d0bfb4:	eb002c03 	bl	33d16fc8 <printf>
33d0bfb8:	ea00005a 	b	33d0c128 <ReadImageFromNand+0x2e0>
33d0bfbc:	e5912044 	ldr	r2, [r1, #68]
33d0bfc0:	e5913040 	ldr	r3, [r1, #64]
33d0bfc4:	e3520000 	cmp	r2, #0	; 0x0
33d0bfc8:	e2839329 	add	r9, r3, #-1543503872	; 0xa4000000
33d0bfcc:	e59f3198 	ldr	r3, [pc, #408]	; 33d0c16c <ReadImageFromNand+0x324>
33d0bfd0:	12822329 	addne	r2, r2, #-1543503872	; 0xa4000000
33d0bfd4:	01a02009 	moveq	r2, r9
33d0bfd8:	e591a03c 	ldr	sl, [r1, #60]
33d0bfdc:	e5832000 	str	r2, [r3]
33d0bfe0:	e3a03000 	mov	r3, #0	; 0x0
33d0bfe4:	e58d3020 	str	r3, [sp, #32]
33d0bfe8:	e35a0000 	cmp	sl, #0	; 0x0
33d0bfec:	0a00004d 	beq	33d0c128 <ReadImageFromNand+0x2e0>
33d0bff0:	e59d1020 	ldr	r1, [sp, #32]
33d0bff4:	e35b0000 	cmp	fp, #0	; 0x0
33d0bff8:	e1a01181 	lsl	r1, r1, #3
33d0bffc:	13a03027 	movne	r3, #39	; 0x27
33d0c000:	03a03000 	moveq	r3, #0	; 0x0
33d0c004:	e59f2140 	ldr	r2, [pc, #320]	; 33d0c14c <ReadImageFromNand+0x304>
33d0c008:	e58d100c 	str	r1, [sp, #12]
33d0c00c:	e0813103 	add	r3, r1, r3, lsl #2
33d0c010:	e0833002 	add	r3, r3, r2
33d0c014:	e1a0110b 	lsl	r1, fp, #2
33d0c018:	e593604c 	ldr	r6, [r3, #76]
33d0c01c:	e58d1008 	str	r1, [sp, #8]
33d0c020:	e5934048 	ldr	r4, [r3, #72]
33d0c024:	e58d6014 	str	r6, [sp, #20]
33d0c028:	e3560000 	cmp	r6, #0	; 0x0
33d0c02c:	0a00002a 	beq	33d0c0dc <ReadImageFromNand+0x294>
33d0c030:	e59d2024 	ldr	r2, [sp, #36]
33d0c034:	e3520001 	cmp	r2, #1	; 0x1
33d0c038:	0a00000b 	beq	33d0c06c <ReadImageFromNand+0x224>
33d0c03c:	e1a01484 	lsl	r1, r4, #9
33d0c040:	e3a02000 	mov	r2, #0	; 0x0
33d0c044:	e1a00007 	mov	r0, r7
33d0c048:	e1a0e00f 	mov	lr, pc
33d0c04c:	e597f134 	ldr	pc, [r7, #308]
33d0c050:	e3500000 	cmp	r0, #0	; 0x0
33d0c054:	0a000004 	beq	33d0c06c <ReadImageFromNand+0x224>
33d0c058:	e59d3024 	ldr	r3, [sp, #36]
33d0c05c:	e59d101c 	ldr	r1, [sp, #28]
33d0c060:	e3530001 	cmp	r3, #1	; 0x1
33d0c064:	e0844001 	add	r4, r4, r1
33d0c068:	eafffff2 	b	33d0c038 <ReadImageFromNand+0x1f0>
33d0c06c:	e59d2018 	ldr	r2, [sp, #24]
33d0c070:	e2822001 	add	r2, r2, #1	; 0x1
33d0c074:	e1a01002 	mov	r1, r2
33d0c078:	e59d0014 	ldr	r0, [sp, #20]
33d0c07c:	e58d2018 	str	r2, [sp, #24]
33d0c080:	ebfff3a5 	bl	33d08f1c <drawProcessBar>
33d0c084:	e1a01484 	lsl	r1, r4, #9
33d0c088:	e28d3028 	add	r3, sp, #40	; 0x28
33d0c08c:	e88d0208 	stm	sp, {r3, r9}
33d0c090:	e3a03c02 	mov	r3, #512	; 0x200
33d0c094:	e3a02000 	mov	r2, #0	; 0x0
33d0c098:	e1a00007 	mov	r0, r7
33d0c09c:	e1a0e00f 	mov	lr, pc
33d0c0a0:	e597f10c 	ldr	pc, [r7, #268]
33d0c0a4:	e59d3028 	ldr	r3, [sp, #40]
33d0c0a8:	e2845001 	add	r5, r4, #1	; 0x1
33d0c0ac:	e3530c02 	cmp	r3, #512	; 0x200
33d0c0b0:	01a04005 	moveq	r4, r5
33d0c0b4:	02466001 	subeq	r6, r6, #1	; 0x1
33d0c0b8:	02899c02 	addeq	r9, r9, #512	; 0x200
33d0c0bc:	0a000004 	beq	33d0c0d4 <ReadImageFromNand+0x28c>
33d0c0c0:	e1a01004 	mov	r1, r4
33d0c0c4:	e1a02000 	mov	r2, r0
33d0c0c8:	e59f00a0 	ldr	r0, [pc, #160]	; 33d0c170 <ReadImageFromNand+0x328>
33d0c0cc:	eb002bbd 	bl	33d16fc8 <printf>
33d0c0d0:	e1a04005 	mov	r4, r5
33d0c0d4:	e3560000 	cmp	r6, #0	; 0x0
33d0c0d8:	eaffffd3 	b	33d0c02c <ReadImageFromNand+0x1e4>
33d0c0dc:	e28d1008 	add	r1, sp, #8	; 0x8
33d0c0e0:	e8910006 	ldm	r1, {r1, r2}
33d0c0e4:	e081300b 	add	r3, r1, fp
33d0c0e8:	e06b3183 	rsb	r3, fp, r3, lsl #3
33d0c0ec:	e59f1058 	ldr	r1, [pc, #88]	; 33d0c14c <ReadImageFromNand+0x304>
33d0c0f0:	e0823103 	add	r3, r2, r3, lsl #2
33d0c0f4:	e0833001 	add	r3, r3, r1
33d0c0f8:	e593304c 	ldr	r3, [r3, #76]
33d0c0fc:	e59d2020 	ldr	r2, [sp, #32]
33d0c100:	e05aa003 	subs	sl, sl, r3
33d0c104:	03a03000 	moveq	r3, #0	; 0x0
33d0c108:	13a03001 	movne	r3, #1	; 0x1
33d0c10c:	e2822001 	add	r2, r2, #1	; 0x1
33d0c110:	e352000d 	cmp	r2, #13	; 0xd
33d0c114:	83a03000 	movhi	r3, #0	; 0x0
33d0c118:	92033001 	andls	r3, r3, #1	; 0x1
33d0c11c:	e3530000 	cmp	r3, #0	; 0x0
33d0c120:	e58d2020 	str	r2, [sp, #32]
33d0c124:	eaffffb0 	b	33d0bfec <ReadImageFromNand+0x1a4>
33d0c128:	e59d0010 	ldr	r0, [sp, #16]
33d0c12c:	e28d1e11 	add	r1, sp, #272	; 0x110
33d0c130:	e3a020c8 	mov	r2, #200	; 0xc8
33d0c134:	eb0038aa 	bl	33d1a3e4 <memcpy>
33d0c138:	e3a00000 	mov	r0, #0	; 0x0
33d0c13c:	e28ddf76 	add	sp, sp, #472	; 0x1d8
33d0c140:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0c144:	33d2ddbc 	.word	0x33d2ddbc
33d0c148:	33d39920 	.word	0x33d39920
33d0c14c:	33d60484 	.word	0x33d60484
33d0c150:	434f544e 	.word	0x434f544e
33d0c154:	33d26d08 	.word	0x33d26d08
33d0c158:	00010002 	.word	0x00010002
33d0c15c:	45424f54 	.word	0x45424f54
33d0c160:	8c038000 	.word	0x8c038000
33d0c164:	33d26d28 	.word	0x33d26d28
33d0c168:	33d249b4 	.word	0x33d249b4
33d0c16c:	33d60480 	.word	0x33d60480
33d0c170:	33d26d4c 	.word	0x33d26d4c

33d0c174 <GetLauchAddrFrmRam>:
33d0c174:	e59f301c 	ldr	r3, [pc, #28]	; 33d0c198 <GetLauchAddrFrmRam+0x24>
33d0c178:	e5931000 	ldr	r1, [r3]
33d0c17c:	e59f3018 	ldr	r3, [pc, #24]	; 33d0c19c <GetLauchAddrFrmRam+0x28>
33d0c180:	e5912000 	ldr	r2, [r1]
33d0c184:	e1520003 	cmp	r2, r3
33d0c188:	059131b0 	ldreq	r3, [r1, #432]
33d0c18c:	e3a00000 	mov	r0, #0	; 0x0
33d0c190:	02830329 	addeq	r0, r3, #-1543503872	; 0xa4000000
33d0c194:	e1a0f00e 	mov	pc, lr
33d0c198:	33d35fd8 	.word	0x33d35fd8
33d0c19c:	12345678 	.word	0x12345678

33d0c1a0 <OEMReadData>:
33d0c1a0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d0c1a4:	e3a06000 	mov	r6, #0	; 0x0
33d0c1a8:	e1a07000 	mov	r7, r0
33d0c1ac:	e1560000 	cmp	r6, r0
33d0c1b0:	e1a0a001 	mov	sl, r1
33d0c1b4:	2a00002e 	bcs	33d0c274 <OEMReadData+0xd4>
33d0c1b8:	e59f0128 	ldr	r0, [pc, #296]	; 33d0c2e8 <OEMReadData+0x148>
33d0c1bc:	e59f4128 	ldr	r4, [pc, #296]	; 33d0c2ec <OEMReadData+0x14c>
33d0c1c0:	e5902000 	ldr	r2, [r0]
33d0c1c4:	e5943000 	ldr	r3, [r4]
33d0c1c8:	e1520003 	cmp	r2, r3
33d0c1cc:	1a000016 	bne	33d0c22c <OEMReadData+0x8c>
33d0c1d0:	e59f5118 	ldr	r5, [pc, #280]	; 33d0c2f0 <OEMReadData+0x150>
33d0c1d4:	e5953000 	ldr	r3, [r5]
33d0c1d8:	e3530000 	cmp	r3, #0	; 0x0
33d0c1dc:	e59f1110 	ldr	r1, [pc, #272]	; 33d0c2f4 <OEMReadData+0x154>
33d0c1e0:	0afffff4 	beq	33d0c1b8 <OEMReadData+0x18>
33d0c1e4:	e5900000 	ldr	r0, [r0]
33d0c1e8:	e5943000 	ldr	r3, [r4]
33d0c1ec:	e5912000 	ldr	r2, [r1]
33d0c1f0:	e0630000 	rsb	r0, r3, r0
33d0c1f4:	e0800002 	add	r0, r0, r2
33d0c1f8:	e5911000 	ldr	r1, [r1]
33d0c1fc:	e2400001 	sub	r0, r0, #1	; 0x1
33d0c200:	eb0049a6 	bl	33d1e8a0 <__umodsi3>
33d0c204:	e59f10ec 	ldr	r1, [pc, #236]	; 33d0c2f8 <OEMReadData+0x158>
33d0c208:	e5913000 	ldr	r3, [r1]
33d0c20c:	e1500003 	cmp	r0, r3
33d0c210:	3affffe8 	bcc	33d0c1b8 <OEMReadData+0x18>
33d0c214:	e3a03000 	mov	r3, #0	; 0x0
33d0c218:	e5853000 	str	r3, [r5]
33d0c21c:	e5940000 	ldr	r0, [r4]
33d0c220:	e5911000 	ldr	r1, [r1]
33d0c224:	ebfffc1c 	bl	33d0b29c <ConfigEp3DmaMode>
33d0c228:	eaffffe2 	b	33d0c1b8 <OEMReadData+0x18>
33d0c22c:	e59f40b4 	ldr	r4, [pc, #180]	; 33d0c2e8 <OEMReadData+0x148>
33d0c230:	e5943000 	ldr	r3, [r4]
33d0c234:	e5d33000 	ldrb	r3, [r3]
33d0c238:	e59f50bc 	ldr	r5, [pc, #188]	; 33d0c2fc <OEMReadData+0x15c>
33d0c23c:	e7ca3006 	strb	r3, [sl, r6]
33d0c240:	e5940000 	ldr	r0, [r4]
33d0c244:	e5952000 	ldr	r2, [r5]
33d0c248:	e59f30a4 	ldr	r3, [pc, #164]	; 33d0c2f4 <OEMReadData+0x154>
33d0c24c:	e0620000 	rsb	r0, r2, r0
33d0c250:	e5931000 	ldr	r1, [r3]
33d0c254:	e2800001 	add	r0, r0, #1	; 0x1
33d0c258:	eb004990 	bl	33d1e8a0 <__umodsi3>
33d0c25c:	e5953000 	ldr	r3, [r5]
33d0c260:	e2866001 	add	r6, r6, #1	; 0x1
33d0c264:	e0800003 	add	r0, r0, r3
33d0c268:	e1560007 	cmp	r6, r7
33d0c26c:	e5840000 	str	r0, [r4]
33d0c270:	eaffffcf 	b	33d0c1b4 <OEMReadData+0x14>
33d0c274:	e59f5074 	ldr	r5, [pc, #116]	; 33d0c2f0 <OEMReadData+0x150>
33d0c278:	e5953000 	ldr	r3, [r5]
33d0c27c:	e3530000 	cmp	r3, #0	; 0x0
33d0c280:	0a000012 	beq	33d0c2d0 <OEMReadData+0x130>
33d0c284:	e59f305c 	ldr	r3, [pc, #92]	; 33d0c2e8 <OEMReadData+0x148>
33d0c288:	e59f405c 	ldr	r4, [pc, #92]	; 33d0c2ec <OEMReadData+0x14c>
33d0c28c:	e59f1060 	ldr	r1, [pc, #96]	; 33d0c2f4 <OEMReadData+0x154>
33d0c290:	e5930000 	ldr	r0, [r3]
33d0c294:	e5943000 	ldr	r3, [r4]
33d0c298:	e5912000 	ldr	r2, [r1]
33d0c29c:	e0630000 	rsb	r0, r3, r0
33d0c2a0:	e0800002 	add	r0, r0, r2
33d0c2a4:	e5911000 	ldr	r1, [r1]
33d0c2a8:	e2400001 	sub	r0, r0, #1	; 0x1
33d0c2ac:	eb00497b 	bl	33d1e8a0 <__umodsi3>
33d0c2b0:	e59f1040 	ldr	r1, [pc, #64]	; 33d0c2f8 <OEMReadData+0x158>
33d0c2b4:	e5913000 	ldr	r3, [r1]
33d0c2b8:	e1500003 	cmp	r0, r3
33d0c2bc:	23a03000 	movcs	r3, #0	; 0x0
33d0c2c0:	25853000 	strcs	r3, [r5]
33d0c2c4:	25940000 	ldrcs	r0, [r4]
33d0c2c8:	25911000 	ldrcs	r1, [r1]
33d0c2cc:	2bfffbf2 	blcs	33d0b29c <ConfigEp3DmaMode>
33d0c2d0:	e59f2028 	ldr	r2, [pc, #40]	; 33d0c300 <OEMReadData+0x160>
33d0c2d4:	e5923000 	ldr	r3, [r2]
33d0c2d8:	e3a00001 	mov	r0, #1	; 0x1
33d0c2dc:	e0833007 	add	r3, r3, r7
33d0c2e0:	e5823000 	str	r3, [r2]
33d0c2e4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0c2e8:	33d60440 	.word	0x33d60440
33d0c2ec:	33d60444 	.word	0x33d60444
33d0c2f0:	33d6044c 	.word	0x33d6044c
33d0c2f4:	33d60454 	.word	0x33d60454
33d0c2f8:	33d60448 	.word	0x33d60448
33d0c2fc:	33d60450 	.word	0x33d60450
33d0c300:	33d60684 	.word	0x33d60684

33d0c304 <OEMMapMemAddr>:
33d0c304:	e2810329 	add	r0, r1, #-1543503872	; 0xa4000000
33d0c308:	e1a0f00e 	mov	pc, lr

33d0c30c <VerifyChecksum>:
33d0c30c:	e92d4030 	push	{r4, r5, lr}
33d0c310:	e3a04000 	mov	r4, #0	; 0x0
33d0c314:	e1a05002 	mov	r5, r2
33d0c318:	e1540000 	cmp	r4, r0
33d0c31c:	e1a02004 	mov	r2, r4
33d0c320:	2a000004 	bcs	33d0c338 <VerifyChecksum+0x2c>
33d0c324:	e4d13001 	ldrb	r3, [r1], #1
33d0c328:	e2822001 	add	r2, r2, #1	; 0x1
33d0c32c:	e1520000 	cmp	r2, r0
33d0c330:	e0844003 	add	r4, r4, r3
33d0c334:	eafffff9 	b	33d0c320 <VerifyChecksum+0x14>
33d0c338:	e1540005 	cmp	r4, r5
33d0c33c:	159f0018 	ldrne	r0, [pc, #24]	; 33d0c35c <VerifyChecksum+0x50>
33d0c340:	11a01005 	movne	r1, r5
33d0c344:	11a02004 	movne	r2, r4
33d0c348:	1b002b1e 	blne	33d16fc8 <printf>
33d0c34c:	e1540005 	cmp	r4, r5
33d0c350:	13a00000 	movne	r0, #0	; 0x0
33d0c354:	03a00001 	moveq	r0, #1	; 0x1
33d0c358:	e8bd8030 	pop	{r4, r5, pc}
33d0c35c:	33d26d7c 	.word	0x33d26d7c

33d0c360 <OEMVerifyMemory>:
33d0c360:	e59f307c 	ldr	r3, [pc, #124]	; 33d0c3e4 <OEMVerifyMemory+0x84>
33d0c364:	e1500003 	cmp	r0, r3
33d0c368:	e0803001 	add	r3, r0, r1
33d0c36c:	e59f2074 	ldr	r2, [pc, #116]	; 33d0c3e8 <OEMVerifyMemory+0x88>
33d0c370:	e243c001 	sub	ip, r3, #1	; 0x1
33d0c374:	9a000005 	bls	33d0c390 <OEMVerifyMemory+0x30>
33d0c378:	e59f306c 	ldr	r3, [pc, #108]	; 33d0c3ec <OEMVerifyMemory+0x8c>
33d0c37c:	e15c0003 	cmp	ip, r3
33d0c380:	91a03002 	movls	r3, r2
33d0c384:	95932000 	ldrls	r2, [r3]
33d0c388:	93a03001 	movls	r3, #1	; 0x1
33d0c38c:	9a000011 	bls	33d0c3d8 <OEMVerifyMemory+0x78>
33d0c390:	e592c000 	ldr	ip, [r2]
33d0c394:	e59c30d0 	ldr	r3, [ip, #208]
33d0c398:	e3530001 	cmp	r3, #1	; 0x1
33d0c39c:	83a0300e 	movhi	r3, #14	; 0xe
33d0c3a0:	8a000008 	bhi	33d0c3c8 <OEMVerifyMemory+0x68>
33d0c3a4:	e0803001 	add	r3, r0, r1
33d0c3a8:	e2431001 	sub	r1, r3, #1	; 0x1
33d0c3ac:	e59f303c 	ldr	r3, [pc, #60]	; 33d0c3f0 <OEMVerifyMemory+0x90>
33d0c3b0:	e1500003 	cmp	r0, r3
33d0c3b4:	9a000005 	bls	33d0c3d0 <OEMVerifyMemory+0x70>
33d0c3b8:	e2833401 	add	r3, r3, #16777216	; 0x1000000
33d0c3bc:	e1510003 	cmp	r1, r3
33d0c3c0:	8a000002 	bhi	33d0c3d0 <OEMVerifyMemory+0x70>
33d0c3c4:	e3a03002 	mov	r3, #2	; 0x2
33d0c3c8:	e58c31a0 	str	r3, [ip, #416]
33d0c3cc:	ea000002 	b	33d0c3dc <OEMVerifyMemory+0x7c>
33d0c3d0:	e5922000 	ldr	r2, [r2]
33d0c3d4:	e3a03006 	mov	r3, #6	; 0x6
33d0c3d8:	e58231a0 	str	r3, [r2, #416]
33d0c3dc:	e3a00001 	mov	r0, #1	; 0x1
33d0c3e0:	e1a0f00e 	mov	pc, lr
33d0c3e4:	8c037fff 	.word	0x8c037fff
33d0c3e8:	33d35fd8 	.word	0x33d35fd8
33d0c3ec:	8c057fff 	.word	0x8c057fff
33d0c3f0:	8c0fffff 	.word	0x8c0fffff

33d0c3f4 <OEMMultiBINNotify>:
33d0c3f4:	e2501000 	subs	r1, r0, #0	; 0x0
33d0c3f8:	e92d4010 	push	{r4, lr}
33d0c3fc:	08bd8010 	popeq	{r4, pc}
33d0c400:	e5913000 	ldr	r3, [r1]
33d0c404:	e3530000 	cmp	r3, #0	; 0x0
33d0c408:	08bd8010 	popeq	{r4, pc}
33d0c40c:	e59fe07c 	ldr	lr, [pc, #124]	; 33d0c490 <OEMMultiBINNotify+0x9c>
33d0c410:	e5913004 	ldr	r3, [r1, #4]
33d0c414:	e59e2000 	ldr	r2, [lr]
33d0c418:	e582319c 	str	r3, [r2, #412]
33d0c41c:	e5913000 	ldr	r3, [r1]
33d0c420:	e3a0c000 	mov	ip, #0	; 0x0
33d0c424:	e15c0003 	cmp	ip, r3
33d0c428:	2a000012 	bcs	33d0c478 <OEMMultiBINNotify+0x84>
33d0c42c:	e59e0000 	ldr	r0, [lr]
33d0c430:	e081318c 	add	r3, r1, ip, lsl #3
33d0c434:	e5932004 	ldr	r2, [r3, #4]
33d0c438:	e590319c 	ldr	r3, [r0, #412]
33d0c43c:	e1520003 	cmp	r2, r3
33d0c440:	e28c4001 	add	r4, ip, #1	; 0x1
33d0c444:	2a000008 	bcs	33d0c46c <OEMMultiBINNotify+0x78>
33d0c448:	e580219c 	str	r2, [r0, #412]
33d0c44c:	e59e3000 	ldr	r3, [lr]
33d0c450:	e593319c 	ldr	r3, [r3, #412]
33d0c454:	e3530000 	cmp	r3, #0	; 0x0
33d0c458:	1a000003 	bne	33d0c46c <OEMMultiBINNotify+0x78>
33d0c45c:	e59f0030 	ldr	r0, [pc, #48]	; 33d0c494 <OEMMultiBINNotify+0xa0>
33d0c460:	e1a0100c 	mov	r1, ip
33d0c464:	e8bd4010 	pop	{r4, lr}
33d0c468:	ea002ad6 	b	33d16fc8 <printf>
33d0c46c:	e5913000 	ldr	r3, [r1]
33d0c470:	e204c0ff 	and	ip, r4, #255	; 0xff
33d0c474:	eaffffea 	b	33d0c424 <OEMMultiBINNotify+0x30>
33d0c478:	e59f3010 	ldr	r3, [pc, #16]	; 33d0c490 <OEMMultiBINNotify+0x9c>
33d0c47c:	e5930000 	ldr	r0, [r3]
33d0c480:	e3a020cc 	mov	r2, #204	; 0xcc
33d0c484:	e28000d0 	add	r0, r0, #208	; 0xd0
33d0c488:	e8bd4010 	pop	{r4, lr}
33d0c48c:	ea0037d4 	b	33d1a3e4 <memcpy>
33d0c490:	33d35fd8 	.word	0x33d35fd8
33d0c494:	33d26db8 	.word	0x33d26db8

33d0c498 <ExtractImgFrmUSBBuf>:
33d0c498:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0c49c:	e59f3444 	ldr	r3, [pc, #1092]	; 33d0c8e8 <ExtractImgFrmUSBBuf+0x450>
33d0c4a0:	e5934000 	ldr	r4, [r3]
33d0c4a4:	e3a07000 	mov	r7, #0	; 0x0
33d0c4a8:	e24dd034 	sub	sp, sp, #52	; 0x34
33d0c4ac:	e3a02f6d 	mov	r2, #436	; 0x1b4
33d0c4b0:	e1a00004 	mov	r0, r4
33d0c4b4:	e1a01007 	mov	r1, r7
33d0c4b8:	eb0037b5 	bl	33d1a394 <memset>
33d0c4bc:	e59f3428 	ldr	r3, [pc, #1064]	; 33d0c8ec <ExtractImgFrmUSBBuf+0x454>
33d0c4c0:	e58471a8 	str	r7, [r4, #424]
33d0c4c4:	e58471b0 	str	r7, [r4, #432]
33d0c4c8:	e58471ac 	str	r7, [r4, #428]
33d0c4cc:	e2842f6a 	add	r2, r4, #424	; 0x1a8
33d0c4d0:	e5837000 	str	r7, [r3]
33d0c4d4:	e2843f6b 	add	r3, r4, #428	; 0x1ac
33d0c4d8:	e58d2014 	str	r2, [sp, #20]
33d0c4dc:	e58d3010 	str	r3, [sp, #16]
33d0c4e0:	e284be1b 	add	fp, r4, #432	; 0x1b0
33d0c4e4:	e3a09001 	mov	r9, #1	; 0x1
33d0c4e8:	e3a0a601 	mov	sl, #1048576	; 0x100000
33d0c4ec:	e28d602c 	add	r6, sp, #44	; 0x2c
33d0c4f0:	e3a00007 	mov	r0, #7	; 0x7
33d0c4f4:	e1a01006 	mov	r1, r6
33d0c4f8:	ebffff28 	bl	33d0c1a0 <OEMReadData>
33d0c4fc:	e21050ff 	ands	r5, r0, #255	; 0xff
33d0c500:	059f03e8 	ldreq	r0, [pc, #1000]	; 33d0c8f0 <ExtractImgFrmUSBBuf+0x458>
33d0c504:	0a00000b 	beq	33d0c538 <ExtractImgFrmUSBBuf+0xa0>
33d0c508:	e1a00006 	mov	r0, r6
33d0c50c:	e59f13e0 	ldr	r1, [pc, #992]	; 33d0c8f4 <ExtractImgFrmUSBBuf+0x45c>
33d0c510:	e3a02007 	mov	r2, #7	; 0x7
33d0c514:	eb0037d4 	bl	33d1a46c <memcmp>
33d0c518:	e2504000 	subs	r4, r0, #0	; 0x0
33d0c51c:	1a00002a 	bne	33d0c5cc <ExtractImgFrmUSBBuf+0x134>
33d0c520:	e2800004 	add	r0, r0, #4	; 0x4
33d0c524:	e28d1028 	add	r1, sp, #40	; 0x28
33d0c528:	ebffff1c 	bl	33d0c1a0 <OEMReadData>
33d0c52c:	e21050ff 	ands	r5, r0, #255	; 0xff
33d0c530:	1a000002 	bne	33d0c540 <ExtractImgFrmUSBBuf+0xa8>
33d0c534:	e59f03bc 	ldr	r0, [pc, #956]	; 33d0c8f8 <ExtractImgFrmUSBBuf+0x460>
33d0c538:	eb002aa2 	bl	33d16fc8 <printf>
33d0c53c:	ea0000ae 	b	33d0c7fc <ExtractImgFrmUSBBuf+0x364>
33d0c540:	e59f63a0 	ldr	r6, [pc, #928]	; 33d0c8e8 <ExtractImgFrmUSBBuf+0x450>
33d0c544:	e5961000 	ldr	r1, [r6]
33d0c548:	e3a00004 	mov	r0, #4	; 0x4
33d0c54c:	e2811004 	add	r1, r1, #4	; 0x4
33d0c550:	ebffff12 	bl	33d0c1a0 <OEMReadData>
33d0c554:	e31000ff 	tst	r0, #255	; 0xff
33d0c558:	0a000006 	beq	33d0c578 <ExtractImgFrmUSBBuf+0xe0>
33d0c55c:	e5961000 	ldr	r1, [r6]
33d0c560:	e5910004 	ldr	r0, [r1, #4]
33d0c564:	e2811008 	add	r1, r1, #8	; 0x8
33d0c568:	e1a00180 	lsl	r0, r0, #3
33d0c56c:	ebffff0b 	bl	33d0c1a0 <OEMReadData>
33d0c570:	e31000ff 	tst	r0, #255	; 0xff
33d0c574:	1a000003 	bne	33d0c588 <ExtractImgFrmUSBBuf+0xf0>
33d0c578:	e59f037c 	ldr	r0, [pc, #892]	; 33d0c8fc <ExtractImgFrmUSBBuf+0x464>
33d0c57c:	eb002a91 	bl	33d16fc8 <printf>
33d0c580:	e1a00004 	mov	r0, r4
33d0c584:	ea0000d5 	b	33d0c8e0 <ExtractImgFrmUSBBuf+0x448>
33d0c588:	e5961000 	ldr	r1, [r6]
33d0c58c:	e5910004 	ldr	r0, [r1, #4]
33d0c590:	e59d2028 	ldr	r2, [sp, #40]
33d0c594:	e2811008 	add	r1, r1, #8	; 0x8
33d0c598:	e1a00180 	lsl	r0, r0, #3
33d0c59c:	ebffff5a 	bl	33d0c30c <VerifyChecksum>
33d0c5a0:	e21050ff 	ands	r5, r0, #255	; 0xff
33d0c5a4:	059f0354 	ldreq	r0, [pc, #852]	; 33d0c900 <ExtractImgFrmUSBBuf+0x468>
33d0c5a8:	0affffe2 	beq	33d0c538 <ExtractImgFrmUSBBuf+0xa0>
33d0c5ac:	e5960000 	ldr	r0, [r6]
33d0c5b0:	e2800004 	add	r0, r0, #4	; 0x4
33d0c5b4:	ebffff8e 	bl	33d0c3f4 <OEMMultiBINNotify>
33d0c5b8:	e5963000 	ldr	r3, [r6]
33d0c5bc:	e5933004 	ldr	r3, [r3, #4]
33d0c5c0:	e2833001 	add	r3, r3, #1	; 0x1
33d0c5c4:	e20390ff 	and	r9, r3, #255	; 0xff
33d0c5c8:	ea0000bc 	b	33d0c8c0 <ExtractImgFrmUSBBuf+0x428>
33d0c5cc:	e1a00006 	mov	r0, r6
33d0c5d0:	e59f132c 	ldr	r1, [pc, #812]	; 33d0c904 <ExtractImgFrmUSBBuf+0x46c>
33d0c5d4:	e3a02007 	mov	r2, #7	; 0x7
33d0c5d8:	eb0037a3 	bl	33d1a46c <memcmp>
33d0c5dc:	e2505000 	subs	r5, r0, #0	; 0x0
33d0c5e0:	0a00000d 	beq	33d0c61c <ExtractImgFrmUSBBuf+0x184>
33d0c5e4:	e5ddc02f 	ldrb	ip, [sp, #47]
33d0c5e8:	e5dde030 	ldrb	lr, [sp, #48]
33d0c5ec:	e5dd4031 	ldrb	r4, [sp, #49]
33d0c5f0:	e5dd5032 	ldrb	r5, [sp, #50]
33d0c5f4:	e59f030c 	ldr	r0, [pc, #780]	; 33d0c908 <ExtractImgFrmUSBBuf+0x470>
33d0c5f8:	e5dd102c 	ldrb	r1, [sp, #44]
33d0c5fc:	e5dd202d 	ldrb	r2, [sp, #45]
33d0c600:	e5dd302e 	ldrb	r3, [sp, #46]
33d0c604:	e88d5000 	stm	sp, {ip, lr}
33d0c608:	e58d4008 	str	r4, [sp, #8]
33d0c60c:	e58d500c 	str	r5, [sp, #12]
33d0c610:	eb002a6c 	bl	33d16fc8 <printf>
33d0c614:	e3a00000 	mov	r0, #0	; 0x0
33d0c618:	ea0000b0 	b	33d0c8e0 <ExtractImgFrmUSBBuf+0x448>
33d0c61c:	e3a00004 	mov	r0, #4	; 0x4
33d0c620:	e28d1024 	add	r1, sp, #36	; 0x24
33d0c624:	ebfffedd 	bl	33d0c1a0 <OEMReadData>
33d0c628:	e31000ff 	tst	r0, #255	; 0xff
33d0c62c:	0a000004 	beq	33d0c644 <ExtractImgFrmUSBBuf+0x1ac>
33d0c630:	e3a00004 	mov	r0, #4	; 0x4
33d0c634:	e28d1020 	add	r1, sp, #32	; 0x20
33d0c638:	ebfffed8 	bl	33d0c1a0 <OEMReadData>
33d0c63c:	e31000ff 	tst	r0, #255	; 0xff
33d0c640:	1a000001 	bne	33d0c64c <ExtractImgFrmUSBBuf+0x1b4>
33d0c644:	e59f02c0 	ldr	r0, [pc, #704]	; 33d0c90c <ExtractImgFrmUSBBuf+0x474>
33d0c648:	eaffffba 	b	33d0c538 <ExtractImgFrmUSBBuf+0xa0>
33d0c64c:	e59f4294 	ldr	r4, [pc, #660]	; 33d0c8e8 <ExtractImgFrmUSBBuf+0x450>
33d0c650:	e5942000 	ldr	r2, [r4]
33d0c654:	e5923004 	ldr	r3, [r2, #4]
33d0c658:	e3530000 	cmp	r3, #0	; 0x0
33d0c65c:	1a00000a 	bne	33d0c68c <ExtractImgFrmUSBBuf+0x1f4>
33d0c660:	e2833001 	add	r3, r3, #1	; 0x1
33d0c664:	e5823004 	str	r3, [r2, #4]
33d0c668:	e59d3024 	ldr	r3, [sp, #36]
33d0c66c:	e5942000 	ldr	r2, [r4]
33d0c670:	e5823008 	str	r3, [r2, #8]
33d0c674:	e59d3020 	ldr	r3, [sp, #32]
33d0c678:	e5942000 	ldr	r2, [r4]
33d0c67c:	e582300c 	str	r3, [r2, #12]
33d0c680:	e5940000 	ldr	r0, [r4]
33d0c684:	e2800004 	add	r0, r0, #4	; 0x4
33d0c688:	ebffff59 	bl	33d0c3f4 <OEMMultiBINNotify>
33d0c68c:	e59d0024 	ldr	r0, [sp, #36]
33d0c690:	e59d1020 	ldr	r1, [sp, #32]
33d0c694:	ebffff31 	bl	33d0c360 <OEMVerifyMemory>
33d0c698:	e21050ff 	ands	r5, r0, #255	; 0xff
33d0c69c:	1a000078 	bne	33d0c884 <ExtractImgFrmUSBBuf+0x3ec>
33d0c6a0:	e59f0268 	ldr	r0, [pc, #616]	; 33d0c910 <ExtractImgFrmUSBBuf+0x478>
33d0c6a4:	eaffffa3 	b	33d0c538 <ExtractImgFrmUSBBuf+0xa0>
33d0c6a8:	e59d101c 	ldr	r1, [sp, #28]
33d0c6ac:	e3510000 	cmp	r1, #0	; 0x0
33d0c6b0:	1a000039 	bne	33d0c79c <ExtractImgFrmUSBBuf+0x304>
33d0c6b4:	e59d2028 	ldr	r2, [sp, #40]
33d0c6b8:	e3520000 	cmp	r2, #0	; 0x0
33d0c6bc:	1a000036 	bne	33d0c79c <ExtractImgFrmUSBBuf+0x304>
33d0c6c0:	e28d3020 	add	r3, sp, #32	; 0x20
33d0c6c4:	e8930018 	ldm	r3, {r3, r4}
33d0c6c8:	e3530000 	cmp	r3, #0	; 0x0
33d0c6cc:	13540000 	cmpne	r4, #0	; 0x0
33d0c6d0:	13a05000 	movne	r5, #0	; 0x0
33d0c6d4:	03a05001 	moveq	r5, #1	; 0x1
33d0c6d8:	01a03002 	moveq	r3, r2
33d0c6dc:	0a000023 	beq	33d0c770 <ExtractImgFrmUSBBuf+0x2d8>
33d0c6e0:	e1a00004 	mov	r0, r4
33d0c6e4:	e2841040 	add	r1, r4, #64	; 0x40
33d0c6e8:	ebffff05 	bl	33d0c304 <OEMMapMemAddr>
33d0c6ec:	e59f3220 	ldr	r3, [pc, #544]	; 33d0c914 <ExtractImgFrmUSBBuf+0x47c>
33d0c6f0:	e5902000 	ldr	r2, [r0]
33d0c6f4:	e1520003 	cmp	r2, r3
33d0c6f8:	1a000008 	bne	33d0c720 <ExtractImgFrmUSBBuf+0x288>
33d0c6fc:	e2841044 	add	r1, r4, #68	; 0x44
33d0c700:	e1a00004 	mov	r0, r4
33d0c704:	ebfffefe 	bl	33d0c304 <OEMMapMemAddr>
33d0c708:	e5901000 	ldr	r1, [r0]
33d0c70c:	e1a00004 	mov	r0, r4
33d0c710:	ebfffefb 	bl	33d0c304 <OEMMapMemAddr>
33d0c714:	e5905010 	ldr	r5, [r0, #16]
33d0c718:	e3550000 	cmp	r5, #0	; 0x0
33d0c71c:	1a000003 	bne	33d0c730 <ExtractImgFrmUSBBuf+0x298>
33d0c720:	e1a03005 	mov	r3, r5
33d0c724:	ea000011 	b	33d0c770 <ExtractImgFrmUSBBuf+0x2d8>
33d0c728:	e3a03001 	mov	r3, #1	; 0x1
33d0c72c:	ea00000f 	b	33d0c770 <ExtractImgFrmUSBBuf+0x2d8>
33d0c730:	e2455001 	sub	r5, r5, #1	; 0x1
33d0c734:	e3750001 	cmn	r5, #1	; 0x1
33d0c738:	e2806054 	add	r6, r0, #84	; 0x54
33d0c73c:	0a00000a 	beq	33d0c76c <ExtractImgFrmUSBBuf+0x2d4>
33d0c740:	e5961010 	ldr	r1, [r6, #16]
33d0c744:	e1a00004 	mov	r0, r4
33d0c748:	ebfffeed 	bl	33d0c304 <OEMMapMemAddr>
33d0c74c:	e59f11c4 	ldr	r1, [pc, #452]	; 33d0c918 <ExtractImgFrmUSBBuf+0x480>
33d0c750:	eb003644 	bl	33d1a068 <strcmp>
33d0c754:	e3500000 	cmp	r0, #0	; 0x0
33d0c758:	e2455001 	sub	r5, r5, #1	; 0x1
33d0c75c:	e2866020 	add	r6, r6, #32	; 0x20
33d0c760:	0afffff0 	beq	33d0c728 <ExtractImgFrmUSBBuf+0x290>
33d0c764:	e3750001 	cmn	r5, #1	; 0x1
33d0c768:	eafffff3 	b	33d0c73c <ExtractImgFrmUSBBuf+0x2a4>
33d0c76c:	e3a03000 	mov	r3, #0	; 0x0
33d0c770:	e31300ff 	tst	r3, #255	; 0xff
33d0c774:	0a000051 	beq	33d0c8c0 <ExtractImgFrmUSBBuf+0x428>
33d0c778:	e59d3024 	ldr	r3, [sp, #36]
33d0c77c:	e59d2014 	ldr	r2, [sp, #20]
33d0c780:	e5823000 	str	r3, [r2]
33d0c784:	e59d3020 	ldr	r3, [sp, #32]
33d0c788:	e59d2010 	ldr	r2, [sp, #16]
33d0c78c:	e5823000 	str	r3, [r2]
33d0c790:	e59d3018 	ldr	r3, [sp, #24]
33d0c794:	e58b3000 	str	r3, [fp]
33d0c798:	ea000048 	b	33d0c8c0 <ExtractImgFrmUSBBuf+0x428>
33d0c79c:	e59d0024 	ldr	r0, [sp, #36]
33d0c7a0:	ebfffed7 	bl	33d0c304 <OEMMapMemAddr>
33d0c7a4:	e1a01000 	mov	r1, r0
33d0c7a8:	e1a06000 	mov	r6, r0
33d0c7ac:	e59d0018 	ldr	r0, [sp, #24]
33d0c7b0:	ebfffe7a 	bl	33d0c1a0 <OEMReadData>
33d0c7b4:	e21050ff 	ands	r5, r0, #255	; 0xff
33d0c7b8:	059f015c 	ldreq	r0, [pc, #348]	; 33d0c91c <ExtractImgFrmUSBBuf+0x484>
33d0c7bc:	01a01007 	moveq	r1, r7
33d0c7c0:	0a00000c 	beq	33d0c7f8 <ExtractImgFrmUSBBuf+0x360>
33d0c7c4:	e59f3120 	ldr	r3, [pc, #288]	; 33d0c8ec <ExtractImgFrmUSBBuf+0x454>
33d0c7c8:	e5933000 	ldr	r3, [r3]
33d0c7cc:	e153000a 	cmp	r3, sl
33d0c7d0:	828aa601 	addhi	sl, sl, #1048576	; 0x100000
33d0c7d4:	8afffffc 	bhi	33d0c7cc <ExtractImgFrmUSBBuf+0x334>
33d0c7d8:	e59d0018 	ldr	r0, [sp, #24]
33d0c7dc:	e1a01006 	mov	r1, r6
33d0c7e0:	e59d2028 	ldr	r2, [sp, #40]
33d0c7e4:	ebfffec8 	bl	33d0c30c <VerifyChecksum>
33d0c7e8:	e21050ff 	ands	r5, r0, #255	; 0xff
33d0c7ec:	1a000004 	bne	33d0c804 <ExtractImgFrmUSBBuf+0x36c>
33d0c7f0:	e59f0128 	ldr	r0, [pc, #296]	; 33d0c920 <ExtractImgFrmUSBBuf+0x488>
33d0c7f4:	e1a01007 	mov	r1, r7
33d0c7f8:	eb0029f2 	bl	33d16fc8 <printf>
33d0c7fc:	e1a00005 	mov	r0, r5
33d0c800:	ea000036 	b	33d0c8e0 <ExtractImgFrmUSBBuf+0x448>
33d0c804:	e59d3018 	ldr	r3, [sp, #24]
33d0c808:	e3530054 	cmp	r3, #84	; 0x54
33d0c80c:	1a00001b 	bne	33d0c880 <ExtractImgFrmUSBBuf+0x3e8>
33d0c810:	e59d5024 	ldr	r5, [sp, #36]
33d0c814:	e1a00005 	mov	r0, r5
33d0c818:	e2851040 	add	r1, r5, #64	; 0x40
33d0c81c:	ebfffeb8 	bl	33d0c304 <OEMMapMemAddr>
33d0c820:	e59f30ec 	ldr	r3, [pc, #236]	; 33d0c914 <ExtractImgFrmUSBBuf+0x47c>
33d0c824:	e5902000 	ldr	r2, [r0]
33d0c828:	e1520003 	cmp	r2, r3
33d0c82c:	1a000013 	bne	33d0c880 <ExtractImgFrmUSBBuf+0x3e8>
33d0c830:	e2851044 	add	r1, r5, #68	; 0x44
33d0c834:	e1a00005 	mov	r0, r5
33d0c838:	ebfffeb1 	bl	33d0c304 <OEMMapMemAddr>
33d0c83c:	e59d201c 	ldr	r2, [sp, #28]
33d0c840:	e5903000 	ldr	r3, [r0]
33d0c844:	e5961008 	ldr	r1, [r6, #8]
33d0c848:	e0630002 	rsb	r0, r3, r2
33d0c84c:	e0603005 	rsb	r3, r0, r5
33d0c850:	e1510003 	cmp	r1, r3
33d0c854:	1a000009 	bne	33d0c880 <ExtractImgFrmUSBBuf+0x3e8>
33d0c858:	e59d3020 	ldr	r3, [sp, #32]
33d0c85c:	e596200c 	ldr	r2, [r6, #12]
33d0c860:	e0813003 	add	r3, r1, r3
33d0c864:	e1520003 	cmp	r2, r3
33d0c868:	1a000004 	bne	33d0c880 <ExtractImgFrmUSBBuf+0x3e8>
33d0c86c:	e1d630b0 	ldrh	r3, [r6]
33d0c870:	e5962004 	ldr	r2, [r6, #4]
33d0c874:	e1530002 	cmp	r3, r2
33d0c878:	95943000 	ldrls	r3, [r4]
33d0c87c:	958301a4 	strls	r0, [r3, #420]
33d0c880:	e2877001 	add	r7, r7, #1	; 0x1
33d0c884:	e3a00004 	mov	r0, #4	; 0x4
33d0c888:	e28d101c 	add	r1, sp, #28	; 0x1c
33d0c88c:	ebfffe43 	bl	33d0c1a0 <OEMReadData>
33d0c890:	e31000ff 	tst	r0, #255	; 0xff
33d0c894:	0a000009 	beq	33d0c8c0 <ExtractImgFrmUSBBuf+0x428>
33d0c898:	e3a00004 	mov	r0, #4	; 0x4
33d0c89c:	e28d1018 	add	r1, sp, #24	; 0x18
33d0c8a0:	ebfffe3e 	bl	33d0c1a0 <OEMReadData>
33d0c8a4:	e31000ff 	tst	r0, #255	; 0xff
33d0c8a8:	0a000004 	beq	33d0c8c0 <ExtractImgFrmUSBBuf+0x428>
33d0c8ac:	e3a00004 	mov	r0, #4	; 0x4
33d0c8b0:	e28d1028 	add	r1, sp, #40	; 0x28
33d0c8b4:	ebfffe39 	bl	33d0c1a0 <OEMReadData>
33d0c8b8:	e31000ff 	tst	r0, #255	; 0xff
33d0c8bc:	1affff79 	bne	33d0c6a8 <ExtractImgFrmUSBBuf+0x210>
33d0c8c0:	e2493001 	sub	r3, r9, #1	; 0x1
33d0c8c4:	e21390ff 	ands	r9, r3, #255	; 0xff
33d0c8c8:	1affff07 	bne	33d0c4ec <ExtractImgFrmUSBBuf+0x54>
33d0c8cc:	e59f3014 	ldr	r3, [pc, #20]	; 33d0c8e8 <ExtractImgFrmUSBBuf+0x450>
33d0c8d0:	e5932000 	ldr	r2, [r3]
33d0c8d4:	e59f3048 	ldr	r3, [pc, #72]	; 33d0c924 <ExtractImgFrmUSBBuf+0x48c>
33d0c8d8:	e5823000 	str	r3, [r2]
33d0c8dc:	e3a00001 	mov	r0, #1	; 0x1
33d0c8e0:	e28dd034 	add	sp, sp, #52	; 0x34
33d0c8e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0c8e8:	33d35fd8 	.word	0x33d35fd8
33d0c8ec:	33d60684 	.word	0x33d60684
33d0c8f0:	33d26dfc 	.word	0x33d26dfc
33d0c8f4:	33d26e20 	.word	0x33d26e20
33d0c8f8:	33d26e28 	.word	0x33d26e28
33d0c8fc:	33d26e50 	.word	0x33d26e50
33d0c900:	33d26e7c 	.word	0x33d26e7c
33d0c904:	33d26eb0 	.word	0x33d26eb0
33d0c908:	33d26eb8 	.word	0x33d26eb8
33d0c90c:	33d26eec 	.word	0x33d26eec
33d0c910:	33d26f10 	.word	0x33d26f10
33d0c914:	43454345 	.word	0x43454345
33d0c918:	33d26f34 	.word	0x33d26f34
33d0c91c:	33d26f3c 	.word	0x33d26f3c
33d0c920:	33d26f70 	.word	0x33d26f70
33d0c924:	12345678 	.word	0x12345678

33d0c928 <delete_char>:

/****************************************************************************/

#ifndef CONFIG_CMDLINE_EDITING
static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
33d0c928:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d0c92c:	e1a07003 	mov	r7, r3
	char *s;

	if (*np == 0) {
33d0c930:	e5933000 	ldr	r3, [r3]
33d0c934:	e3530000 	cmp	r3, #0	; 0x0

/****************************************************************************/

#ifndef CONFIG_CMDLINE_EDITING
static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
33d0c938:	e1a05000 	mov	r5, r0
33d0c93c:	e1a06001 	mov	r6, r1
33d0c940:	e1a04002 	mov	r4, r2
33d0c944:	e59da018 	ldr	sl, [sp, #24]
	char *s;

	if (*np == 0) {
33d0c948:	0a000029 	beq	33d0c9f4 <delete_char+0xcc>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
33d0c94c:	e5763001 	ldrb	r3, [r6, #-1]!
33d0c950:	e3530009 	cmp	r3, #9	; 0x9
33d0c954:	1a00001e 	bne	33d0c9d4 <delete_char+0xac>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
33d0c958:	e5923000 	ldr	r3, [r2]
33d0c95c:	e153000a 	cmp	r3, sl
33d0c960:	da000006 	ble	33d0c980 <delete_char+0x58>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
33d0c964:	e59f0090 	ldr	r0, [pc, #144]	; 33d0c9fc <delete_char+0xd4>
33d0c968:	eb00298f 	bl	33d16fac <puts>
			(*colp)--;
33d0c96c:	e5943000 	ldr	r3, [r4]
33d0c970:	e2433001 	sub	r3, r3, #1	; 0x1
33d0c974:	e153000a 	cmp	r3, sl
33d0c978:	e5843000 	str	r3, [r4]
33d0c97c:	eafffff7 	b	33d0c960 <delete_char+0x38>
		}
		for (s=buffer; s<p; ++s) {
33d0c980:	e1550006 	cmp	r5, r6
33d0c984:	2a000017 	bcs	33d0c9e8 <delete_char+0xc0>
			if (*s == '\t') {
33d0c988:	e5d53000 	ldrb	r3, [r5]
33d0c98c:	e5942000 	ldr	r2, [r4]
				puts (tab_seq+((*colp) & 07));
33d0c990:	e59f0068 	ldr	r0, [pc, #104]	; 33d0ca00 <delete_char+0xd8>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
33d0c994:	e3530009 	cmp	r3, #9	; 0x9
				puts (tab_seq+((*colp) & 07));
33d0c998:	e2023007 	and	r3, r2, #7	; 0x7
33d0c99c:	e0830000 	add	r0, r3, r0
				*colp += 8 - ((*colp) & 07);
			} else {
				++(*colp);
33d0c9a0:	e2822001 	add	r2, r2, #1	; 0x1
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
33d0c9a4:	1a000005 	bne	33d0c9c0 <delete_char+0x98>
				puts (tab_seq+((*colp) & 07));
33d0c9a8:	eb00297f 	bl	33d16fac <puts>
				*colp += 8 - ((*colp) & 07);
33d0c9ac:	e5943000 	ldr	r3, [r4]
33d0c9b0:	e3c33007 	bic	r3, r3, #7	; 0x7
33d0c9b4:	e2833008 	add	r3, r3, #8	; 0x8
33d0c9b8:	e5843000 	str	r3, [r4]
33d0c9bc:	ea000002 	b	33d0c9cc <delete_char+0xa4>
			} else {
				++(*colp);
33d0c9c0:	e5842000 	str	r2, [r4]
				putc (*s);
33d0c9c4:	e5d50000 	ldrb	r0, [r5]
33d0c9c8:	eb00296d 	bl	33d16f84 <putc>
	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
33d0c9cc:	e2855001 	add	r5, r5, #1	; 0x1
33d0c9d0:	eaffffea 	b	33d0c980 <delete_char+0x58>
				++(*colp);
				putc (*s);
			}
		}
	} else {
		puts (erase_seq);
33d0c9d4:	e59f0020 	ldr	r0, [pc, #32]	; 33d0c9fc <delete_char+0xd4>
33d0c9d8:	eb002973 	bl	33d16fac <puts>
		(*colp)--;
33d0c9dc:	e5943000 	ldr	r3, [r4]
33d0c9e0:	e2433001 	sub	r3, r3, #1	; 0x1
33d0c9e4:	e5843000 	str	r3, [r4]
	}
	(*np)--;
33d0c9e8:	e5973000 	ldr	r3, [r7]
33d0c9ec:	e2433001 	sub	r3, r3, #1	; 0x1
33d0c9f0:	e5873000 	str	r3, [r7]
	return (p);
}
33d0c9f4:	e1a00006 	mov	r0, r6
33d0c9f8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0c9fc:	33d35fe8 	.word	0x33d35fe8
33d0ca00:	33d35fdc 	.word	0x33d35fdc

33d0ca04 <readline>:
 * Return:	number of read characters
 *		-1 if break
 *		-2 if timed out
 */
int readline (const char *const prompt)
{
33d0ca04:	e92d40f0 	push	{r4, r5, r6, r7, lr}

	rc = cread_line(p, &len);
	return rc < 0 ? rc : len;
#else
	char   *p = console_buffer;
	int	n = 0;				/* buffer index		*/
33d0ca08:	e3a03000 	mov	r3, #0	; 0x0
 * Return:	number of read characters
 *		-1 if break
 *		-2 if timed out
 */
int readline (const char *const prompt)
{
33d0ca0c:	e24dd00c 	sub	sp, sp, #12	; 0xc
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
33d0ca10:	e2504000 	subs	r4, r0, #0	; 0x0

	rc = cread_line(p, &len);
	return rc < 0 ? rc : len;
#else
	char   *p = console_buffer;
	int	n = 0;				/* buffer index		*/
33d0ca14:	e58d3004 	str	r3, [sp, #4]
	int	plen = 0;			/* prompt length	*/
33d0ca18:	e1a06003 	mov	r6, r3
	puts (prompt);

	rc = cread_line(p, &len);
	return rc < 0 ? rc : len;
#else
	char   *p = console_buffer;
33d0ca1c:	e59f51ac 	ldr	r5, [pc, #428]	; 33d0cbd0 <readline+0x1cc>
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
33d0ca20:	0a000003 	beq	33d0ca34 <readline+0x30>
		plen = strlen (prompt);
33d0ca24:	eb0035b9 	bl	33d1a110 <strlen>
33d0ca28:	e1a06000 	mov	r6, r0
		puts (prompt);
33d0ca2c:	e1a00004 	mov	r0, r4
33d0ca30:	eb00295d 	bl	33d16fac <puts>
	}
	col = plen;
33d0ca34:	e58d6008 	str	r6, [sp, #8]
		while (!tstc()) {
			extern void show_activity(int arg);
			show_activity(0);
		}
#endif
		c = getc();
33d0ca38:	eb002945 	bl	33d16f54 <getc>
33d0ca3c:	e20040ff 	and	r4, r0, #255	; 0xff

		/*
		 * Special character handling
		 */
		switch (c) {
33d0ca40:	e354000a 	cmp	r4, #10	; 0xa
33d0ca44:	0a000013 	beq	33d0ca98 <readline+0x94>
33d0ca48:	ca000007 	bgt	33d0ca6c <readline+0x68>
33d0ca4c:	e3540003 	cmp	r4, #3	; 0x3
33d0ca50:	0a000017 	beq	33d0cab4 <readline+0xb0>
33d0ca54:	ca000002 	bgt	33d0ca64 <readline+0x60>
33d0ca58:	e3540000 	cmp	r4, #0	; 0x0
33d0ca5c:	0afffff5 	beq	33d0ca38 <readline+0x34>
33d0ca60:	ea00003d 	b	33d0cb5c <readline+0x158>
33d0ca64:	e3540008 	cmp	r4, #8	; 0x8
33d0ca68:	ea000008 	b	33d0ca90 <readline+0x8c>
33d0ca6c:	e3540015 	cmp	r4, #21	; 0x15
33d0ca70:	0a000014 	beq	33d0cac8 <readline+0xc4>
33d0ca74:	ca000002 	bgt	33d0ca84 <readline+0x80>
33d0ca78:	e354000d 	cmp	r4, #13	; 0xd
33d0ca7c:	0a000005 	beq	33d0ca98 <readline+0x94>
33d0ca80:	ea000035 	b	33d0cb5c <readline+0x158>
33d0ca84:	e3540017 	cmp	r4, #23	; 0x17
33d0ca88:	0a00001b 	beq	33d0cafc <readline+0xf8>
33d0ca8c:	e354007f 	cmp	r4, #127	; 0x7f
33d0ca90:	0a000029 	beq	33d0cb3c <readline+0x138>
33d0ca94:	ea000030 	b	33d0cb5c <readline+0x158>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
33d0ca98:	e3a03000 	mov	r3, #0	; 0x0
33d0ca9c:	e5c53000 	strb	r3, [r5]
			puts ("\r\n");
33d0caa0:	e59f012c 	ldr	r0, [pc, #300]	; 33d0cbd4 <readline+0x1d0>
33d0caa4:	eb002940 	bl	33d16fac <puts>
			return (p - console_buffer);
33d0caa8:	e59f3120 	ldr	r3, [pc, #288]	; 33d0cbd0 <readline+0x1cc>
33d0caac:	e0630005 	rsb	r0, r3, r5
33d0cab0:	ea000044 	b	33d0cbc8 <readline+0x1c4>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			console_buffer[0] = '\0';	/* discard input */
33d0cab4:	e59f3114 	ldr	r3, [pc, #276]	; 33d0cbd0 <readline+0x1cc>
33d0cab8:	e3a02000 	mov	r2, #0	; 0x0
			return (-1);
33d0cabc:	e3e00000 	mvn	r0, #0	; 0x0

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			console_buffer[0] = '\0';	/* discard input */
33d0cac0:	e5c32000 	strb	r2, [r3]
			return (-1);
33d0cac4:	ea00003f 	b	33d0cbc8 <readline+0x1c4>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
				--col;
33d0cac8:	e59d3008 	ldr	r3, [sp, #8]
33d0cacc:	e1530006 	cmp	r3, r6
33d0cad0:	da000006 	ble	33d0caf0 <readline+0xec>
			console_buffer[0] = '\0';	/* discard input */
			return (-1);

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
33d0cad4:	e59f00fc 	ldr	r0, [pc, #252]	; 33d0cbd8 <readline+0x1d4>
33d0cad8:	eb002933 	bl	33d16fac <puts>
				--col;
33d0cadc:	e59d3008 	ldr	r3, [sp, #8]
33d0cae0:	e2433001 	sub	r3, r3, #1	; 0x1
33d0cae4:	e1530006 	cmp	r3, r6
33d0cae8:	e58d3008 	str	r3, [sp, #8]
33d0caec:	eafffff7 	b	33d0cad0 <readline+0xcc>
			}
			p = console_buffer;
33d0caf0:	e59f50d8 	ldr	r5, [pc, #216]	; 33d0cbd0 <readline+0x1cc>
			n = 0;
33d0caf4:	e3a03000 	mov	r3, #0	; 0x0
33d0caf8:	ea00002d 	b	33d0cbb4 <readline+0x1b0>
			continue;

		case 0x17:				/* ^W - erase word 	*/
			p=delete_char(console_buffer, p, &col, &n, plen);
33d0cafc:	e28d7008 	add	r7, sp, #8	; 0x8
33d0cb00:	e28d4004 	add	r4, sp, #4	; 0x4
33d0cb04:	e1a01005 	mov	r1, r5
33d0cb08:	e1a03004 	mov	r3, r4
33d0cb0c:	e59f00bc 	ldr	r0, [pc, #188]	; 33d0cbd0 <readline+0x1cc>
33d0cb10:	e1a02007 	mov	r2, r7
33d0cb14:	e58d6000 	str	r6, [sp]
33d0cb18:	ebffff82 	bl	33d0c928 <delete_char>
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(console_buffer, p, &col, &n, plen);
33d0cb1c:	e59d3004 	ldr	r3, [sp, #4]
33d0cb20:	e3530000 	cmp	r3, #0	; 0x0
			p = console_buffer;
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word 	*/
			p=delete_char(console_buffer, p, &col, &n, plen);
33d0cb24:	e1a05000 	mov	r5, r0
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(console_buffer, p, &col, &n, plen);
33d0cb28:	daffffc2 	ble	33d0ca38 <readline+0x34>
33d0cb2c:	e5d03000 	ldrb	r3, [r0]
33d0cb30:	e3530020 	cmp	r3, #32	; 0x20
33d0cb34:	0affffbf 	beq	33d0ca38 <readline+0x34>
33d0cb38:	eafffff1 	b	33d0cb04 <readline+0x100>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(console_buffer, p, &col, &n, plen);
33d0cb3c:	e1a01005 	mov	r1, r5
33d0cb40:	e59f0088 	ldr	r0, [pc, #136]	; 33d0cbd0 <readline+0x1cc>
33d0cb44:	e28d2008 	add	r2, sp, #8	; 0x8
33d0cb48:	e28d3004 	add	r3, sp, #4	; 0x4
33d0cb4c:	e58d6000 	str	r6, [sp]
33d0cb50:	ebffff74 	bl	33d0c928 <delete_char>
33d0cb54:	e1a05000 	mov	r5, r0
			continue;
33d0cb58:	eaffffb6 	b	33d0ca38 <readline+0x34>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CFG_CBSIZE-2) {
33d0cb5c:	e59d3004 	ldr	r3, [sp, #4]
33d0cb60:	e35300fd 	cmp	r3, #253	; 0xfd
33d0cb64:	ca000014 	bgt	33d0cbbc <readline+0x1b8>
				if (c == '\t') {	/* expand TABs		*/
33d0cb68:	e3540009 	cmp	r4, #9	; 0x9
33d0cb6c:	e59d3008 	ldr	r3, [sp, #8]
33d0cb70:	1a000008 	bne	33d0cb98 <readline+0x194>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = console_buffer + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
33d0cb74:	e59f0060 	ldr	r0, [pc, #96]	; 33d0cbdc <readline+0x1d8>
33d0cb78:	e2033007 	and	r3, r3, #7	; 0x7
33d0cb7c:	e0830000 	add	r0, r3, r0
33d0cb80:	eb002909 	bl	33d16fac <puts>
					col += 8 - (col&07);
33d0cb84:	e59d3008 	ldr	r3, [sp, #8]
33d0cb88:	e3c33007 	bic	r3, r3, #7	; 0x7
33d0cb8c:	e2833008 	add	r3, r3, #8	; 0x8
33d0cb90:	e58d3008 	str	r3, [sp, #8]
33d0cb94:	ea000003 	b	33d0cba8 <readline+0x1a4>
				} else {
					++col;		/* echo input		*/
33d0cb98:	e2833001 	add	r3, r3, #1	; 0x1
					putc (c);
33d0cb9c:	e1a00004 	mov	r0, r4
					}
#endif
					puts (tab_seq+(col&07));
					col += 8 - (col&07);
				} else {
					++col;		/* echo input		*/
33d0cba0:	e58d3008 	str	r3, [sp, #8]
					putc (c);
33d0cba4:	eb0028f6 	bl	33d16f84 <putc>
				}
				*p++ = c;
33d0cba8:	e4c54001 	strb	r4, [r5], #1
				++n;
33d0cbac:	e59d3004 	ldr	r3, [sp, #4]
33d0cbb0:	e2833001 	add	r3, r3, #1	; 0x1
33d0cbb4:	e58d3004 	str	r3, [sp, #4]
33d0cbb8:	eaffff9e 	b	33d0ca38 <readline+0x34>
			} else {			/* Buffer full		*/
				putc ('\a');
33d0cbbc:	e3a00007 	mov	r0, #7	; 0x7
33d0cbc0:	eb0028ef 	bl	33d16f84 <putc>
		plen = strlen (prompt);
		puts (prompt);
	}
	col = plen;

	for (;;) {
33d0cbc4:	eaffff9b 	b	33d0ca38 <readline+0x34>
				putc ('\a');
			}
		}
	}
#endif /* CONFIG_CMDLINE_EDITING */
}
33d0cbc8:	e28dd00c 	add	sp, sp, #12	; 0xc
33d0cbcc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0cbd0:	33d60688 	.word	0x33d60688
33d0cbd4:	33d2bbb8 	.word	0x33d2bbb8
33d0cbd8:	33d35fe8 	.word	0x33d35fe8
33d0cbdc:	33d35fdc 	.word	0x33d35fdc

33d0cbe0 <run_command>:
 * the environment data, which may change magicly when the command we run
 * creates or modifies environment variables (like "bootp" does).
 */

int run_command (const char *cmd, int flag)
{
33d0cbe0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0cbe4:	e1a04000 	mov	r4, r0
33d0cbe8:	e24dde35 	sub	sp, sp, #848	; 0x350
33d0cbec:	e58d1008 	str	r1, [sp, #8]
	printf ("[RUN_COMMAND] cmd[%p]=\"", cmd);
	puts (cmd ? cmd : "NULL");	/* use puts - string may be loooong */
	puts ("\"\n");
#endif

	clear_ctrlc();		/* forget any previous Control C */
33d0cbf0:	eb00292d 	bl	33d170ac <clear_ctrlc>
	char *sep;			/* end of token (separator) in cmdbuf */
	char finaltoken[CFG_CBSIZE];
	char *str = cmdbuf;
	char *argv[CFG_MAXARGS + 1];	/* NULL terminated	*/
	int argc, inquotes;
	int repeatable = 1;
33d0cbf4:	e3a01001 	mov	r1, #1	; 0x1
	puts ("\"\n");
#endif

	clear_ctrlc();		/* forget any previous Control C */

	if (!cmd || !*cmd) {
33d0cbf8:	e3540000 	cmp	r4, #0	; 0x0
	cmd_tbl_t *cmdtp;
	char cmdbuf[CFG_CBSIZE];	/* working copy of cmd		*/
	char *token;			/* start of token in cmdbuf	*/
	char *sep;			/* end of token (separator) in cmdbuf */
	char finaltoken[CFG_CBSIZE];
	char *str = cmdbuf;
33d0cbfc:	e28dbe25 	add	fp, sp, #592	; 0x250
	char *argv[CFG_MAXARGS + 1];	/* NULL terminated	*/
	int argc, inquotes;
	int repeatable = 1;
33d0cc00:	e58d1004 	str	r1, [sp, #4]
	int rc = 0;
33d0cc04:	e3a09000 	mov	r9, #0	; 0x0
	puts ("\"\n");
#endif

	clear_ctrlc();		/* forget any previous Control C */

	if (!cmd || !*cmd) {
33d0cc08:	0a000008 	beq	33d0cc30 <run_command+0x50>
33d0cc0c:	e5d43000 	ldrb	r3, [r4]
33d0cc10:	e1530009 	cmp	r3, r9
33d0cc14:	0a000005 	beq	33d0cc30 <run_command+0x50>
		return -1;	/* empty command */
	}

	if (strlen(cmd) >= CFG_CBSIZE) {
33d0cc18:	e1a00004 	mov	r0, r4
33d0cc1c:	eb00353b 	bl	33d1a110 <strlen>
33d0cc20:	e35000ff 	cmp	r0, #255	; 0xff
33d0cc24:	9a000005 	bls	33d0cc40 <run_command+0x60>
		puts ("## Command too long!\n");
33d0cc28:	e59f03e8 	ldr	r0, [pc, #1000]	; 33d0d018 <run_command+0x438>
33d0cc2c:	eb0028de 	bl	33d16fac <puts>
		return -1;
33d0cc30:	e3e00000 	mvn	r0, #0	; 0x0
33d0cc34:	ea0000f5 	b	33d0d010 <run_command+0x430>

		repeatable &= cmdtp->repeatable;

		/* Did the user stop this? */
		if (had_ctrlc ())
			return 0;	/* if stopped then not repeatable */
33d0cc38:	e3a00000 	mov	r0, #0	; 0x0
33d0cc3c:	ea0000f3 	b	33d0d010 <run_command+0x430>
	if (strlen(cmd) >= CFG_CBSIZE) {
		puts ("## Command too long!\n");
		return -1;
	}

	strcpy (cmdbuf, cmd);
33d0cc40:	e1a01004 	mov	r1, r4
33d0cc44:	e1a0000b 	mov	r0, fp
33d0cc48:	eb0034db 	bl	33d19fbc <strcpy>

		repeatable &= cmdtp->repeatable;

		/* Did the user stop this? */
		if (had_ctrlc ())
			return 0;	/* if stopped then not repeatable */
33d0cc4c:	e5db3000 	ldrb	r3, [fp]
33d0cc50:	e3530000 	cmp	r3, #0	; 0x0
33d0cc54:	0a0000ea 	beq	33d0d004 <run_command+0x424>

		/*
		 * Find separator, or string end
		 * Allow simple escape of ';' by writing "\;"
		 */
		for (inquotes = 0, sep = str; *sep; sep++) {
33d0cc58:	e3530000 	cmp	r3, #0	; 0x0
33d0cc5c:	e3a00000 	mov	r0, #0	; 0x0
33d0cc60:	e1a0200b 	mov	r2, fp
33d0cc64:	0a000014 	beq	33d0ccbc <run_command+0xdc>
			if ((*sep=='\'') &&
33d0cc68:	e5d21000 	ldrb	r1, [r2]
33d0cc6c:	e3510027 	cmp	r1, #39	; 0x27
33d0cc70:	1a000002 	bne	33d0cc80 <run_command+0xa0>
33d0cc74:	e5523001 	ldrb	r3, [r2, #-1]
33d0cc78:	e353005c 	cmp	r3, #92	; 0x5c
			    (*(sep-1) != '\\'))
				inquotes=!inquotes;
33d0cc7c:	12200001 	eorne	r0, r0, #1	; 0x1

			if (!inquotes &&
33d0cc80:	e3500000 	cmp	r0, #0	; 0x0
33d0cc84:	1a000009 	bne	33d0ccb0 <run_command+0xd0>
33d0cc88:	e351003b 	cmp	r1, #59	; 0x3b
33d0cc8c:	13a03000 	movne	r3, #0	; 0x0
33d0cc90:	03a03001 	moveq	r3, #1	; 0x1
33d0cc94:	e152000b 	cmp	r2, fp
33d0cc98:	03a03000 	moveq	r3, #0	; 0x0
33d0cc9c:	e3530000 	cmp	r3, #0	; 0x0
33d0cca0:	0a000002 	beq	33d0ccb0 <run_command+0xd0>
33d0cca4:	e5523001 	ldrb	r3, [r2, #-1]
33d0cca8:	e353005c 	cmp	r3, #92	; 0x5c
33d0ccac:	1a000002 	bne	33d0ccbc <run_command+0xdc>

		/*
		 * Find separator, or string end
		 * Allow simple escape of ';' by writing "\;"
		 */
		for (inquotes = 0, sep = str; *sep; sep++) {
33d0ccb0:	e5f23001 	ldrb	r3, [r2, #1]!
33d0ccb4:	e3530000 	cmp	r3, #0	; 0x0
33d0ccb8:	eaffffe9 	b	33d0cc64 <run_command+0x84>

		/*
		 * Limit the token to data between separators
		 */
		token = str;
		if (*sep) {
33d0ccbc:	e5d23000 	ldrb	r3, [r2]
33d0ccc0:	e3530000 	cmp	r3, #0	; 0x0
			str = sep + 1;	/* start of command for next pass */
			*sep = '\0';
33d0ccc4:	13a03000 	movne	r3, #0	; 0x0
		}

		/*
		 * Limit the token to data between separators
		 */
		token = str;
33d0ccc8:	e1a0000b 	mov	r0, fp
		if (*sep) {
			str = sep + 1;	/* start of command for next pass */
			*sep = '\0';
33d0cccc:	15c23000 	strbne	r3, [r2]
		/*
		 * Limit the token to data between separators
		 */
		token = str;
		if (*sep) {
			str = sep + 1;	/* start of command for next pass */
33d0ccd0:	1282b001 	addne	fp, r2, #1	; 0x1

		/*
		 * Limit the token to data between separators
		 */
		token = str;
		if (*sep) {
33d0ccd4:	1a000003 	bne	33d0cce8 <run_command+0x108>
33d0ccd8:	ea000001 	b	33d0cce4 <run_command+0x104>
		while (*line && (*line != ' ') && (*line != '\t')) {
			++line;
		}

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
33d0ccdc:	e7863105 	str	r3, [r6, r5, lsl #2]
33d0cce0:	ea00009a 	b	33d0cf50 <run_command+0x370>
		if (*sep) {
			str = sep + 1;	/* start of command for next pass */
			*sep = '\0';
		}
		else
			str = sep;	/* no more commands for next pass */
33d0cce4:	e1a0b002 	mov	fp, r2
}

/****************************************************************************/

static void process_macros (const char *input, char *output)
{
33d0cce8:	e1a07000 	mov	r7, r0
	char c, prev;
	const char *varname_start = NULL;
	int inputcnt = strlen (input);
33d0ccec:	eb003507 	bl	33d1a110 <strlen>
/****************************************************************************/

static void process_macros (const char *input, char *output)
{
	char c, prev;
	const char *varname_start = NULL;
33d0ccf0:	e3a0c000 	mov	ip, #0	; 0x0
				*(output++) = c;
				outputcnt--;
			}
			break;
		}
		prev = c;
33d0ccf4:	e150000c 	cmp	r0, ip
33d0ccf8:	e1a06000 	mov	r6, r0
{
	char c, prev;
	const char *varname_start = NULL;
	int inputcnt = strlen (input);
	int outputcnt = CFG_CBSIZE;
	int state = 0;		/* 0 = waiting for '$'  */
33d0ccfc:	e1a0200c 	mov	r2, ip
}

/****************************************************************************/

static void process_macros (const char *input, char *output)
{
33d0cd00:	e28dae15 	add	sl, sp, #336	; 0x150
	char c, prev;
	const char *varname_start = NULL;
	int inputcnt = strlen (input);
	int outputcnt = CFG_CBSIZE;
33d0cd04:	e3a05c01 	mov	r5, #256	; 0x100

	printf ("[PROCESS_MACROS] INPUT len %d: \"%s\"\n", strlen (input),
		input);
#endif

	prev = '\0';		/* previous character   */
33d0cd08:	e1a0100c 	mov	r1, ip
				*(output++) = c;
				outputcnt--;
			}
			break;
		}
		prev = c;
33d0cd0c:	0a00006c 	beq	33d0cec4 <run_command+0x2e4>

	while (inputcnt && outputcnt) {
		c = *input++;
		inputcnt--;

		if (state != 3) {
33d0cd10:	e3510003 	cmp	r1, #3	; 0x3

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
		inputcnt--;
33d0cd14:	e2466001 	sub	r6, r6, #1	; 0x1
#endif

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
33d0cd18:	e4d74001 	ldrb	r4, [r7], #1
		inputcnt--;

		if (state != 3) {
33d0cd1c:	0a00000a 	beq	33d0cd4c <run_command+0x16c>
			/* remove one level of escape characters */
			if ((c == '\\') && (prev != '\\')) {
33d0cd20:	e354005c 	cmp	r4, #92	; 0x5c
33d0cd24:	13a03000 	movne	r3, #0	; 0x0
33d0cd28:	03a03001 	moveq	r3, #1	; 0x1
33d0cd2c:	e352005c 	cmp	r2, #92	; 0x5c
33d0cd30:	03a03000 	moveq	r3, #0	; 0x0
33d0cd34:	e3530000 	cmp	r3, #0	; 0x0
33d0cd38:	0a000003 	beq	33d0cd4c <run_command+0x16c>
				if (inputcnt-- == 0)
33d0cd3c:	e2566001 	subs	r6, r6, #1	; 0x1
33d0cd40:	3a00005d 	bcc	33d0cebc <run_command+0x2dc>
					break;
				prev = c;
33d0cd44:	e1a02004 	mov	r2, r4
				c = *input++;
33d0cd48:	e4d74001 	ldrb	r4, [r7], #1
			}
		}

		switch (state) {
33d0cd4c:	e3510003 	cmp	r1, #3	; 0x3
33d0cd50:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
33d0cd54:	ea000054 	b	33d0ceac <run_command+0x2cc>
33d0cd58:	33d0cd68 	.word	0x33d0cd68
33d0cd5c:	33d0cdac 	.word	0x33d0cdac
33d0cd60:	33d0cde0 	.word	0x33d0cde0
33d0cd64:	33d0ce80 	.word	0x33d0ce80
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
33d0cd68:	e3540027 	cmp	r4, #39	; 0x27
33d0cd6c:	13a03000 	movne	r3, #0	; 0x0
33d0cd70:	03a03001 	moveq	r3, #1	; 0x1
33d0cd74:	e352005c 	cmp	r2, #92	; 0x5c
33d0cd78:	03a03000 	moveq	r3, #0	; 0x0
33d0cd7c:	e3530000 	cmp	r3, #0	; 0x0
				state = 3;
33d0cd80:	13a01003 	movne	r1, #3	; 0x3
			}
		}

		switch (state) {
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
33d0cd84:	1a000048 	bne	33d0ceac <run_command+0x2cc>
				state = 3;
				break;
			}
			if ((c == '$') && (prev != '\\')) {
33d0cd88:	e3540024 	cmp	r4, #36	; 0x24
33d0cd8c:	13a03000 	movne	r3, #0	; 0x0
33d0cd90:	03a03001 	moveq	r3, #1	; 0x1
33d0cd94:	e352005c 	cmp	r2, #92	; 0x5c
33d0cd98:	03a03000 	moveq	r3, #0	; 0x0
33d0cd9c:	e3530000 	cmp	r3, #0	; 0x0
				state++;
33d0cda0:	12811001 	addne	r1, r1, #1	; 0x1
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
				state = 3;
				break;
			}
			if ((c == '$') && (prev != '\\')) {
33d0cda4:	1a000040 	bne	33d0ceac <run_command+0x2cc>
33d0cda8:	ea00003d 	b	33d0cea4 <run_command+0x2c4>
				*(output++) = c;
				outputcnt--;
			}
			break;
		case 1:	/* Waiting for (        */
			if (c == '(' || c == '{') {
33d0cdac:	e354007b 	cmp	r4, #123	; 0x7b
33d0cdb0:	13540028 	cmpne	r4, #40	; 0x28
33d0cdb4:	13a02000 	movne	r2, #0	; 0x0
33d0cdb8:	03a02001 	moveq	r2, #1	; 0x1
				state++;
33d0cdbc:	02811001 	addeq	r1, r1, #1	; 0x1
				varname_start = input;
33d0cdc0:	01a0c007 	moveq	ip, r7
				*(output++) = c;
				outputcnt--;
			}
			break;
		case 1:	/* Waiting for (        */
			if (c == '(' || c == '{') {
33d0cdc4:	0a000038 	beq	33d0ceac <run_command+0x2cc>
				state++;
				varname_start = input;
			} else {
				state = 0;
				*(output++) = '$';
33d0cdc8:	e3a03024 	mov	r3, #36	; 0x24
				outputcnt--;

				if (outputcnt) {
33d0cdcc:	e2555001 	subs	r5, r5, #1	; 0x1
			if (c == '(' || c == '{') {
				state++;
				varname_start = input;
			} else {
				state = 0;
				*(output++) = '$';
33d0cdd0:	e4ca3001 	strb	r3, [sl], #1
		case 1:	/* Waiting for (        */
			if (c == '(' || c == '{') {
				state++;
				varname_start = input;
			} else {
				state = 0;
33d0cdd4:	e1a01002 	mov	r1, r2
				*(output++) = '$';
				outputcnt--;

				if (outputcnt) {
33d0cdd8:	0a000033 	beq	33d0ceac <run_command+0x2cc>
33d0cddc:	ea000030 	b	33d0cea4 <run_command+0x2c4>
					outputcnt--;
				}
			}
			break;
		case 2:	/* Waiting for )        */
			if (c == ')' || c == '}') {
33d0cde0:	e354007d 	cmp	r4, #125	; 0x7d
33d0cde4:	13540029 	cmpne	r4, #41	; 0x29
33d0cde8:	1a00002f 	bne	33d0ceac <run_command+0x2cc>
				int i;
				char envname[CFG_CBSIZE], *envval;
				int envcnt = input - varname_start - 1;	/* Varname # of chars */
33d0cdec:	e06c3007 	rsb	r3, ip, r7
33d0cdf0:	e2431001 	sub	r1, r3, #1	; 0x1

				/* Get the varname */
				for (i = 0; i < envcnt; i++) {
33d0cdf4:	e3a02000 	mov	r2, #0	; 0x0
33d0cdf8:	e1520001 	cmp	r2, r1
33d0cdfc:	aa000005 	bge	33d0ce18 <run_command+0x238>
33d0ce00:	e28d000c 	add	r0, sp, #12	; 0xc
					envname[i] = varname_start[i];
33d0ce04:	e7dc3002 	ldrb	r3, [ip, r2]
				int i;
				char envname[CFG_CBSIZE], *envval;
				int envcnt = input - varname_start - 1;	/* Varname # of chars */

				/* Get the varname */
				for (i = 0; i < envcnt; i++) {
33d0ce08:	e2822001 	add	r2, r2, #1	; 0x1
33d0ce0c:	e1520001 	cmp	r2, r1
					envname[i] = varname_start[i];
33d0ce10:	e4c03001 	strb	r3, [r0], #1
				int i;
				char envname[CFG_CBSIZE], *envval;
				int envcnt = input - varname_start - 1;	/* Varname # of chars */

				/* Get the varname */
				for (i = 0; i < envcnt; i++) {
33d0ce14:	bafffffa 	blt	33d0ce04 <run_command+0x224>
					envname[i] = varname_start[i];
				}
				envname[i] = 0;
33d0ce18:	e28d1e35 	add	r1, sp, #848	; 0x350
33d0ce1c:	e0813002 	add	r3, r1, r2
33d0ce20:	e2433fd1 	sub	r3, r3, #836	; 0x344
33d0ce24:	e3a02000 	mov	r2, #0	; 0x0
33d0ce28:	e5c32000 	strb	r2, [r3]

				/* Get its value */
				envval = getenv (envname);
33d0ce2c:	e28d000c 	add	r0, sp, #12	; 0xc
33d0ce30:	e58dc000 	str	ip, [sp]
33d0ce34:	eb002285 	bl	33d15850 <getenv>

				/* Copy into the line if it exists */
				if (envval != NULL)
33d0ce38:	e3500000 	cmp	r0, #0	; 0x0
33d0ce3c:	e59dc000 	ldr	ip, [sp]
33d0ce40:	0a000015 	beq	33d0ce9c <run_command+0x2bc>
					while ((*envval) && outputcnt) {
						*(output++) = *(envval++);
						outputcnt--;
33d0ce44:	e5d02000 	ldrb	r2, [r0]
33d0ce48:	e3520000 	cmp	r2, #0	; 0x0
33d0ce4c:	13550000 	cmpne	r5, #0	; 0x0
33d0ce50:	0a000011 	beq	33d0ce9c <run_command+0x2bc>
				envval = getenv (envname);

				/* Copy into the line if it exists */
				if (envval != NULL)
					while ((*envval) && outputcnt) {
						*(output++) = *(envval++);
33d0ce54:	e4ca2001 	strb	r2, [sl], #1
						outputcnt--;
33d0ce58:	e2555001 	subs	r5, r5, #1	; 0x1
33d0ce5c:	e5f02001 	ldrb	r2, [r0, #1]!
33d0ce60:	03a03000 	moveq	r3, #0	; 0x0
33d0ce64:	13a03001 	movne	r3, #1	; 0x1
33d0ce68:	e3520000 	cmp	r2, #0	; 0x0
33d0ce6c:	03a03000 	moveq	r3, #0	; 0x0
33d0ce70:	12033001 	andne	r3, r3, #1	; 0x1
33d0ce74:	e3530000 	cmp	r3, #0	; 0x0
33d0ce78:	1afffff5 	bne	33d0ce54 <run_command+0x274>
33d0ce7c:	ea000006 	b	33d0ce9c <run_command+0x2bc>
				/* Look for another '$' */
				state = 0;
			}
			break;
		case 3:	/* Waiting for '        */
			if ((c == '\'') && (prev != '\\')) {
33d0ce80:	e3540027 	cmp	r4, #39	; 0x27
33d0ce84:	13a03000 	movne	r3, #0	; 0x0
33d0ce88:	03a03001 	moveq	r3, #1	; 0x1
33d0ce8c:	e352005c 	cmp	r2, #92	; 0x5c
33d0ce90:	03a03000 	moveq	r3, #0	; 0x0
33d0ce94:	e3530000 	cmp	r3, #0	; 0x0
33d0ce98:	0a000001 	beq	33d0cea4 <run_command+0x2c4>
				state = 0;
33d0ce9c:	e3a01000 	mov	r1, #0	; 0x0
33d0cea0:	ea000001 	b	33d0ceac <run_command+0x2cc>
			} else {
				*(output++) = c;
33d0cea4:	e4ca4001 	strb	r4, [sl], #1
				outputcnt--;
33d0cea8:	e2455001 	sub	r5, r5, #1	; 0x1
			}
			break;
		}
		prev = c;
33d0ceac:	e3560000 	cmp	r6, #0	; 0x0
33d0ceb0:	13550000 	cmpne	r5, #0	; 0x0
33d0ceb4:	e1a02004 	mov	r2, r4
33d0ceb8:	1affff94 	bne	33d0cd10 <run_command+0x130>
	}

	if (outputcnt)
33d0cebc:	e3550000 	cmp	r5, #0	; 0x0
33d0cec0:	0a000001 	beq	33d0cecc <run_command+0x2ec>
		*output = 0;
33d0cec4:	e3a03000 	mov	r3, #0	; 0x0
33d0cec8:	e5ca3000 	strb	r3, [sl]
#endif /* CONFIG_CMDLINE_EDITING */

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
33d0cecc:	e28d2e15 	add	r2, sp, #336	; 0x150
33d0ced0:	e28d6f43 	add	r6, sp, #268	; 0x10c
	int nargs = 0;
33d0ced4:	e3a05000 	mov	r5, #0	; 0x0
#endif
	while (nargs < CFG_MAXARGS) {

		/* skip any white space */
		while ((*line == ' ') || (*line == '\t')) {
			++line;
33d0ced8:	e5d23000 	ldrb	r3, [r2]
33d0cedc:	e3530009 	cmp	r3, #9	; 0x9
33d0cee0:	13530020 	cmpne	r3, #32	; 0x20
33d0cee4:	05f23001 	ldrbeq	r3, [r2, #1]!
33d0cee8:	0afffffb 	beq	33d0cedc <run_command+0x2fc>
		}

		if (*line == '\0') {	/* end of line, no more args	*/
33d0ceec:	e5d23000 	ldrb	r3, [r2]
33d0cef0:	e3530000 	cmp	r3, #0	; 0x0
33d0cef4:	0affff78 	beq	33d0ccdc <run_command+0xfc>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
33d0cef8:	e7862105 	str	r2, [r6, r5, lsl #2]

		/* find end of string */
		while (*line && (*line != ' ') && (*line != '\t')) {
			++line;
33d0cefc:	e5d23000 	ldrb	r3, [r2]
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
33d0cf00:	e2855001 	add	r5, r5, #1	; 0x1

		/* find end of string */
		while (*line && (*line != ' ') && (*line != '\t')) {
			++line;
33d0cf04:	e3530000 	cmp	r3, #0	; 0x0
33d0cf08:	13530020 	cmpne	r3, #32	; 0x20
33d0cf0c:	ea000004 	b	33d0cf24 <run_command+0x344>
33d0cf10:	e3530009 	cmp	r3, #9	; 0x9
33d0cf14:	0a000003 	beq	33d0cf28 <run_command+0x348>
33d0cf18:	e5f23001 	ldrb	r3, [r2, #1]!
33d0cf1c:	e3530000 	cmp	r3, #0	; 0x0
33d0cf20:	13530020 	cmpne	r3, #32	; 0x20
33d0cf24:	1afffff9 	bne	33d0cf10 <run_command+0x330>
		}

		if (*line == '\0') {	/* end of line, no more args	*/
33d0cf28:	e5d23000 	ldrb	r3, [r2]
33d0cf2c:	e3530000 	cmp	r3, #0	; 0x0
33d0cf30:	0affff69 	beq	33d0ccdc <run_command+0xfc>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		*line++ = '\0';		/* terminate current arg	 */
33d0cf34:	e3a03000 	mov	r3, #0	; 0x0
33d0cf38:	e355000f 	cmp	r5, #15	; 0xf
33d0cf3c:	e4c23001 	strb	r3, [r2], #1
33d0cf40:	daffffe4 	ble	33d0ced8 <run_command+0x2f8>
	}

	printf ("** Too many args (max. %d) **\n", CFG_MAXARGS);
33d0cf44:	e59f00d0 	ldr	r0, [pc, #208]	; 33d0d01c <run_command+0x43c>
33d0cf48:	e3a01010 	mov	r1, #16	; 0x10
33d0cf4c:	eb00281d 	bl	33d16fc8 <printf>
#endif /* CONFIG_CMDLINE_EDITING */

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
33d0cf50:	e3550000 	cmp	r5, #0	; 0x0
33d0cf54:	0a000018 	beq	33d0cfbc <run_command+0x3dc>
			rc = -1;	/* no command at all */
			continue;
		}

		/* Look up command in command table */
		if ((cmdtp = find_cmd(argv[0])) == NULL) {
33d0cf58:	e59d010c 	ldr	r0, [sp, #268]
33d0cf5c:	eb0026ef 	bl	33d16b20 <find_cmd>
33d0cf60:	e2504000 	subs	r4, r0, #0	; 0x0
			printf ("Unknown command '%s' - try 'help'\n", argv[0]);
33d0cf64:	059f00b4 	ldreq	r0, [pc, #180]	; 33d0d020 <run_command+0x440>
33d0cf68:	059d110c 	ldreq	r1, [sp, #268]
			rc = -1;	/* no command at all */
			continue;
		}

		/* Look up command in command table */
		if ((cmdtp = find_cmd(argv[0])) == NULL) {
33d0cf6c:	0a000004 	beq	33d0cf84 <run_command+0x3a4>
			rc = -1;	/* give up after bad command */
			continue;
		}

		/* found - check max args */
		if (argc > cmdtp->maxargs) {
33d0cf70:	e5943004 	ldr	r3, [r4, #4]
33d0cf74:	e1550003 	cmp	r5, r3
33d0cf78:	da000003 	ble	33d0cf8c <run_command+0x3ac>
			printf ("Usage:\n%s\n", cmdtp->usage);
33d0cf7c:	e5941010 	ldr	r1, [r4, #16]
33d0cf80:	e59f009c 	ldr	r0, [pc, #156]	; 33d0d024 <run_command+0x444>
33d0cf84:	eb00280f 	bl	33d16fc8 <printf>
33d0cf88:	ea00000b 	b	33d0cfbc <run_command+0x3dc>
			continue;
		}

#if (CONFIG_COMMANDS & CFG_CMD_BOOTD)
		/* avoid "bootd" recursion */
		if (cmdtp->cmd == do_bootd) {
33d0cf8c:	e594c00c 	ldr	ip, [r4, #12]
33d0cf90:	e59f3090 	ldr	r3, [pc, #144]	; 33d0d028 <run_command+0x448>
33d0cf94:	e15c0003 	cmp	ip, r3
33d0cf98:	1a000009 	bne	33d0cfc4 <run_command+0x3e4>
#ifdef DEBUG_PARSER
			printf ("[%s]\n", finaltoken);
#endif
			if (flag & CMD_FLAG_BOOTD) {
33d0cf9c:	e59d2008 	ldr	r2, [sp, #8]
33d0cfa0:	e3120002 	tst	r2, #2	; 0x2
				puts ("'bootd' recursion detected\n");
				rc = -1;
				continue;
			} else {
				flag |= CMD_FLAG_BOOTD;
33d0cfa4:	059d3008 	ldreq	r3, [sp, #8]
33d0cfa8:	03833002 	orreq	r3, r3, #2	; 0x2
33d0cfac:	058d3008 	streq	r3, [sp, #8]
		/* avoid "bootd" recursion */
		if (cmdtp->cmd == do_bootd) {
#ifdef DEBUG_PARSER
			printf ("[%s]\n", finaltoken);
#endif
			if (flag & CMD_FLAG_BOOTD) {
33d0cfb0:	0a000003 	beq	33d0cfc4 <run_command+0x3e4>
				puts ("'bootd' recursion detected\n");
33d0cfb4:	e59f0070 	ldr	r0, [pc, #112]	; 33d0d02c <run_command+0x44c>
33d0cfb8:	eb0027fb 	bl	33d16fac <puts>
				rc = -1;
33d0cfbc:	e3e09000 	mvn	r9, #0	; 0x0
				continue;
33d0cfc0:	eaffff21 	b	33d0cc4c <run_command+0x6c>
			}
		}
#endif	/* CFG_CMD_BOOTD */

		/* OK - call function to do the command */
		if ((cmdtp->cmd) (cmdtp, flag, argc, argv) != 0) {
33d0cfc4:	e1a02005 	mov	r2, r5
33d0cfc8:	e1a03006 	mov	r3, r6
33d0cfcc:	e59d1008 	ldr	r1, [sp, #8]
33d0cfd0:	e1a00004 	mov	r0, r4
33d0cfd4:	e1a0e00f 	mov	lr, pc
33d0cfd8:	e1a0f00c 	mov	pc, ip
			rc = -1;
		}

		repeatable &= cmdtp->repeatable;
33d0cfdc:	e5943008 	ldr	r3, [r4, #8]
33d0cfe0:	e59d1004 	ldr	r1, [sp, #4]
			}
		}
#endif	/* CFG_CMD_BOOTD */

		/* OK - call function to do the command */
		if ((cmdtp->cmd) (cmdtp, flag, argc, argv) != 0) {
33d0cfe4:	e3500000 	cmp	r0, #0	; 0x0
			rc = -1;
		}

		repeatable &= cmdtp->repeatable;
33d0cfe8:	e0011003 	and	r1, r1, r3
		}
#endif	/* CFG_CMD_BOOTD */

		/* OK - call function to do the command */
		if ((cmdtp->cmd) (cmdtp, flag, argc, argv) != 0) {
			rc = -1;
33d0cfec:	13e09000 	mvnne	r9, #0	; 0x0
		}

		repeatable &= cmdtp->repeatable;
33d0cff0:	e58d1004 	str	r1, [sp, #4]

		/* Did the user stop this? */
		if (had_ctrlc ())
33d0cff4:	eb002828 	bl	33d1709c <had_ctrlc>
33d0cff8:	e3500000 	cmp	r0, #0	; 0x0
33d0cffc:	1affff0d 	bne	33d0cc38 <run_command+0x58>
33d0d000:	eaffff11 	b	33d0cc4c <run_command+0x6c>
			return 0;	/* if stopped then not repeatable */
	}

	return rc ? rc : repeatable;
33d0d004:	e3590000 	cmp	r9, #0	; 0x0
33d0d008:	e59d0004 	ldr	r0, [sp, #4]
33d0d00c:	11a00009 	movne	r0, r9
}
33d0d010:	e28dde35 	add	sp, sp, #848	; 0x350
33d0d014:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0d018:	33d26fac 	.word	0x33d26fac
33d0d01c:	33d26fc4 	.word	0x33d26fc4
33d0d020:	33d26fe4 	.word	0x33d26fe4
33d0d024:	33d27008 	.word	0x33d27008
33d0d028:	33d0d620 	.word	0x33d0d620
33d0d02c:	33d27014 	.word	0x33d27014

33d0d030 <main_loop>:
#endif	/* CONFIG_BOOTDELAY >= 0  */

/****************************************************************************/

void main_loop (void)
{
33d0d030:	e92d4070 	push	{r4, r5, r6, lr}
	char *bcs;
	char bcs_set[16];
#endif /* CONFIG_BOOTCOUNT_LIMIT */

#ifdef CONFIG_EMBEDSKY_LOGO
	embedsky_lcd_Init();				//LCD初始化程序
33d0d034:	ebfff023 	bl	33d090c8 <embedsky_lcd_Init>
# endif
	}
#endif /* CONFIG_PREBOOT */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
33d0d038:	e59f0168 	ldr	r0, [pc, #360]	; 33d0d1a8 <main_loop+0x178>
33d0d03c:	eb002203 	bl	33d15850 <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
33d0d040:	e2503000 	subs	r3, r0, #0	; 0x0
void main_loop (void)
{
#ifndef CFG_HUSH_PARSER
	static char lastcommand[CFG_CBSIZE] = { 0, };
	int len;
	int rc = 1;
33d0d044:	e3a06001 	mov	r6, #1	; 0x1
	}
#endif /* CONFIG_PREBOOT */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
33d0d048:	01a04003 	moveq	r4, r3
33d0d04c:	0a000003 	beq	33d0d060 <main_loop+0x30>
33d0d050:	e3a01000 	mov	r1, #0	; 0x0
33d0d054:	e3a0200a 	mov	r2, #10	; 0xa
33d0d058:	eb00356c 	bl	33d1a610 <simple_strtol>
33d0d05c:	e1a04000 	mov	r4, r0
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
33d0d060:	e59f0144 	ldr	r0, [pc, #324]	; 33d0d1ac <main_loop+0x17c>
33d0d064:	eb0021f9 	bl	33d15850 <getenv>

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
33d0d068:	e1e03004 	mvn	r3, r4
33d0d06c:	e1a03fa3 	lsr	r3, r3, #31
33d0d070:	e3500000 	cmp	r0, #0	; 0x0
33d0d074:	03a03000 	moveq	r3, #0	; 0x0
33d0d078:	e3530000 	cmp	r3, #0	; 0x0
33d0d07c:	0a000025 	beq	33d0d118 <main_loop+0xe8>

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT, bootdelay);
#else
//	printf("Press any key to stop autoboot: %2d ", bootdelay);
	printf("Press Space key to Download Mode !");
33d0d080:	e59f0128 	ldr	r0, [pc, #296]	; 33d0d1b0 <main_loop+0x180>
33d0d084:	eb0027cf 	bl	33d16fc8 <printf>

		printf ("\b\b\b%2d ", bootdelay);
	}
    }								//HJ_del end

	putc ('\n');
33d0d088:	e3a0000a 	mov	r0, #10	; 0xa
33d0d08c:	eb0027bc 	bl	33d16f84 <putc>

#if 1								//方法1
	c = awaitkey2(0x1, NULL);					//HJ_add_start	判断是否有按键输入
33d0d090:	e3a00001 	mov	r0, #1	; 0x1
33d0d094:	e3a01000 	mov	r1, #0	; 0x0
33d0d098:	eb0044e3 	bl	33d1e42c <awaitkey2>
33d0d09c:	e20000ff 	and	r0, r0, #255	; 0xff
	if(c == 0x20)
33d0d0a0:	e3500020 	cmp	r0, #32	; 0x20
33d0d0a4:	1a000001 	bne	33d0d0b0 <main_loop+0x80>
		abort  = 1;	/* don't auto boot	*/
//		bootdelay = 0;	/* no more delay	*/

/* add by www.embedsky.net */
#ifdef CONFIG_EMBEDSKY_LOGO
		embedsky_tq_logo();						//LCD显示程序
33d0d0a8:	ebfff0a2 	bl	33d09338 <embedsky_tq_logo>
33d0d0ac:	ea000019 	b	33d0d118 <main_loop+0xe8>

	}
	else
	{
#ifdef CONFIG_EMBEDSKY_LOGO
		if(bBootFrmNORFlash())
33d0d0b0:	ebffce06 	bl	33d008d0 <bBootFrmNORFlash>
33d0d0b4:	e3500000 	cmp	r0, #0	; 0x0
33d0d0b8:	0a000001 	beq	33d0d0c4 <main_loop+0x94>
		{
			embedsky_tq_logo();
33d0d0bc:	ebfff09d 	bl	33d09338 <embedsky_tq_logo>
33d0d0c0:	ea000000 	b	33d0d0c8 <main_loop+0x98>
		}
		else
		{
			embedsky_user_logo();						//user's logo display
33d0d0c4:	ebfff0b9 	bl	33d093b0 <embedsky_user_logo>
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

# ifndef CFG_HUSH_PARSER

	if (bBootFrmNORFlash())
33d0d0c8:	ebffce00 	bl	33d008d0 <bBootFrmNORFlash>
33d0d0cc:	e2504000 	subs	r4, r0, #0	; 0x0
33d0d0d0:	0a00000b 	beq	33d0d104 <main_loop+0xd4>
	{
#ifdef CONFIG_JFFS2_CMDLINE
	extern int mtdparts_init(void);
	if (!getenv("mtdparts"))
33d0d0d4:	e59f00d8 	ldr	r0, [pc, #216]	; 33d0d1b4 <main_loop+0x184>
33d0d0d8:	eb0021dc 	bl	33d15850 <getenv>
33d0d0dc:	e3500000 	cmp	r0, #0	; 0x0
33d0d0e0:	1a000003 	bne	33d0d0f4 <main_loop+0xc4>
	{
		run_command("mtdparts default", 0);
33d0d0e4:	e1a01000 	mov	r1, r0
33d0d0e8:	e59f00c8 	ldr	r0, [pc, #200]	; 33d0d1b8 <main_loop+0x188>
33d0d0ec:	ebfffebb 	bl	33d0cbe0 <run_command>
33d0d0f0:	ea000000 	b	33d0d0f8 <main_loop+0xc8>
	}
	else
	{
		mtdparts_init();
33d0d0f4:	eb000fda 	bl	33d11064 <mtdparts_init>
	}
#endif

		run_command("menu", 0);
33d0d0f8:	e59f00bc 	ldr	r0, [pc, #188]	; 33d0d1bc <main_loop+0x18c>
33d0d0fc:	e3a01000 	mov	r1, #0	; 0x0
33d0d100:	ea000003 	b	33d0d114 <main_loop+0xe4>
			run_command("wince", 0);
		}
		else
#endif
		{
			printf("Booting Linux ...\n");
33d0d104:	e59f00b4 	ldr	r0, [pc, #180]	; 33d0d1c0 <main_loop+0x190>
33d0d108:	eb0027ae 	bl	33d16fc8 <printf>
			run_command("boot_zImage", 0);
33d0d10c:	e59f00b0 	ldr	r0, [pc, #176]	; 33d0d1c4 <main_loop+0x194>
33d0d110:	e1a01004 	mov	r1, r4
33d0d114:	ebfffeb1 	bl	33d0cbe0 <run_command>
	}
#endif

#ifdef CONFIG_JFFS2_CMDLINE
	extern int mtdparts_init(void);
	if (!getenv("mtdparts"))
33d0d118:	e59f0094 	ldr	r0, [pc, #148]	; 33d0d1b4 <main_loop+0x184>
33d0d11c:	eb0021cb 	bl	33d15850 <getenv>
33d0d120:	e3500000 	cmp	r0, #0	; 0x0
33d0d124:	1a000003 	bne	33d0d138 <main_loop+0x108>
	{
		run_command("mtdparts default", 0);
33d0d128:	e1a01000 	mov	r1, r0
33d0d12c:	e59f0084 	ldr	r0, [pc, #132]	; 33d0d1b8 <main_loop+0x188>
33d0d130:	ebfffeaa 	bl	33d0cbe0 <run_command>
33d0d134:	ea000000 	b	33d0d13c <main_loop+0x10c>
	}
	else
	{
		mtdparts_init();
33d0d138:	eb000fc9 	bl	33d11064 <mtdparts_init>
	}
#endif

	run_command("menu", 0);
33d0d13c:	e59f0078 	ldr	r0, [pc, #120]	; 33d0d1bc <main_loop+0x18c>
33d0d140:	e3a01000 	mov	r1, #0	; 0x0
33d0d144:	ebfffea5 	bl	33d0cbe0 <run_command>
			 * restart the timeout.
			 */
			reset_cmd_timeout();
		}
#endif
		len = readline (CFG_PROMPT);
33d0d148:	e59f0078 	ldr	r0, [pc, #120]	; 33d0d1c8 <main_loop+0x198>
33d0d14c:	ebfffe2c 	bl	33d0ca04 <readline>

		flag = 0;	/* assume no special flags for now */
		if (len > 0)
33d0d150:	e2505000 	subs	r5, r0, #0	; 0x0
			strcpy (lastcommand, console_buffer);
33d0d154:	e59f1070 	ldr	r1, [pc, #112]	; 33d0d1cc <main_loop+0x19c>
33d0d158:	e59f0070 	ldr	r0, [pc, #112]	; 33d0d1d0 <main_loop+0x1a0>
			reset_cmd_timeout();
		}
#endif
		len = readline (CFG_PROMPT);

		flag = 0;	/* assume no special flags for now */
33d0d15c:	e3a04000 	mov	r4, #0	; 0x0
		if (len > 0)
33d0d160:	da000001 	ble	33d0d16c <main_loop+0x13c>
			strcpy (lastcommand, console_buffer);
33d0d164:	eb003394 	bl	33d19fbc <strcpy>
33d0d168:	ea000000 	b	33d0d170 <main_loop+0x140>
		else if (len == 0)
			flag |= CMD_FLAG_REPEAT;
33d0d16c:	03a04001 	moveq	r4, #1	; 0x1
			return;		/* retry autoboot */
# endif
		}
#endif

		if (len == -1)
33d0d170:	e3750001 	cmn	r5, #1	; 0x1
			puts ("<INTERRUPT>\n");
		else
			rc = run_command (lastcommand, flag);
33d0d174:	e1a01004 	mov	r1, r4
# endif
		}
#endif

		if (len == -1)
			puts ("<INTERRUPT>\n");
33d0d178:	e59f0054 	ldr	r0, [pc, #84]	; 33d0d1d4 <main_loop+0x1a4>
			return;		/* retry autoboot */
# endif
		}
#endif

		if (len == -1)
33d0d17c:	1a000001 	bne	33d0d188 <main_loop+0x158>
			puts ("<INTERRUPT>\n");
33d0d180:	eb002789 	bl	33d16fac <puts>
33d0d184:	ea000002 	b	33d0d194 <main_loop+0x164>
		else
			rc = run_command (lastcommand, flag);
33d0d188:	e59f0040 	ldr	r0, [pc, #64]	; 33d0d1d0 <main_loop+0x1a0>
33d0d18c:	ebfffe93 	bl	33d0cbe0 <run_command>
33d0d190:	e1a06000 	mov	r6, r0

		if (rc <= 0) {
33d0d194:	e3560000 	cmp	r6, #0	; 0x0
			/* invalid command or not repeatable, forget it */
			lastcommand[0] = 0;
33d0d198:	d59f3030 	ldrle	r3, [pc, #48]	; 33d0d1d0 <main_loop+0x1a0>
33d0d19c:	d3a02000 	movle	r2, #0	; 0x0
33d0d1a0:	d5c32000 	strble	r2, [r3]
33d0d1a4:	eaffffe7 	b	33d0d148 <main_loop+0x118>
33d0d1a8:	33d27030 	.word	0x33d27030
33d0d1ac:	33d2703c 	.word	0x33d2703c
33d0d1b0:	33d27044 	.word	0x33d27044
33d0d1b4:	33d27068 	.word	0x33d27068
33d0d1b8:	33d27074 	.word	0x33d27074
33d0d1bc:	33d27088 	.word	0x33d27088
33d0d1c0:	33d27090 	.word	0x33d27090
33d0d1c4:	33d255ac 	.word	0x33d255ac
33d0d1c8:	33d270a4 	.word	0x33d270a4
33d0d1cc:	33d60688 	.word	0x33d60688
33d0d1d0:	33d60788 	.word	0x33d60788
33d0d1d4:	33d270b0 	.word	0x33d270b0

33d0d1d8 <do_run>:

/****************************************************************************/

#if (CONFIG_COMMANDS & CFG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d0d1d8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int i;

	if (argc < 2) {
33d0d1dc:	e3520001 	cmp	r2, #1	; 0x1

/****************************************************************************/

#if (CONFIG_COMMANDS & CFG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d0d1e0:	e1a07001 	mov	r7, r1
33d0d1e4:	e1a05002 	mov	r5, r2
	int i;

	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0d1e8:	d5901010 	ldrle	r1, [r0, #16]

/****************************************************************************/

#if (CONFIG_COMMANDS & CFG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d0d1ec:	e1a06003 	mov	r6, r3
	int i;

	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0d1f0:	d59f0054 	ldrle	r0, [pc, #84]	; 33d0d24c <do_run+0x74>
#if (CONFIG_COMMANDS & CFG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
	int i;

	if (argc < 2) {
33d0d1f4:	da000002 	ble	33d0d204 <do_run+0x2c>
33d0d1f8:	ea000004 	b	33d0d210 <do_run+0x38>

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
33d0d1fc:	e7961104 	ldr	r1, [r6, r4, lsl #2]
33d0d200:	e59f0048 	ldr	r0, [pc, #72]	; 33d0d250 <do_run+0x78>
33d0d204:	eb00276f 	bl	33d16fc8 <printf>
			return 1;
33d0d208:	e3a00001 	mov	r0, #1	; 0x1
33d0d20c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	for (i=1; i<argc; ++i) {
33d0d210:	e3a04001 	mov	r4, #1	; 0x1
33d0d214:	e1540005 	cmp	r4, r5
33d0d218:	aa000009 	bge	33d0d244 <do_run+0x6c>
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
33d0d21c:	e7960104 	ldr	r0, [r6, r4, lsl #2]
33d0d220:	eb00218a 	bl	33d15850 <getenv>
33d0d224:	e3500000 	cmp	r0, #0	; 0x0
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}
#ifndef CFG_HUSH_PARSER
		if (run_command (arg, flag) == -1)
33d0d228:	e1a01007 	mov	r1, r7
	}

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
33d0d22c:	0afffff2 	beq	33d0d1fc <do_run+0x24>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}
#ifndef CFG_HUSH_PARSER
		if (run_command (arg, flag) == -1)
33d0d230:	ebfffe6a 	bl	33d0cbe0 <run_command>
33d0d234:	e3700001 	cmn	r0, #1	; 0x1
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	for (i=1; i<argc; ++i) {
33d0d238:	e2844001 	add	r4, r4, #1	; 0x1
		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}
#ifndef CFG_HUSH_PARSER
		if (run_command (arg, flag) == -1)
33d0d23c:	0afffff1 	beq	33d0d208 <do_run+0x30>
33d0d240:	eafffff3 	b	33d0d214 <do_run+0x3c>
		if (parse_string_outer(arg,
		    FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0)
			return 1;
#endif
	}
	return 0;
33d0d244:	e3a00000 	mov	r0, #0	; 0x0
}
33d0d248:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0d24c:	33d27008 	.word	0x33d27008
33d0d250:	33d270c0 	.word	0x33d270c0

33d0d254 <autoscript>:
	 (CONFIG_COMMANDS & CFG_CMD_AUTOSCRIPT )

extern image_header_t header;		/* from cmd_bootm.c */
int
autoscript (ulong addr)
{
33d0d254:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d0d258:	e1a0a000 	mov	sl, r0
	ulong *len_ptr;
	char *cmd;
	int rcode = 0;
	int verify;

	cmd = getenv ("verify");
33d0d25c:	e59f01f0 	ldr	r0, [pc, #496]	; 33d0d454 <autoscript+0x200>
33d0d260:	eb00217a 	bl	33d15850 <getenv>
{
	ulong crc, data, len;
	image_header_t *hdr = &header;
	ulong *len_ptr;
	char *cmd;
	int rcode = 0;
33d0d264:	e3a09000 	mov	r9, #0	; 0x0
	int verify;

	cmd = getenv ("verify");
	verify = (cmd && (*cmd == 'n')) ? 0 : 1;
33d0d268:	e2504000 	subs	r4, r0, #0	; 0x0
extern image_header_t header;		/* from cmd_bootm.c */
int
autoscript (ulong addr)
{
	ulong crc, data, len;
	image_header_t *hdr = &header;
33d0d26c:	e59f71e4 	ldr	r7, [pc, #484]	; 33d0d458 <autoscript+0x204>
	char *cmd;
	int rcode = 0;
	int verify;

	cmd = getenv ("verify");
	verify = (cmd && (*cmd == 'n')) ? 0 : 1;
33d0d270:	e1a05009 	mov	r5, r9
33d0d274:	0a000002 	beq	33d0d284 <autoscript+0x30>
33d0d278:	e5d43000 	ldrb	r3, [r4]
33d0d27c:	e353006e 	cmp	r3, #110	; 0x6e
33d0d280:	0a000000 	beq	33d0d288 <autoscript+0x34>
33d0d284:	e3a05001 	mov	r5, #1	; 0x1


	memmove (hdr, (char *)addr, sizeof(image_header_t));
33d0d288:	e1a0100a 	mov	r1, sl
33d0d28c:	e3a02040 	mov	r2, #64	; 0x40
33d0d290:	e59f01c0 	ldr	r0, [pc, #448]	; 33d0d458 <autoscript+0x204>
33d0d294:	eb00345c 	bl	33d1a40c <memmove>
33d0d298:	e5971000 	ldr	r1, [r7]
	return __arch__swab32(x);
33d0d29c:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d0d2a0:	e1a03403 	lsl	r3, r3, #8
33d0d2a4:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d0d2a8:	e1833c01 	orr	r3, r3, r1, lsl #24
33d0d2ac:	e1833422 	orr	r3, r3, r2, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d2b0:	e59f21a4 	ldr	r2, [pc, #420]	; 33d0d45c <autoscript+0x208>
	return __arch__swab32(x);
33d0d2b4:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d2b8:	e1530002 	cmp	r3, r2

	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
33d0d2bc:	e3a06000 	mov	r6, #0	; 0x0
		puts ("Bad magic number\n");
33d0d2c0:	159f0198 	ldrne	r0, [pc, #408]	; 33d0d460 <autoscript+0x20c>
33d0d2c4:	1a00000e 	bne	33d0d304 <autoscript+0xb0>
33d0d2c8:	e5973004 	ldr	r3, [r7, #4]
	return __arch__swab32(x);
33d0d2cc:	e2034cff 	and	r4, r3, #65280	; 0xff00
33d0d2d0:	e1a04404 	lsl	r4, r4, #8
33d0d2d4:	e20328ff 	and	r2, r3, #16711680	; 0xff0000
33d0d2d8:	e1844c03 	orr	r4, r4, r3, lsl #24
33d0d2dc:	e1844422 	orr	r4, r4, r2, lsr #8

	crc = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;
	len = sizeof (image_header_t);
	data = (ulong)hdr;
	if (crc32(0, (uchar *)data, len) != crc) {
33d0d2e0:	e1a00006 	mov	r0, r6
33d0d2e4:	e59f116c 	ldr	r1, [pc, #364]	; 33d0d458 <autoscript+0x204>
33d0d2e8:	e3a02040 	mov	r2, #64	; 0x40
		puts ("Bad magic number\n");
		return 1;
	}

	crc = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;
33d0d2ec:	e5876004 	str	r6, [r7, #4]
33d0d2f0:	e1844c23 	orr	r4, r4, r3, lsr #24
	len = sizeof (image_header_t);
	data = (ulong)hdr;
	if (crc32(0, (uchar *)data, len) != crc) {
33d0d2f4:	eb003287 	bl	33d19d18 <crc32>
33d0d2f8:	e1500004 	cmp	r0, r4
33d0d2fc:	0a000003 	beq	33d0d310 <autoscript+0xbc>
		puts ("Bad header crc\n");
33d0d300:	e59f015c 	ldr	r0, [pc, #348]	; 33d0d464 <autoscript+0x210>
33d0d304:	eb002728 	bl	33d16fac <puts>
		return 1;
33d0d308:	e3a00001 	mov	r0, #1	; 0x1
33d0d30c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d0d310:	e597300c 	ldr	r3, [r7, #12]
33d0d314:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0d318:	e1a02402 	lsl	r2, r2, #8
33d0d31c:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0d320:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d0d324:	e1822421 	orr	r2, r2, r1, lsr #8
	}

	data = addr + sizeof(image_header_t);
	len = ntohl(hdr->ih_size);

	if (verify) {
33d0d328:	e3550000 	cmp	r5, #0	; 0x0
	if (crc32(0, (uchar *)data, len) != crc) {
		puts ("Bad header crc\n");
		return 1;
	}

	data = addr + sizeof(image_header_t);
33d0d32c:	e28a4040 	add	r4, sl, #64	; 0x40
33d0d330:	e1825c23 	orr	r5, r2, r3, lsr #24
	len = ntohl(hdr->ih_size);

	if (verify) {
33d0d334:	0a00000d 	beq	33d0d370 <autoscript+0x11c>
		if (crc32(0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
33d0d338:	e1a02005 	mov	r2, r5
33d0d33c:	e1a01004 	mov	r1, r4
33d0d340:	e1a00006 	mov	r0, r6
33d0d344:	eb003273 	bl	33d19d18 <crc32>
33d0d348:	e5973018 	ldr	r3, [r7, #24]
33d0d34c:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0d350:	e1a02402 	lsl	r2, r2, #8
33d0d354:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0d358:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d0d35c:	e1822421 	orr	r2, r2, r1, lsr #8
33d0d360:	e1822c23 	orr	r2, r2, r3, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d364:	e1500002 	cmp	r0, r2
			puts ("Bad data crc\n");
33d0d368:	159f00f8 	ldrne	r0, [pc, #248]	; 33d0d468 <autoscript+0x214>
33d0d36c:	1affffe4 	bne	33d0d304 <autoscript+0xb0>
			return 1;
		}
	}

	if (hdr->ih_type != IH_TYPE_SCRIPT) {
33d0d370:	e5d7301e 	ldrb	r3, [r7, #30]
33d0d374:	e3530006 	cmp	r3, #6	; 0x6
		puts ("Bad image type\n");
33d0d378:	159f00ec 	ldrne	r0, [pc, #236]	; 33d0d46c <autoscript+0x218>
			puts ("Bad data crc\n");
			return 1;
		}
	}

	if (hdr->ih_type != IH_TYPE_SCRIPT) {
33d0d37c:	1affffe0 	bne	33d0d304 <autoscript+0xb0>
33d0d380:	e5943000 	ldr	r3, [r4]
	return __arch__swab32(x);
33d0d384:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0d388:	e1a02402 	lsl	r2, r2, #8
33d0d38c:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0d390:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d0d394:	e1822421 	orr	r2, r2, r1, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d398:	e1925c23 	orrs	r5, r2, r3, lsr #24
		puts ("Bad image type\n");
		return 1;
	}

	/* get length of script */
	len_ptr = (ulong *)data;
33d0d39c:	e1a06004 	mov	r6, r4

	if ((len = ntohl(*len_ptr)) == 0) {
		puts ("Empty Script\n");
33d0d3a0:	059f00c8 	ldreq	r0, [pc, #200]	; 33d0d470 <autoscript+0x21c>
33d0d3a4:	0affffd6 	beq	33d0d304 <autoscript+0xb0>
		return 1;
	}

	debug ("** Script length: %ld\n", len);

	if ((cmd = malloc (len + 1)) == NULL) {
33d0d3a8:	e2850001 	add	r0, r5, #1	; 0x1
33d0d3ac:	eb0028ad 	bl	33d17668 <malloc>
33d0d3b0:	e2504000 	subs	r4, r0, #0	; 0x0
		return 1;
33d0d3b4:	02800001 	addeq	r0, r0, #1	; 0x1
		return 1;
	}

	debug ("** Script length: %ld\n", len);

	if ((cmd = malloc (len + 1)) == NULL) {
33d0d3b8:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
33d0d3bc:	ea000001 	b	33d0d3c8 <autoscript+0x174>
				/* run only non-empty commands */
				if ((next - line) > 1) {
					debug ("** exec: \"%s\"\n",
						line);
					if (run_command (line, 0) < 0) {
						rcode = 1;
33d0d3c0:	e3a09001 	mov	r9, #1	; 0x1
						break;
33d0d3c4:	ea00001e 	b	33d0d444 <autoscript+0x1f0>

	if ((cmd = malloc (len + 1)) == NULL) {
		return 1;
	}

	while (*len_ptr++);
33d0d3c8:	e4967004 	ldr	r7, [r6], #4
33d0d3cc:	e3570000 	cmp	r7, #0	; 0x0
33d0d3d0:	1afffffc 	bne	33d0d3c8 <autoscript+0x174>

	/* make sure cmd is null terminated */
	memmove (cmd, (char *)len_ptr, len);
33d0d3d4:	e1a01006 	mov	r1, r6
33d0d3d8:	e1a00004 	mov	r0, r4
33d0d3dc:	e1a02005 	mov	r2, r5
33d0d3e0:	eb003409 	bl	33d1a40c <memmove>
	*(cmd + len) = 0;
33d0d3e4:	e7c47005 	strb	r7, [r4, r5]
						break;
					}
				}
				line = next + 1;
			}
			++next;
33d0d3e8:	e5d43000 	ldrb	r3, [r4]
33d0d3ec:	e3530000 	cmp	r3, #0	; 0x0

#ifdef CFG_HUSH_PARSER /*?? */
	rcode = parse_string_outer (cmd, FLAG_PARSE_SEMICOLON);
#else
	{
		char *line = cmd;
33d0d3f0:	e1a00004 	mov	r0, r4
		char *next = cmd;
33d0d3f4:	e1a06004 	mov	r6, r4
						break;
					}
				}
				line = next + 1;
			}
			++next;
33d0d3f8:	0a000011 	beq	33d0d444 <autoscript+0x1f0>
33d0d3fc:	e2845001 	add	r5, r4, #1	; 0x1
		 * break into individual lines,
		 * and execute each line;
		 * terminate on error.
		 */
		while (*next) {
			if (*next == '\n') {
33d0d400:	e5553001 	ldrb	r3, [r5, #-1]
33d0d404:	e353000a 	cmp	r3, #10	; 0xa
				*next = '\0';
				/* run only non-empty commands */
				if ((next - line) > 1) {
33d0d408:	e0602006 	rsb	r2, r0, r6
		 * and execute each line;
		 * terminate on error.
		 */
		while (*next) {
			if (*next == '\n') {
				*next = '\0';
33d0d40c:	e3a03000 	mov	r3, #0	; 0x0
						break;
					}
				}
				line = next + 1;
			}
			++next;
33d0d410:	e2866001 	add	r6, r6, #1	; 0x1
		 * break into individual lines,
		 * and execute each line;
		 * terminate on error.
		 */
		while (*next) {
			if (*next == '\n') {
33d0d414:	1a000007 	bne	33d0d438 <autoscript+0x1e4>
				*next = '\0';
				/* run only non-empty commands */
				if ((next - line) > 1) {
33d0d418:	e3520001 	cmp	r2, #1	; 0x1
					debug ("** exec: \"%s\"\n",
						line);
					if (run_command (line, 0) < 0) {
33d0d41c:	e1a01003 	mov	r1, r3
		 * and execute each line;
		 * terminate on error.
		 */
		while (*next) {
			if (*next == '\n') {
				*next = '\0';
33d0d420:	e5453001 	strb	r3, [r5, #-1]
				/* run only non-empty commands */
				if ((next - line) > 1) {
33d0d424:	da000002 	ble	33d0d434 <autoscript+0x1e0>
					debug ("** exec: \"%s\"\n",
						line);
					if (run_command (line, 0) < 0) {
33d0d428:	ebfffdec 	bl	33d0cbe0 <run_command>
33d0d42c:	e3500000 	cmp	r0, #0	; 0x0
33d0d430:	baffffe2 	blt	33d0d3c0 <autoscript+0x16c>
						rcode = 1;
						break;
					}
				}
				line = next + 1;
33d0d434:	e1a00005 	mov	r0, r5
			}
			++next;
33d0d438:	e4d53001 	ldrb	r3, [r5], #1
33d0d43c:	e3530000 	cmp	r3, #0	; 0x0
33d0d440:	1affffee 	bne	33d0d400 <autoscript+0x1ac>
		}
	}
#endif
	free (cmd);
33d0d444:	e1a00004 	mov	r0, r4
33d0d448:	eb002801 	bl	33d17454 <free>
	return rcode;
33d0d44c:	e1a00009 	mov	r0, r9
}
33d0d450:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d0d454:	33d27158 	.word	0x33d27158
33d0d458:	33d60888 	.word	0x33d60888
33d0d45c:	27051956 	.word	0x27051956
33d0d460:	33d27160 	.word	0x33d27160
33d0d464:	33d27174 	.word	0x33d27174
33d0d468:	33d27184 	.word	0x33d27184
33d0d46c:	33d27194 	.word	0x33d27194
33d0d470:	33d271a4 	.word	0x33d271a4

33d0d474 <do_autoscript>:
do_autoscript (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	ulong addr;
	int rcode;

	if (argc < 2) {
33d0d474:	e3520001 	cmp	r2, #1	; 0x1
#endif	/* CONFIG_AUTOSCRIPT || CFG_CMD_AUTOSCRIPT */
/**************************************************/
#if (CONFIG_COMMANDS & CFG_CMD_AUTOSCRIPT)
int
do_autoscript (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d478:	e92d4010 	push	{r4, lr}
	int rcode;

	if (argc < 2) {
		addr = CFG_LOAD_ADDR;
	} else {
		addr = simple_strtoul (argv[1],0,16);
33d0d47c:	e3a01000 	mov	r1, #0	; 0x0
33d0d480:	e3a02010 	mov	r2, #16	; 0x10
{
	ulong addr;
	int rcode;

	if (argc < 2) {
		addr = CFG_LOAD_ADDR;
33d0d484:	e3a04437 	mov	r4, #922746880	; 0x37000000
do_autoscript (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	ulong addr;
	int rcode;

	if (argc < 2) {
33d0d488:	da000002 	ble	33d0d498 <do_autoscript+0x24>
		addr = CFG_LOAD_ADDR;
	} else {
		addr = simple_strtoul (argv[1],0,16);
33d0d48c:	e5930004 	ldr	r0, [r3, #4]
33d0d490:	eb003431 	bl	33d1a55c <simple_strtoul>
33d0d494:	e1a04000 	mov	r4, r0
	}

	printf ("## Executing script at %08lx\n",addr);
33d0d498:	e59f0010 	ldr	r0, [pc, #16]	; 33d0d4b0 <do_autoscript+0x3c>
33d0d49c:	e1a01004 	mov	r1, r4
33d0d4a0:	eb0026c8 	bl	33d16fc8 <printf>
	rcode = autoscript (addr);
33d0d4a4:	e1a00004 	mov	r0, r4
	return rcode;
}
33d0d4a8:	e8bd4010 	pop	{r4, lr}
	} else {
		addr = simple_strtoul (argv[1],0,16);
	}

	printf ("## Executing script at %08lx\n",addr);
	rcode = autoscript (addr);
33d0d4ac:	eaffff68 	b	33d0d254 <autoscript>
33d0d4b0:	33d271b4 	.word	0x33d271b4

33d0d4b4 <print_num>:
}

#endif /* CONFIG_ARM XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */

static void print_num(const char *name, ulong value)
{
33d0d4b4:	e1a02001 	mov	r2, r1
	printf ("%-12s= 0x%08lX\n", name, value);
33d0d4b8:	e1a01000 	mov	r1, r0
33d0d4bc:	e59f0000 	ldr	r0, [pc, #0]	; 33d0d4c4 <print_num+0x10>
33d0d4c0:	ea0026c0 	b	33d16fc8 <printf>
33d0d4c4:	33d27204 	.word	0x33d27204

33d0d4c8 <do_bdinfo>:
#endif  /* MIPS */

#else	/* ARM */

int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d4c8:	e92d4030 	push	{r4, r5, lr}
	int i;
	bd_t *bd = gd->bd;
33d0d4cc:	e5984000 	ldr	r4, [r8]

	print_num ("arch_number",	bd->bi_arch_number);
33d0d4d0:	e59f0098 	ldr	r0, [pc, #152]	; 33d0d570 <do_bdinfo+0xa8>
33d0d4d4:	e5941014 	ldr	r1, [r4, #20]
33d0d4d8:	ebfffff5 	bl	33d0d4b4 <print_num>
	print_num ("env_t",		(ulong)bd->bi_env);
33d0d4dc:	e59f0090 	ldr	r0, [pc, #144]	; 33d0d574 <do_bdinfo+0xac>
33d0d4e0:	e5941010 	ldr	r1, [r4, #16]
33d0d4e4:	ebfffff2 	bl	33d0d4b4 <print_num>
	print_num ("boot_params",	(ulong)bd->bi_boot_params);

	for (i=0; i<CONFIG_NR_DRAM_BANKS; ++i) {
33d0d4e8:	e3a05000 	mov	r5, #0	; 0x0
	int i;
	bd_t *bd = gd->bd;

	print_num ("arch_number",	bd->bi_arch_number);
	print_num ("env_t",		(ulong)bd->bi_env);
	print_num ("boot_params",	(ulong)bd->bi_boot_params);
33d0d4ec:	e59f0084 	ldr	r0, [pc, #132]	; 33d0d578 <do_bdinfo+0xb0>
33d0d4f0:	e5941018 	ldr	r1, [r4, #24]
33d0d4f4:	ebffffee 	bl	33d0d4b4 <print_num>

	for (i=0; i<CONFIG_NR_DRAM_BANKS; ++i) {
		print_num("DRAM bank",	i);
33d0d4f8:	e1a01005 	mov	r1, r5
33d0d4fc:	e59f0078 	ldr	r0, [pc, #120]	; 33d0d57c <do_bdinfo+0xb4>
33d0d500:	ebffffeb 	bl	33d0d4b4 <print_num>
		print_num("-> start",	bd->bi_dram[i].start);
33d0d504:	e59f0074 	ldr	r0, [pc, #116]	; 33d0d580 <do_bdinfo+0xb8>
33d0d508:	e594101c 	ldr	r1, [r4, #28]
33d0d50c:	ebffffe8 	bl	33d0d4b4 <print_num>
		print_num("-> size",	bd->bi_dram[i].size);
33d0d510:	e59f006c 	ldr	r0, [pc, #108]	; 33d0d584 <do_bdinfo+0xbc>
33d0d514:	e5941020 	ldr	r1, [r4, #32]
33d0d518:	ebffffe5 	bl	33d0d4b4 <print_num>
	}

	puts ("ethaddr     =");
33d0d51c:	e59f0064 	ldr	r0, [pc, #100]	; 33d0d588 <do_bdinfo+0xc0>
33d0d520:	eb0026a1 	bl	33d16fac <puts>
	for (i=0; i<6; ++i) {
		printf ("%c%02X", i ? ':' : ' ', bd->bi_enetaddr[i]);
33d0d524:	e3550000 	cmp	r5, #0	; 0x0
33d0d528:	e0853004 	add	r3, r5, r4
33d0d52c:	03a01020 	moveq	r1, #32	; 0x20
33d0d530:	13a0103a 	movne	r1, #58	; 0x3a
33d0d534:	e5d32008 	ldrb	r2, [r3, #8]
		print_num("-> start",	bd->bi_dram[i].start);
		print_num("-> size",	bd->bi_dram[i].size);
	}

	puts ("ethaddr     =");
	for (i=0; i<6; ++i) {
33d0d538:	e2855001 	add	r5, r5, #1	; 0x1
		printf ("%c%02X", i ? ':' : ' ', bd->bi_enetaddr[i]);
33d0d53c:	e59f0048 	ldr	r0, [pc, #72]	; 33d0d58c <do_bdinfo+0xc4>
33d0d540:	eb0026a0 	bl	33d16fc8 <printf>
		print_num("-> start",	bd->bi_dram[i].start);
		print_num("-> size",	bd->bi_dram[i].size);
	}

	puts ("ethaddr     =");
	for (i=0; i<6; ++i) {
33d0d544:	e3550005 	cmp	r5, #5	; 0x5
33d0d548:	dafffff5 	ble	33d0d524 <do_bdinfo+0x5c>
		printf ("%c%02X", i ? ':' : ' ', bd->bi_enetaddr[i]);
	}
	puts  ( "\n"
33d0d54c:	e59f003c 	ldr	r0, [pc, #60]	; 33d0d590 <do_bdinfo+0xc8>
33d0d550:	eb002695 	bl	33d16fac <puts>
		"ip_addr     = ");
	print_IPaddr (bd->bi_ip_addr);
33d0d554:	e5940004 	ldr	r0, [r4, #4]
33d0d558:	ebffd3c3 	bl	33d0246c <print_IPaddr>
	printf ("\n"
33d0d55c:	e5941000 	ldr	r1, [r4]
33d0d560:	e59f002c 	ldr	r0, [pc, #44]	; 33d0d594 <do_bdinfo+0xcc>
33d0d564:	eb002697 	bl	33d16fc8 <printf>
		"baudrate    = %d bps\n", bd->bi_baudrate);

	return 0;
}
33d0d568:	e3a00000 	mov	r0, #0	; 0x0
33d0d56c:	e8bd8030 	pop	{r4, r5, pc}
33d0d570:	33d27214 	.word	0x33d27214
33d0d574:	33d27220 	.word	0x33d27220
33d0d578:	33d27228 	.word	0x33d27228
33d0d57c:	33d27234 	.word	0x33d27234
33d0d580:	33d27240 	.word	0x33d27240
33d0d584:	33d2724c 	.word	0x33d2724c
33d0d588:	33d27254 	.word	0x33d27254
33d0d58c:	33d27264 	.word	0x33d27264
33d0d590:	33d2726c 	.word	0x33d2726c
33d0d594:	33d2727c 	.word	0x33d2727c

33d0d598 <do_go>:
#if defined(CONFIG_I386)
DECLARE_GLOBAL_DATA_PTR;
#endif

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d598:	e92d4070 	push	{r4, r5, r6, lr}
33d0d59c:	e1a06002 	mov	r6, r2
	ulong	addr, rc;
	int     rcode = 0;
33d0d5a0:	e3a04000 	mov	r4, #0	; 0x0

	if (argc < 2) {
33d0d5a4:	e3560001 	cmp	r6, #1	; 0x1
#if defined(CONFIG_I386)
DECLARE_GLOBAL_DATA_PTR;
#endif

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d5a8:	e1a05003 	mov	r5, r3
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	addr = simple_strtoul(argv[1], NULL, 16);
33d0d5ac:	e3a02010 	mov	r2, #16	; 0x10
#if defined(CONFIG_I386)
DECLARE_GLOBAL_DATA_PTR;
#endif

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d5b0:	e1a03000 	mov	r3, r0
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	addr = simple_strtoul(argv[1], NULL, 16);
33d0d5b4:	e1a01004 	mov	r1, r4
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0d5b8:	e59f0054 	ldr	r0, [pc, #84]	; 33d0d614 <do_go+0x7c>
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2) {
33d0d5bc:	ca000003 	bgt	33d0d5d0 <do_go+0x38>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0d5c0:	e5931010 	ldr	r1, [r3, #16]
33d0d5c4:	eb00267f 	bl	33d16fc8 <printf>
		return 1;
33d0d5c8:	e3a00001 	mov	r0, #1	; 0x1
33d0d5cc:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	addr = simple_strtoul(argv[1], NULL, 16);
33d0d5d0:	e5b50004 	ldr	r0, [r5, #4]!
33d0d5d4:	eb0033e0 	bl	33d1a55c <simple_strtoul>
33d0d5d8:	e1a04000 	mov	r4, r0

	printf ("## Starting application at 0x%08lX ...\n", addr);
33d0d5dc:	e1a01000 	mov	r1, r0
33d0d5e0:	e59f0030 	ldr	r0, [pc, #48]	; 33d0d618 <do_go+0x80>
33d0d5e4:	eb002677 	bl	33d16fc8 <printf>
	 * to the global_data
	 */
	argv[0] = (char *)gd;
#endif
#if !defined(CONFIG_NIOS)
	rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
33d0d5e8:	e1a01005 	mov	r1, r5
33d0d5ec:	e2460001 	sub	r0, r6, #1	; 0x1
33d0d5f0:	e1a0e00f 	mov	lr, pc
33d0d5f4:	e1a0f004 	mov	pc, r4
	/*
	 * Nios function pointers are address >> 1
	 */
	rc = ((ulong (*)(int, char *[]))(addr>>1)) (--argc, &argv[1]);
#endif
	if (rc != 0) rcode = 1;
33d0d5f8:	e1a01000 	mov	r1, r0
33d0d5fc:	e2504000 	subs	r4, r0, #0	; 0x0
33d0d600:	13a04001 	movne	r4, #1	; 0x1

	printf ("## Application terminated, rc = 0x%lX\n", rc);
33d0d604:	e59f0010 	ldr	r0, [pc, #16]	; 33d0d61c <do_go+0x84>
33d0d608:	eb00266e 	bl	33d16fc8 <printf>
	return rcode;
33d0d60c:	e1a00004 	mov	r0, r4
}
33d0d610:	e8bd8070 	pop	{r4, r5, r6, pc}
33d0d614:	33d27008 	.word	0x33d27008
33d0d618:	33d27350 	.word	0x33d27350
33d0d61c:	33d27378 	.word	0x33d27378

33d0d620 <do_bootd>:
#endif


#if (CONFIG_COMMANDS & CFG_CMD_BOOTD)
int do_bootd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d620:	e92d4010 	push	{r4, lr}
	int rcode = 0;
#ifndef CFG_HUSH_PARSER
	if (run_command (getenv ("bootcmd"), flag) < 0) rcode = 1;
33d0d624:	e59f0014 	ldr	r0, [pc, #20]	; 33d0d640 <do_bootd+0x20>
#endif


#if (CONFIG_COMMANDS & CFG_CMD_BOOTD)
int do_bootd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0d628:	e1a04001 	mov	r4, r1
	int rcode = 0;
#ifndef CFG_HUSH_PARSER
	if (run_command (getenv ("bootcmd"), flag) < 0) rcode = 1;
33d0d62c:	eb002087 	bl	33d15850 <getenv>
33d0d630:	e1a01004 	mov	r1, r4
33d0d634:	ebfffd69 	bl	33d0cbe0 <run_command>
#else
	if (parse_string_outer(getenv("bootcmd"),
		FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0 ) rcode = 1;
#endif
	return rcode;
}
33d0d638:	e1a00fa0 	lsr	r0, r0, #31
33d0d63c:	e8bd8010 	pop	{r4, pc}
33d0d640:	33d2703c 	.word	0x33d2703c

33d0d644 <print_image_hdr>:
);
#endif	/* CFG_CMD_IMLS */

void
print_image_hdr (image_header_t *hdr)
{
33d0d644:	e92d4070 	push	{r4, r5, r6, lr}
33d0d648:	e5902008 	ldr	r2, [r0, #8]
	return __arch__swab32(x);
33d0d64c:	e2024cff 	and	r4, r2, #65280	; 0xff00
33d0d650:	e1a04404 	lsl	r4, r4, #8
33d0d654:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
33d0d658:	e1844c02 	orr	r4, r4, r2, lsl #24
33d0d65c:	e1844423 	orr	r4, r4, r3, lsr #8
33d0d660:	e24dd030 	sub	sp, sp, #48	; 0x30
33d0d664:	e1a05000 	mov	r5, r0
33d0d668:	e1844c22 	orr	r4, r4, r2, lsr #24
#if (CONFIG_COMMANDS & CFG_CMD_DATE) || defined(CONFIG_TIMESTAMP)
	time_t timestamp = (time_t)ntohl(hdr->ih_time);
	struct rtc_time tm;
#endif

	printf ("   Image Name:   %.*s\n", IH_NMLEN, hdr->ih_name);
33d0d66c:	e3a01020 	mov	r1, #32	; 0x20
33d0d670:	e2802020 	add	r2, r0, #32	; 0x20
33d0d674:	e59f0368 	ldr	r0, [pc, #872]	; 33d0d9e4 <print_image_hdr+0x3a0>
33d0d678:	eb002652 	bl	33d16fc8 <printf>
#if (CONFIG_COMMANDS & CFG_CMD_DATE) || defined(CONFIG_TIMESTAMP)
	to_tm (timestamp, &tm);
33d0d67c:	e1a00004 	mov	r0, r4
33d0d680:	e28d100c 	add	r1, sp, #12	; 0xc
33d0d684:	eb0053db 	bl	33d225f8 <to_tm>
	printf ("   Created:      %4d-%02d-%02d  %2d:%02d:%02d UTC\n",
33d0d688:	e59dc014 	ldr	ip, [sp, #20]
33d0d68c:	e58dc000 	str	ip, [sp]
33d0d690:	e59dc010 	ldr	ip, [sp, #16]
33d0d694:	e58dc004 	str	ip, [sp, #4]
33d0d698:	e59dc00c 	ldr	ip, [sp, #12]
33d0d69c:	e59d3018 	ldr	r3, [sp, #24]
33d0d6a0:	e59d1020 	ldr	r1, [sp, #32]
33d0d6a4:	e59d201c 	ldr	r2, [sp, #28]
33d0d6a8:	e59f0338 	ldr	r0, [pc, #824]	; 33d0d9e8 <print_image_hdr+0x3a4>
33d0d6ac:	e58dc008 	str	ip, [sp, #8]
33d0d6b0:	eb002644 	bl	33d16fc8 <printf>
		tm.tm_year, tm.tm_mon, tm.tm_mday,
		tm.tm_hour, tm.tm_min, tm.tm_sec);
#endif	/* CFG_CMD_DATE, CONFIG_TIMESTAMP */
	puts ("   Image Type:   "); print_type(hdr);
33d0d6b4:	e59f0330 	ldr	r0, [pc, #816]	; 33d0d9ec <print_image_hdr+0x3a8>
33d0d6b8:	eb00263b 	bl	33d16fac <puts>
static void
print_type (image_header_t *hdr)
{
	char *os, *arch, *type, *comp;

	switch (hdr->ih_os) {
33d0d6bc:	e5d5301c 	ldrb	r3, [r5, #28]
33d0d6c0:	e3530012 	cmp	r3, #18	; 0x12
33d0d6c4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d0d6c8:	ea000020 	b	33d0d750 <print_image_hdr+0x10c>
33d0d6cc:	33d0d718 	.word	0x33d0d718
33d0d6d0:	33d0d750 	.word	0x33d0d750
33d0d6d4:	33d0d720 	.word	0x33d0d720
33d0d6d8:	33d0d750 	.word	0x33d0d750
33d0d6dc:	33d0d750 	.word	0x33d0d750
33d0d6e0:	33d0d728 	.word	0x33d0d728
33d0d6e4:	33d0d750 	.word	0x33d0d750
33d0d6e8:	33d0d750 	.word	0x33d0d750
33d0d6ec:	33d0d750 	.word	0x33d0d750
33d0d6f0:	33d0d750 	.word	0x33d0d750
33d0d6f4:	33d0d750 	.word	0x33d0d750
33d0d6f8:	33d0d750 	.word	0x33d0d750
33d0d6fc:	33d0d750 	.word	0x33d0d750
33d0d700:	33d0d750 	.word	0x33d0d750
33d0d704:	33d0d730 	.word	0x33d0d730
33d0d708:	33d0d750 	.word	0x33d0d750
33d0d70c:	33d0d738 	.word	0x33d0d738
33d0d710:	33d0d740 	.word	0x33d0d740
33d0d714:	33d0d748 	.word	0x33d0d748
	case IH_OS_INVALID:	os = "Invalid OS";		break;
33d0d718:	e59f22d0 	ldr	r2, [pc, #720]	; 33d0d9f0 <print_image_hdr+0x3ac>
33d0d71c:	ea00000c 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_NETBSD:	os = "NetBSD";			break;
33d0d720:	e59f22cc 	ldr	r2, [pc, #716]	; 33d0d9f4 <print_image_hdr+0x3b0>
33d0d724:	ea00000a 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_LINUX:	os = "Linux";			break;
33d0d728:	e59f22c8 	ldr	r2, [pc, #712]	; 33d0d9f8 <print_image_hdr+0x3b4>
33d0d72c:	ea000008 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_VXWORKS:	os = "VxWorks";			break;
33d0d730:	e59f22c4 	ldr	r2, [pc, #708]	; 33d0d9fc <print_image_hdr+0x3b8>
33d0d734:	ea000006 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_QNX:		os = "QNX";			break;
33d0d738:	e59f22c0 	ldr	r2, [pc, #704]	; 33d0da00 <print_image_hdr+0x3bc>
33d0d73c:	ea000004 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_U_BOOT:	os = "U-Boot";			break;
33d0d740:	e59f22bc 	ldr	r2, [pc, #700]	; 33d0da04 <print_image_hdr+0x3c0>
33d0d744:	ea000002 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_RTEMS:	os = "RTEMS";			break;
33d0d748:	e59f22b8 	ldr	r2, [pc, #696]	; 33d0da08 <print_image_hdr+0x3c4>
33d0d74c:	ea000000 	b	33d0d754 <print_image_hdr+0x110>
	case IH_OS_ARTOS:	os = "ARTOS";			break;
#endif
#ifdef CONFIG_LYNXKDI
	case IH_OS_LYNXOS:	os = "LynxOS";			break;
#endif
	default:		os = "Unknown OS";		break;
33d0d750:	e59f22b4 	ldr	r2, [pc, #692]	; 33d0da0c <print_image_hdr+0x3c8>
	}

	switch (hdr->ih_arch) {
33d0d754:	e5d5301d 	ldrb	r3, [r5, #29]
33d0d758:	e3530011 	cmp	r3, #17	; 0x11
33d0d75c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d0d760:	ea000033 	b	33d0d834 <print_image_hdr+0x1f0>
33d0d764:	33d0d7ac 	.word	0x33d0d7ac
33d0d768:	33d0d7b4 	.word	0x33d0d7b4
33d0d76c:	33d0d7bc 	.word	0x33d0d7bc
33d0d770:	33d0d7cc 	.word	0x33d0d7cc
33d0d774:	33d0d7d4 	.word	0x33d0d7d4
33d0d778:	33d0d7dc 	.word	0x33d0d7dc
33d0d77c:	33d0d7e4 	.word	0x33d0d7e4
33d0d780:	33d0d7ec 	.word	0x33d0d7ec
33d0d784:	33d0d7f4 	.word	0x33d0d7f4
33d0d788:	33d0d7fc 	.word	0x33d0d7fc
33d0d78c:	33d0d804 	.word	0x33d0d804
33d0d790:	33d0d80c 	.word	0x33d0d80c
33d0d794:	33d0d814 	.word	0x33d0d814
33d0d798:	33d0d824 	.word	0x33d0d824
33d0d79c:	33d0d81c 	.word	0x33d0d81c
33d0d7a0:	33d0d82c 	.word	0x33d0d82c
33d0d7a4:	33d0d834 	.word	0x33d0d834
33d0d7a8:	33d0d7c4 	.word	0x33d0d7c4
	case IH_CPU_INVALID:	arch = "Invalid CPU";		break;
33d0d7ac:	e59f125c 	ldr	r1, [pc, #604]	; 33d0da10 <print_image_hdr+0x3cc>
33d0d7b0:	ea000020 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_ALPHA:	arch = "Alpha";			break;
33d0d7b4:	e59f1258 	ldr	r1, [pc, #600]	; 33d0da14 <print_image_hdr+0x3d0>
33d0d7b8:	ea00001e 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_ARM:	arch = "ARM";			break;
33d0d7bc:	e59f1254 	ldr	r1, [pc, #596]	; 33d0da18 <print_image_hdr+0x3d4>
33d0d7c0:	ea00001c 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_AVR32:	arch = "AVR32";			break;
33d0d7c4:	e59f1250 	ldr	r1, [pc, #592]	; 33d0da1c <print_image_hdr+0x3d8>
33d0d7c8:	ea00001a 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_I386:	arch = "Intel x86";		break;
33d0d7cc:	e59f124c 	ldr	r1, [pc, #588]	; 33d0da20 <print_image_hdr+0x3dc>
33d0d7d0:	ea000018 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_IA64:	arch = "IA64";			break;
33d0d7d4:	e59f1248 	ldr	r1, [pc, #584]	; 33d0da24 <print_image_hdr+0x3e0>
33d0d7d8:	ea000016 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_MIPS:	arch = "MIPS";			break;
33d0d7dc:	e59f1244 	ldr	r1, [pc, #580]	; 33d0da28 <print_image_hdr+0x3e4>
33d0d7e0:	ea000014 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_MIPS64:	arch = "MIPS 64 Bit";		break;
33d0d7e4:	e59f1240 	ldr	r1, [pc, #576]	; 33d0da2c <print_image_hdr+0x3e8>
33d0d7e8:	ea000012 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_PPC:	arch = "PowerPC";		break;
33d0d7ec:	e59f123c 	ldr	r1, [pc, #572]	; 33d0da30 <print_image_hdr+0x3ec>
33d0d7f0:	ea000010 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_S390:	arch = "IBM S390";		break;
33d0d7f4:	e59f1238 	ldr	r1, [pc, #568]	; 33d0da34 <print_image_hdr+0x3f0>
33d0d7f8:	ea00000e 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_SH:		arch = "SuperH";		break;
33d0d7fc:	e59f1234 	ldr	r1, [pc, #564]	; 33d0da38 <print_image_hdr+0x3f4>
33d0d800:	ea00000c 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_SPARC:	arch = "SPARC";			break;
33d0d804:	e59f1230 	ldr	r1, [pc, #560]	; 33d0da3c <print_image_hdr+0x3f8>
33d0d808:	ea00000a 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_SPARC64:	arch = "SPARC 64 Bit";		break;
33d0d80c:	e59f122c 	ldr	r1, [pc, #556]	; 33d0da40 <print_image_hdr+0x3fc>
33d0d810:	ea000008 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_M68K:	arch = "M68K"; 			break;
33d0d814:	e59f1228 	ldr	r1, [pc, #552]	; 33d0da44 <print_image_hdr+0x400>
33d0d818:	ea000006 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_MICROBLAZE:	arch = "Microblaze"; 		break;
33d0d81c:	e59f1224 	ldr	r1, [pc, #548]	; 33d0da48 <print_image_hdr+0x404>
33d0d820:	ea000004 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_NIOS:	arch = "Nios";			break;
33d0d824:	e59f1220 	ldr	r1, [pc, #544]	; 33d0da4c <print_image_hdr+0x408>
33d0d828:	ea000002 	b	33d0d838 <print_image_hdr+0x1f4>
	case IH_CPU_NIOS2:	arch = "Nios-II";		break;
33d0d82c:	e59f121c 	ldr	r1, [pc, #540]	; 33d0da50 <print_image_hdr+0x40c>
33d0d830:	ea000000 	b	33d0d838 <print_image_hdr+0x1f4>
	default:		arch = "Unknown Architecture";	break;
33d0d834:	e59f1218 	ldr	r1, [pc, #536]	; 33d0da54 <print_image_hdr+0x410>
	}

	switch (hdr->ih_type) {
33d0d838:	e5d5301e 	ldrb	r3, [r5, #30]
33d0d83c:	e3530008 	cmp	r3, #8	; 0x8
33d0d840:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d0d844:	ea000018 	b	33d0d8ac <print_image_hdr+0x268>
33d0d848:	33d0d86c 	.word	0x33d0d86c
33d0d84c:	33d0d874 	.word	0x33d0d874
33d0d850:	33d0d87c 	.word	0x33d0d87c
33d0d854:	33d0d884 	.word	0x33d0d884
33d0d858:	33d0d88c 	.word	0x33d0d88c
33d0d85c:	33d0d894 	.word	0x33d0d894
33d0d860:	33d0d89c 	.word	0x33d0d89c
33d0d864:	33d0d8ac 	.word	0x33d0d8ac
33d0d868:	33d0d8a4 	.word	0x33d0d8a4
	case IH_TYPE_INVALID:	type = "Invalid Image";		break;
33d0d86c:	e59f31e4 	ldr	r3, [pc, #484]	; 33d0da58 <print_image_hdr+0x414>
33d0d870:	ea00000e 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_STANDALONE:type = "Standalone Program";	break;
33d0d874:	e59f31e0 	ldr	r3, [pc, #480]	; 33d0da5c <print_image_hdr+0x418>
33d0d878:	ea00000c 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_KERNEL:	type = "Kernel Image";		break;
33d0d87c:	e59f31dc 	ldr	r3, [pc, #476]	; 33d0da60 <print_image_hdr+0x41c>
33d0d880:	ea00000a 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_RAMDISK:	type = "RAMDisk Image";		break;
33d0d884:	e59f31d8 	ldr	r3, [pc, #472]	; 33d0da64 <print_image_hdr+0x420>
33d0d888:	ea000008 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_MULTI:	type = "Multi-File Image";	break;
33d0d88c:	e59f31d4 	ldr	r3, [pc, #468]	; 33d0da68 <print_image_hdr+0x424>
33d0d890:	ea000006 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_FIRMWARE:	type = "Firmware";		break;
33d0d894:	e59f31d0 	ldr	r3, [pc, #464]	; 33d0da6c <print_image_hdr+0x428>
33d0d898:	ea000004 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_SCRIPT:	type = "Script";		break;
33d0d89c:	e59f31cc 	ldr	r3, [pc, #460]	; 33d0da70 <print_image_hdr+0x42c>
33d0d8a0:	ea000002 	b	33d0d8b0 <print_image_hdr+0x26c>
	case IH_TYPE_FLATDT:	type = "Flat Device Tree";	break;
33d0d8a4:	e59f31c8 	ldr	r3, [pc, #456]	; 33d0da74 <print_image_hdr+0x430>
33d0d8a8:	ea000000 	b	33d0d8b0 <print_image_hdr+0x26c>
	default:		type = "Unknown Image";		break;
33d0d8ac:	e59f31c4 	ldr	r3, [pc, #452]	; 33d0da78 <print_image_hdr+0x434>
	}

	switch (hdr->ih_comp) {
33d0d8b0:	e5d5001f 	ldrb	r0, [r5, #31]
33d0d8b4:	e3500001 	cmp	r0, #1	; 0x1
	case IH_COMP_NONE:	comp = "uncompressed";		break;
	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
33d0d8b8:	059fc1bc 	ldreq	ip, [pc, #444]	; 33d0da7c <print_image_hdr+0x438>
	case IH_TYPE_SCRIPT:	type = "Script";		break;
	case IH_TYPE_FLATDT:	type = "Flat Device Tree";	break;
	default:		type = "Unknown Image";		break;
	}

	switch (hdr->ih_comp) {
33d0d8bc:	0a000008 	beq	33d0d8e4 <print_image_hdr+0x2a0>
33d0d8c0:	ca000003 	bgt	33d0d8d4 <print_image_hdr+0x290>
33d0d8c4:	e3500000 	cmp	r0, #0	; 0x0
	case IH_COMP_NONE:	comp = "uncompressed";		break;
33d0d8c8:	059fc1b0 	ldreq	ip, [pc, #432]	; 33d0da80 <print_image_hdr+0x43c>
	case IH_TYPE_SCRIPT:	type = "Script";		break;
	case IH_TYPE_FLATDT:	type = "Flat Device Tree";	break;
	default:		type = "Unknown Image";		break;
	}

	switch (hdr->ih_comp) {
33d0d8cc:	0a000004 	beq	33d0d8e4 <print_image_hdr+0x2a0>
33d0d8d0:	ea000002 	b	33d0d8e0 <print_image_hdr+0x29c>
33d0d8d4:	e3500002 	cmp	r0, #2	; 0x2
	case IH_COMP_NONE:	comp = "uncompressed";		break;
	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
33d0d8d8:	059fc1a4 	ldreq	ip, [pc, #420]	; 33d0da84 <print_image_hdr+0x440>
	case IH_TYPE_SCRIPT:	type = "Script";		break;
	case IH_TYPE_FLATDT:	type = "Flat Device Tree";	break;
	default:		type = "Unknown Image";		break;
	}

	switch (hdr->ih_comp) {
33d0d8dc:	0a000000 	beq	33d0d8e4 <print_image_hdr+0x2a0>
	case IH_COMP_NONE:	comp = "uncompressed";		break;
	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
	default:		comp = "unknown compression";	break;
33d0d8e0:	e59fc1a0 	ldr	ip, [pc, #416]	; 33d0da88 <print_image_hdr+0x444>
	}

	printf ("%s %s %s (%s)", arch, os, type, comp);
33d0d8e4:	e59f01a0 	ldr	r0, [pc, #416]	; 33d0da8c <print_image_hdr+0x448>
33d0d8e8:	e58dc000 	str	ip, [sp]
33d0d8ec:	eb0025b5 	bl	33d16fc8 <printf>
33d0d8f0:	e595200c 	ldr	r2, [r5, #12]
33d0d8f4:	e2021cff 	and	r1, r2, #65280	; 0xff00
33d0d8f8:	e1a01401 	lsl	r1, r1, #8
33d0d8fc:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
33d0d900:	e1811c02 	orr	r1, r1, r2, lsl #24
33d0d904:	e1811423 	orr	r1, r1, r3, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d908:	e1811c22 	orr	r1, r1, r2, lsr #24
33d0d90c:	e59f017c 	ldr	r0, [pc, #380]	; 33d0da90 <print_image_hdr+0x44c>
33d0d910:	eb0025ac 	bl	33d16fc8 <printf>
33d0d914:	e595200c 	ldr	r2, [r5, #12]
	return __arch__swab32(x);
33d0d918:	e2020cff 	and	r0, r2, #65280	; 0xff00
33d0d91c:	e1a00400 	lsl	r0, r0, #8
33d0d920:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
33d0d924:	e1800c02 	orr	r0, r0, r2, lsl #24
33d0d928:	e1800423 	orr	r0, r0, r3, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d92c:	e1800c22 	orr	r0, r0, r2, lsr #24
33d0d930:	e59f115c 	ldr	r1, [pc, #348]	; 33d0da94 <print_image_hdr+0x450>
33d0d934:	eb00317b 	bl	33d19f28 <print_size>
33d0d938:	e285c010 	add	ip, r5, #16	; 0x10
33d0d93c:	e89c5000 	ldm	ip, {ip, lr}
	return __arch__swab32(x);
33d0d940:	e20e2cff 	and	r2, lr, #65280	; 0xff00
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d944:	e20c1cff 	and	r1, ip, #65280	; 0xff00
	return __arch__swab32(x);
33d0d948:	e1a02402 	lsl	r2, r2, #8
33d0d94c:	e1a01401 	lsl	r1, r1, #8
33d0d950:	e20e38ff 	and	r3, lr, #16711680	; 0xff0000
33d0d954:	e20c08ff 	and	r0, ip, #16711680	; 0xff0000
33d0d958:	e1822c0e 	orr	r2, r2, lr, lsl #24
33d0d95c:	e1811c0c 	orr	r1, r1, ip, lsl #24
33d0d960:	e1822423 	orr	r2, r2, r3, lsr #8
33d0d964:	e1811420 	orr	r1, r1, r0, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d968:	e1811c2c 	orr	r1, r1, ip, lsr #24
33d0d96c:	e1822c2e 	orr	r2, r2, lr, lsr #24
33d0d970:	e59f0120 	ldr	r0, [pc, #288]	; 33d0da98 <print_image_hdr+0x454>
33d0d974:	eb002593 	bl	33d16fc8 <printf>
	print_size (ntohl(hdr->ih_size), "\n");
	printf ("   Load Address: %08x\n"
		"   Entry Point:  %08x\n",
		 ntohl(hdr->ih_load), ntohl(hdr->ih_ep));

	if (hdr->ih_type == IH_TYPE_MULTI) {
33d0d978:	e5d5301e 	ldrb	r3, [r5, #30]
33d0d97c:	e3530004 	cmp	r3, #4	; 0x4
33d0d980:	1a000015 	bne	33d0d9dc <print_image_hdr+0x398>
		int i;
		ulong len;
		ulong *len_ptr = (ulong *)((ulong)hdr + sizeof(image_header_t));

		puts ("   Contents:\n");
33d0d984:	e59f0110 	ldr	r0, [pc, #272]	; 33d0da9c <print_image_hdr+0x458>
33d0d988:	eb002587 	bl	33d16fac <puts>
		 ntohl(hdr->ih_load), ntohl(hdr->ih_ep));

	if (hdr->ih_type == IH_TYPE_MULTI) {
		int i;
		ulong len;
		ulong *len_ptr = (ulong *)((ulong)hdr + sizeof(image_header_t));
33d0d98c:	e2855040 	add	r5, r5, #64	; 0x40

		puts ("   Contents:\n");
		for (i=0; (len = ntohl(*len_ptr)); ++i, ++len_ptr) {
33d0d990:	e3a06000 	mov	r6, #0	; 0x0
33d0d994:	ea000003 	b	33d0d9a8 <print_image_hdr+0x364>
			printf ("   Image %d: %8ld Bytes = ", i, len);
33d0d998:	eb00258a 	bl	33d16fc8 <printf>
			print_size (len, "\n");
33d0d99c:	e1a00004 	mov	r0, r4
33d0d9a0:	e59f10ec 	ldr	r1, [pc, #236]	; 33d0da94 <print_image_hdr+0x450>
33d0d9a4:	eb00315f 	bl	33d19f28 <print_size>
33d0d9a8:	e5953000 	ldr	r3, [r5]
	return __arch__swab32(x);
33d0d9ac:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0d9b0:	e1a02402 	lsl	r2, r2, #8
33d0d9b4:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0d9b8:	e203c8ff 	and	ip, r3, #16711680	; 0xff0000
33d0d9bc:	e182242c 	orr	r2, r2, ip, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0d9c0:	e1924c23 	orrs	r4, r2, r3, lsr #24
		ulong len;
		ulong *len_ptr = (ulong *)((ulong)hdr + sizeof(image_header_t));

		puts ("   Contents:\n");
		for (i=0; (len = ntohl(*len_ptr)); ++i, ++len_ptr) {
			printf ("   Image %d: %8ld Bytes = ", i, len);
33d0d9c4:	e1a01006 	mov	r1, r6
33d0d9c8:	e59f00d0 	ldr	r0, [pc, #208]	; 33d0daa0 <print_image_hdr+0x45c>
33d0d9cc:	e1a02004 	mov	r2, r4
		int i;
		ulong len;
		ulong *len_ptr = (ulong *)((ulong)hdr + sizeof(image_header_t));

		puts ("   Contents:\n");
		for (i=0; (len = ntohl(*len_ptr)); ++i, ++len_ptr) {
33d0d9d0:	e2866001 	add	r6, r6, #1	; 0x1
33d0d9d4:	e2855004 	add	r5, r5, #4	; 0x4
33d0d9d8:	1affffee 	bne	33d0d998 <print_image_hdr+0x354>
			printf ("   Image %d: %8ld Bytes = ", i, len);
			print_size (len, "\n");
		}
	}
}
33d0d9dc:	e28dd030 	add	sp, sp, #48	; 0x30
33d0d9e0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d0d9e4:	33d27690 	.word	0x33d27690
33d0d9e8:	33d276a8 	.word	0x33d276a8
33d0d9ec:	33d276dc 	.word	0x33d276dc
33d0d9f0:	33d276f0 	.word	0x33d276f0
33d0d9f4:	33d276fc 	.word	0x33d276fc
33d0d9f8:	33d27704 	.word	0x33d27704
33d0d9fc:	33d2770c 	.word	0x33d2770c
33d0da00:	33d27714 	.word	0x33d27714
33d0da04:	33d27718 	.word	0x33d27718
33d0da08:	33d27720 	.word	0x33d27720
33d0da0c:	33d27728 	.word	0x33d27728
33d0da10:	33d27734 	.word	0x33d27734
33d0da14:	33d27740 	.word	0x33d27740
33d0da18:	33d27748 	.word	0x33d27748
33d0da1c:	33d2774c 	.word	0x33d2774c
33d0da20:	33d27754 	.word	0x33d27754
33d0da24:	33d27760 	.word	0x33d27760
33d0da28:	33d27768 	.word	0x33d27768
33d0da2c:	33d27770 	.word	0x33d27770
33d0da30:	33d2777c 	.word	0x33d2777c
33d0da34:	33d27784 	.word	0x33d27784
33d0da38:	33d27790 	.word	0x33d27790
33d0da3c:	33d27798 	.word	0x33d27798
33d0da40:	33d277a0 	.word	0x33d277a0
33d0da44:	33d277b0 	.word	0x33d277b0
33d0da48:	33d277b8 	.word	0x33d277b8
33d0da4c:	33d277c4 	.word	0x33d277c4
33d0da50:	33d277cc 	.word	0x33d277cc
33d0da54:	33d277d4 	.word	0x33d277d4
33d0da58:	33d277ec 	.word	0x33d277ec
33d0da5c:	33d277fc 	.word	0x33d277fc
33d0da60:	33d27810 	.word	0x33d27810
33d0da64:	33d27820 	.word	0x33d27820
33d0da68:	33d27830 	.word	0x33d27830
33d0da6c:	33d27844 	.word	0x33d27844
33d0da70:	33d27850 	.word	0x33d27850
33d0da74:	33d27858 	.word	0x33d27858
33d0da78:	33d2786c 	.word	0x33d2786c
33d0da7c:	33d2787c 	.word	0x33d2787c
33d0da80:	33d2788c 	.word	0x33d2788c
33d0da84:	33d2789c 	.word	0x33d2789c
33d0da88:	33d278b0 	.word	0x33d278b0
33d0da8c:	33d278c4 	.word	0x33d278c4
33d0da90:	33d278d4 	.word	0x33d278d4
33d0da94:	33d2bd80 	.word	0x33d2bd80
33d0da98:	33d278f4 	.word	0x33d278f4
33d0da9c:	33d27924 	.word	0x33d27924
33d0daa0:	33d27934 	.word	0x33d27934

33d0daa4 <image_info>:
	}
	return rcode;
}

static int image_info (ulong addr)
{
33d0daa4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	data, len, checksum;
	image_header_t *hdr = &header;
33d0daa8:	e59f610c 	ldr	r6, [pc, #268]	; 33d0dbbc <image_info+0x118>

	printf ("\n## Checking Image at %08lx ...\n", addr);
33d0daac:	e1a01000 	mov	r1, r0
	}
	return rcode;
}

static int image_info (ulong addr)
{
33d0dab0:	e1a05000 	mov	r5, r0
	ulong	data, len, checksum;
	image_header_t *hdr = &header;

	printf ("\n## Checking Image at %08lx ...\n", addr);
33d0dab4:	e59f0104 	ldr	r0, [pc, #260]	; 33d0dbc0 <image_info+0x11c>
33d0dab8:	eb002542 	bl	33d16fc8 <printf>

	/* Copy header so we can blank CRC field for re-calculation */
	memmove (&header, (char *)addr, sizeof(image_header_t));
33d0dabc:	e1a01005 	mov	r1, r5
33d0dac0:	e3a02040 	mov	r2, #64	; 0x40
33d0dac4:	e1a00006 	mov	r0, r6
33d0dac8:	eb00324f 	bl	33d1a40c <memmove>
33d0dacc:	e596e000 	ldr	lr, [r6]
	return __arch__swab32(x);
33d0dad0:	e20e3cff 	and	r3, lr, #65280	; 0xff00
33d0dad4:	e1a03403 	lsl	r3, r3, #8
33d0dad8:	e20ec8ff 	and	ip, lr, #16711680	; 0xff0000
33d0dadc:	e1833c0e 	orr	r3, r3, lr, lsl #24
33d0dae0:	e183342c 	orr	r3, r3, ip, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0dae4:	e59fc0d8 	ldr	ip, [pc, #216]	; 33d0dbc4 <image_info+0x120>
	return __arch__swab32(x);
33d0dae8:	e1833c2e 	orr	r3, r3, lr, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0daec:	e153000c 	cmp	r3, ip
	len  = sizeof(image_header_t);

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;

	if (crc32 (0, (uchar *)data, len) != checksum) {
33d0daf0:	e1a01006 	mov	r1, r6
33d0daf4:	e3a02040 	mov	r2, #64	; 0x40

	/* Copy header so we can blank CRC field for re-calculation */
	memmove (&header, (char *)addr, sizeof(image_header_t));

	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
		puts ("   Bad Magic Number\n");
33d0daf8:	e59f00c8 	ldr	r0, [pc, #200]	; 33d0dbc8 <image_info+0x124>
	printf ("\n## Checking Image at %08lx ...\n", addr);

	/* Copy header so we can blank CRC field for re-calculation */
	memmove (&header, (char *)addr, sizeof(image_header_t));

	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
33d0dafc:	e3a07000 	mov	r7, #0	; 0x0
33d0db00:	1a00000e 	bne	33d0db40 <image_info+0x9c>
33d0db04:	e5963004 	ldr	r3, [r6, #4]
	return __arch__swab32(x);
33d0db08:	e2034cff 	and	r4, r3, #65280	; 0xff00
33d0db0c:	e1a04404 	lsl	r4, r4, #8
33d0db10:	e20308ff 	and	r0, r3, #16711680	; 0xff0000
33d0db14:	e1844c03 	orr	r4, r4, r3, lsl #24
33d0db18:	e1844420 	orr	r4, r4, r0, lsr #8
	len  = sizeof(image_header_t);

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;

	if (crc32 (0, (uchar *)data, len) != checksum) {
33d0db1c:	e1a00007 	mov	r0, r7
33d0db20:	e1844c23 	orr	r4, r4, r3, lsr #24

	data = (ulong)&header;
	len  = sizeof(image_header_t);

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;
33d0db24:	e5867004 	str	r7, [r6, #4]

	if (crc32 (0, (uchar *)data, len) != checksum) {
33d0db28:	eb00307a 	bl	33d19d18 <crc32>
33d0db2c:	e1500004 	cmp	r0, r4
	}

	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);

	data = addr + sizeof(image_header_t);
33d0db30:	e285a040 	add	sl, r5, #64	; 0x40
		puts ("   Bad Header Checksum\n");
		return 1;
	}

	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);
33d0db34:	e1a00005 	mov	r0, r5
	len  = sizeof(image_header_t);

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;

	if (crc32 (0, (uchar *)data, len) != checksum) {
33d0db38:	0a000003 	beq	33d0db4c <image_info+0xa8>
		puts ("   Bad Header Checksum\n");
33d0db3c:	e59f0088 	ldr	r0, [pc, #136]	; 33d0dbcc <image_info+0x128>
33d0db40:	eb002519 	bl	33d16fac <puts>
		return 1;
33d0db44:	e3a00001 	mov	r0, #1	; 0x1
33d0db48:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);
33d0db4c:	ebfffebc 	bl	33d0d644 <print_image_hdr>
33d0db50:	e596200c 	ldr	r2, [r6, #12]
33d0db54:	e2024cff 	and	r4, r2, #65280	; 0xff00
33d0db58:	e1a04404 	lsl	r4, r4, #8
33d0db5c:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
33d0db60:	e1844c02 	orr	r4, r4, r2, lsl #24
33d0db64:	e1844423 	orr	r4, r4, r3, lsr #8
33d0db68:	e1844c22 	orr	r4, r4, r2, lsr #24

	data = addr + sizeof(image_header_t);
	len  = ntohl(hdr->ih_size);

	puts ("   Verifying Checksum ... ");
33d0db6c:	e59f005c 	ldr	r0, [pc, #92]	; 33d0dbd0 <image_info+0x12c>
33d0db70:	eb00250d 	bl	33d16fac <puts>
	if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
33d0db74:	e1a0100a 	mov	r1, sl
33d0db78:	e1a02004 	mov	r2, r4
33d0db7c:	e1a00007 	mov	r0, r7
33d0db80:	eb003064 	bl	33d19d18 <crc32>
33d0db84:	e5961018 	ldr	r1, [r6, #24]
33d0db88:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d0db8c:	e1a03403 	lsl	r3, r3, #8
33d0db90:	e1833c01 	orr	r3, r3, r1, lsl #24
33d0db94:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d0db98:	e1833422 	orr	r3, r3, r2, lsr #8
33d0db9c:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0dba0:	e1500003 	cmp	r0, r3
		puts ("   Bad Data CRC\n");
33d0dba4:	e59f0028 	ldr	r0, [pc, #40]	; 33d0dbd4 <image_info+0x130>
33d0dba8:	1affffe4 	bne	33d0db40 <image_info+0x9c>
		return 1;
	}
	puts ("OK\n");
33d0dbac:	e59f0024 	ldr	r0, [pc, #36]	; 33d0dbd8 <image_info+0x134>
33d0dbb0:	eb0024fd 	bl	33d16fac <puts>
	return 0;
33d0dbb4:	e1a00007 	mov	r0, r7
}
33d0dbb8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0dbbc:	33d60888 	.word	0x33d60888
33d0dbc0:	33d27950 	.word	0x33d27950
33d0dbc4:	27051956 	.word	0x27051956
33d0dbc8:	33d27974 	.word	0x33d27974
33d0dbcc:	33d2798c 	.word	0x33d2798c
33d0dbd0:	33d279a4 	.word	0x33d279a4
33d0dbd4:	33d279c0 	.word	0x33d279c0
33d0dbd8:	33d279d4 	.word	0x33d279d4

33d0dbdc <do_iminfo>:
{
	int	arg;
	ulong	addr;
	int     rcode=0;

	if (argc < 2) {
33d0dbdc:	e3520001 	cmp	r2, #1	; 0x1

#endif

#if (CONFIG_COMMANDS & CFG_CMD_IMI)
int do_iminfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0dbe0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d0dbe4:	e1a04002 	mov	r4, r2
33d0dbe8:	e1a07003 	mov	r7, r3
	int	arg;
	ulong	addr;
	int     rcode=0;
33d0dbec:	e3a06000 	mov	r6, #0	; 0x0

	if (argc < 2) {
		return image_info (load_addr);
	}

	for (arg=1; arg <argc; ++arg) {
33d0dbf0:	c3a05001 	movgt	r5, #1	; 0x1
{
	int	arg;
	ulong	addr;
	int     rcode=0;

	if (argc < 2) {
33d0dbf4:	ca000003 	bgt	33d0dc08 <do_iminfo+0x2c>
		return image_info (load_addr);
33d0dbf8:	e59f303c 	ldr	r3, [pc, #60]	; 33d0dc3c <do_iminfo+0x60>
33d0dbfc:	e5930000 	ldr	r0, [r3]
	for (arg=1; arg <argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info (addr) != 0) rcode = 1;
	}
	return rcode;
}
33d0dc00:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
	int	arg;
	ulong	addr;
	int     rcode=0;

	if (argc < 2) {
		return image_info (load_addr);
33d0dc04:	eaffffa6 	b	33d0daa4 <image_info>
	}

	for (arg=1; arg <argc; ++arg) {
33d0dc08:	e1550004 	cmp	r5, r4
33d0dc0c:	aa000008 	bge	33d0dc34 <do_iminfo+0x58>
		addr = simple_strtoul(argv[arg], NULL, 16);
33d0dc10:	e7970105 	ldr	r0, [r7, r5, lsl #2]
33d0dc14:	e3a01000 	mov	r1, #0	; 0x0
33d0dc18:	e3a02010 	mov	r2, #16	; 0x10
33d0dc1c:	eb00324e 	bl	33d1a55c <simple_strtoul>
		if (image_info (addr) != 0) rcode = 1;
33d0dc20:	ebffff9f 	bl	33d0daa4 <image_info>
33d0dc24:	e3500000 	cmp	r0, #0	; 0x0

	if (argc < 2) {
		return image_info (load_addr);
	}

	for (arg=1; arg <argc; ++arg) {
33d0dc28:	e2855001 	add	r5, r5, #1	; 0x1
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info (addr) != 0) rcode = 1;
33d0dc2c:	13a06001 	movne	r6, #1	; 0x1
33d0dc30:	eafffff4 	b	33d0dc08 <do_iminfo+0x2c>
	}
	return rcode;
}
33d0dc34:	e1a00006 	mov	r0, r6
33d0dc38:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0dc3c:	33d35fec 	.word	0x33d35fec

33d0dc40 <zalloc>:

static void *zalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
33d0dc40:	e0000291 	mul	r0, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
33d0dc44:	e280000f 	add	r0, r0, #15	; 0xf

	p = malloc (size);
33d0dc48:	e3c0000f 	bic	r0, r0, #15	; 0xf
33d0dc4c:	ea002685 	b	33d17668 <malloc>

33d0dc50 <zfree>:
	return (p);
}

static void zfree(void *x, void *addr, unsigned nb)
{
	free (addr);
33d0dc50:	e1a00001 	mov	r0, r1
33d0dc54:	ea0025fe 	b	33d17454 <free>

33d0dc58 <gunzip>:
#define RESERVED	0xe0

#define DEFLATED	8

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
33d0dc58:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0dc5c:	e1a04002 	mov	r4, r2
	int r, i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
33d0dc60:	e5d22002 	ldrb	r2, [r2, #2]
	z_stream s;
	int r, i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
33d0dc64:	e5d4c003 	ldrb	ip, [r4, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
33d0dc68:	e3520008 	cmp	r2, #8	; 0x8
#define RESERVED	0xe0

#define DEFLATED	8

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
33d0dc6c:	e1a0b001 	mov	fp, r1
33d0dc70:	e24dd034 	sub	sp, sp, #52	; 0x34
33d0dc74:	e1a09000 	mov	r9, r0
33d0dc78:	e1a07003 	mov	r7, r3
	z_stream s;
	int r, i, flags;

	/* skip header */
	i = 10;
33d0dc7c:	e3a0500a 	mov	r5, #10	; 0xa
	flags = src[3];
33d0dc80:	e20c10ff 	and	r1, ip, #255	; 0xff
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
33d0dc84:	1a000001 	bne	33d0dc90 <gunzip+0x38>
33d0dc88:	e31c00e0 	tst	ip, #224	; 0xe0
33d0dc8c:	0a000001 	beq	33d0dc98 <gunzip+0x40>
		puts ("Error: Bad gzipped data\n");
33d0dc90:	e59f0104 	ldr	r0, [pc, #260]	; 33d0dd9c <gunzip+0x144>
33d0dc94:	ea000018 	b	33d0dcfc <gunzip+0xa4>
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
33d0dc98:	e31c0004 	tst	ip, #4	; 0x4
		i = 12 + src[10] + (src[11] << 8);
33d0dc9c:	15d4300a 	ldrbne	r3, [r4, #10]
33d0dca0:	15d4200b 	ldrbne	r2, [r4, #11]
33d0dca4:	10833402 	addne	r3, r3, r2, lsl #8
33d0dca8:	1283500c 	addne	r5, r3, #12	; 0xc
	if ((flags & ORIG_NAME) != 0)
33d0dcac:	e31c0008 	tst	ip, #8	; 0x8
33d0dcb0:	0a000004 	beq	33d0dcc8 <gunzip+0x70>
		while (src[i++] != 0)
33d0dcb4:	e0853004 	add	r3, r5, r4
33d0dcb8:	e5d33000 	ldrb	r3, [r3]
33d0dcbc:	e3530000 	cmp	r3, #0	; 0x0
33d0dcc0:	e2855001 	add	r5, r5, #1	; 0x1
33d0dcc4:	1afffffa 	bne	33d0dcb4 <gunzip+0x5c>
			;
	if ((flags & COMMENT) != 0)
33d0dcc8:	e3110010 	tst	r1, #16	; 0x10
33d0dccc:	0a000004 	beq	33d0dce4 <gunzip+0x8c>
		while (src[i++] != 0)
33d0dcd0:	e0853004 	add	r3, r5, r4
33d0dcd4:	e5d33000 	ldrb	r3, [r3]
33d0dcd8:	e3530000 	cmp	r3, #0	; 0x0
33d0dcdc:	e2855001 	add	r5, r5, #1	; 0x1
33d0dce0:	1afffffa 	bne	33d0dcd0 <gunzip+0x78>
			;
	if ((flags & HEAD_CRC) != 0)
33d0dce4:	e3110002 	tst	r1, #2	; 0x2
		i += 2;
	if (i >= *lenp) {
33d0dce8:	e5973000 	ldr	r3, [r7]
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0)
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
33d0dcec:	12855002 	addne	r5, r5, #2	; 0x2
	if (i >= *lenp) {
33d0dcf0:	e1550003 	cmp	r5, r3
33d0dcf4:	3a000002 	bcc	33d0dd04 <gunzip+0xac>
		puts ("Error: gunzip out of data in header\n");
33d0dcf8:	e59f00a0 	ldr	r0, [pc, #160]	; 33d0dda0 <gunzip+0x148>
33d0dcfc:	eb0024aa 	bl	33d16fac <puts>
33d0dd00:	ea00001b 	b	33d0dd74 <gunzip+0x11c>
		return (-1);
	}

	s.zalloc = zalloc;
33d0dd04:	e59f3098 	ldr	r3, [pc, #152]	; 33d0dda4 <gunzip+0x14c>
33d0dd08:	e58d3020 	str	r3, [sp, #32]
	s.zfree = zfree;
33d0dd0c:	e59f3094 	ldr	r3, [pc, #148]	; 33d0dda8 <gunzip+0x150>
	s.outcb = (cb_func)WATCHDOG_RESET;
#else
	s.outcb = Z_NULL;
#endif	/* CONFIG_HW_WATCHDOG */

	r = inflateInit2(&s, -MAX_WBITS);
33d0dd10:	e3e0100e 	mvn	r1, #14	; 0xe
	s.zalloc = zalloc;
	s.zfree = zfree;
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
	s.outcb = (cb_func)WATCHDOG_RESET;
#else
	s.outcb = Z_NULL;
33d0dd14:	e3a0a000 	mov	sl, #0	; 0x0
#endif	/* CONFIG_HW_WATCHDOG */

	r = inflateInit2(&s, -MAX_WBITS);
33d0dd18:	e1a0000d 	mov	r0, sp
		puts ("Error: gunzip out of data in header\n");
		return (-1);
	}

	s.zalloc = zalloc;
	s.zfree = zfree;
33d0dd1c:	e58d3024 	str	r3, [sp, #36]
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
	s.outcb = (cb_func)WATCHDOG_RESET;
#else
	s.outcb = Z_NULL;
33d0dd20:	e58da030 	str	sl, [sp, #48]
#endif	/* CONFIG_HW_WATCHDOG */

	r = inflateInit2(&s, -MAX_WBITS);
33d0dd24:	eb0034dd 	bl	33d1b0a0 <inflateInit2>
	if (r != Z_OK) {
33d0dd28:	e3500000 	cmp	r0, #0	; 0x0
		printf ("Error: inflateInit2() returned %d\n", r);
33d0dd2c:	11a01000 	movne	r1, r0
	s.outcb = (cb_func)WATCHDOG_RESET;
#else
	s.outcb = Z_NULL;
#endif	/* CONFIG_HW_WATCHDOG */

	r = inflateInit2(&s, -MAX_WBITS);
33d0dd30:	e1a0600d 	mov	r6, sp
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
33d0dd34:	159f0070 	ldrne	r0, [pc, #112]	; 33d0ddac <gunzip+0x154>
#else
	s.outcb = Z_NULL;
#endif	/* CONFIG_HW_WATCHDOG */

	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
33d0dd38:	1a00000c 	bne	33d0dd70 <gunzip+0x118>
		printf ("Error: inflateInit2() returned %d\n", r);
		return (-1);
	}
	s.next_in = src + i;
	s.avail_in = *lenp - i;
33d0dd3c:	e5973000 	ldr	r3, [r7]
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return (-1);
	}
	s.next_in = src + i;
33d0dd40:	e0842005 	add	r2, r4, r5
	s.avail_in = *lenp - i;
33d0dd44:	e0653003 	rsb	r3, r5, r3
	s.next_out = dst;
	s.avail_out = dstlen;
	r = inflate(&s, Z_FINISH);
33d0dd48:	e1a0000d 	mov	r0, sp
33d0dd4c:	e3a01004 	mov	r1, #4	; 0x4
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return (-1);
	}
	s.next_in = src + i;
33d0dd50:	e88d000c 	stm	sp, {r2, r3}
	s.avail_in = *lenp - i;
	s.next_out = dst;
	s.avail_out = dstlen;
33d0dd54:	e58db010 	str	fp, [sp, #16]
		printf ("Error: inflateInit2() returned %d\n", r);
		return (-1);
	}
	s.next_in = src + i;
	s.avail_in = *lenp - i;
	s.next_out = dst;
33d0dd58:	e58d900c 	str	r9, [sp, #12]
	s.avail_out = dstlen;
	r = inflate(&s, Z_FINISH);
33d0dd5c:	eb003771 	bl	33d1bb28 <inflate>
	if (r != Z_OK && r != Z_STREAM_END) {
33d0dd60:	e3500001 	cmp	r0, #1	; 0x1
33d0dd64:	9a000004 	bls	33d0dd7c <gunzip+0x124>
		printf ("Error: inflate() returned %d\n", r);
33d0dd68:	e1a01000 	mov	r1, r0
33d0dd6c:	e59f003c 	ldr	r0, [pc, #60]	; 33d0ddb0 <gunzip+0x158>
33d0dd70:	eb002494 	bl	33d16fc8 <printf>
		return (-1);
33d0dd74:	e3e00000 	mvn	r0, #0	; 0x0
33d0dd78:	ea000005 	b	33d0dd94 <gunzip+0x13c>
	}
	*lenp = s.next_out - (unsigned char *) dst;
33d0dd7c:	e59d300c 	ldr	r3, [sp, #12]
33d0dd80:	e0693003 	rsb	r3, r9, r3
33d0dd84:	e5873000 	str	r3, [r7]
	inflateEnd(&s);
33d0dd88:	e1a0000d 	mov	r0, sp
33d0dd8c:	eb00343e 	bl	33d1ae8c <inflateEnd>

	return (0);
33d0dd90:	e1a0000a 	mov	r0, sl
}
33d0dd94:	e28dd034 	add	sp, sp, #52	; 0x34
33d0dd98:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0dd9c:	33d279d8 	.word	0x33d279d8
33d0dda0:	33d279f4 	.word	0x33d279f4
33d0dda4:	33d0dc40 	.word	0x33d0dc40
33d0dda8:	33d0dc50 	.word	0x33d0dc50
33d0ddac:	33d27a1c 	.word	0x33d27a1c
33d0ddb0:	33d27a40 	.word	0x33d27a40

33d0ddb4 <do_bootm>:
image_header_t header;

ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */

int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0ddb4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0ddb8:	e24dd0a8 	sub	sp, sp, #168	; 0xa8
33d0ddbc:	e58d0018 	str	r0, [sp, #24]
	int	i, verify;
	char	*name, *s;
	int	(*appl)(int, char *[]);
	image_header_t *hdr = &header;

	s = getenv ("verify");
33d0ddc0:	e59f0658 	ldr	r0, [pc, #1624]	; 33d0e420 <do_bootm+0x66c>
image_header_t header;

ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */

int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0ddc4:	e58d3010 	str	r3, [sp, #16]
33d0ddc8:	e58d1014 	str	r1, [sp, #20]
33d0ddcc:	e1a07002 	mov	r7, r2
	int	i, verify;
	char	*name, *s;
	int	(*appl)(int, char *[]);
	image_header_t *hdr = &header;

	s = getenv ("verify");
33d0ddd0:	eb001e9e 	bl	33d15850 <getenv>
	verify = (s && (*s == 'n')) ? 0 : 1;
33d0ddd4:	e3a03000 	mov	r3, #0	; 0x0
33d0ddd8:	e3500000 	cmp	r0, #0	; 0x0
	ulong  *len_ptr;
	uint	unc_len = CFG_BOOTM_LEN;
	int	i, verify;
	char	*name, *s;
	int	(*appl)(int, char *[]);
	image_header_t *hdr = &header;
33d0dddc:	e59f6640 	ldr	r6, [pc, #1600]	; 33d0e424 <do_bootm+0x670>

	s = getenv ("verify");
	verify = (s && (*s == 'n')) ? 0 : 1;
33d0dde0:	e58d300c 	str	r3, [sp, #12]
33d0dde4:	0a000002 	beq	33d0ddf4 <do_bootm+0x40>
33d0dde8:	e5d03000 	ldrb	r3, [r0]
33d0ddec:	e353006e 	cmp	r3, #110	; 0x6e
33d0ddf0:	0a000001 	beq	33d0ddfc <do_bootm+0x48>
33d0ddf4:	e3a0c001 	mov	ip, #1	; 0x1
33d0ddf8:	e58dc00c 	str	ip, [sp, #12]

	if (argc < 2) {
33d0ddfc:	e3570001 	cmp	r7, #1	; 0x1
		addr = load_addr;
33d0de00:	d59f3620 	ldrle	r3, [pc, #1568]	; 33d0e428 <do_bootm+0x674>
33d0de04:	d5935000 	ldrle	r5, [r3]
	image_header_t *hdr = &header;

	s = getenv ("verify");
	verify = (s && (*s == 'n')) ? 0 : 1;

	if (argc < 2) {
33d0de08:	da000005 	ble	33d0de24 <do_bootm+0x70>
		addr = load_addr;
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
33d0de0c:	e59d3010 	ldr	r3, [sp, #16]
33d0de10:	e3a01000 	mov	r1, #0	; 0x0
33d0de14:	e5930004 	ldr	r0, [r3, #4]
33d0de18:	e3a02010 	mov	r2, #16	; 0x10
33d0de1c:	eb0031ce 	bl	33d1a55c <simple_strtoul>
33d0de20:	e1a05000 	mov	r5, r0
	}

	SHOW_BOOT_PROGRESS (1);
	printf ("## Booting image at %08lx ...\n", addr);
33d0de24:	e59f0600 	ldr	r0, [pc, #1536]	; 33d0e42c <do_bootm+0x678>
33d0de28:	e1a01005 	mov	r1, r5
33d0de2c:	eb002465 	bl	33d16fc8 <printf>
#ifdef CONFIG_HAS_DATAFLASH
	if (addr_dataflash(addr)){
		read_dataflash(addr, sizeof(image_header_t), (char *)&header);
	} else
#endif
	memmove (&header, (char *)addr, sizeof(image_header_t));
33d0de30:	e1a01005 	mov	r1, r5
33d0de34:	e3a02040 	mov	r2, #64	; 0x40
33d0de38:	e59f05e4 	ldr	r0, [pc, #1508]	; 33d0e424 <do_bootm+0x670>
33d0de3c:	eb003172 	bl	33d1a40c <memmove>
33d0de40:	e5961000 	ldr	r1, [r6]
	return __arch__swab32(x);
33d0de44:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d0de48:	e1a03403 	lsl	r3, r3, #8
33d0de4c:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d0de50:	e1833c01 	orr	r3, r3, r1, lsl #24
33d0de54:	e1833422 	orr	r3, r3, r2, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0de58:	e59f25d0 	ldr	r2, [pc, #1488]	; 33d0e430 <do_bootm+0x67c>
	return __arch__swab32(x);
33d0de5c:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0de60:	e1530002 	cmp	r3, r2

	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
33d0de64:	e3a0a000 	mov	sl, #0	; 0x0
			 */
			verify = 0;
		} else
#endif	/* __I386__ */
	    {
		puts ("Bad Magic Number\n");
33d0de68:	159f05c4 	ldrne	r0, [pc, #1476]	; 33d0e434 <do_bootm+0x680>
33d0de6c:	1a000010 	bne	33d0deb4 <do_bootm+0x100>
33d0de70:	e596c004 	ldr	ip, [r6, #4]
	return __arch__swab32(x);
33d0de74:	e20c4cff 	and	r4, ip, #65280	; 0xff00
33d0de78:	e1a04404 	lsl	r4, r4, #8
	    }
	}
	SHOW_BOOT_PROGRESS (2);

	data = (ulong)&header;
	len  = sizeof(image_header_t);
33d0de7c:	e3a0e040 	mov	lr, #64	; 0x40
33d0de80:	e1844c0c 	orr	r4, r4, ip, lsl #24
33d0de84:	e20c38ff 	and	r3, ip, #16711680	; 0xff0000
33d0de88:	e1844423 	orr	r4, r4, r3, lsr #8
33d0de8c:	e58de024 	str	lr, [sp, #36]

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;

	if (crc32 (0, (uchar *)data, len) != checksum) {
33d0de90:	e1a0200e 	mov	r2, lr
33d0de94:	e1a0000a 	mov	r0, sl
33d0de98:	e59f1584 	ldr	r1, [pc, #1412]	; 33d0e424 <do_bootm+0x670>

	data = (ulong)&header;
	len  = sizeof(image_header_t);

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;
33d0de9c:	e586a004 	str	sl, [r6, #4]
33d0dea0:	e1844c2c 	orr	r4, r4, ip, lsr #24

	if (crc32 (0, (uchar *)data, len) != checksum) {
33d0dea4:	eb002f9b 	bl	33d19d18 <crc32>
33d0dea8:	e1500004 	cmp	r0, r4
33d0deac:	0a000002 	beq	33d0debc <do_bootm+0x108>
		puts ("Bad Header Checksum\n");
33d0deb0:	e59f0580 	ldr	r0, [pc, #1408]	; 33d0e438 <do_bootm+0x684>
33d0deb4:	eb00243c 	bl	33d16fac <puts>
33d0deb8:	ea000155 	b	33d0e414 <do_bootm+0x660>
	}
#endif


	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);
33d0debc:	e1a00005 	mov	r0, r5
33d0dec0:	ebfffddf 	bl	33d0d644 <print_image_hdr>
33d0dec4:	e596300c 	ldr	r3, [r6, #12]
33d0dec8:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0decc:	e1a02402 	lsl	r2, r2, #8
33d0ded0:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0ded4:	e20318ff 	and	r1, r3, #16711680	; 0xff0000

	data = addr + sizeof(image_header_t);
	len  = ntohl(hdr->ih_size);

	if (verify) {
33d0ded8:	e59dc00c 	ldr	ip, [sp, #12]
33d0dedc:	e1822421 	orr	r2, r2, r1, lsr #8
33d0dee0:	e1822c23 	orr	r2, r2, r3, lsr #24
33d0dee4:	e35c0000 	cmp	ip, #0	; 0x0
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0dee8:	e58d2024 	str	r2, [sp, #36]


	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);

	data = addr + sizeof(image_header_t);
33d0deec:	e2854040 	add	r4, r5, #64	; 0x40
	len  = ntohl(hdr->ih_size);

	if (verify) {
33d0def0:	0a000013 	beq	33d0df44 <do_bootm+0x190>
		puts ("   Verifying Checksum ... ");
33d0def4:	e59f0540 	ldr	r0, [pc, #1344]	; 33d0e43c <do_bootm+0x688>
33d0def8:	eb00242b 	bl	33d16fac <puts>
		if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
33d0defc:	e1a01004 	mov	r1, r4
33d0df00:	e59d2024 	ldr	r2, [sp, #36]
33d0df04:	e1a0000a 	mov	r0, sl
33d0df08:	eb002f82 	bl	33d19d18 <crc32>
33d0df0c:	e5963018 	ldr	r3, [r6, #24]
	return __arch__swab32(x);
33d0df10:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0df14:	e1a02402 	lsl	r2, r2, #8
33d0df18:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0df1c:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d0df20:	e1822421 	orr	r2, r2, r1, lsr #8
33d0df24:	e1822c23 	orr	r2, r2, r3, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0df28:	e1500002 	cmp	r0, r2
33d0df2c:	0a000002 	beq	33d0df3c <do_bootm+0x188>
			printf ("Bad Data CRC\n");
33d0df30:	e59f0508 	ldr	r0, [pc, #1288]	; 33d0e440 <do_bootm+0x68c>
33d0df34:	eb002423 	bl	33d16fc8 <printf>
33d0df38:	ea000135 	b	33d0e414 <do_bootm+0x660>
			SHOW_BOOT_PROGRESS (-3);
			return 1;
		}
		puts ("OK\n");
33d0df3c:	e59f0500 	ldr	r0, [pc, #1280]	; 33d0e444 <do_bootm+0x690>
33d0df40:	eb002419 	bl	33d16fac <puts>
	len_ptr = (ulong *)data;

#if defined(__PPC__)
	if (hdr->ih_arch != IH_CPU_PPC)
#elif defined(__ARM__)
	if (hdr->ih_arch != IH_CPU_ARM)
33d0df44:	e5d6101d 	ldrb	r1, [r6, #29]
33d0df48:	e3510002 	cmp	r1, #2	; 0x2
		}
		puts ("OK\n");
	}
	SHOW_BOOT_PROGRESS (4);

	len_ptr = (ulong *)data;
33d0df4c:	e1a0b004 	mov	fp, r4
	if (hdr->ih_arch != IH_CPU_AVR32)
#else
# error Unknown CPU type
#endif
	{
		printf ("Unsupported Architecture 0x%x\n", hdr->ih_arch);
33d0df50:	159f04f0 	ldrne	r0, [pc, #1264]	; 33d0e448 <do_bootm+0x694>
	len_ptr = (ulong *)data;

#if defined(__PPC__)
	if (hdr->ih_arch != IH_CPU_PPC)
#elif defined(__ARM__)
	if (hdr->ih_arch != IH_CPU_ARM)
33d0df54:	1a000031 	bne	33d0e020 <do_bootm+0x26c>
		SHOW_BOOT_PROGRESS (-4);
		return 1;
	}
	SHOW_BOOT_PROGRESS (5);

	switch (hdr->ih_type) {
33d0df58:	e5d6301e 	ldrb	r3, [r6, #30]
33d0df5c:	e3530002 	cmp	r3, #2	; 0x2
33d0df60:	0a000016 	beq	33d0dfc0 <do_bootm+0x20c>
33d0df64:	ca000002 	bgt	33d0df74 <do_bootm+0x1c0>
33d0df68:	e3530001 	cmp	r3, #1	; 0x1
33d0df6c:	0a000003 	beq	33d0df80 <do_bootm+0x1cc>
33d0df70:	ea000027 	b	33d0e014 <do_bootm+0x260>
33d0df74:	e3530004 	cmp	r3, #4	; 0x4
33d0df78:	0a000012 	beq	33d0dfc8 <do_bootm+0x214>
33d0df7c:	ea000024 	b	33d0e014 <do_bootm+0x260>
	case IH_TYPE_STANDALONE:
		name = "Standalone Application";
		/* A second argument overwrites the load address */
		if (argc > 2) {
33d0df80:	e3570002 	cmp	r7, #2	; 0x2
	}
	SHOW_BOOT_PROGRESS (5);

	switch (hdr->ih_type) {
	case IH_TYPE_STANDALONE:
		name = "Standalone Application";
33d0df84:	e59f94c0 	ldr	r9, [pc, #1216]	; 33d0e44c <do_bootm+0x698>
		/* A second argument overwrites the load address */
		if (argc > 2) {
33d0df88:	da000026 	ble	33d0e028 <do_bootm+0x274>
33d0df8c:	e59d3010 	ldr	r3, [sp, #16]
33d0df90:	e3a02010 	mov	r2, #16	; 0x10
33d0df94:	e5930008 	ldr	r0, [r3, #8]
33d0df98:	e3a01000 	mov	r1, #0	; 0x0
33d0df9c:	eb00316e 	bl	33d1a55c <simple_strtoul>
	return __arch__swab32(x);
33d0dfa0:	e2003cff 	and	r3, r0, #65280	; 0xff00
33d0dfa4:	e1a03403 	lsl	r3, r3, #8
33d0dfa8:	e1833c00 	orr	r3, r3, r0, lsl #24
33d0dfac:	e20028ff 	and	r2, r0, #16711680	; 0xff0000
33d0dfb0:	e1833422 	orr	r3, r3, r2, lsr #8
33d0dfb4:	e1833c20 	orr	r3, r3, r0, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0dfb8:	e5863010 	str	r3, [r6, #16]
			hdr->ih_load = htonl(simple_strtoul(argv[2], NULL, 16));
		}
		break;
33d0dfbc:	ea000019 	b	33d0e028 <do_bootm+0x274>
	case IH_TYPE_KERNEL:
		name = "Kernel Image";
33d0dfc0:	e59f9488 	ldr	r9, [pc, #1160]	; 33d0e450 <do_bootm+0x69c>
		break;
33d0dfc4:	ea000017 	b	33d0e028 <do_bootm+0x274>
33d0dfc8:	e5941000 	ldr	r1, [r4]
	return __arch__swab32(x);
33d0dfcc:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d0dfd0:	e1a03403 	lsl	r3, r3, #8
33d0dfd4:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d0dfd8:	e1833c01 	orr	r3, r3, r1, lsl #24
33d0dfdc:	e1833422 	orr	r3, r3, r2, lsr #8
33d0dfe0:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0dfe4:	e58d3024 	str	r3, [sp, #36]
	case IH_TYPE_MULTI:
		name = "Multi-File Image";
		len  = ntohl(len_ptr[0]);
		/* OS kernel is always the first image */
		data += 8; /* kernel_len + terminator */
		for (i=1; len_ptr[i]; ++i)
33d0dfe8:	e5943004 	ldr	r3, [r4, #4]
		break;
	case IH_TYPE_KERNEL:
		name = "Kernel Image";
		break;
	case IH_TYPE_MULTI:
		name = "Multi-File Image";
33d0dfec:	e59f9460 	ldr	r9, [pc, #1120]	; 33d0e454 <do_bootm+0x6a0>
		len  = ntohl(len_ptr[0]);
		/* OS kernel is always the first image */
		data += 8; /* kernel_len + terminator */
		for (i=1; len_ptr[i]; ++i)
33d0dff0:	e3530000 	cmp	r3, #0	; 0x0
		break;
	case IH_TYPE_MULTI:
		name = "Multi-File Image";
		len  = ntohl(len_ptr[0]);
		/* OS kernel is always the first image */
		data += 8; /* kernel_len + terminator */
33d0dff4:	e2844008 	add	r4, r4, #8	; 0x8
		for (i=1; len_ptr[i]; ++i)
33d0dff8:	e3a02001 	mov	r2, #1	; 0x1
33d0dffc:	0a000009 	beq	33d0e028 <do_bootm+0x274>
33d0e000:	e2822001 	add	r2, r2, #1	; 0x1
33d0e004:	e79b3102 	ldr	r3, [fp, r2, lsl #2]
			data += 4;
33d0e008:	e2844004 	add	r4, r4, #4	; 0x4
	case IH_TYPE_MULTI:
		name = "Multi-File Image";
		len  = ntohl(len_ptr[0]);
		/* OS kernel is always the first image */
		data += 8; /* kernel_len + terminator */
		for (i=1; len_ptr[i]; ++i)
33d0e00c:	e3530000 	cmp	r3, #0	; 0x0
33d0e010:	eafffff9 	b	33d0dffc <do_bootm+0x248>
			data += 4;
		break;
	default: printf ("Wrong Image Type for %s command\n", cmdtp->name);
33d0e014:	e59dc018 	ldr	ip, [sp, #24]
33d0e018:	e59f0438 	ldr	r0, [pc, #1080]	; 33d0e458 <do_bootm+0x6a4>
33d0e01c:	e59c1000 	ldr	r1, [ip]
33d0e020:	eb0023e8 	bl	33d16fc8 <printf>
33d0e024:	ea0000fa 	b	33d0e414 <do_bootm+0x660>
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */

	iflag = disable_interrupts();
33d0e028:	ebffca8a 	bl	33d00a58 <disable_interrupts>
	invalidate_l1_instruction_cache();
	flush_data_cache();
	dcache_disable();
#endif

	switch (hdr->ih_comp) {
33d0e02c:	e5d6301f 	ldrb	r3, [r6, #31]
33d0e030:	e3530000 	cmp	r3, #0	; 0x0
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */

	iflag = disable_interrupts();
33d0e034:	e1a0a000 	mov	sl, r0
	invalidate_l1_instruction_cache();
	flush_data_cache();
	dcache_disable();
#endif

	switch (hdr->ih_comp) {
33d0e038:	0a000002 	beq	33d0e048 <do_bootm+0x294>
33d0e03c:	e3530001 	cmp	r3, #1	; 0x1
33d0e040:	0a000017 	beq	33d0e0a4 <do_bootm+0x2f0>
33d0e044:	ea00002e 	b	33d0e104 <do_bootm+0x350>
33d0e048:	e5961010 	ldr	r1, [r6, #16]
	return __arch__swab32(x);
33d0e04c:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d0e050:	e1a03403 	lsl	r3, r3, #8
33d0e054:	e1833c01 	orr	r3, r3, r1, lsl #24
33d0e058:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d0e05c:	e1833422 	orr	r3, r3, r2, lsr #8
33d0e060:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0e064:	e1530005 	cmp	r3, r5
33d0e068:	1a000003 	bne	33d0e07c <do_bootm+0x2c8>
	case IH_COMP_NONE:
		if(ntohl(hdr->ih_load) == addr) {
			printf ("   XIP %s ... ", name);
33d0e06c:	e1a01009 	mov	r1, r9
33d0e070:	e59f03e4 	ldr	r0, [pc, #996]	; 33d0e45c <do_bootm+0x6a8>
33d0e074:	eb0023d3 	bl	33d16fc8 <printf>
33d0e078:	ea000026 	b	33d0e118 <do_bootm+0x364>
	return __arch__swab32(x);
33d0e07c:	e2010cff 	and	r0, r1, #65280	; 0xff00
33d0e080:	e1a00400 	lsl	r0, r0, #8
33d0e084:	e20138ff 	and	r3, r1, #16711680	; 0xff0000
33d0e088:	e1800c01 	orr	r0, r0, r1, lsl #24
33d0e08c:	e1800423 	orr	r0, r0, r3, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0e090:	e1800c21 	orr	r0, r0, r1, lsr #24
33d0e094:	e59d2024 	ldr	r2, [sp, #36]
33d0e098:	e1a01004 	mov	r1, r4
33d0e09c:	eb0030da 	bl	33d1a40c <memmove>
			}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
			memmove ((void *) ntohl(hdr->ih_load), (uchar *)data, len);
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
		}
		break;
33d0e0a0:	ea00001c 	b	33d0e118 <do_bootm+0x364>
	case IH_COMP_GZIP:
		printf ("   Uncompressing %s ... ", name);
33d0e0a4:	e1a01009 	mov	r1, r9
33d0e0a8:	e59f03b0 	ldr	r0, [pc, #944]	; 33d0e460 <do_bootm+0x6ac>
33d0e0ac:	eb0023c5 	bl	33d16fc8 <printf>
33d0e0b0:	e5961010 	ldr	r1, [r6, #16]
	return __arch__swab32(x);
33d0e0b4:	e2010cff 	and	r0, r1, #65280	; 0xff00
33d0e0b8:	e1a00400 	lsl	r0, r0, #8
33d0e0bc:	e20138ff 	and	r3, r1, #16711680	; 0xff0000
33d0e0c0:	e1800c01 	orr	r0, r0, r1, lsl #24
33d0e0c4:	e1800423 	orr	r0, r0, r3, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0e0c8:	e1800c21 	orr	r0, r0, r1, lsr #24
33d0e0cc:	e1a02004 	mov	r2, r4
33d0e0d0:	e3a01502 	mov	r1, #8388608	; 0x800000
33d0e0d4:	e28d3024 	add	r3, sp, #36	; 0x24
33d0e0d8:	ebfffede 	bl	33d0dc58 <gunzip>
33d0e0dc:	e3500000 	cmp	r0, #0	; 0x0
33d0e0e0:	0a00000c 	beq	33d0e118 <do_bootm+0x364>
		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
			    (uchar *)data, &len) != 0) {
			puts ("GUNZIP ERROR - must RESET board to recover\n");
33d0e0e4:	e59f0378 	ldr	r0, [pc, #888]	; 33d0e464 <do_bootm+0x6b0>
33d0e0e8:	eb0023af 	bl	33d16fac <puts>
			SHOW_BOOT_PROGRESS (-6);
			do_reset (cmdtp, flag, argc, argv);
33d0e0ec:	e59d0018 	ldr	r0, [sp, #24]
33d0e0f0:	e59d1014 	ldr	r1, [sp, #20]
33d0e0f4:	e1a02007 	mov	r2, r7
33d0e0f8:	e59d3010 	ldr	r3, [sp, #16]
33d0e0fc:	eb004044 	bl	33d1e214 <do_reset>
		}
		break;
33d0e100:	ea000004 	b	33d0e118 <do_bootm+0x364>
			do_reset (cmdtp, flag, argc, argv);
		}
		break;
#endif /* CONFIG_BZIP2 */
	default:
		if (iflag)
33d0e104:	e3500000 	cmp	r0, #0	; 0x0
			enable_interrupts();
33d0e108:	1bffca4e 	blne	33d00a48 <enable_interrupts>
		printf ("Unimplemented compression type %d\n", hdr->ih_comp);
33d0e10c:	e5d6101f 	ldrb	r1, [r6, #31]
33d0e110:	e59f0350 	ldr	r0, [pc, #848]	; 33d0e468 <do_bootm+0x6b4>
33d0e114:	eaffffc1 	b	33d0e020 <do_bootm+0x26c>
		SHOW_BOOT_PROGRESS (-7);
		return 1;
	}
	puts ("OK\n");
33d0e118:	e59f0324 	ldr	r0, [pc, #804]	; 33d0e444 <do_bootm+0x690>
33d0e11c:	eb0023a2 	bl	33d16fac <puts>
	SHOW_BOOT_PROGRESS (7);

	switch (hdr->ih_type) {
33d0e120:	e5d6301e 	ldrb	r3, [r6, #30]
33d0e124:	e3530002 	cmp	r3, #2	; 0x2
33d0e128:	0a00002d 	beq	33d0e1e4 <do_bootm+0x430>
33d0e12c:	ca000002 	bgt	33d0e13c <do_bootm+0x388>
33d0e130:	e3530001 	cmp	r3, #1	; 0x1
33d0e134:	0a000003 	beq	33d0e148 <do_bootm+0x394>
33d0e138:	ea000024 	b	33d0e1d0 <do_bootm+0x41c>
33d0e13c:	e3530004 	cmp	r3, #4	; 0x4
33d0e140:	0a000027 	beq	33d0e1e4 <do_bootm+0x430>
33d0e144:	ea000021 	b	33d0e1d0 <do_bootm+0x41c>
	case IH_TYPE_STANDALONE:
		if (iflag)
33d0e148:	e35a0000 	cmp	sl, #0	; 0x0
			enable_interrupts();
33d0e14c:	1bffca3d 	blne	33d00a48 <enable_interrupts>

		/* load (and uncompress), but don't start if "autostart"
		 * is set to "no"
		 */
		if (((s = getenv("autostart")) != NULL) && (strcmp(s,"no") == 0)) {
33d0e150:	e59f0314 	ldr	r0, [pc, #788]	; 33d0e46c <do_bootm+0x6b8>
33d0e154:	eb001dbd 	bl	33d15850 <getenv>
33d0e158:	e3500000 	cmp	r0, #0	; 0x0
33d0e15c:	0a00000d 	beq	33d0e198 <do_bootm+0x3e4>
33d0e160:	e59f1308 	ldr	r1, [pc, #776]	; 33d0e470 <do_bootm+0x6bc>
33d0e164:	eb002fbf 	bl	33d1a068 <strcmp>
33d0e168:	e2505000 	subs	r5, r0, #0	; 0x0
33d0e16c:	1a000009 	bne	33d0e198 <do_bootm+0x3e4>
			char buf[32];
			sprintf(buf, "%lX", len);
33d0e170:	e28d4088 	add	r4, sp, #136	; 0x88
33d0e174:	e59f12f8 	ldr	r1, [pc, #760]	; 33d0e474 <do_bootm+0x6c0>
33d0e178:	e59d2024 	ldr	r2, [sp, #36]
33d0e17c:	e1a00004 	mov	r0, r4
33d0e180:	eb0032db 	bl	33d1acf4 <sprintf>
			setenv("filesize", buf);
33d0e184:	e59f02ec 	ldr	r0, [pc, #748]	; 33d0e478 <do_bootm+0x6c4>
33d0e188:	e1a01004 	mov	r1, r4
33d0e18c:	eb001d91 	bl	33d157d8 <setenv>
			return 0;
33d0e190:	e1a00005 	mov	r0, r5
33d0e194:	ea00009f 	b	33d0e418 <do_bootm+0x664>
33d0e198:	e5963014 	ldr	r3, [r6, #20]
	return __arch__swab32(x);
33d0e19c:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d0e1a0:	e1a02402 	lsl	r2, r2, #8
33d0e1a4:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d0e1a8:	e1822c03 	orr	r2, r2, r3, lsl #24
33d0e1ac:	e1822421 	orr	r2, r2, r1, lsr #8
33d0e1b0:	e1822c23 	orr	r2, r2, r3, lsr #24
		}
		appl = (int (*)(int, char *[]))ntohl(hdr->ih_ep);
		(*appl)(argc-1, &argv[1]);
33d0e1b4:	e59d3010 	ldr	r3, [sp, #16]
33d0e1b8:	e2470001 	sub	r0, r7, #1	; 0x1
33d0e1bc:	e2831004 	add	r1, r3, #4	; 0x4
33d0e1c0:	e1a0e00f 	mov	lr, pc
33d0e1c4:	e1a0f002 	mov	pc, r2
		return 0;
33d0e1c8:	e3a00000 	mov	r0, #0	; 0x0
33d0e1cc:	ea000091 	b	33d0e418 <do_bootm+0x664>
	case IH_TYPE_KERNEL:
	case IH_TYPE_MULTI:
		/* handled below */
		break;
	default:
		if (iflag)
33d0e1d0:	e35a0000 	cmp	sl, #0	; 0x0
			enable_interrupts();
33d0e1d4:	1bffca1b 	blne	33d00a48 <enable_interrupts>
		printf ("Can't boot image type %d\n", hdr->ih_type);
33d0e1d8:	e5d6101e 	ldrb	r1, [r6, #30]
33d0e1dc:	e59f0298 	ldr	r0, [pc, #664]	; 33d0e47c <do_bootm+0x6c8>
33d0e1e0:	eaffff8e 	b	33d0e020 <do_bootm+0x26c>
		SHOW_BOOT_PROGRESS (-8);
		return 1;
	}
	SHOW_BOOT_PROGRESS (8);

	switch (hdr->ih_os) {
33d0e1e4:	e5d6201c 	ldrb	r2, [r6, #28]
33d0e1e8:	e352000e 	cmp	r2, #14	; 0xe
33d0e1ec:	0a000060 	beq	33d0e374 <do_bootm+0x5c0>
33d0e1f0:	ca000002 	bgt	33d0e200 <do_bootm+0x44c>
33d0e1f4:	e3520002 	cmp	r2, #2	; 0x2
33d0e1f8:	0a00000c 	beq	33d0e230 <do_bootm+0x47c>
33d0e1fc:	ea000003 	b	33d0e210 <do_bootm+0x45c>
33d0e200:	e3520010 	cmp	r2, #16	; 0x10
33d0e204:	0a00006e 	beq	33d0e3c4 <do_bootm+0x610>
33d0e208:	e3520012 	cmp	r2, #18	; 0x12
33d0e20c:	0a00004a 	beq	33d0e33c <do_bootm+0x588>
	default:			/* handled by (original) Linux case */
	case IH_OS_LINUX:
#ifdef CONFIG_SILENT_CONSOLE
	    fixup_silent_linux();
#endif
	    do_bootm_linux  (cmdtp, flag, argc, argv,
33d0e210:	e59dc00c 	ldr	ip, [sp, #12]
33d0e214:	e59d0018 	ldr	r0, [sp, #24]
33d0e218:	e59d1014 	ldr	r1, [sp, #20]
33d0e21c:	e1a02007 	mov	r2, r7
33d0e220:	e59d3010 	ldr	r3, [sp, #16]
33d0e224:	e88d1820 	stm	sp, {r5, fp, ip}
33d0e228:	eb0041c9 	bl	33d1e954 <do_bootm_linux>
			     addr, len_ptr, verify);
	    break;
33d0e22c:	ea000078 	b	33d0e414 <do_bootm+0x660>
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */

	img_addr = 0;
	if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1]))
33d0e230:	e5d6301e 	ldrb	r3, [r6, #30]
33d0e234:	e3530004 	cmp	r3, #4	; 0x4
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */

	img_addr = 0;
33d0e238:	e3a0a000 	mov	sl, #0	; 0x0
	if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1]))
33d0e23c:	1a000002 	bne	33d0e24c <do_bootm+0x498>
33d0e240:	e59b3004 	ldr	r3, [fp, #4]
		img_addr = (image_header_t *) addr;
33d0e244:	e153000a 	cmp	r3, sl
33d0e248:	11a0a005 	movne	sl, r5
	consdev = "scc2";
#elif defined (CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
33d0e24c:	e3570002 	cmp	r7, #2	; 0x2
33d0e250:	da000021 	ble	33d0e2dc <do_bootm+0x528>
		ulong len;
		int   i;

		for (i=2, len=0 ; i<argc ; i+=1)
33d0e254:	e1a04002 	mov	r4, r2
33d0e258:	e1520007 	cmp	r2, r7
33d0e25c:	e3a05000 	mov	r5, #0	; 0x0
33d0e260:	aa000007 	bge	33d0e284 <do_bootm+0x4d0>
			len += strlen (argv[i]) + 1;
33d0e264:	e59d3010 	ldr	r3, [sp, #16]
33d0e268:	e7930104 	ldr	r0, [r3, r4, lsl #2]
33d0e26c:	eb002fa7 	bl	33d1a110 <strlen>

	if (argc > 2) {
		ulong len;
		int   i;

		for (i=2, len=0 ; i<argc ; i+=1)
33d0e270:	e2844001 	add	r4, r4, #1	; 0x1
			len += strlen (argv[i]) + 1;
33d0e274:	e0850000 	add	r0, r5, r0

	if (argc > 2) {
		ulong len;
		int   i;

		for (i=2, len=0 ; i<argc ; i+=1)
33d0e278:	e1540007 	cmp	r4, r7
			len += strlen (argv[i]) + 1;
33d0e27c:	e2805001 	add	r5, r0, #1	; 0x1
33d0e280:	eafffff6 	b	33d0e260 <do_bootm+0x4ac>
		cmdline = malloc (len);
33d0e284:	e1a00005 	mov	r0, r5
33d0e288:	eb0024f6 	bl	33d17668 <malloc>

		for (i=2, len=0 ; i<argc ; i+=1) {
33d0e28c:	e3a04002 	mov	r4, #2	; 0x2
		ulong len;
		int   i;

		for (i=2, len=0 ; i<argc ; i+=1)
			len += strlen (argv[i]) + 1;
		cmdline = malloc (len);
33d0e290:	e1a06000 	mov	r6, r0

		for (i=2, len=0 ; i<argc ; i+=1) {
33d0e294:	e1540007 	cmp	r4, r7
33d0e298:	e3a05000 	mov	r5, #0	; 0x0
33d0e29c:	aa000014 	bge	33d0e2f4 <do_bootm+0x540>
			if (i > 2)
33d0e2a0:	e3540002 	cmp	r4, #2	; 0x2
				cmdline[len++] = ' ';
33d0e2a4:	c3a03020 	movgt	r3, #32	; 0x20
33d0e2a8:	c7c53006 	strbgt	r3, [r5, r6]
			strcpy (&cmdline[len], argv[i]);
33d0e2ac:	e59dc010 	ldr	ip, [sp, #16]
			len += strlen (argv[i]) + 1;
		cmdline = malloc (len);

		for (i=2, len=0 ; i<argc ; i+=1) {
			if (i > 2)
				cmdline[len++] = ' ';
33d0e2b0:	c2855001 	addgt	r5, r5, #1	; 0x1
			strcpy (&cmdline[len], argv[i]);
33d0e2b4:	e79c1104 	ldr	r1, [ip, r4, lsl #2]
33d0e2b8:	e0860005 	add	r0, r6, r5
33d0e2bc:	eb002f3e 	bl	33d19fbc <strcpy>
			len += strlen (argv[i]);
33d0e2c0:	e59d3010 	ldr	r3, [sp, #16]
33d0e2c4:	e7930104 	ldr	r0, [r3, r4, lsl #2]
33d0e2c8:	eb002f90 	bl	33d1a110 <strlen>

		for (i=2, len=0 ; i<argc ; i+=1)
			len += strlen (argv[i]) + 1;
		cmdline = malloc (len);

		for (i=2, len=0 ; i<argc ; i+=1) {
33d0e2cc:	e2844001 	add	r4, r4, #1	; 0x1
33d0e2d0:	e1540007 	cmp	r4, r7
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy (&cmdline[len], argv[i]);
			len += strlen (argv[i]);
33d0e2d4:	e0855000 	add	r5, r5, r0
33d0e2d8:	eaffffef 	b	33d0e29c <do_bootm+0x4e8>
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
33d0e2dc:	e59f019c 	ldr	r0, [pc, #412]	; 33d0e480 <do_bootm+0x6cc>
33d0e2e0:	eb001d5a 	bl	33d15850 <getenv>
		cmdline = "";
33d0e2e4:	e59f3198 	ldr	r3, [pc, #408]	; 33d0e484 <do_bootm+0x6d0>
33d0e2e8:	e3500000 	cmp	r0, #0	; 0x0
33d0e2ec:	11a06000 	movne	r6, r0
33d0e2f0:	01a06003 	moveq	r6, r3
33d0e2f4:	e59f3128 	ldr	r3, [pc, #296]	; 33d0e424 <do_bootm+0x670>
33d0e2f8:	e5932014 	ldr	r2, [r3, #20]
33d0e2fc:	e2024cff 	and	r4, r2, #65280	; 0xff00
33d0e300:	e1a04404 	lsl	r4, r4, #8
33d0e304:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
33d0e308:	e1844c02 	orr	r4, r4, r2, lsl #24
33d0e30c:	e1844423 	orr	r4, r4, r3, lsr #8
33d0e310:	e1844c22 	orr	r4, r4, r2, lsr #24
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *)) ntohl(hdr->ih_ep);

	printf ("## Transferring control to NetBSD stage-2 loader (at address %08lx) ...\n",
33d0e314:	e1a01004 	mov	r1, r4
33d0e318:	e59f0168 	ldr	r0, [pc, #360]	; 33d0e488 <do_bootm+0x6d4>
33d0e31c:	eb002329 	bl	33d16fc8 <printf>
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader) (gd->bd, img_addr, consdev, cmdline);
33d0e320:	e1a0100a 	mov	r1, sl
33d0e324:	e5980000 	ldr	r0, [r8]
33d0e328:	e1a03006 	mov	r3, r6
33d0e32c:	e59f2150 	ldr	r2, [pc, #336]	; 33d0e484 <do_bootm+0x6d0>
33d0e330:	e1a0e00f 	mov	lr, pc
33d0e334:	e1a0f004 	mov	pc, r4
			     addr, len_ptr, verify);
	    break;
	case IH_OS_NETBSD:
	    do_bootm_netbsd (cmdtp, flag, argc, argv,
			     addr, len_ptr, verify);
	    break;
33d0e338:	ea000035 	b	33d0e414 <do_bootm+0x660>
33d0e33c:	e5962014 	ldr	r2, [r6, #20]
33d0e340:	e2024cff 	and	r4, r2, #65280	; 0xff00
33d0e344:	e1a04404 	lsl	r4, r4, #8
33d0e348:	e1844c02 	orr	r4, r4, r2, lsl #24
33d0e34c:	e20238ff 	and	r3, r2, #16711680	; 0xff0000
33d0e350:	e1844423 	orr	r4, r4, r3, lsr #8
33d0e354:	e1844c22 	orr	r4, r4, r2, lsr #24
	image_header_t *hdr = &header;
	void	(*entry_point)(bd_t *);

	entry_point = (void (*)(bd_t *)) ntohl(hdr->ih_ep);

	printf ("## Transferring control to RTEMS (at address %08lx) ...\n",
33d0e358:	e59f012c 	ldr	r0, [pc, #300]	; 33d0e48c <do_bootm+0x6d8>
33d0e35c:	e1a01004 	mov	r1, r4
33d0e360:	eb002318 	bl	33d16fc8 <printf>
	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */

	(*entry_point ) ( gd->bd );
33d0e364:	e5980000 	ldr	r0, [r8]
33d0e368:	e1a0e00f 	mov	lr, pc
33d0e36c:	e1a0f004 	mov	pc, r4
#endif

	case IH_OS_RTEMS:
	    do_bootm_rtems (cmdtp, flag, argc, argv,
			     addr, len_ptr, verify);
	    break;
33d0e370:	ea000027 	b	33d0e414 <do_bootm+0x660>
33d0e374:	e5961014 	ldr	r1, [r6, #20]
33d0e378:	e2012cff 	and	r2, r1, #65280	; 0xff00
33d0e37c:	e1a02402 	lsl	r2, r2, #8
33d0e380:	e20138ff 	and	r3, r1, #16711680	; 0xff0000
33d0e384:	e1822c01 	orr	r2, r2, r1, lsl #24
33d0e388:	e1822423 	orr	r2, r2, r3, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0e38c:	e28d4038 	add	r4, sp, #56	; 0x38
33d0e390:	e1822c21 	orr	r2, r2, r1, lsr #24
33d0e394:	e1a00004 	mov	r0, r4
33d0e398:	e59f10f0 	ldr	r1, [pc, #240]	; 33d0e490 <do_bootm+0x6dc>
33d0e39c:	eb003254 	bl	33d1acf4 <sprintf>
{
	image_header_t *hdr = &header;
	char str[80];

	sprintf(str, "%x", ntohl(hdr->ih_ep)); /* write entry-point into string */
	setenv("loadaddr", str);
33d0e3a0:	e1a01004 	mov	r1, r4
33d0e3a4:	e59f00e8 	ldr	r0, [pc, #232]	; 33d0e494 <do_bootm+0x6e0>
33d0e3a8:	eb001d0a 	bl	33d157d8 <setenv>
	do_bootvx(cmdtp, 0, 0, NULL);
33d0e3ac:	e3a01000 	mov	r1, #0	; 0x0
33d0e3b0:	e59d0018 	ldr	r0, [sp, #24]
33d0e3b4:	e1a02001 	mov	r2, r1
33d0e3b8:	e1a03001 	mov	r3, r1
33d0e3bc:	eb0001eb 	bl	33d0eb70 <do_bootvx>

#if (CONFIG_COMMANDS & CFG_CMD_ELF)
	case IH_OS_VXWORKS:
	    do_bootm_vxworks (cmdtp, flag, argc, argv,
			      addr, len_ptr, verify);
	    break;
33d0e3c0:	ea000013 	b	33d0e414 <do_bootm+0x660>
33d0e3c4:	e5961014 	ldr	r1, [r6, #20]
	return __arch__swab32(x);
33d0e3c8:	e2012cff 	and	r2, r1, #65280	; 0xff00
33d0e3cc:	e1a02402 	lsl	r2, r2, #8
33d0e3d0:	e20138ff 	and	r3, r1, #16711680	; 0xff0000
33d0e3d4:	e1822c01 	orr	r2, r2, r1, lsl #24
33d0e3d8:	e1822423 	orr	r2, r2, r3, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d0e3dc:	e28d4028 	add	r4, sp, #40	; 0x28
33d0e3e0:	e1822c21 	orr	r2, r2, r1, lsr #24
33d0e3e4:	e1a00004 	mov	r0, r4
33d0e3e8:	e59f10a0 	ldr	r1, [pc, #160]	; 33d0e490 <do_bootm+0x6dc>
33d0e3ec:	eb003240 	bl	33d1acf4 <sprintf>
	image_header_t *hdr = &header;
	char *local_args[2];
	char str[16];

	sprintf(str, "%x", ntohl(hdr->ih_ep)); /* write entry-point into string */
	local_args[0] = argv[0];
33d0e3f0:	e59d3010 	ldr	r3, [sp, #16]
33d0e3f4:	e593c000 	ldr	ip, [r3]
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(cmdtp, 0, 2, local_args);
33d0e3f8:	e59d0018 	ldr	r0, [sp, #24]
33d0e3fc:	e3a01000 	mov	r1, #0	; 0x0
33d0e400:	e3a02002 	mov	r2, #2	; 0x2
33d0e404:	e28d301c 	add	r3, sp, #28	; 0x1c
	image_header_t *hdr = &header;
	char *local_args[2];
	char str[16];

	sprintf(str, "%x", ntohl(hdr->ih_ep)); /* write entry-point into string */
	local_args[0] = argv[0];
33d0e408:	e58dc01c 	str	ip, [sp, #28]
	local_args[1] = str;	/* and provide it via the arguments */
33d0e40c:	e58d4020 	str	r4, [sp, #32]
	do_bootelf(cmdtp, 0, 2, local_args);
33d0e410:	eb000235 	bl	33d0ecec <do_bootelf>
	SHOW_BOOT_PROGRESS (-9);
#ifdef DEBUG
	puts ("\n## Control returned to monitor - resetting...\n");
	do_reset (cmdtp, flag, argc, argv);
#endif
	return 1;
33d0e414:	e3a00001 	mov	r0, #1	; 0x1
}
33d0e418:	e28dd0a8 	add	sp, sp, #168	; 0xa8
33d0e41c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0e420:	33d27158 	.word	0x33d27158
33d0e424:	33d60888 	.word	0x33d60888
33d0e428:	33d35fec 	.word	0x33d35fec
33d0e42c:	33d27a60 	.word	0x33d27a60
33d0e430:	27051956 	.word	0x27051956
33d0e434:	33d27a80 	.word	0x33d27a80
33d0e438:	33d27a94 	.word	0x33d27a94
33d0e43c:	33d279a4 	.word	0x33d279a4
33d0e440:	33d27aac 	.word	0x33d27aac
33d0e444:	33d279d4 	.word	0x33d279d4
33d0e448:	33d27abc 	.word	0x33d27abc
33d0e44c:	33d27adc 	.word	0x33d27adc
33d0e450:	33d27810 	.word	0x33d27810
33d0e454:	33d27830 	.word	0x33d27830
33d0e458:	33d27af4 	.word	0x33d27af4
33d0e45c:	33d27b18 	.word	0x33d27b18
33d0e460:	33d27b28 	.word	0x33d27b28
33d0e464:	33d27b44 	.word	0x33d27b44
33d0e468:	33d27b70 	.word	0x33d27b70
33d0e46c:	33d27b94 	.word	0x33d27b94
33d0e470:	33d257b8 	.word	0x33d257b8
33d0e474:	33d2596c 	.word	0x33d2596c
33d0e478:	33d25954 	.word	0x33d25954
33d0e47c:	33d27ba0 	.word	0x33d27ba0
33d0e480:	33d255f4 	.word	0x33d255f4
33d0e484:	33d2a490 	.word	0x33d2a490
33d0e488:	33d273a0 	.word	0x33d273a0
33d0e48c:	33d273ec 	.word	0x33d273ec
33d0e490:	33d27428 	.word	0x33d27428
33d0e494:	33d25514 	.word	0x33d25514

33d0e498 <on_off>:
	return 0;

}

static int on_off (const char *s)
{
33d0e498:	e92d4010 	push	{r4, lr}
	if (strcmp(s, "on") == 0) {
33d0e49c:	e59f1030 	ldr	r1, [pc, #48]	; 33d0e4d4 <on_off+0x3c>
	return 0;

}

static int on_off (const char *s)
{
33d0e4a0:	e1a04000 	mov	r4, r0
	if (strcmp(s, "on") == 0) {
33d0e4a4:	eb002eef 	bl	33d1a068 <strcmp>
33d0e4a8:	e3500000 	cmp	r0, #0	; 0x0
		return (1);
	} else if (strcmp(s, "off") == 0) {
33d0e4ac:	e59f1024 	ldr	r1, [pc, #36]	; 33d0e4d8 <on_off+0x40>
33d0e4b0:	e1a00004 	mov	r0, r4
}

static int on_off (const char *s)
{
	if (strcmp(s, "on") == 0) {
		return (1);
33d0e4b4:	e3a03001 	mov	r3, #1	; 0x1

}

static int on_off (const char *s)
{
	if (strcmp(s, "on") == 0) {
33d0e4b8:	0a000003 	beq	33d0e4cc <on_off+0x34>
		return (1);
	} else if (strcmp(s, "off") == 0) {
33d0e4bc:	eb002ee9 	bl	33d1a068 <strcmp>
33d0e4c0:	e3500000 	cmp	r0, #0	; 0x0
		return (0);
33d0e4c4:	01a03000 	moveq	r3, r0
33d0e4c8:	13e03000 	mvnne	r3, #0	; 0x0
	}
	return (-1);
}
33d0e4cc:	e1a00003 	mov	r0, r3
33d0e4d0:	e8bd8010 	pop	{r4, pc}
33d0e4d4:	33d27af0 	.word	0x33d27af0
33d0e4d8:	33d253f0 	.word	0x33d253f0

33d0e4dc <do_dcache>:
	return 0;
}

int do_dcache ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	switch (argc) {
33d0e4dc:	e3520001 	cmp	r2, #1	; 0x1
	}
	return 0;
}

int do_dcache ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0e4e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0e4e4:	e1a01000 	mov	r1, r0
	switch (argc) {
33d0e4e8:	0a00000c 	beq	33d0e520 <do_dcache+0x44>
33d0e4ec:	e3520002 	cmp	r2, #2	; 0x2
	case 1:			/* get status */
		printf ("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0e4f0:	e59f005c 	ldr	r0, [pc, #92]	; 33d0e554 <do_dcache+0x78>
	return 0;
}

int do_dcache ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	switch (argc) {
33d0e4f4:	1a000012 	bne	33d0e544 <do_dcache+0x68>
	case 2:			/* on / off	*/
		switch (on_off(argv[1])) {
33d0e4f8:	e5930004 	ldr	r0, [r3, #4]
33d0e4fc:	ebffffe5 	bl	33d0e498 <on_off>
33d0e500:	e3500000 	cmp	r0, #0	; 0x0
33d0e504:	0a000002 	beq	33d0e514 <do_dcache+0x38>
33d0e508:	e3500001 	cmp	r0, #1	; 0x1
33d0e50c:	0a000002 	beq	33d0e51c <do_dcache+0x40>
33d0e510:	ea000002 	b	33d0e520 <do_dcache+0x44>
#if 0	/* prevented by varargs handling; FALLTROUGH is harmless, too */
		default: printf ("Usage:\n%s\n", cmdtp->usage);
			return;
#endif
		case 0:	dcache_disable();
33d0e514:	eb003f5e 	bl	33d1e294 <dcache_disable>
			break;
33d0e518:	ea000000 	b	33d0e520 <do_dcache+0x44>
		case 1:	dcache_enable ();
33d0e51c:	eb003f55 	bl	33d1e278 <dcache_enable>
			break;
		}
		/* FALL TROUGH */
	case 1:			/* get status */
		printf ("Data (writethrough) Cache is %s\n",
33d0e520:	eb003f62 	bl	33d1e2b0 <dcache_status>
33d0e524:	e59f302c 	ldr	r3, [pc, #44]	; 33d0e558 <do_dcache+0x7c>
33d0e528:	e3500000 	cmp	r0, #0	; 0x0
33d0e52c:	e59f1028 	ldr	r1, [pc, #40]	; 33d0e55c <do_dcache+0x80>
33d0e530:	e59f0028 	ldr	r0, [pc, #40]	; 33d0e560 <do_dcache+0x84>
33d0e534:	11a01003 	movne	r1, r3
33d0e538:	eb0022a2 	bl	33d16fc8 <printf>
			dcache_status() ? "ON" : "OFF");
		return 0;
33d0e53c:	e3a00000 	mov	r0, #0	; 0x0
33d0e540:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	default:
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0e544:	e5911010 	ldr	r1, [r1, #16]
33d0e548:	eb00229e 	bl	33d16fc8 <printf>
		return 1;
33d0e54c:	e3a00001 	mov	r0, #1	; 0x1
	}
	return 0;

}
33d0e550:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d0e554:	33d27008 	.word	0x33d27008
33d0e558:	33d27c9c 	.word	0x33d27c9c
33d0e55c:	33d27ca0 	.word	0x33d27ca0
33d0e560:	33d27ca4 	.word	0x33d27ca4

33d0e564 <do_icache>:

static int on_off (const char *);

int do_icache ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	switch (argc) {
33d0e564:	e3520001 	cmp	r2, #1	; 0x1
#if (CONFIG_COMMANDS & CFG_CMD_CACHE)

static int on_off (const char *);

int do_icache ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0e568:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0e56c:	e1a01000 	mov	r1, r0
	switch (argc) {
33d0e570:	0a00000c 	beq	33d0e5a8 <do_icache+0x44>
33d0e574:	e3520002 	cmp	r2, #2	; 0x2
	case 1:			/* get status */
		printf ("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0e578:	e59f005c 	ldr	r0, [pc, #92]	; 33d0e5dc <do_icache+0x78>

static int on_off (const char *);

int do_icache ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	switch (argc) {
33d0e57c:	1a000012 	bne	33d0e5cc <do_icache+0x68>
	case 2:			/* on / off	*/
		switch (on_off(argv[1])) {
33d0e580:	e5930004 	ldr	r0, [r3, #4]
33d0e584:	ebffffc3 	bl	33d0e498 <on_off>
33d0e588:	e3500000 	cmp	r0, #0	; 0x0
33d0e58c:	0a000002 	beq	33d0e59c <do_icache+0x38>
33d0e590:	e3500001 	cmp	r0, #1	; 0x1
33d0e594:	0a000002 	beq	33d0e5a4 <do_icache+0x40>
33d0e598:	ea000002 	b	33d0e5a8 <do_icache+0x44>
#if 0	/* prevented by varargs handling; FALLTROUGH is harmless, too */
		default: printf ("Usage:\n%s\n", cmdtp->usage);
			return;
#endif
		case 0:	icache_disable();
33d0e59c:	eb003f29 	bl	33d1e248 <icache_disable>
			break;
33d0e5a0:	ea000000 	b	33d0e5a8 <do_icache+0x44>
		case 1:	icache_enable ();
33d0e5a4:	eb003f20 	bl	33d1e22c <icache_enable>
			break;
		}
		/* FALL TROUGH */
	case 1:			/* get status */
		printf ("Instruction Cache is %s\n",
33d0e5a8:	eb003f2d 	bl	33d1e264 <icache_status>
33d0e5ac:	e59f302c 	ldr	r3, [pc, #44]	; 33d0e5e0 <do_icache+0x7c>
33d0e5b0:	e3500000 	cmp	r0, #0	; 0x0
33d0e5b4:	e59f1028 	ldr	r1, [pc, #40]	; 33d0e5e4 <do_icache+0x80>
33d0e5b8:	e59f0028 	ldr	r0, [pc, #40]	; 33d0e5e8 <do_icache+0x84>
33d0e5bc:	11a01003 	movne	r1, r3
33d0e5c0:	eb002280 	bl	33d16fc8 <printf>
			icache_status() ? "ON" : "OFF");
		return 0;
33d0e5c4:	e3a00000 	mov	r0, #0	; 0x0
33d0e5c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	default:
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0e5cc:	e5911010 	ldr	r1, [r1, #16]
33d0e5d0:	eb00227c 	bl	33d16fc8 <printf>
		return 1;
33d0e5d4:	e3a00001 	mov	r0, #1	; 0x1
	}
	return 0;
}
33d0e5d8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d0e5dc:	33d27008 	.word	0x33d27008
33d0e5e0:	33d27c9c 	.word	0x33d27c9c
33d0e5e4:	33d27ca0 	.word	0x33d27ca0
33d0e5e8:	33d27cc8 	.word	0x33d27cc8

33d0e5ec <do_coninfo>:

#if (CONFIG_COMMANDS & CFG_CMD_CONSOLE)

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char *argv[])
{
33d0e5ec:	e92d4070 	push	{r4, r5, r6, lr}
	int i, l;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
33d0e5f0:	e59f00b4 	ldr	r0, [pc, #180]	; 33d0e6ac <do_coninfo+0xc0>

#if (CONFIG_COMMANDS & CFG_CMD_CONSOLE)

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char *argv[])
{
33d0e5f4:	e24dd008 	sub	sp, sp, #8	; 0x8
	int i, l;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
33d0e5f8:	eb00226b 	bl	33d16fac <puts>

	for (i = 1; i <= ListNumItems (devlist); i++) {
33d0e5fc:	e3a06001 	mov	r6, #1	; 0x1
33d0e600:	ea000021 	b	33d0e68c <do_coninfo+0xa0>
		device_t *dev = ListGetPtrToItem (devlist, i);
33d0e604:	e5940000 	ldr	r0, [r4]
33d0e608:	e1a01006 	mov	r1, r6
33d0e60c:	eb002a35 	bl	33d18ee8 <ListGetPtrToItem>

		printf ("%-8s %08x %c%c%c ",
33d0e610:	e5902000 	ldr	r2, [r0]
33d0e614:	e3120001 	tst	r2, #1	; 0x1
33d0e618:	03a0302e 	moveq	r3, #46	; 0x2e
33d0e61c:	13a03049 	movne	r3, #73	; 0x49
33d0e620:	e58d3000 	str	r3, [sp]
33d0e624:	e5903000 	ldr	r3, [r0]
33d0e628:	e3130002 	tst	r3, #2	; 0x2
33d0e62c:	03a0c02e 	moveq	ip, #46	; 0x2e
33d0e630:	13a0c04f 	movne	ip, #79	; 0x4f
	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	for (i = 1; i <= ListNumItems (devlist); i++) {
		device_t *dev = ListGetPtrToItem (devlist, i);
33d0e634:	e1a05000 	mov	r5, r0

		printf ("%-8s %08x %c%c%c ",
33d0e638:	e3520000 	cmp	r2, #0	; 0x0
33d0e63c:	a3a0302e 	movge	r3, #46	; 0x2e
33d0e640:	b3a03053 	movlt	r3, #83	; 0x53
33d0e644:	e59f0064 	ldr	r0, [pc, #100]	; 33d0e6b0 <do_coninfo+0xc4>
33d0e648:	e2851008 	add	r1, r5, #8	; 0x8
33d0e64c:	e58dc004 	str	ip, [sp, #4]
33d0e650:	eb00225c 	bl	33d16fc8 <printf>
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
33d0e654:	e3a04000 	mov	r4, #0	; 0x0
			if (stdio_devices[l] == dev) {
33d0e658:	e59f3054 	ldr	r3, [pc, #84]	; 33d0e6b4 <do_coninfo+0xc8>
33d0e65c:	e7933104 	ldr	r3, [r3, r4, lsl #2]
33d0e660:	e1530005 	cmp	r3, r5
				printf ("%s ", stdio_names[l]);
33d0e664:	e59f004c 	ldr	r0, [pc, #76]	; 33d0e6b8 <do_coninfo+0xcc>
33d0e668:	059f304c 	ldreq	r3, [pc, #76]	; 33d0e6bc <do_coninfo+0xd0>
33d0e66c:	07931104 	ldreq	r1, [r3, r4, lsl #2]
33d0e670:	0b002254 	bleq	33d16fc8 <printf>
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
33d0e674:	e2844001 	add	r4, r4, #1	; 0x1
33d0e678:	e3540002 	cmp	r4, #2	; 0x2
33d0e67c:	dafffff5 	ble	33d0e658 <do_coninfo+0x6c>
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
			}
		}
		putc ('\n');
33d0e680:	e3a0000a 	mov	r0, #10	; 0xa
33d0e684:	eb00223e 	bl	33d16f84 <putc>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	for (i = 1; i <= ListNumItems (devlist); i++) {
33d0e688:	e2866001 	add	r6, r6, #1	; 0x1
33d0e68c:	e59f402c 	ldr	r4, [pc, #44]	; 33d0e6c0 <do_coninfo+0xd4>
33d0e690:	e5940000 	ldr	r0, [r4]
33d0e694:	eb002a25 	bl	33d18f30 <ListNumItems>
33d0e698:	e1560000 	cmp	r6, r0
33d0e69c:	daffffd8 	ble	33d0e604 <do_coninfo+0x18>
			}
		}
		putc ('\n');
	}
	return 0;
}
33d0e6a0:	e3a00000 	mov	r0, #0	; 0x0
33d0e6a4:	e28dd008 	add	sp, sp, #8	; 0x8
33d0e6a8:	e8bd8070 	pop	{r4, r5, r6, pc}
33d0e6ac:	33d27d20 	.word	0x33d27d20
33d0e6b0:	33d27d3c 	.word	0x33d27d3c
33d0e6b4:	33d60c1c 	.word	0x33d60c1c
33d0e6b8:	33d27d50 	.word	0x33d27d50
33d0e6bc:	33d36080 	.word	0x33d36080
33d0e6c0:	33d60c28 	.word	0x33d60c28

33d0e6c4 <cnvrt2>:

/*
 * simple conversion of two-digit string with error checking
 */
static int cnvrt2 (char *str, int *valp)
{
33d0e6c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int val;

	if ((*str < '0') || (*str > '9'))
33d0e6c8:	e5d0c000 	ldrb	ip, [r0]
33d0e6cc:	e24c3030 	sub	r3, ip, #48	; 0x30
33d0e6d0:	e3530009 	cmp	r3, #9	; 0x9
		return (-1);
33d0e6d4:	e3e0e000 	mvn	lr, #0	; 0x0
 */
static int cnvrt2 (char *str, int *valp)
{
	int val;

	if ((*str < '0') || (*str > '9'))
33d0e6d8:	8a000009 	bhi	33d0e704 <cnvrt2+0x40>

	val = *str - '0';

	++str;

	if ((*str < '0') || (*str > '9'))
33d0e6dc:	e5d02001 	ldrb	r2, [r0, #1]
33d0e6e0:	e2423030 	sub	r3, r2, #48	; 0x30
33d0e6e4:	e3530009 	cmp	r3, #9	; 0x9
	int val;

	if ((*str < '0') || (*str > '9'))
		return (-1);

	val = *str - '0';
33d0e6e8:	e24c3030 	sub	r3, ip, #48	; 0x30
	++str;

	if ((*str < '0') || (*str > '9'))
		return (-1);

	*valp = 10 * val + (*str - '0');
33d0e6ec:	e0833103 	add	r3, r3, r3, lsl #2
33d0e6f0:	e0822083 	add	r2, r2, r3, lsl #1
33d0e6f4:	e2420030 	sub	r0, r2, #48	; 0x30
33d0e6f8:	95810000 	strls	r0, [r1]
	val = *str - '0';

	++str;

	if ((*str < '0') || (*str > '9'))
		return (-1);
33d0e6fc:	e3e0e000 	mvn	lr, #0	; 0x0

	*valp = 10 * val + (*str - '0');

	return (0);
33d0e700:	93a0e000 	movls	lr, #0	; 0x0
}
33d0e704:	e1a0000e 	mov	r0, lr
33d0e708:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d0e70c <mk_date>:
 *
 * Some basic checking for valid values is done, but this will not catch
 * all possible error conditions.
 */
int mk_date (char *datestr, struct rtc_time *tmp)
{
33d0e70c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d0e710:	e1a06001 	mov	r6, r1
33d0e714:	e24dd014 	sub	sp, sp, #20	; 0x14
	int len, val;
	char *ptr;

	ptr = strchr (datestr,'.');
33d0e718:	e3a0102e 	mov	r1, #46	; 0x2e
 *
 * Some basic checking for valid values is done, but this will not catch
 * all possible error conditions.
 */
int mk_date (char *datestr, struct rtc_time *tmp)
{
33d0e71c:	e1a05000 	mov	r5, r0
	int len, val;
	char *ptr;

	ptr = strchr (datestr,'.');
33d0e720:	eb002e6e 	bl	33d1a0e0 <strchr>
33d0e724:	e1a04000 	mov	r4, r0
	len = strlen (datestr);
33d0e728:	e1a00005 	mov	r0, r5
33d0e72c:	eb002e77 	bl	33d1a110 <strlen>

	/* Set seconds */
	if (ptr) {
33d0e730:	e3540000 	cmp	r4, #0	; 0x0
{
	int len, val;
	char *ptr;

	ptr = strchr (datestr,'.');
	len = strlen (datestr);
33d0e734:	e1a07000 	mov	r7, r0

	/* Set seconds */
	if (ptr) {
33d0e738:	0a000010 	beq	33d0e780 <mk_date+0x74>
		int sec;

		*ptr++ = '\0';
33d0e73c:	e3a03000 	mov	r3, #0	; 0x0
33d0e740:	e4c43001 	strb	r3, [r4], #1
		if ((len - (ptr - datestr)) != 2)
33d0e744:	e0653004 	rsb	r3, r5, r4
33d0e748:	e0633000 	rsb	r3, r3, r0
33d0e74c:	e3530002 	cmp	r3, #2	; 0x2
33d0e750:	1a000064 	bne	33d0e8e8 <mk_date+0x1dc>
			return (-1);

		len = strlen (datestr);
33d0e754:	e1a00005 	mov	r0, r5
33d0e758:	eb002e6c 	bl	33d1a110 <strlen>

		if (cnvrt2 (ptr, &sec))
33d0e75c:	e28d1010 	add	r1, sp, #16	; 0x10

		*ptr++ = '\0';
		if ((len - (ptr - datestr)) != 2)
			return (-1);

		len = strlen (datestr);
33d0e760:	e1a07000 	mov	r7, r0

		if (cnvrt2 (ptr, &sec))
33d0e764:	e1a00004 	mov	r0, r4
33d0e768:	ebffffd5 	bl	33d0e6c4 <cnvrt2>
33d0e76c:	e3500000 	cmp	r0, #0	; 0x0
			return (-1);

		tmp->tm_sec = sec;
33d0e770:	059d3010 	ldreq	r3, [sp, #16]
33d0e774:	05863000 	streq	r3, [r6]
		if ((len - (ptr - datestr)) != 2)
			return (-1);

		len = strlen (datestr);

		if (cnvrt2 (ptr, &sec))
33d0e778:	0a000001 	beq	33d0e784 <mk_date+0x78>
33d0e77c:	ea000059 	b	33d0e8e8 <mk_date+0x1dc>
			return (-1);

		tmp->tm_sec = sec;
	} else {
		tmp->tm_sec = 0;
33d0e780:	e5864000 	str	r4, [r6]
	}

	if (len == 12) {		/* MMDDhhmmCCYY	*/
33d0e784:	e357000c 	cmp	r7, #12	; 0xc
33d0e788:	1a000010 	bne	33d0e7d0 <mk_date+0xc4>
		int year, century;

		if (cnvrt2 (datestr+ 8, &century) ||
33d0e78c:	e2850008 	add	r0, r5, #8	; 0x8
33d0e790:	e28d100c 	add	r1, sp, #12	; 0xc
33d0e794:	ebffffca 	bl	33d0e6c4 <cnvrt2>
33d0e798:	e3500000 	cmp	r0, #0	; 0x0
33d0e79c:	1a000051 	bne	33d0e8e8 <mk_date+0x1dc>
33d0e7a0:	e285000a 	add	r0, r5, #10	; 0xa
33d0e7a4:	e28d1008 	add	r1, sp, #8	; 0x8
33d0e7a8:	ebffffc5 	bl	33d0e6c4 <cnvrt2>
33d0e7ac:	e3500000 	cmp	r0, #0	; 0x0
33d0e7b0:	1a00004c 	bne	33d0e8e8 <mk_date+0x1dc>
		    cnvrt2 (datestr+10, &year) ) {
			return (-1);
		}
		tmp->tm_year = 100 * century + year;
33d0e7b4:	e28d2008 	add	r2, sp, #8	; 0x8
33d0e7b8:	e892000c 	ldm	r2, {r2, r3}
33d0e7bc:	e0833103 	add	r3, r3, r3, lsl #2
33d0e7c0:	e0833103 	add	r3, r3, r3, lsl #2
33d0e7c4:	e0822103 	add	r2, r2, r3, lsl #2
33d0e7c8:	e5862014 	str	r2, [r6, #20]
33d0e7cc:	ea000012 	b	33d0e81c <mk_date+0x110>
	} else if (len == 10) {		/* MMDDhhmmYY	*/
33d0e7d0:	e357000a 	cmp	r7, #10	; 0xa
33d0e7d4:	1a00000e 	bne	33d0e814 <mk_date+0x108>
		int year, century;

		century = tmp->tm_year / 100;
33d0e7d8:	e5960014 	ldr	r0, [r6, #20]
33d0e7dc:	e3a01064 	mov	r1, #100	; 0x64
33d0e7e0:	eb003f9e 	bl	33d1e660 <__divsi3>
		if (cnvrt2 (datestr+ 8, &year))
33d0e7e4:	e28d1004 	add	r1, sp, #4	; 0x4
		}
		tmp->tm_year = 100 * century + year;
	} else if (len == 10) {		/* MMDDhhmmYY	*/
		int year, century;

		century = tmp->tm_year / 100;
33d0e7e8:	e1a04000 	mov	r4, r0
		if (cnvrt2 (datestr+ 8, &year))
33d0e7ec:	e2850008 	add	r0, r5, #8	; 0x8
33d0e7f0:	ebffffb3 	bl	33d0e6c4 <cnvrt2>
33d0e7f4:	e3500000 	cmp	r0, #0	; 0x0
33d0e7f8:	1a00003a 	bne	33d0e8e8 <mk_date+0x1dc>
			return (-1);
		tmp->tm_year = 100 * century + year;
33d0e7fc:	e59d3004 	ldr	r3, [sp, #4]
33d0e800:	e0842104 	add	r2, r4, r4, lsl #2
33d0e804:	e0822102 	add	r2, r2, r2, lsl #2
33d0e808:	e0833102 	add	r3, r3, r2, lsl #2
33d0e80c:	e5863014 	str	r3, [r6, #20]
33d0e810:	ea000001 	b	33d0e81c <mk_date+0x110>
	}

	switch (len) {
33d0e814:	e357000c 	cmp	r7, #12	; 0xc
33d0e818:	8a000032 	bhi	33d0e8e8 <mk_date+0x1dc>
33d0e81c:	e3a03001 	mov	r3, #1	; 0x1
33d0e820:	e1a03713 	lsl	r3, r3, r7
33d0e824:	e3130c15 	tst	r3, #5376	; 0x1500
33d0e828:	0a00002e 	beq	33d0e8e8 <mk_date+0x1dc>
	case 8:			/* MMDDhhmm	*/
		/* fall thru */
	case 10:		/* MMDDhhmmYY	*/
		/* fall thru */
	case 12:		/* MMDDhhmmCCYY	*/
		if (cnvrt2 (datestr+0, &val) ||
33d0e82c:	e1a00005 	mov	r0, r5
33d0e830:	e1a0100d 	mov	r1, sp
33d0e834:	ebffffa2 	bl	33d0e6c4 <cnvrt2>
33d0e838:	e3500000 	cmp	r0, #0	; 0x0
33d0e83c:	e1a0400d 	mov	r4, sp
33d0e840:	1a000028 	bne	33d0e8e8 <mk_date+0x1dc>
33d0e844:	e59d3000 	ldr	r3, [sp]
33d0e848:	e353000c 	cmp	r3, #12	; 0xc
33d0e84c:	ca000025 	bgt	33d0e8e8 <mk_date+0x1dc>
		    val > 12) {
			break;
		}
		tmp->tm_mon  = val;
33d0e850:	e5863010 	str	r3, [r6, #16]
		if (cnvrt2 (datestr+2, &val) ||
33d0e854:	e2850002 	add	r0, r5, #2	; 0x2
33d0e858:	e1a0100d 	mov	r1, sp
33d0e85c:	ebffff98 	bl	33d0e6c4 <cnvrt2>
33d0e860:	e3500000 	cmp	r0, #0	; 0x0
33d0e864:	1a00001f 	bne	33d0e8e8 <mk_date+0x1dc>
33d0e868:	e5963010 	ldr	r3, [r6, #16]
33d0e86c:	e3530002 	cmp	r3, #2	; 0x2
33d0e870:	e59d3000 	ldr	r3, [sp]
33d0e874:	1a000001 	bne	33d0e880 <mk_date+0x174>
33d0e878:	e353001d 	cmp	r3, #29	; 0x1d
33d0e87c:	ea000000 	b	33d0e884 <mk_date+0x178>
33d0e880:	e353001f 	cmp	r3, #31	; 0x1f
33d0e884:	ca000017 	bgt	33d0e8e8 <mk_date+0x1dc>
		    val > ((tmp->tm_mon==2) ? 29 : 31)) {
			break;
		}
		tmp->tm_mday = val;
33d0e888:	e59d3000 	ldr	r3, [sp]

		if (cnvrt2 (datestr+4, &val) ||
33d0e88c:	e2850004 	add	r0, r5, #4	; 0x4
		tmp->tm_mon  = val;
		if (cnvrt2 (datestr+2, &val) ||
		    val > ((tmp->tm_mon==2) ? 29 : 31)) {
			break;
		}
		tmp->tm_mday = val;
33d0e890:	e586300c 	str	r3, [r6, #12]

		if (cnvrt2 (datestr+4, &val) ||
33d0e894:	e1a01004 	mov	r1, r4
33d0e898:	ebffff89 	bl	33d0e6c4 <cnvrt2>
33d0e89c:	e3500000 	cmp	r0, #0	; 0x0
33d0e8a0:	1a000010 	bne	33d0e8e8 <mk_date+0x1dc>
33d0e8a4:	e59d3000 	ldr	r3, [sp]
33d0e8a8:	e3530017 	cmp	r3, #23	; 0x17
33d0e8ac:	ca00000d 	bgt	33d0e8e8 <mk_date+0x1dc>
		    val > 23) {
			break;
		}
		tmp->tm_hour = val;

		if (cnvrt2 (datestr+6, &val) ||
33d0e8b0:	e1a01004 	mov	r1, r4

		if (cnvrt2 (datestr+4, &val) ||
		    val > 23) {
			break;
		}
		tmp->tm_hour = val;
33d0e8b4:	e5863008 	str	r3, [r6, #8]

		if (cnvrt2 (datestr+6, &val) ||
33d0e8b8:	e2850006 	add	r0, r5, #6	; 0x6
33d0e8bc:	ebffff80 	bl	33d0e6c4 <cnvrt2>
33d0e8c0:	e2504000 	subs	r4, r0, #0	; 0x0
33d0e8c4:	1a000007 	bne	33d0e8e8 <mk_date+0x1dc>
33d0e8c8:	e59d3000 	ldr	r3, [sp]
33d0e8cc:	e353003b 	cmp	r3, #59	; 0x3b
33d0e8d0:	ca000004 	bgt	33d0e8e8 <mk_date+0x1dc>
			break;
		}
		tmp->tm_min  = val;

		/* calculate day of week */
		GregorianDay (tmp);
33d0e8d4:	e1a00006 	mov	r0, r6

		if (cnvrt2 (datestr+6, &val) ||
		    val > 59) {
			break;
		}
		tmp->tm_min  = val;
33d0e8d8:	e5863004 	str	r3, [r6, #4]

		/* calculate day of week */
		GregorianDay (tmp);
33d0e8dc:	eb004f09 	bl	33d22508 <GregorianDay>

		return (0);
33d0e8e0:	e1a00004 	mov	r0, r4
33d0e8e4:	ea000000 	b	33d0e8ec <mk_date+0x1e0>
	default:
		break;
	}

	return (-1);
33d0e8e8:	e3e00000 	mvn	r0, #0	; 0x0
}
33d0e8ec:	e28dd014 	add	sp, sp, #20	; 0x14
33d0e8f0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d0e8f4 <do_date>:
#define RELOC(a)	((typeof(a))((unsigned long)(a) + gd->reloc_off))

int mk_date (char *, struct rtc_time *);

int do_date (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0e8f4:	e92d4030 	push	{r4, r5, lr}
	struct rtc_time tm;
	int rcode = 0;

	switch (argc) {
33d0e8f8:	e3520001 	cmp	r2, #1	; 0x1
#define RELOC(a)	((typeof(a))((unsigned long)(a) + gd->reloc_off))

int mk_date (char *, struct rtc_time *);

int do_date (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0e8fc:	e24dd034 	sub	sp, sp, #52	; 0x34
33d0e900:	e1a05003 	mov	r5, r3
	struct rtc_time tm;
	int rcode = 0;

	switch (argc) {
33d0e904:	0a000017 	beq	33d0e968 <do_date+0x74>
33d0e908:	e3520002 	cmp	r2, #2	; 0x2
33d0e90c:	1a00002e 	bne	33d0e9cc <do_date+0xd8>
	case 2:			/* set date & time */
		if (strcmp(argv[1],"reset") == 0) {
33d0e910:	e5930004 	ldr	r0, [r3, #4]
33d0e914:	e59f10c8 	ldr	r1, [pc, #200]	; 33d0e9e4 <do_date+0xf0>
33d0e918:	eb002dd2 	bl	33d1a068 <strcmp>
33d0e91c:	e3500000 	cmp	r0, #0	; 0x0
33d0e920:	1a000003 	bne	33d0e934 <do_date+0x40>
			puts ("Reset RTC...\n");
33d0e924:	e59f00bc 	ldr	r0, [pc, #188]	; 33d0e9e8 <do_date+0xf4>
33d0e928:	eb00219f 	bl	33d16fac <puts>
			rtc_reset ();
33d0e92c:	eb00501f 	bl	33d229b0 <rtc_reset>
33d0e930:	ea00000c 	b	33d0e968 <do_date+0x74>
		} else {
			/* initialize tm with current time */
			rtc_get (&tm);
33d0e934:	e28d4010 	add	r4, sp, #16	; 0x10
33d0e938:	e1a00004 	mov	r0, r4
33d0e93c:	eb004fb2 	bl	33d2280c <rtc_get>
			/* insert new date & time */
			if (mk_date (argv[1], &tm) != 0) {
33d0e940:	e5950004 	ldr	r0, [r5, #4]
33d0e944:	e1a01004 	mov	r1, r4
33d0e948:	ebffff6f 	bl	33d0e70c <mk_date>
33d0e94c:	e3500000 	cmp	r0, #0	; 0x0
33d0e950:	0a000002 	beq	33d0e960 <do_date+0x6c>
				puts ("## Bad date format\n");
33d0e954:	e59f0090 	ldr	r0, [pc, #144]	; 33d0e9ec <do_date+0xf8>
33d0e958:	eb002193 	bl	33d16fac <puts>
33d0e95c:	ea00001d 	b	33d0e9d8 <do_date+0xe4>
				return 1;
			}
			/* and write to RTC */
			rtc_set (&tm);
33d0e960:	e1a00004 	mov	r0, r4
33d0e964:	eb004fe3 	bl	33d228f8 <rtc_set>
		}
		/* FALL TROUGH */
	case 1:			/* get date & time */
		rtc_get (&tm);
33d0e968:	e28d0010 	add	r0, sp, #16	; 0x10
33d0e96c:	eb004fa6 	bl	33d2280c <rtc_get>

		printf ("Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n",
33d0e970:	e59d2028 	ldr	r2, [sp, #40]
33d0e974:	e3520006 	cmp	r2, #6	; 0x6
33d0e978:	959f3070 	ldrls	r3, [pc, #112]	; 33d0e9f0 <do_date+0xfc>
33d0e97c:	97932102 	ldrls	r2, [r3, r2, lsl #2]
33d0e980:	95983010 	ldrls	r3, [r8, #16]
33d0e984:	859fc068 	ldrhi	ip, [pc, #104]	; 33d0e9f4 <do_date+0x100>
33d0e988:	9082c003 	addls	ip, r2, r3
33d0e98c:	e58dc000 	str	ip, [sp]
33d0e990:	e59dc018 	ldr	ip, [sp, #24]
33d0e994:	e58dc004 	str	ip, [sp, #4]
33d0e998:	e59dc014 	ldr	ip, [sp, #20]
33d0e99c:	e59d0020 	ldr	r0, [sp, #32]
33d0e9a0:	e59de01c 	ldr	lr, [sp, #28]
33d0e9a4:	e58dc008 	str	ip, [sp, #8]
33d0e9a8:	e59dc010 	ldr	ip, [sp, #16]
33d0e9ac:	e1a02000 	mov	r2, r0
33d0e9b0:	e59d1024 	ldr	r1, [sp, #36]
33d0e9b4:	e59f003c 	ldr	r0, [pc, #60]	; 33d0e9f8 <do_date+0x104>
33d0e9b8:	e1a0300e 	mov	r3, lr
33d0e9bc:	e58dc00c 	str	ip, [sp, #12]
33d0e9c0:	eb002180 	bl	33d16fc8 <printf>
			tm.tm_year, tm.tm_mon, tm.tm_mday,
			(tm.tm_wday<0 || tm.tm_wday>6) ?
				"unknown " : RELOC(weekdays[tm.tm_wday]),
			tm.tm_hour, tm.tm_min, tm.tm_sec);

		return 0;
33d0e9c4:	e3a00000 	mov	r0, #0	; 0x0
33d0e9c8:	ea000003 	b	33d0e9dc <do_date+0xe8>
	default:
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0e9cc:	e5901010 	ldr	r1, [r0, #16]
33d0e9d0:	e59f0024 	ldr	r0, [pc, #36]	; 33d0e9fc <do_date+0x108>
33d0e9d4:	eb00217b 	bl	33d16fc8 <printf>
		rcode = 1;
33d0e9d8:	e3a00001 	mov	r0, #1	; 0x1
	}
	return rcode;
}
33d0e9dc:	e28dd034 	add	sp, sp, #52	; 0x34
33d0e9e0:	e8bd8030 	pop	{r4, r5, pc}
33d0e9e4:	33d27294 	.word	0x33d27294
33d0e9e8:	33d27e5c 	.word	0x33d27e5c
33d0e9ec:	33d27e6c 	.word	0x33d27e6c
33d0e9f0:	33d35ff0 	.word	0x33d35ff0
33d0e9f4:	33d27e80 	.word	0x33d27e80
33d0e9f8:	33d27e8c 	.word	0x33d27e8c
33d0e9fc:	33d27008 	.word	0x33d27008

33d0ea00 <valid_elf_image>:
 * Determine if a valid ELF image exists at the given memory location.
 * First looks at the ELF header magic field, the makes sure that it is
 * executable and makes sure that it is for a PowerPC.
 * ====================================================================== */
int valid_elf_image (unsigned long addr)
{
33d0ea00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d0ea04:	e1a0c000 	mov	ip, r0

	/* -------------------------------------------------- */

	ehdr = (Elf32_Ehdr *) addr;

	if (!IS_ELF (*ehdr)) {
33d0ea08:	e59c2000 	ldr	r2, [ip]
33d0ea0c:	e59f3034 	ldr	r3, [pc, #52]	; 33d0ea48 <valid_elf_image+0x48>
33d0ea10:	e1520003 	cmp	r2, r3
		printf ("## No elf image at address 0x%08lx\n", addr);
33d0ea14:	e1a01000 	mov	r1, r0
33d0ea18:	e59f002c 	ldr	r0, [pc, #44]	; 33d0ea4c <valid_elf_image+0x4c>

	/* -------------------------------------------------- */

	ehdr = (Elf32_Ehdr *) addr;

	if (!IS_ELF (*ehdr)) {
33d0ea1c:	1a000005 	bne	33d0ea38 <valid_elf_image+0x38>
		printf ("## No elf image at address 0x%08lx\n", addr);
		return 0;
	}

	if (ehdr->e_type != ET_EXEC) {
33d0ea20:	e1dc31b0 	ldrh	r3, [ip, #16]
33d0ea24:	e3530002 	cmp	r3, #2	; 0x2
		printf ("## Not a 32-bit elf image at address 0x%08lx\n",
33d0ea28:	e1a0100c 	mov	r1, ip
33d0ea2c:	e59f001c 	ldr	r0, [pc, #28]	; 33d0ea50 <valid_elf_image+0x50>
			addr);
		return 0;
	}
#endif

	return 1;
33d0ea30:	e3a03001 	mov	r3, #1	; 0x1
	if (!IS_ELF (*ehdr)) {
		printf ("## No elf image at address 0x%08lx\n", addr);
		return 0;
	}

	if (ehdr->e_type != ET_EXEC) {
33d0ea34:	0a000001 	beq	33d0ea40 <valid_elf_image+0x40>
		printf ("## Not a 32-bit elf image at address 0x%08lx\n",
33d0ea38:	eb002162 	bl	33d16fc8 <printf>
			addr);
		return 0;
33d0ea3c:	e3a03000 	mov	r3, #0	; 0x0
		return 0;
	}
#endif

	return 1;
}
33d0ea40:	e1a00003 	mov	r0, r3
33d0ea44:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d0ea48:	464c457f 	.word	0x464c457f
33d0ea4c:	33d27f88 	.word	0x33d27f88
33d0ea50:	33d27fac 	.word	0x33d27fac

33d0ea54 <load_elf_image>:
/* ======================================================================
 * A very simple elf loader, assumes the image is valid, returns the
 * entry point address.
 * ====================================================================== */
unsigned long load_elf_image (unsigned long addr)
{
33d0ea54:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	/* -------------------------------------------------- */

	ehdr = (Elf32_Ehdr *) addr;

	/* Find the section header string table for output info */
	shdr = (Elf32_Shdr *) (addr + ehdr->e_shoff +
33d0ea58:	e5903020 	ldr	r3, [r0, #32]
33d0ea5c:	e1d023b2 	ldrh	r2, [r0, #50]
33d0ea60:	e0803003 	add	r3, r0, r3
33d0ea64:	e0822102 	add	r2, r2, r2, lsl #2
33d0ea68:	e0834182 	add	r4, r3, r2, lsl #3
			       (ehdr->e_shstrndx * sizeof (Elf32_Shdr)));

	if (shdr->sh_type == SHT_STRTAB)
33d0ea6c:	e5943004 	ldr	r3, [r4, #4]
33d0ea70:	e3530003 	cmp	r3, #3	; 0x3
		strtab = (unsigned char *) (addr + shdr->sh_offset);
33d0ea74:	05943010 	ldreq	r3, [r4, #16]
 * ====================================================================== */
unsigned long load_elf_image (unsigned long addr)
{
	Elf32_Ehdr *ehdr;		/* Elf header structure pointer     */
	Elf32_Shdr *shdr;		/* Section header structure pointer */
	unsigned char *strtab = 0;	/* String table pointer             */
33d0ea78:	e3a0a000 	mov	sl, #0	; 0x0
	/* Find the section header string table for output info */
	shdr = (Elf32_Shdr *) (addr + ehdr->e_shoff +
			       (ehdr->e_shstrndx * sizeof (Elf32_Shdr)));

	if (shdr->sh_type == SHT_STRTAB)
		strtab = (unsigned char *) (addr + shdr->sh_offset);
33d0ea7c:	0080a003 	addeq	sl, r0, r3

	/* Load each appropriate section */
	for (i = 0; i < ehdr->e_shnum; ++i) {
33d0ea80:	e1d033b0 	ldrh	r3, [r0, #48]
33d0ea84:	e3a06000 	mov	r6, #0	; 0x0
33d0ea88:	e1560003 	cmp	r6, r3
/* ======================================================================
 * A very simple elf loader, assumes the image is valid, returns the
 * entry point address.
 * ====================================================================== */
unsigned long load_elf_image (unsigned long addr)
{
33d0ea8c:	e24dd004 	sub	sp, sp, #4	; 0x4
33d0ea90:	e1a05000 	mov	r5, r0

	if (shdr->sh_type == SHT_STRTAB)
		strtab = (unsigned char *) (addr + shdr->sh_offset);

	/* Load each appropriate section */
	for (i = 0; i < ehdr->e_shnum; ++i) {
33d0ea94:	aa00002f 	bge	33d0eb58 <load_elf_image+0x104>
33d0ea98:	e1a07006 	mov	r7, r6
		shdr = (Elf32_Shdr *) (addr + ehdr->e_shoff +
33d0ea9c:	e5953020 	ldr	r3, [r5, #32]
33d0eaa0:	e0852003 	add	r2, r5, r3
33d0eaa4:	e0824007 	add	r4, r2, r7
				       (i * sizeof (Elf32_Shdr)));

		if (!(shdr->sh_flags & SHF_ALLOC)
33d0eaa8:	e5943008 	ldr	r3, [r4, #8]
33d0eaac:	e3130002 	tst	r3, #2	; 0x2
33d0eab0:	0a000023 	beq	33d0eb44 <load_elf_image+0xf0>
33d0eab4:	e594300c 	ldr	r3, [r4, #12]
33d0eab8:	e3530000 	cmp	r3, #0	; 0x0
33d0eabc:	0a000020 	beq	33d0eb44 <load_elf_image+0xf0>
33d0eac0:	e5941014 	ldr	r1, [r4, #20]
33d0eac4:	e3510000 	cmp	r1, #0	; 0x0
33d0eac8:	0a00001d 	beq	33d0eb44 <load_elf_image+0xf0>
		   || shdr->sh_addr == 0 || shdr->sh_size == 0) {
			continue;
		}

		if (strtab) {
33d0eacc:	e35a0000 	cmp	sl, #0	; 0x0
			printf ("%sing %s @ 0x%08lx (%ld bytes)\n",
33d0ead0:	e59f008c 	ldr	r0, [pc, #140]	; 33d0eb64 <load_elf_image+0x110>
		if (!(shdr->sh_flags & SHF_ALLOC)
		   || shdr->sh_addr == 0 || shdr->sh_size == 0) {
			continue;
		}

		if (strtab) {
33d0ead4:	0a000008 	beq	33d0eafc <load_elf_image+0xa8>
			printf ("%sing %s @ 0x%08lx (%ld bytes)\n",
33d0ead8:	e594e004 	ldr	lr, [r4, #4]
33d0eadc:	e7922007 	ldr	r2, [r2, r7]
33d0eae0:	e59fc080 	ldr	ip, [pc, #128]	; 33d0eb68 <load_elf_image+0x114>
33d0eae4:	e35e0008 	cmp	lr, #8	; 0x8
33d0eae8:	e58d1000 	str	r1, [sp]
33d0eaec:	e08a2002 	add	r2, sl, r2
33d0eaf0:	e59f1074 	ldr	r1, [pc, #116]	; 33d0eb6c <load_elf_image+0x118>
33d0eaf4:	11a0100c 	movne	r1, ip
33d0eaf8:	eb002132 	bl	33d16fc8 <printf>
				&strtab[shdr->sh_name],
				(unsigned long) shdr->sh_addr,
				(long) shdr->sh_size);
		}

		if (shdr->sh_type == SHT_NOBITS) {
33d0eafc:	e5943004 	ldr	r3, [r4, #4]
33d0eb00:	e594e00c 	ldr	lr, [r4, #12]
33d0eb04:	e594c014 	ldr	ip, [r4, #20]
33d0eb08:	e3530008 	cmp	r3, #8	; 0x8
			memset ((void *)shdr->sh_addr, 0, shdr->sh_size);
33d0eb0c:	e3a01000 	mov	r1, #0	; 0x0
33d0eb10:	e1a0000e 	mov	r0, lr
33d0eb14:	e1a0200c 	mov	r2, ip
				&strtab[shdr->sh_name],
				(unsigned long) shdr->sh_addr,
				(long) shdr->sh_size);
		}

		if (shdr->sh_type == SHT_NOBITS) {
33d0eb18:	1a000001 	bne	33d0eb24 <load_elf_image+0xd0>
			memset ((void *)shdr->sh_addr, 0, shdr->sh_size);
33d0eb1c:	eb002e1c 	bl	33d1a394 <memset>
33d0eb20:	ea000004 	b	33d0eb38 <load_elf_image+0xe4>
		} else {
			image = (unsigned char *) addr + shdr->sh_offset;
33d0eb24:	e5941010 	ldr	r1, [r4, #16]
			memcpy ((void *) shdr->sh_addr,
33d0eb28:	e1a0200c 	mov	r2, ip
33d0eb2c:	e1a0000e 	mov	r0, lr
33d0eb30:	e0851001 	add	r1, r5, r1
33d0eb34:	eb002e2a 	bl	33d1a3e4 <memcpy>
				(const void *) image,
				shdr->sh_size);
		}
		flush_cache (shdr->sh_addr, shdr->sh_size);
33d0eb38:	e5941014 	ldr	r1, [r4, #20]
33d0eb3c:	e594000c 	ldr	r0, [r4, #12]
33d0eb40:	eb004071 	bl	33d1ed0c <flush_cache>

	if (shdr->sh_type == SHT_STRTAB)
		strtab = (unsigned char *) (addr + shdr->sh_offset);

	/* Load each appropriate section */
	for (i = 0; i < ehdr->e_shnum; ++i) {
33d0eb44:	e1d533b0 	ldrh	r3, [r5, #48]
33d0eb48:	e2866001 	add	r6, r6, #1	; 0x1
33d0eb4c:	e1560003 	cmp	r6, r3
33d0eb50:	e2877028 	add	r7, r7, #40	; 0x28
33d0eb54:	baffffd0 	blt	33d0ea9c <load_elf_image+0x48>
		}
		flush_cache (shdr->sh_addr, shdr->sh_size);
	}

	return ehdr->e_entry;
}
33d0eb58:	e5950018 	ldr	r0, [r5, #24]
33d0eb5c:	e28dd004 	add	sp, sp, #4	; 0x4
33d0eb60:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0eb64:	33d27fdc 	.word	0x33d27fdc
33d0eb68:	33d27ffc 	.word	0x33d27ffc
33d0eb6c:	33d28004 	.word	0x33d28004

33d0eb70 <do_bootvx>:
 * Interpreter command to boot VxWorks from a memory image.  The image can
 * be either an ELF image or a raw binary.  Will attempt to setup the
 * bootline and other parameters correctly.
 * ====================================================================== */
int do_bootvx ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0eb70:	e92d4070 	push	{r4, r5, r6, lr}
	/*
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if ((tmp = getenv ("loadaddr")) != NULL) {
33d0eb74:	e59f0140 	ldr	r0, [pc, #320]	; 33d0ecbc <do_bootvx+0x14c>
 * Interpreter command to boot VxWorks from a memory image.  The image can
 * be either an ELF image or a raw binary.  Will attempt to setup the
 * bootline and other parameters correctly.
 * ====================================================================== */
int do_bootvx ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0eb78:	e1a04002 	mov	r4, r2
33d0eb7c:	e1a06003 	mov	r6, r3
	/*
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if ((tmp = getenv ("loadaddr")) != NULL) {
33d0eb80:	eb001b32 	bl	33d15850 <getenv>
33d0eb84:	e3500000 	cmp	r0, #0	; 0x0
		addr = simple_strtoul (tmp, NULL, 16);
	} else {
		puts ("No load address provided\n");
33d0eb88:	059f0130 	ldreq	r0, [pc, #304]	; 33d0ecc0 <do_bootvx+0x150>
	/*
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if ((tmp = getenv ("loadaddr")) != NULL) {
33d0eb8c:	0a000047 	beq	33d0ecb0 <do_bootvx+0x140>
		addr = simple_strtoul (tmp, NULL, 16);
33d0eb90:	e3a01000 	mov	r1, #0	; 0x0
33d0eb94:	e3a02010 	mov	r2, #16	; 0x10
33d0eb98:	eb002e6f 	bl	33d1a55c <simple_strtoul>
	}

#if (CONFIG_COMMANDS & CFG_CMD_NET)
	/* Check to see if we need to tftp the image ourselves before starting */

	if ((argc == 2) && (strcmp (argv[1], "tftp") == 0)) {
33d0eb9c:	e3540002 	cmp	r4, #2	; 0x2
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if ((tmp = getenv ("loadaddr")) != NULL) {
		addr = simple_strtoul (tmp, NULL, 16);
33d0eba0:	e1a05000 	mov	r5, r0
	}

#if (CONFIG_COMMANDS & CFG_CMD_NET)
	/* Check to see if we need to tftp the image ourselves before starting */

	if ((argc == 2) && (strcmp (argv[1], "tftp") == 0)) {
33d0eba4:	1a00000b 	bne	33d0ebd8 <do_bootvx+0x68>
33d0eba8:	e5960004 	ldr	r0, [r6, #4]
33d0ebac:	e59f1110 	ldr	r1, [pc, #272]	; 33d0ecc4 <do_bootvx+0x154>
33d0ebb0:	eb002d2c 	bl	33d1a068 <strcmp>
33d0ebb4:	e3500000 	cmp	r0, #0	; 0x0
33d0ebb8:	1a000006 	bne	33d0ebd8 <do_bootvx+0x68>
		if (NetLoop (TFTP) <= 0)
33d0ebbc:	e2800003 	add	r0, r0, #3	; 0x3
33d0ebc0:	ebffd01e 	bl	33d02c40 <NetLoop>
33d0ebc4:	e3500000 	cmp	r0, #0	; 0x0
33d0ebc8:	da000039 	ble	33d0ecb4 <do_bootvx+0x144>
			return 1;
		printf ("Automatic boot of VxWorks image at address 0x%08lx ... \n", addr);
33d0ebcc:	e59f00f4 	ldr	r0, [pc, #244]	; 33d0ecc8 <do_bootvx+0x158>
33d0ebd0:	e1a01005 	mov	r1, r5
33d0ebd4:	eb0020fb 	bl	33d16fc8 <printf>
	memcpy ((char *) tmp, (char *) &gd->bd->bi_enetaddr[3], 3);
#elif defined(CFG_VXWORKS_MAC_PTR)
	tmp = (char *) CFG_VXWORKS_MAC_PTR;
	memcpy ((char *) tmp, (char *) &gd->bd->bi_enetaddr[0], 6);
#else
	puts ("## Ethernet MAC address not copied to NV RAM\n");
33d0ebd8:	e59f00ec 	ldr	r0, [pc, #236]	; 33d0eccc <do_bootvx+0x15c>
33d0ebdc:	eb0020f2 	bl	33d16fac <puts>
	 * will look for the bootline string. The default value for
	 * PowerPC is LOCAL_MEM_LOCAL_ADRS + BOOT_LINE_OFFSET which
	 * defaults to 0x4200
	 */

	if ((tmp = getenv ("bootaddr")) == NULL)
33d0ebe0:	e59f00e8 	ldr	r0, [pc, #232]	; 33d0ecd0 <do_bootvx+0x160>
33d0ebe4:	eb001b19 	bl	33d15850 <getenv>
33d0ebe8:	e3500000 	cmp	r0, #0	; 0x0
		bootaddr = 0x4200;
33d0ebec:	03a06c42 	moveq	r6, #16896	; 0x4200
	 * will look for the bootline string. The default value for
	 * PowerPC is LOCAL_MEM_LOCAL_ADRS + BOOT_LINE_OFFSET which
	 * defaults to 0x4200
	 */

	if ((tmp = getenv ("bootaddr")) == NULL)
33d0ebf0:	0a000003 	beq	33d0ec04 <do_bootvx+0x94>
		bootaddr = 0x4200;
	else
		bootaddr = simple_strtoul (tmp, NULL, 16);
33d0ebf4:	e3a01000 	mov	r1, #0	; 0x0
33d0ebf8:	e3a02010 	mov	r2, #16	; 0x10
33d0ebfc:	eb002e56 	bl	33d1a55c <simple_strtoul>
33d0ec00:	e1a06000 	mov	r6, r0
	 * Check to see if the bootline is defined in the 'bootargs'
	 * parameter. If it is not defined, we may be able to
	 * construct the info
	 */

	if ((bootline = getenv ("bootargs")) != NULL) {
33d0ec04:	e59f00c8 	ldr	r0, [pc, #200]	; 33d0ecd4 <do_bootvx+0x164>
33d0ec08:	eb001b10 	bl	33d15850 <getenv>
33d0ec0c:	e2504000 	subs	r4, r0, #0	; 0x0
		 * I'm not sure what the device should be for other
		 * PPC flavors, the hostname and ipaddr should be ok
		 * to just copy
		 */

		puts ("No bootargs defined\n");
33d0ec10:	059f00c0 	ldreq	r0, [pc, #192]	; 33d0ecd8 <do_bootvx+0x168>
	 * Check to see if the bootline is defined in the 'bootargs'
	 * parameter. If it is not defined, we may be able to
	 * construct the info
	 */

	if ((bootline = getenv ("bootargs")) != NULL) {
33d0ec14:	0a000025 	beq	33d0ecb0 <do_bootvx+0x140>
		memcpy ((void *) bootaddr, bootline, MAX(strlen(bootline), 255));
33d0ec18:	eb002d3c 	bl	33d1a110 <strlen>
33d0ec1c:	e35000ff 	cmp	r0, #255	; 0xff
33d0ec20:	93a000ff 	movls	r0, #255	; 0xff
33d0ec24:	81a00004 	movhi	r0, r4
33d0ec28:	8b002d38 	blhi	33d1a110 <strlen>
33d0ec2c:	e1a02000 	mov	r2, r0
33d0ec30:	e1a01004 	mov	r1, r4
33d0ec34:	e1a00006 	mov	r0, r6
33d0ec38:	eb002de9 	bl	33d1a3e4 <memcpy>
		flush_cache (bootaddr, MAX(strlen(bootline), 255));
33d0ec3c:	e1a00004 	mov	r0, r4
33d0ec40:	eb002d32 	bl	33d1a110 <strlen>
33d0ec44:	e35000ff 	cmp	r0, #255	; 0xff
33d0ec48:	93a000ff 	movls	r0, #255	; 0xff
33d0ec4c:	81a00004 	movhi	r0, r4
33d0ec50:	8b002d2e 	blhi	33d1a110 <strlen>
33d0ec54:	e1a01000 	mov	r1, r0
33d0ec58:	e1a00006 	mov	r0, r6
33d0ec5c:	eb00402a 	bl	33d1ed0c <flush_cache>
	 * If the data at the load address is an elf image, then
	 * treat it like an elf image. Otherwise, assume that it is a
	 * binary image
	 */

	if (valid_elf_image (addr)) {
33d0ec60:	e1a00005 	mov	r0, r5
33d0ec64:	ebffff65 	bl	33d0ea00 <valid_elf_image>
33d0ec68:	e3500000 	cmp	r0, #0	; 0x0
33d0ec6c:	0a000003 	beq	33d0ec80 <do_bootvx+0x110>
		addr = load_elf_image (addr);
33d0ec70:	e1a00005 	mov	r0, r5
33d0ec74:	ebffff76 	bl	33d0ea54 <load_elf_image>
33d0ec78:	e1a05000 	mov	r5, r0
33d0ec7c:	ea000001 	b	33d0ec88 <do_bootvx+0x118>
	} else {
		puts ("## Not an ELF image, assuming binary\n");
33d0ec80:	e59f0054 	ldr	r0, [pc, #84]	; 33d0ecdc <do_bootvx+0x16c>
33d0ec84:	eb0020c8 	bl	33d16fac <puts>
		/* leave addr as load_addr */
	}

	printf ("## Using bootline (@ 0x%lx): %s\n", bootaddr,
33d0ec88:	e1a02006 	mov	r2, r6
33d0ec8c:	e1a01006 	mov	r1, r6
33d0ec90:	e59f0048 	ldr	r0, [pc, #72]	; 33d0ece0 <do_bootvx+0x170>
33d0ec94:	eb0020cb 	bl	33d16fc8 <printf>
			(char *) bootaddr);
	printf ("## Starting vxWorks at 0x%08lx ...\n", addr);
33d0ec98:	e59f0044 	ldr	r0, [pc, #68]	; 33d0ece4 <do_bootvx+0x174>
33d0ec9c:	e1a01005 	mov	r1, r5
33d0eca0:	eb0020c8 	bl	33d16fc8 <printf>

	((void (*)(void)) addr) ();
33d0eca4:	e1a0e00f 	mov	lr, pc
33d0eca8:	e1a0f005 	mov	pc, r5

	puts ("## vxWorks terminated\n");
33d0ecac:	e59f0034 	ldr	r0, [pc, #52]	; 33d0ece8 <do_bootvx+0x178>
33d0ecb0:	eb0020bd 	bl	33d16fac <puts>
	return 1;
}
33d0ecb4:	e3a00001 	mov	r0, #1	; 0x1
33d0ecb8:	e8bd8070 	pop	{r4, r5, r6, pc}
33d0ecbc:	33d25514 	.word	0x33d25514
33d0ecc0:	33d2800c 	.word	0x33d2800c
33d0ecc4:	33d28028 	.word	0x33d28028
33d0ecc8:	33d28030 	.word	0x33d28030
33d0eccc:	33d2806c 	.word	0x33d2806c
33d0ecd0:	33d2809c 	.word	0x33d2809c
33d0ecd4:	33d255f4 	.word	0x33d255f4
33d0ecd8:	33d280a8 	.word	0x33d280a8
33d0ecdc:	33d280c0 	.word	0x33d280c0
33d0ece0:	33d280e8 	.word	0x33d280e8
33d0ece4:	33d2810c 	.word	0x33d2810c
33d0ece8:	33d28130 	.word	0x33d28130

33d0ecec <do_bootelf>:

/* ======================================================================
 * Interpreter command to boot an arbitrary ELF image from memory.
 * ====================================================================== */
int do_bootelf (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0ecec:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d0ecf0:	e1a07002 	mov	r7, r2
	unsigned long rc;		/* Return value from user code  */

	/* -------------------------------------------------- */
	int rcode = 0;

	if (argc < 2)
33d0ecf4:	e3570001 	cmp	r7, #1	; 0x1

/* ======================================================================
 * Interpreter command to boot an arbitrary ELF image from memory.
 * ====================================================================== */
int do_bootelf (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0ecf8:	e1a06003 	mov	r6, r3

	/* -------------------------------------------------- */
	int rcode = 0;

	if (argc < 2)
		addr = load_addr;
33d0ecfc:	d59f3084 	ldrle	r3, [pc, #132]	; 33d0ed88 <do_bootelf+0x9c>
{
	unsigned long addr;		/* Address of the ELF image     */
	unsigned long rc;		/* Return value from user code  */

	/* -------------------------------------------------- */
	int rcode = 0;
33d0ed00:	e3a05000 	mov	r5, #0	; 0x0

	if (argc < 2)
		addr = load_addr;
	else
		addr = simple_strtoul (argv[1], NULL, 16);
33d0ed04:	e3a02010 	mov	r2, #16	; 0x10
33d0ed08:	e1a01005 	mov	r1, r5

	/* -------------------------------------------------- */
	int rcode = 0;

	if (argc < 2)
		addr = load_addr;
33d0ed0c:	d5934000 	ldrle	r4, [r3]
	unsigned long rc;		/* Return value from user code  */

	/* -------------------------------------------------- */
	int rcode = 0;

	if (argc < 2)
33d0ed10:	da000002 	ble	33d0ed20 <do_bootelf+0x34>
		addr = load_addr;
	else
		addr = simple_strtoul (argv[1], NULL, 16);
33d0ed14:	e5960004 	ldr	r0, [r6, #4]
33d0ed18:	eb002e0f 	bl	33d1a55c <simple_strtoul>
33d0ed1c:	e1a04000 	mov	r4, r0

	if (!valid_elf_image (addr))
33d0ed20:	e1a00004 	mov	r0, r4
33d0ed24:	ebffff35 	bl	33d0ea00 <valid_elf_image>
33d0ed28:	e3500000 	cmp	r0, #0	; 0x0
		return 1;
33d0ed2c:	e3a03001 	mov	r3, #1	; 0x1

	addr = load_elf_image (addr);
33d0ed30:	e1a00004 	mov	r0, r4
	if (argc < 2)
		addr = load_addr;
	else
		addr = simple_strtoul (argv[1], NULL, 16);

	if (!valid_elf_image (addr))
33d0ed34:	0a000011 	beq	33d0ed80 <do_bootelf+0x94>
		return 1;

	addr = load_elf_image (addr);
33d0ed38:	ebffff45 	bl	33d0ea54 <load_elf_image>

	printf ("## Starting application at 0x%08lx ...\n", addr);
33d0ed3c:	e1a01000 	mov	r1, r0
		addr = simple_strtoul (argv[1], NULL, 16);

	if (!valid_elf_image (addr))
		return 1;

	addr = load_elf_image (addr);
33d0ed40:	e1a04000 	mov	r4, r0

	printf ("## Starting application at 0x%08lx ...\n", addr);
33d0ed44:	e59f0040 	ldr	r0, [pc, #64]	; 33d0ed8c <do_bootelf+0xa0>
33d0ed48:	eb00209e 	bl	33d16fc8 <printf>

	/*
	 * QNX images require the data cache is disabled.
	 * Data cache is already flushed, so just turn it off.
	 */
	if (dcache_status ())
33d0ed4c:	eb003d57 	bl	33d1e2b0 <dcache_status>
33d0ed50:	e3500000 	cmp	r0, #0	; 0x0
		dcache_disable ();
33d0ed54:	1b003d4e 	blne	33d1e294 <dcache_disable>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = ((ulong (*)(int, char *[])) addr) (--argc, &argv[1]);
33d0ed58:	e2861004 	add	r1, r6, #4	; 0x4
33d0ed5c:	e2470001 	sub	r0, r7, #1	; 0x1
33d0ed60:	e1a0e00f 	mov	lr, pc
33d0ed64:	e1a0f004 	mov	pc, r4
	if (rc != 0)
		rcode = 1;
33d0ed68:	e3500000 	cmp	r0, #0	; 0x0
	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = ((ulong (*)(int, char *[])) addr) (--argc, &argv[1]);
	if (rc != 0)
33d0ed6c:	e1a01000 	mov	r1, r0
		rcode = 1;
33d0ed70:	13a05001 	movne	r5, #1	; 0x1

	printf ("## Application terminated, rc = 0x%lx\n", rc);
33d0ed74:	e59f0014 	ldr	r0, [pc, #20]	; 33d0ed90 <do_bootelf+0xa4>
33d0ed78:	eb002092 	bl	33d16fc8 <printf>
	return rcode;
33d0ed7c:	e1a03005 	mov	r3, r5
}
33d0ed80:	e1a00003 	mov	r0, r3
33d0ed84:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0ed88:	33d35fec 	.word	0x33d35fec
33d0ed8c:	33d28148 	.word	0x33d28148
33d0ed90:	33d28170 	.word	0x33d28170

33d0ed94 <abbrev_spec>:
 *			  a parsing error, a number out of range,
 *			  or an invalid flash bank.
 */
static int
abbrev_spec (char *str, flash_info_t ** pinfo, int *psf, int *psl)
{
33d0ed94:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0ed98:	e24dd008 	sub	sp, sp, #8	; 0x8
33d0ed9c:	e58d1000 	str	r1, [sp]
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
33d0eda0:	e3a0103a 	mov	r1, #58	; 0x3a
 *			  a parsing error, a number out of range,
 *			  or an invalid flash bank.
 */
static int
abbrev_spec (char *str, flash_info_t ** pinfo, int *psf, int *psl)
{
33d0eda4:	e1a09002 	mov	r9, r2
33d0eda8:	e1a0b003 	mov	fp, r3
33d0edac:	e1a05000 	mov	r5, r0
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
33d0edb0:	eb002cca 	bl	33d1a0e0 <strchr>
33d0edb4:	e2504000 	subs	r4, r0, #0	; 0x0
		return 0;
33d0edb8:	01a00004 	moveq	r0, r4
{
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
33d0edbc:	0a000047 	beq	33d0eee0 <abbrev_spec+0x14c>
		return 0;
	*p++ = '\0';
33d0edc0:	e3a03000 	mov	r3, #0	; 0x0

	bank = simple_strtoul (str, &ep, 10);
33d0edc4:	e28da004 	add	sl, sp, #4	; 0x4
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
		return 0;
	*p++ = '\0';
33d0edc8:	e4c43001 	strb	r3, [r4], #1

	bank = simple_strtoul (str, &ep, 10);
33d0edcc:	e1a00005 	mov	r0, r5
33d0edd0:	e1a0100a 	mov	r1, sl
33d0edd4:	e3a0200a 	mov	r2, #10	; 0xa
33d0edd8:	eb002ddf 	bl	33d1a55c <simple_strtoul>
	if (ep == str || *ep != '\0' ||
33d0eddc:	e59d3004 	ldr	r3, [sp, #4]
33d0ede0:	e1530005 	cmp	r3, r5
33d0ede4:	0a000036 	beq	33d0eec4 <abbrev_spec+0x130>
33d0ede8:	e5d32000 	ldrb	r2, [r3]
33d0edec:	e3500000 	cmp	r0, #0	; 0x0
33d0edf0:	c3a03000 	movgt	r3, #0	; 0x0
33d0edf4:	d3a03001 	movle	r3, #1	; 0x1
33d0edf8:	e3520000 	cmp	r2, #0	; 0x0
33d0edfc:	01a06003 	moveq	r6, r3
33d0ee00:	13836001 	orrne	r6, r3, #1	; 0x1
33d0ee04:	e3560000 	cmp	r6, #0	; 0x0
33d0ee08:	1a00002d 	bne	33d0eec4 <abbrev_spec+0x130>
33d0ee0c:	e3500001 	cmp	r0, #1	; 0x1
33d0ee10:	ca00002b 	bgt	33d0eec4 <abbrev_spec+0x130>
33d0ee14:	e59f20cc 	ldr	r2, [pc, #204]	; 33d0eee8 <abbrev_spec+0x154>
33d0ee18:	e0803080 	add	r3, r0, r0, lsl #1
33d0ee1c:	e0833183 	add	r3, r3, r3, lsl #3
33d0ee20:	e0827103 	add	r7, r2, r3, lsl #2
33d0ee24:	e5972008 	ldr	r2, [r7, #8]
33d0ee28:	e59f30bc 	ldr	r3, [pc, #188]	; 33d0eeec <abbrev_spec+0x158>
33d0ee2c:	e1520003 	cmp	r2, r3
33d0ee30:	0a000023 	beq	33d0eec4 <abbrev_spec+0x130>
		bank < 1 || bank > CFG_MAX_FLASH_BANKS ||
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
		return -1;

	str = p;
	if ((p = strchr (str, '-')) != NULL)
33d0ee34:	e1a00004 	mov	r0, r4
33d0ee38:	e3a0102d 	mov	r1, #45	; 0x2d
33d0ee3c:	eb002ca7 	bl	33d1a0e0 <strchr>
	if (ep == str || *ep != '\0' ||
		bank < 1 || bank > CFG_MAX_FLASH_BANKS ||
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
		return -1;

	str = p;
33d0ee40:	e1a05004 	mov	r5, r4
	if ((p = strchr (str, '-')) != NULL)
33d0ee44:	e2504000 	subs	r4, r0, #0	; 0x0
		*p++ = '\0';
33d0ee48:	14c46001 	strbne	r6, [r4], #1

	first = simple_strtoul (str, &ep, 10);
33d0ee4c:	e1a00005 	mov	r0, r5
33d0ee50:	e1a0100a 	mov	r1, sl
33d0ee54:	e3a0200a 	mov	r2, #10	; 0xa
33d0ee58:	eb002dbf 	bl	33d1a55c <simple_strtoul>
	if (ep == str || *ep != '\0' || first >= fp->sector_count)
33d0ee5c:	e59d3004 	ldr	r3, [sp, #4]
33d0ee60:	e1530005 	cmp	r3, r5

	str = p;
	if ((p = strchr (str, '-')) != NULL)
		*p++ = '\0';

	first = simple_strtoul (str, &ep, 10);
33d0ee64:	e1a06000 	mov	r6, r0
	if (ep == str || *ep != '\0' || first >= fp->sector_count)
33d0ee68:	0a000015 	beq	33d0eec4 <abbrev_spec+0x130>
33d0ee6c:	e5d33000 	ldrb	r3, [r3]
33d0ee70:	e3530000 	cmp	r3, #0	; 0x0
33d0ee74:	1a000012 	bne	33d0eec4 <abbrev_spec+0x130>
33d0ee78:	e1d730b4 	ldrh	r3, [r7, #4]
33d0ee7c:	e1500003 	cmp	r0, r3
33d0ee80:	aa00000f 	bge	33d0eec4 <abbrev_spec+0x130>
		return -1;

	if (p != NULL) {
33d0ee84:	e3540000 	cmp	r4, #0	; 0x0
33d0ee88:	0a00000f 	beq	33d0eecc <abbrev_spec+0x138>
		last = simple_strtoul (p, &ep, 10);
33d0ee8c:	e1a0100a 	mov	r1, sl
33d0ee90:	e1a00004 	mov	r0, r4
33d0ee94:	e3a0200a 	mov	r2, #10	; 0xa
33d0ee98:	eb002daf 	bl	33d1a55c <simple_strtoul>
		if (ep == p || *ep != '\0' ||
33d0ee9c:	e59d3004 	ldr	r3, [sp, #4]
33d0eea0:	e1530004 	cmp	r3, r4
33d0eea4:	0a000006 	beq	33d0eec4 <abbrev_spec+0x130>
33d0eea8:	e5d33000 	ldrb	r3, [r3]
33d0eeac:	e1500006 	cmp	r0, r6
33d0eeb0:	a3530000 	cmpge	r3, #0	; 0x0
33d0eeb4:	1a000002 	bne	33d0eec4 <abbrev_spec+0x130>
33d0eeb8:	e1d730b4 	ldrh	r3, [r7, #4]
33d0eebc:	e1500003 	cmp	r0, r3
33d0eec0:	ba000001 	blt	33d0eecc <abbrev_spec+0x138>
			last < first || last >= fp->sector_count)
			return -1;
33d0eec4:	e3e00000 	mvn	r0, #0	; 0x0
33d0eec8:	ea000004 	b	33d0eee0 <abbrev_spec+0x14c>
	} else {
		last = first;
	}

	*pinfo = fp;
33d0eecc:	e59d3000 	ldr	r3, [sp]
33d0eed0:	e5837000 	str	r7, [r3]
	*psf = first;
33d0eed4:	e5896000 	str	r6, [r9]
	*psl = last;
33d0eed8:	e58b0000 	str	r0, [fp]

	return 1;
33d0eedc:	e3a00001 	mov	r0, #1	; 0x1
}
33d0eee0:	e28dd008 	add	sp, sp, #8	; 0x8
33d0eee4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0eee8:	33d624e8 	.word	0x33d624e8
33d0eeec:	0000ffff 	.word	0x0000ffff

33d0eef0 <addr_spec>:
 *    1: success
 *   -1: failure (bad format, bad address).
*/
static int
addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
{
33d0eef0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d0eef4:	e24dd004 	sub	sp, sp, #4	; 0x4
33d0eef8:	e1a07002 	mov	r7, r2
33d0eefc:	e1a05001 	mov	r5, r1
	char *ep;
	char len_used; /* indicates if the "start +length" form used */
	char found;
	ulong bank;

	*addr_first = simple_strtoul(arg1, &ep, 16);
33d0ef00:	e3a02010 	mov	r2, #16	; 0x10
33d0ef04:	e1a0100d 	mov	r1, sp
 *    1: success
 *   -1: failure (bad format, bad address).
*/
static int
addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
{
33d0ef08:	e1a06003 	mov	r6, r3
33d0ef0c:	e1a04000 	mov	r4, r0
	char *ep;
	char len_used; /* indicates if the "start +length" form used */
	char found;
	ulong bank;

	*addr_first = simple_strtoul(arg1, &ep, 16);
33d0ef10:	eb002d91 	bl	33d1a55c <simple_strtoul>
	if (ep == arg1 || *ep != '\0')
33d0ef14:	e59d3000 	ldr	r3, [sp]
33d0ef18:	e1530004 	cmp	r3, r4
	char *ep;
	char len_used; /* indicates if the "start +length" form used */
	char found;
	ulong bank;

	*addr_first = simple_strtoul(arg1, &ep, 16);
33d0ef1c:	e1a0a00d 	mov	sl, sp
33d0ef20:	e5870000 	str	r0, [r7]
	if (ep == arg1 || *ep != '\0')
33d0ef24:	0a000052 	beq	33d0f074 <addr_spec+0x184>
33d0ef28:	e5d33000 	ldrb	r3, [r3]
33d0ef2c:	e3530000 	cmp	r3, #0	; 0x0
33d0ef30:	1a00004f 	bne	33d0f074 <addr_spec+0x184>
		return -1;

	len_used = 0;
	if (arg2 && *arg2 == '+'){
33d0ef34:	e3550000 	cmp	r5, #0	; 0x0

	*addr_first = simple_strtoul(arg1, &ep, 16);
	if (ep == arg1 || *ep != '\0')
		return -1;

	len_used = 0;
33d0ef38:	e1a04003 	mov	r4, r3
	if (arg2 && *arg2 == '+'){
33d0ef3c:	0a000003 	beq	33d0ef50 <addr_spec+0x60>
33d0ef40:	e5d53000 	ldrb	r3, [r5]
33d0ef44:	e353002b 	cmp	r3, #43	; 0x2b
		len_used = 1;
		++arg2;
33d0ef48:	02855001 	addeq	r5, r5, #1	; 0x1
	if (ep == arg1 || *ep != '\0')
		return -1;

	len_used = 0;
	if (arg2 && *arg2 == '+'){
		len_used = 1;
33d0ef4c:	03a04001 	moveq	r4, #1	; 0x1
		++arg2;
	}

	*addr_last = simple_strtoul(arg2, &ep, 16);
33d0ef50:	e1a0100a 	mov	r1, sl
33d0ef54:	e1a00005 	mov	r0, r5
33d0ef58:	e3a02010 	mov	r2, #16	; 0x10
33d0ef5c:	eb002d7e 	bl	33d1a55c <simple_strtoul>
	if (ep == arg2 || *ep != '\0')
33d0ef60:	e59d3000 	ldr	r3, [sp]
33d0ef64:	e1530005 	cmp	r3, r5
	if (arg2 && *arg2 == '+'){
		len_used = 1;
		++arg2;
	}

	*addr_last = simple_strtoul(arg2, &ep, 16);
33d0ef68:	e5860000 	str	r0, [r6]
	if (ep == arg2 || *ep != '\0')
33d0ef6c:	0a000040 	beq	33d0f074 <addr_spec+0x184>
33d0ef70:	e5d31000 	ldrb	r1, [r3]
33d0ef74:	e3510000 	cmp	r1, #0	; 0x0
33d0ef78:	1a00003d 	bne	33d0f074 <addr_spec+0x184>
		return -1;

	if (len_used){
33d0ef7c:	e3540000 	cmp	r4, #0	; 0x0
33d0ef80:	0a00003d 	beq	33d0f07c <addr_spec+0x18c>
		/*
		 * *addr_last has the length, compute correct *addr_last
		 * XXX watch out for the integer overflow! Right now it is
		 * checked for in both the callers.
		 */
		*addr_last = *addr_first + *addr_last - 1;
33d0ef84:	e5973000 	ldr	r3, [r7]
33d0ef88:	e0833000 	add	r3, r3, r0
33d0ef8c:	e2433001 	sub	r3, r3, #1	; 0x1
33d0ef90:	e5863000 	str	r3, [r6]
33d0ef94:	e59fc0ec 	ldr	ip, [pc, #236]	; 33d0f088 <addr_spec+0x198>
		 * boundary. We want to round such an address to the next
		 * sector boundary, so that the commands don't fail later on.
		 */

		/* find the end addr of the sector where the *addr_last is */
		found = 0;
33d0ef98:	e1a04001 	mov	r4, r1
		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
33d0ef9c:	e1a05001 	mov	r5, r1
			int i;
			flash_info_t *info = &flash_info[bank];
			for (i = 0; i < info->sector_count && !found; ++i){
33d0efa0:	e1dc20b4 	ldrh	r2, [ip, #4]
33d0efa4:	e3a0e000 	mov	lr, #0	; 0x0
33d0efa8:	e152000e 	cmp	r2, lr
33d0efac:	d3a03000 	movle	r3, #0	; 0x0
33d0efb0:	c3a03001 	movgt	r3, #1	; 0x1
33d0efb4:	e154000e 	cmp	r4, lr
33d0efb8:	13a03000 	movne	r3, #0	; 0x0
33d0efbc:	e153000e 	cmp	r3, lr
33d0efc0:	e1a03802 	lsl	r3, r2, #16
33d0efc4:	0a00001c 	beq	33d0f03c <addr_spec+0x14c>
33d0efc8:	e28c000c 	add	r0, ip, #12	; 0xc
				/* get the end address of the sector */
				ulong sector_end_addr;
				if (i == info->sector_count - 1){
33d0efcc:	e1a03823 	lsr	r3, r3, #16
33d0efd0:	e2433001 	sub	r3, r3, #1	; 0x1
33d0efd4:	e15e0003 	cmp	lr, r3
					sector_end_addr =
33d0efd8:	059c300c 	ldreq	r3, [ip, #12]
33d0efdc:	059c2000 	ldreq	r2, [ip]
						info->start[0] + info->size - 1;
				} else {
					sector_end_addr =
33d0efe0:	15903004 	ldrne	r3, [r0, #4]
			flash_info_t *info = &flash_info[bank];
			for (i = 0; i < info->sector_count && !found; ++i){
				/* get the end address of the sector */
				ulong sector_end_addr;
				if (i == info->sector_count - 1){
					sector_end_addr =
33d0efe4:	00833002 	addeq	r3, r3, r2
						info->start[0] + info->size - 1;
				} else {
					sector_end_addr =
						info->start[i+1] - 1;
				}
				if (*addr_last <= sector_end_addr &&
33d0efe8:	e5962000 	ldr	r2, [r6]
				ulong sector_end_addr;
				if (i == info->sector_count - 1){
					sector_end_addr =
						info->start[0] + info->size - 1;
				} else {
					sector_end_addr =
33d0efec:	e2431001 	sub	r1, r3, #1	; 0x1
						info->start[i+1] - 1;
				}
				if (*addr_last <= sector_end_addr &&
33d0eff0:	e1520001 	cmp	r2, r1
		/* find the end addr of the sector where the *addr_last is */
		found = 0;
		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
			int i;
			flash_info_t *info = &flash_info[bank];
			for (i = 0; i < info->sector_count && !found; ++i){
33d0eff4:	e28ee001 	add	lr, lr, #1	; 0x1
						info->start[0] + info->size - 1;
				} else {
					sector_end_addr =
						info->start[i+1] - 1;
				}
				if (*addr_last <= sector_end_addr &&
33d0eff8:	8a000005 	bhi	33d0f014 <addr_spec+0x124>
33d0effc:	e5903000 	ldr	r3, [r0]
33d0f000:	e1520003 	cmp	r2, r3
33d0f004:	3a000002 	bcc	33d0f014 <addr_spec+0x124>
						*addr_last >= info->start[i]){
					/* sector found */
					found = 1;
					/* adjust *addr_last if necessary */
					if (*addr_last < sector_end_addr){
33d0f008:	e1520001 	cmp	r2, r1
						*addr_last = sector_end_addr;
33d0f00c:	35861000 	strcc	r1, [r6]
						info->start[i+1] - 1;
				}
				if (*addr_last <= sector_end_addr &&
						*addr_last >= info->start[i]){
					/* sector found */
					found = 1;
33d0f010:	e3a04001 	mov	r4, #1	; 0x1
		/* find the end addr of the sector where the *addr_last is */
		found = 0;
		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
			int i;
			flash_info_t *info = &flash_info[bank];
			for (i = 0; i < info->sector_count && !found; ++i){
33d0f014:	e1dc20b4 	ldrh	r2, [ip, #4]
33d0f018:	e152000e 	cmp	r2, lr
33d0f01c:	d3a03000 	movle	r3, #0	; 0x0
33d0f020:	c3a03001 	movgt	r3, #1	; 0x1
33d0f024:	e3540000 	cmp	r4, #0	; 0x0
33d0f028:	13a03000 	movne	r3, #0	; 0x0
33d0f02c:	e3530000 	cmp	r3, #0	; 0x0
33d0f030:	e2800004 	add	r0, r0, #4	; 0x4
33d0f034:	e1a03802 	lsl	r3, r2, #16
33d0f038:	1affffe3 	bne	33d0efcc <addr_spec+0xdc>
		 * sector boundary, so that the commands don't fail later on.
		 */

		/* find the end addr of the sector where the *addr_last is */
		found = 0;
		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
33d0f03c:	e2955001 	adds	r5, r5, #1	; 0x1
33d0f040:	13a03000 	movne	r3, #0	; 0x0
33d0f044:	03a03001 	moveq	r3, #1	; 0x1
33d0f048:	e3540000 	cmp	r4, #0	; 0x0
33d0f04c:	13a03000 	movne	r3, #0	; 0x0
33d0f050:	02033001 	andeq	r3, r3, #1	; 0x1
33d0f054:	e3530000 	cmp	r3, #0	; 0x0
33d0f058:	e28cc06c 	add	ip, ip, #108	; 0x6c
33d0f05c:	1affffcf 	bne	33d0efa0 <addr_spec+0xb0>
						*addr_last = sector_end_addr;
					}
				}
			} /* sector */
		} /* bank */
		if (!found){
33d0f060:	e3540000 	cmp	r4, #0	; 0x0
33d0f064:	1a000004 	bne	33d0f07c <addr_spec+0x18c>
			/* error, addres not in flash */
			printf("Error: end address (0x%08lx) not in flash!\n",
33d0f068:	e5961000 	ldr	r1, [r6]
33d0f06c:	e59f0018 	ldr	r0, [pc, #24]	; 33d0f08c <addr_spec+0x19c>
33d0f070:	eb001fd4 	bl	33d16fc8 <printf>
								*addr_last);
			return -1;
33d0f074:	e3e00000 	mvn	r0, #0	; 0x0
33d0f078:	ea000000 	b	33d0f080 <addr_spec+0x190>
		}
	} /* "start +length" from used */

	return 1;
33d0f07c:	e3a00001 	mov	r0, #1	; 0x1
}
33d0f080:	e28dd004 	add	sp, sp, #4	; 0x4
33d0f084:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0f088:	33d62554 	.word	0x33d62554
33d0f08c:	33d28718 	.word	0x33d28718

33d0f090 <flash_fill_sect_ranges>:

static int
flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
			int *s_first, int *s_last,
			int *s_count )
{
33d0f090:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0f094:	e24dd004 	sub	sp, sp, #4	; 0x4
33d0f098:	e1a0e000 	mov	lr, r0
	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info=&flash_info[0];
33d0f09c:	e1500001 	cmp	r0, r1
{
	flash_info_t *info;
	ulong bank;
	int rcode = 0;

	*s_count = 0;
33d0f0a0:	e59d0024 	ldr	r0, [sp, #36]
			int *s_first, int *s_last,
			int *s_count )
{
	flash_info_t *info;
	ulong bank;
	int rcode = 0;
33d0f0a4:	e3a09000 	mov	r9, #0	; 0x0

static int
flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
			int *s_first, int *s_last,
			int *s_count )
{
33d0f0a8:	e1a0a003 	mov	sl, r3
	int rcode = 0;

	*s_count = 0;

	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
33d0f0ac:	e3e03000 	mvn	r3, #0	; 0x0

static int
flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
			int *s_first, int *s_last,
			int *s_count )
{
33d0f0b0:	e58d2000 	str	r2, [sp]
33d0f0b4:	e1a0b001 	mov	fp, r1
	flash_info_t *info;
	ulong bank;
	int rcode = 0;

	*s_count = 0;
33d0f0b8:	e5809000 	str	r9, [r0]
	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info=&flash_info[0];
33d0f0bc:	e1a04009 	mov	r4, r9
	int rcode = 0;

	*s_count = 0;

	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
33d0f0c0:	e7823109 	str	r3, [r2, r9, lsl #2]
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info=&flash_info[0];
33d0f0c4:	e59f6180 	ldr	r6, [pc, #384]	; 33d0f24c <flash_fill_sect_ranges+0x1bc>

	*s_count = 0;

	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
		s_last [bank] = -1;	/* last  sector to erase	*/
33d0f0c8:	e78a3109 	str	r3, [sl, r9, lsl #2]
	}

	for (bank=0,info=&flash_info[0];
33d0f0cc:	8a00005b 	bhi	33d0f240 <flash_fill_sect_ranges+0x1b0>
	     ++bank, ++info) {
		ulong b_end;
		int sect;
		short s_end;

		if (info->flash_id == FLASH_UNKNOWN) {
33d0f0d0:	e5962008 	ldr	r2, [r6, #8]
33d0f0d4:	e59f3174 	ldr	r3, [pc, #372]	; 33d0f250 <flash_fill_sect_ranges+0x1c0>
33d0f0d8:	e1520003 	cmp	r2, r3
33d0f0dc:	0a00004e 	beq	33d0f21c <flash_fill_sect_ranges+0x18c>
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
		s_end = info->sector_count - 1;			/* last sector   */
33d0f0e0:	e1d600b4 	ldrh	r0, [r6, #4]

		if (info->flash_id == FLASH_UNKNOWN) {
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
33d0f0e4:	e596200c 	ldr	r2, [r6, #12]
33d0f0e8:	e5961000 	ldr	r1, [r6]
		s_end = info->sector_count - 1;			/* last sector   */
33d0f0ec:	e2403001 	sub	r3, r0, #1	; 0x1


		for (sect=0; sect < info->sector_count; ++sect) {
33d0f0f0:	e3a0c000 	mov	ip, #0	; 0x0

		if (info->flash_id == FLASH_UNKNOWN) {
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
33d0f0f4:	e0822001 	add	r2, r2, r1
		s_end = info->sector_count - 1;			/* last sector   */
33d0f0f8:	e1a03803 	lsl	r3, r3, #16


		for (sect=0; sect < info->sector_count; ++sect) {
33d0f0fc:	e15c0000 	cmp	ip, r0

		if (info->flash_id == FLASH_UNKNOWN) {
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
33d0f100:	e2425001 	sub	r5, r2, #1	; 0x1
		s_end = info->sector_count - 1;			/* last sector   */
33d0f104:	e1a07823 	lsr	r7, r3, #16


		for (sect=0; sect < info->sector_count; ++sect) {
33d0f108:	aa000014 	bge	33d0f160 <flash_fill_sect_ranges+0xd0>
33d0f10c:	e286000c 	add	r0, r6, #12	; 0xc
			ulong end;	/* last address in current sect	*/

			end = (sect == s_end) ? b_end : info->start[sect + 1] - 1;
33d0f110:	e1a03807 	lsl	r3, r7, #16
33d0f114:	e15c0843 	cmp	ip, r3, asr #16
33d0f118:	e1a03005 	mov	r3, r5
33d0f11c:	15903004 	ldrne	r3, [r0, #4]
33d0f120:	12433001 	subne	r3, r3, #1	; 0x1

			if (addr_first > end)
33d0f124:	e15e0003 	cmp	lr, r3
33d0f128:	8a000007 	bhi	33d0f14c <flash_fill_sect_ranges+0xbc>
				continue;
			if (addr_last < info->start[sect])
33d0f12c:	e5901000 	ldr	r1, [r0]
33d0f130:	e15b0001 	cmp	fp, r1
33d0f134:	3a000004 	bcc	33d0f14c <flash_fill_sect_ranges+0xbc>
				continue;

			if (addr_first == info->start[sect]) {
33d0f138:	e15e0001 	cmp	lr, r1
				s_first[bank] = sect;
33d0f13c:	059d1000 	ldreq	r1, [sp]
33d0f140:	0781c104 	streq	ip, [r1, r4, lsl #2]
			}
			if (addr_last  == end) {
33d0f144:	e15b0003 	cmp	fp, r3
				s_last[bank]  = sect;
33d0f148:	078ac104 	streq	ip, [sl, r4, lsl #2]

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
		s_end = info->sector_count - 1;			/* last sector   */


		for (sect=0; sect < info->sector_count; ++sect) {
33d0f14c:	e1d630b4 	ldrh	r3, [r6, #4]
33d0f150:	e28cc001 	add	ip, ip, #1	; 0x1
33d0f154:	e15c0003 	cmp	ip, r3
33d0f158:	e2800004 	add	r0, r0, #4	; 0x4
33d0f15c:	baffffeb 	blt	33d0f110 <flash_fill_sect_ranges+0x80>
			}
			if (addr_last  == end) {
				s_last[bank]  = sect;
			}
		}
		if (s_first[bank] >= 0) {
33d0f160:	e59d2000 	ldr	r2, [sp]
33d0f164:	e7923104 	ldr	r3, [r2, r4, lsl #2]
33d0f168:	e3530000 	cmp	r3, #0	; 0x0
33d0f16c:	ba00001a 	blt	33d0f1dc <flash_fill_sect_ranges+0x14c>
			if (s_last[bank] < 0) {
33d0f170:	e79a3104 	ldr	r3, [sl, r4, lsl #2]
33d0f174:	e3530000 	cmp	r3, #0	; 0x0
33d0f178:	aa000005 	bge	33d0f194 <flash_fill_sect_ranges+0x104>
				if (addr_last > b_end) {
33d0f17c:	e15b0005 	cmp	fp, r5
					s_last[bank] = s_end;
33d0f180:	81a03807 	lslhi	r3, r7, #16
33d0f184:	81a03843 	asrhi	r3, r3, #16
33d0f188:	878a3104 	strhi	r3, [sl, r4, lsl #2]
				} else {
					puts ("Error: end address"
33d0f18c:	959f00c0 	ldrls	r0, [pc, #192]	; 33d0f254 <flash_fill_sect_ranges+0x1c4>
33d0f190:	9a00001e 	bls	33d0f210 <flash_fill_sect_ranges+0x180>
						" not on sector boundary\n");
					rcode = 1;
					break;
				}
			}
			if (s_last[bank] < s_first[bank]) {
33d0f194:	e59d3000 	ldr	r3, [sp]
33d0f198:	e79a2104 	ldr	r2, [sl, r4, lsl #2]
33d0f19c:	e7931104 	ldr	r1, [r3, r4, lsl #2]
33d0f1a0:	e1520001 	cmp	r2, r1
				puts ("Error: end sector"
33d0f1a4:	b59f00ac 	ldrlt	r0, [pc, #172]	; 33d0f258 <flash_fill_sect_ranges+0x1c8>
33d0f1a8:	ba000018 	blt	33d0f210 <flash_fill_sect_ranges+0x180>
					" precedes start sector\n");
				rcode = 1;
				break;
			}
			sect = s_last[bank];
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
33d0f1ac:	e1a03807 	lsl	r3, r7, #16
33d0f1b0:	e1520843 	cmp	r2, r3, asr #16
			(*s_count) += s_last[bank] - s_first[bank] + 1;
33d0f1b4:	e59d0024 	ldr	r0, [sp, #36]
					" precedes start sector\n");
				rcode = 1;
				break;
			}
			sect = s_last[bank];
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
33d0f1b8:	10863102 	addne	r3, r6, r2, lsl #2
33d0f1bc:	1593e010 	ldrne	lr, [r3, #16]
			(*s_count) += s_last[bank] - s_first[bank] + 1;
33d0f1c0:	e5903000 	ldr	r3, [r0]
33d0f1c4:	e0612002 	rsb	r2, r1, r2
33d0f1c8:	e0833002 	add	r3, r3, r2
33d0f1cc:	e2833001 	add	r3, r3, #1	; 0x1
					" precedes start sector\n");
				rcode = 1;
				break;
			}
			sect = s_last[bank];
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
33d0f1d0:	0285e001 	addeq	lr, r5, #1	; 0x1
			(*s_count) += s_last[bank] - s_first[bank] + 1;
33d0f1d4:	e5803000 	str	r3, [r0]
33d0f1d8:	ea00000f 	b	33d0f21c <flash_fill_sect_ranges+0x18c>
		} else if (addr_first >= info->start[0] && addr_first < b_end) {
33d0f1dc:	e596300c 	ldr	r3, [r6, #12]
33d0f1e0:	e15e0003 	cmp	lr, r3
33d0f1e4:	33a03000 	movcc	r3, #0	; 0x0
33d0f1e8:	23a03001 	movcs	r3, #1	; 0x1
33d0f1ec:	e15e0005 	cmp	lr, r5
33d0f1f0:	23a03000 	movcs	r3, #0	; 0x0
33d0f1f4:	e3530000 	cmp	r3, #0	; 0x0
			puts ("Error: start address not on sector boundary\n");
33d0f1f8:	159f005c 	ldrne	r0, [pc, #92]	; 33d0f25c <flash_fill_sect_ranges+0x1cc>
33d0f1fc:	1a000003 	bne	33d0f210 <flash_fill_sect_ranges+0x180>
			rcode = 1;
			break;
		} else if (s_last[bank] >= 0) {
33d0f200:	e79a3104 	ldr	r3, [sl, r4, lsl #2]
33d0f204:	e3530000 	cmp	r3, #0	; 0x0
33d0f208:	ba000003 	blt	33d0f21c <flash_fill_sect_ranges+0x18c>
			puts ("Error: cannot span across banks when they are"
33d0f20c:	e59f004c 	ldr	r0, [pc, #76]	; 33d0f260 <flash_fill_sect_ranges+0x1d0>
33d0f210:	eb001f65 	bl	33d16fac <puts>
			       " mapped in reverse order\n");
			rcode = 1;
33d0f214:	e3a09001 	mov	r9, #1	; 0x1
			break;
33d0f218:	ea000008 	b	33d0f240 <flash_fill_sect_ranges+0x1b0>
	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info=&flash_info[0];
33d0f21c:	e2944001 	adds	r4, r4, #1	; 0x1
33d0f220:	13a03000 	movne	r3, #0	; 0x0
33d0f224:	03a03001 	moveq	r3, #1	; 0x1
33d0f228:	e15e000b 	cmp	lr, fp
33d0f22c:	83a03000 	movhi	r3, #0	; 0x0
33d0f230:	92033001 	andls	r3, r3, #1	; 0x1
33d0f234:	e3530000 	cmp	r3, #0	; 0x0
33d0f238:	e286606c 	add	r6, r6, #108	; 0x6c
33d0f23c:	1affffa3 	bne	33d0f0d0 <flash_fill_sect_ranges+0x40>
			break;
		}
	}

	return rcode;
}
33d0f240:	e1a00009 	mov	r0, r9
33d0f244:	e28dd004 	add	sp, sp, #4	; 0x4
33d0f248:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0f24c:	33d62554 	.word	0x33d62554
33d0f250:	0000ffff 	.word	0x0000ffff
33d0f254:	33d28744 	.word	0x33d28744
33d0f258:	33d28770 	.word	0x33d28770
33d0f25c:	33d2879c 	.word	0x33d2879c
33d0f260:	33d287cc 	.word	0x33d287cc

33d0f264 <do_flinfo>:

#ifdef CONFIG_HAS_DATAFLASH
	dataflash_print_info();
#endif

	if (argc == 1) {	/* print info for all FLASH banks */
33d0f264:	e3520001 	cmp	r2, #1	; 0x1

	return rcode;
}

int do_flinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0f268:	e92d4030 	push	{r4, r5, lr}

#ifdef CONFIG_HAS_DATAFLASH
	dataflash_print_info();
#endif

	if (argc == 1) {	/* print info for all FLASH banks */
33d0f26c:	1a00000d 	bne	33d0f2a8 <do_flinfo+0x44>
		for (bank=0; bank <CFG_MAX_FLASH_BANKS; ++bank) {
33d0f270:	e3a05000 	mov	r5, #0	; 0x0
			printf ("\nBank # %ld: ", bank+1);
33d0f274:	e2854001 	add	r4, r5, #1	; 0x1
33d0f278:	e59f0074 	ldr	r0, [pc, #116]	; 33d0f2f4 <do_flinfo+0x90>
33d0f27c:	e1a01004 	mov	r1, r4
33d0f280:	eb001f50 	bl	33d16fc8 <printf>

			flash_print_info (&flash_info[bank]);
33d0f284:	e0850085 	add	r0, r5, r5, lsl #1
33d0f288:	e59f3068 	ldr	r3, [pc, #104]	; 33d0f2f8 <do_flinfo+0x94>
33d0f28c:	e0800180 	add	r0, r0, r0, lsl #3
33d0f290:	e0830100 	add	r0, r3, r0, lsl #2
33d0f294:	eb003a3f 	bl	33d1db98 <flash_print_info>
#ifdef CONFIG_HAS_DATAFLASH
	dataflash_print_info();
#endif

	if (argc == 1) {	/* print info for all FLASH banks */
		for (bank=0; bank <CFG_MAX_FLASH_BANKS; ++bank) {
33d0f298:	e2545000 	subs	r5, r4, #0	; 0x0
33d0f29c:	0afffff4 	beq	33d0f274 <do_flinfo+0x10>
			printf ("\nBank # %ld: ", bank+1);

			flash_print_info (&flash_info[bank]);
		}
		return 0;
33d0f2a0:	e3a00000 	mov	r0, #0	; 0x0
33d0f2a4:	e8bd8030 	pop	{r4, r5, pc}
	}

	bank = simple_strtoul(argv[1], NULL, 16);
33d0f2a8:	e5930004 	ldr	r0, [r3, #4]
33d0f2ac:	e3a01000 	mov	r1, #0	; 0x0
33d0f2b0:	e3a02010 	mov	r2, #16	; 0x10
33d0f2b4:	eb002ca8 	bl	33d1a55c <simple_strtoul>
	if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
33d0f2b8:	e3500001 	cmp	r0, #1	; 0x1
			flash_print_info (&flash_info[bank]);
		}
		return 0;
	}

	bank = simple_strtoul(argv[1], NULL, 16);
33d0f2bc:	e1a05000 	mov	r5, r0
	if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
33d0f2c0:	0a000004 	beq	33d0f2d8 <do_flinfo+0x74>
		printf ("Only FLASH Banks # 1 ... # %d supported\n",
33d0f2c4:	e59f0030 	ldr	r0, [pc, #48]	; 33d0f2fc <do_flinfo+0x98>
33d0f2c8:	e3a01001 	mov	r1, #1	; 0x1
33d0f2cc:	eb001f3d 	bl	33d16fc8 <printf>
			CFG_MAX_FLASH_BANKS);
		return 1;
33d0f2d0:	e3a00001 	mov	r0, #1	; 0x1
33d0f2d4:	e8bd8030 	pop	{r4, r5, pc}
	}
	printf ("\nBank # %ld: ", bank);
33d0f2d8:	e1a01000 	mov	r1, r0
33d0f2dc:	e59f0010 	ldr	r0, [pc, #16]	; 33d0f2f4 <do_flinfo+0x90>
33d0f2e0:	eb001f38 	bl	33d16fc8 <printf>
	flash_print_info (&flash_info[bank-1]);
33d0f2e4:	e59f000c 	ldr	r0, [pc, #12]	; 33d0f2f8 <do_flinfo+0x94>
33d0f2e8:	eb003a2a 	bl	33d1db98 <flash_print_info>
	return 0;
33d0f2ec:	e3a00000 	mov	r0, #0	; 0x0
}
33d0f2f0:	e8bd8030 	pop	{r4, r5, pc}
33d0f2f4:	33d28814 	.word	0x33d28814
33d0f2f8:	33d62554 	.word	0x33d62554
33d0f2fc:	33d28824 	.word	0x33d28824

33d0f300 <flash_sect_erase>:
	rcode = flash_sect_erase(addr_first, addr_last);
	return rcode;
}

int flash_sect_erase (ulong addr_first, ulong addr_last)
{
33d0f300:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d0f304:	e24dd010 	sub	sp, sp, #16	; 0x10
#endif
	int erased = 0;
	int planned;
	int rcode = 0;

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
33d0f308:	e28d900c 	add	r9, sp, #12	; 0xc
33d0f30c:	e28da008 	add	sl, sp, #8	; 0x8
33d0f310:	e1a02009 	mov	r2, r9
33d0f314:	e1a0300a 	mov	r3, sl
33d0f318:	e28dc004 	add	ip, sp, #4	; 0x4
33d0f31c:	e58dc000 	str	ip, [sp]
33d0f320:	ebffff5a 	bl	33d0f090 <flash_fill_sect_ranges>
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
33d0f324:	e59d3004 	ldr	r3, [sp, #4]
33d0f328:	e2702001 	rsbs	r2, r0, #1	; 0x1
33d0f32c:	33a02000 	movcc	r2, #0	; 0x0
33d0f330:	e3530000 	cmp	r3, #0	; 0x0
33d0f334:	03a03000 	moveq	r3, #0	; 0x0
33d0f338:	12023001 	andne	r3, r2, #1	; 0x1
33d0f33c:	e3530000 	cmp	r3, #0	; 0x0
33d0f340:	e1a04000 	mov	r4, r0
#else
	int s_first[CFG_MAX_FLASH_BANKS], s_last[CFG_MAX_FLASH_BANKS];
#endif
	int erased = 0;
	int planned;
	int rcode = 0;
33d0f344:	e3a06000 	mov	r6, #0	; 0x0

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
33d0f348:	0a00001a 	beq	33d0f3b8 <flash_sect_erase+0xb8>
		for (bank=0,info=&flash_info[0];
33d0f34c:	e59f7084 	ldr	r7, [pc, #132]	; 33d0f3d8 <flash_sect_erase+0xd8>
33d0f350:	e1520006 	cmp	r2, r6
33d0f354:	e1a05006 	mov	r5, r6
33d0f358:	0a000012 	beq	33d0f3a8 <flash_sect_erase+0xa8>
		     (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0);
		     ++bank, ++info) {
			if (s_first[bank]>=0) {
33d0f35c:	e7993105 	ldr	r3, [r9, r5, lsl #2]
33d0f360:	e2531000 	subs	r1, r3, #0	; 0x0
					info->start[s_first[bank]],
					(s_last[bank] == info->sector_count) ?
						info->start[0] + info->size - 1:
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
33d0f364:	e1a00007 	mov	r0, r7

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
		for (bank=0,info=&flash_info[0];
33d0f368:	e287706c 	add	r7, r7, #108	; 0x6c
		     (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0);
		     ++bank, ++info) {
			if (s_first[bank]>=0) {
33d0f36c:	ba000005 	blt	33d0f388 <flash_sect_erase+0x88>
				erased += s_last[bank] - s_first[bank] + 1;
33d0f370:	e79a2105 	ldr	r2, [sl, r5, lsl #2]
33d0f374:	e0633002 	rsb	r3, r3, r2
33d0f378:	e0863003 	add	r3, r6, r3
33d0f37c:	e2836001 	add	r6, r3, #1	; 0x1
					info->start[s_first[bank]],
					(s_last[bank] == info->sector_count) ?
						info->start[0] + info->size - 1:
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
33d0f380:	eb003a49 	bl	33d1dcac <flash_erase>
33d0f384:	e1a04000 	mov	r4, r0

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
		for (bank=0,info=&flash_info[0];
33d0f388:	e2955001 	adds	r5, r5, #1	; 0x1
33d0f38c:	13a03000 	movne	r3, #0	; 0x0
33d0f390:	03a03001 	moveq	r3, #1	; 0x1
33d0f394:	e3540000 	cmp	r4, #0	; 0x0
33d0f398:	13a03000 	movne	r3, #0	; 0x0
33d0f39c:	02033001 	andeq	r3, r3, #1	; 0x1
33d0f3a0:	e3530000 	cmp	r3, #0	; 0x0
33d0f3a4:	eaffffeb 	b	33d0f358 <flash_sect_erase+0x58>
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
			}
		}
		printf ("Erased %d sectors\n", erased);
33d0f3a8:	e1a01006 	mov	r1, r6
33d0f3ac:	e59f0028 	ldr	r0, [pc, #40]	; 33d0f3dc <flash_sect_erase+0xdc>
33d0f3b0:	eb001f04 	bl	33d16fc8 <printf>
33d0f3b4:	ea000004 	b	33d0f3cc <flash_sect_erase+0xcc>
	} else if (rcode == 0) {
33d0f3b8:	e3500000 	cmp	r0, #0	; 0x0
33d0f3bc:	1a000002 	bne	33d0f3cc <flash_sect_erase+0xcc>
		puts ("Error: start and/or end address"
33d0f3c0:	e59f0018 	ldr	r0, [pc, #24]	; 33d0f3e0 <flash_sect_erase+0xe0>
33d0f3c4:	eb001ef8 	bl	33d16fac <puts>
			" not on sector boundary\n");
		rcode = 1;
33d0f3c8:	e2844001 	add	r4, r4, #1	; 0x1
	}
	return rcode;
}
33d0f3cc:	e1a00004 	mov	r0, r4
33d0f3d0:	e28dd010 	add	sp, sp, #16	; 0x10
33d0f3d4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d0f3d8:	33d62554 	.word	0x33d62554
33d0f3dc:	33d28850 	.word	0x33d28850
33d0f3e0:	33d28864 	.word	0x33d28864

33d0f3e4 <do_flerase>:
	flash_print_info (&flash_info[bank-1]);
	return 0;
}

int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0f3e4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct part_info *part;
	u8 dev_type, dev_num, pnum;
#endif
	int rcode = 0;

	if (argc < 2) {
33d0f3e8:	e3520001 	cmp	r2, #1	; 0x1
	flash_print_info (&flash_info[bank-1]);
	return 0;
}

int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0f3ec:	e24dd024 	sub	sp, sp, #36	; 0x24
33d0f3f0:	e1a05002 	mov	r5, r2
33d0f3f4:	e1a06000 	mov	r6, r0
33d0f3f8:	e1a04003 	mov	r4, r3
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	struct mtd_device *dev;
	struct part_info *part;
	u8 dev_type, dev_num, pnum;
#endif
	int rcode = 0;
33d0f3fc:	e3a07000 	mov	r7, #0	; 0x0

	if (argc < 2) {
33d0f400:	da000080 	ble	33d0f608 <do_flerase+0x224>
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	if (strcmp(argv[1], "all") == 0) {
33d0f404:	e5930004 	ldr	r0, [r3, #4]
33d0f408:	e59f1218 	ldr	r1, [pc, #536]	; 33d0f628 <do_flerase+0x244>
33d0f40c:	eb002b15 	bl	33d1a068 <strcmp>
33d0f410:	e3500000 	cmp	r0, #0	; 0x0
33d0f414:	1a000009 	bne	33d0f440 <do_flerase+0x5c>
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
			printf ("Erase Flash Bank # %ld ", bank);
33d0f418:	e59f020c 	ldr	r0, [pc, #524]	; 33d0f62c <do_flerase+0x248>
33d0f41c:	e3a01001 	mov	r1, #1	; 0x1
33d0f420:	eb001ee8 	bl	33d16fc8 <printf>
33d0f424:	e59f4204 	ldr	r4, [pc, #516]	; 33d0f630 <do_flerase+0x24c>
			info = &flash_info[bank-1];
			rcode = flash_erase (info, 0, info->sector_count-1);
33d0f428:	e1d420b4 	ldrh	r2, [r4, #4]
33d0f42c:	e1a00004 	mov	r0, r4
33d0f430:	e1a01007 	mov	r1, r7
33d0f434:	e2422001 	sub	r2, r2, #1	; 0x1
	}

	if (strcmp(argv[1], "all") == 0) {
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
			printf ("Erase Flash Bank # %ld ", bank);
			info = &flash_info[bank-1];
33d0f438:	e58d401c 	str	r4, [sp, #28]
33d0f43c:	ea000062 	b	33d0f5cc <do_flerase+0x1e8>
			rcode = flash_erase (info, 0, info->sector_count-1);
		}
		return rcode;
	}

	if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
33d0f440:	e5940004 	ldr	r0, [r4, #4]
33d0f444:	e28d101c 	add	r1, sp, #28	; 0x1c
33d0f448:	e28d2018 	add	r2, sp, #24	; 0x18
33d0f44c:	e28d3014 	add	r3, sp, #20	; 0x14
33d0f450:	ebfffe4f 	bl	33d0ed94 <abbrev_spec>
33d0f454:	e3500000 	cmp	r0, #0	; 0x0
33d0f458:	0a000014 	beq	33d0f4b0 <do_flerase+0xcc>
		if (n < 0) {
33d0f45c:	aa000002 	bge	33d0f46c <do_flerase+0x88>
			puts ("Bad sector specification\n");
33d0f460:	e59f01cc 	ldr	r0, [pc, #460]	; 33d0f634 <do_flerase+0x250>
33d0f464:	eb001ed0 	bl	33d16fac <puts>
33d0f468:	ea000069 	b	33d0f614 <do_flerase+0x230>
			return 1;
		}
		printf ("Erase Flash Sectors %d-%d in Bank # %d ",
33d0f46c:	e59d301c 	ldr	r3, [sp, #28]
33d0f470:	e59f21b8 	ldr	r2, [pc, #440]	; 33d0f630 <do_flerase+0x24c>
33d0f474:	e0623003 	rsb	r3, r2, r3
33d0f478:	e1a03143 	asr	r3, r3, #2
33d0f47c:	e0832183 	add	r2, r3, r3, lsl #3
33d0f480:	e0833082 	add	r3, r3, r2, lsl #1
33d0f484:	e0633483 	rsb	r3, r3, r3, lsl #9
33d0f488:	e0833903 	add	r3, r3, r3, lsl #18
33d0f48c:	e59f01a4 	ldr	r0, [pc, #420]	; 33d0f638 <do_flerase+0x254>
33d0f490:	e59d1018 	ldr	r1, [sp, #24]
33d0f494:	e59d2014 	ldr	r2, [sp, #20]
33d0f498:	e2633001 	rsb	r3, r3, #1	; 0x1
33d0f49c:	eb001ec9 	bl	33d16fc8 <printf>
			sect_first, sect_last, (info-flash_info)+1);
		rcode = flash_erase(info, sect_first, sect_last);
33d0f4a0:	e59d001c 	ldr	r0, [sp, #28]
33d0f4a4:	e59d1018 	ldr	r1, [sp, #24]
33d0f4a8:	e59d2014 	ldr	r2, [sp, #20]
33d0f4ac:	ea000046 	b	33d0f5cc <do_flerase+0x1e8>
		return rcode;
	}

#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	/* erase <part-id> - erase partition */
	if ((argc == 2) && (id_parse(argv[1], NULL, &dev_type, &dev_num) == 0)) {
33d0f4b0:	e3550002 	cmp	r5, #2	; 0x2
33d0f4b4:	1a00002b 	bne	33d0f568 <do_flerase+0x184>
33d0f4b8:	e1a01007 	mov	r1, r7
33d0f4bc:	e5940004 	ldr	r0, [r4, #4]
33d0f4c0:	e28d2023 	add	r2, sp, #35	; 0x23
33d0f4c4:	e28d3022 	add	r3, sp, #34	; 0x22
33d0f4c8:	eb000593 	bl	33d10b1c <id_parse>
33d0f4cc:	e3500000 	cmp	r0, #0	; 0x0
33d0f4d0:	1a00004c 	bne	33d0f608 <do_flerase+0x224>
		mtdparts_init();
33d0f4d4:	eb0006e2 	bl	33d11064 <mtdparts_init>
		if (find_dev_and_part(argv[1], &dev, &pnum, &part) == 0) {
33d0f4d8:	e5940004 	ldr	r0, [r4, #4]
33d0f4dc:	e28d1010 	add	r1, sp, #16	; 0x10
33d0f4e0:	e28d2021 	add	r2, sp, #33	; 0x21
33d0f4e4:	e28d300c 	add	r3, sp, #12	; 0xc
33d0f4e8:	eb000674 	bl	33d10ec0 <find_dev_and_part>
33d0f4ec:	e3500000 	cmp	r0, #0	; 0x0
33d0f4f0:	1a000044 	bne	33d0f608 <do_flerase+0x224>
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
33d0f4f4:	e59d3010 	ldr	r3, [sp, #16]
33d0f4f8:	e5930008 	ldr	r0, [r3, #8]
33d0f4fc:	e5d03008 	ldrb	r3, [r0, #8]
33d0f500:	e3530001 	cmp	r3, #1	; 0x1

				rcode = flash_sect_erase(addr_first, addr_last);
				return rcode;
			}

			printf("cannot erase, not a NOR device\n");
33d0f504:	159f0130 	ldrne	r0, [pc, #304]	; 33d0f63c <do_flerase+0x258>
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	/* erase <part-id> - erase partition */
	if ((argc == 2) && (id_parse(argv[1], NULL, &dev_type, &dev_num) == 0)) {
		mtdparts_init();
		if (find_dev_and_part(argv[1], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
33d0f508:	1a000038 	bne	33d0f5f0 <do_flerase+0x20c>
				bank = dev->id->num;
33d0f50c:	e5d00009 	ldrb	r0, [r0, #9]
				info = &flash_info[bank];
33d0f510:	e59f2118 	ldr	r2, [pc, #280]	; 33d0f630 <do_flerase+0x24c>
33d0f514:	e0803080 	add	r3, r0, r0, lsl #1
33d0f518:	e0833183 	add	r3, r3, r3, lsl #3
33d0f51c:	e0822103 	add	r2, r2, r3, lsl #2
33d0f520:	e58d201c 	str	r2, [sp, #28]
				addr_first = part->offset + info->start[0];
33d0f524:	e59d100c 	ldr	r1, [sp, #12]
33d0f528:	e592200c 	ldr	r2, [r2, #12]
33d0f52c:	e5913014 	ldr	r3, [r1, #20]
33d0f530:	e0833002 	add	r3, r3, r2
33d0f534:	e58d3008 	str	r3, [sp, #8]
				addr_last = addr_first + part->size - 1;
33d0f538:	e591c010 	ldr	ip, [r1, #16]
33d0f53c:	e083c00c 	add	ip, r3, ip

				printf ("Erase Flash Parition %s, "
33d0f540:	e5941004 	ldr	r1, [r4, #4]
		if (find_dev_and_part(argv[1], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;
33d0f544:	e24cc001 	sub	ip, ip, #1	; 0x1

				printf ("Erase Flash Parition %s, "
33d0f548:	e1a02000 	mov	r2, r0
33d0f54c:	e59f00ec 	ldr	r0, [pc, #236]	; 33d0f640 <do_flerase+0x25c>
33d0f550:	e58dc000 	str	ip, [sp]
		if (find_dev_and_part(argv[1], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;
33d0f554:	e58dc004 	str	ip, [sp, #4]

				printf ("Erase Flash Parition %s, "
33d0f558:	eb001e9a 	bl	33d16fc8 <printf>
						"bank %d, 0x%08lx - 0x%08lx ",
						argv[1], bank, addr_first,
						addr_last);

				rcode = flash_sect_erase(addr_first, addr_last);
33d0f55c:	e59d0008 	ldr	r0, [sp, #8]
33d0f560:	e59d1004 	ldr	r1, [sp, #4]
33d0f564:	ea00002c 	b	33d0f61c <do_flerase+0x238>
			return 1;
		}
	}
#endif

	if (argc != 3) {
33d0f568:	e3550003 	cmp	r5, #3	; 0x3
33d0f56c:	1a000025 	bne	33d0f608 <do_flerase+0x224>
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	if (strcmp(argv[1], "bank") == 0) {
33d0f570:	e59f10cc 	ldr	r1, [pc, #204]	; 33d0f644 <do_flerase+0x260>
33d0f574:	e5940004 	ldr	r0, [r4, #4]
33d0f578:	eb002aba 	bl	33d1a068 <strcmp>
33d0f57c:	e3500000 	cmp	r0, #0	; 0x0
33d0f580:	e5941008 	ldr	r1, [r4, #8]
33d0f584:	1a000012 	bne	33d0f5d4 <do_flerase+0x1f0>
		bank = simple_strtoul(argv[2], NULL, 16);
33d0f588:	e1a00001 	mov	r0, r1
33d0f58c:	e3a02010 	mov	r2, #16	; 0x10
33d0f590:	e1a01007 	mov	r1, r7
33d0f594:	eb002bf0 	bl	33d1a55c <simple_strtoul>
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
33d0f598:	e3500001 	cmp	r0, #1	; 0x1
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
33d0f59c:	159f00a4 	ldrne	r0, [pc, #164]	; 33d0f648 <do_flerase+0x264>
33d0f5a0:	13a01001 	movne	r1, #1	; 0x1
		return 1;
	}

	if (strcmp(argv[1], "bank") == 0) {
		bank = simple_strtoul(argv[2], NULL, 16);
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
33d0f5a4:	1a000019 	bne	33d0f610 <do_flerase+0x22c>
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
				CFG_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("Erase Flash Bank # %ld ", bank);
33d0f5a8:	e1a01000 	mov	r1, r0
33d0f5ac:	e59f0078 	ldr	r0, [pc, #120]	; 33d0f62c <do_flerase+0x248>
33d0f5b0:	eb001e84 	bl	33d16fc8 <printf>
		info = &flash_info[bank-1];
33d0f5b4:	e59f3074 	ldr	r3, [pc, #116]	; 33d0f630 <do_flerase+0x24c>
		rcode = flash_erase (info, 0, info->sector_count-1);
33d0f5b8:	e1d320b4 	ldrh	r2, [r3, #4]
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
				CFG_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("Erase Flash Bank # %ld ", bank);
		info = &flash_info[bank-1];
33d0f5bc:	e58d301c 	str	r3, [sp, #28]
		rcode = flash_erase (info, 0, info->sector_count-1);
33d0f5c0:	e1a00003 	mov	r0, r3
33d0f5c4:	e1a01007 	mov	r1, r7
33d0f5c8:	e2422001 	sub	r2, r2, #1	; 0x1
33d0f5cc:	eb0039b6 	bl	33d1dcac <flash_erase>
		return rcode;
33d0f5d0:	ea000012 	b	33d0f620 <do_flerase+0x23c>
	}

	if (addr_spec(argv[1], argv[2], &addr_first, &addr_last) < 0){
33d0f5d4:	e5940004 	ldr	r0, [r4, #4]
33d0f5d8:	e28d2008 	add	r2, sp, #8	; 0x8
33d0f5dc:	e28d3004 	add	r3, sp, #4	; 0x4
33d0f5e0:	ebfffe42 	bl	33d0eef0 <addr_spec>
33d0f5e4:	e3500000 	cmp	r0, #0	; 0x0
33d0f5e8:	aa000002 	bge	33d0f5f8 <do_flerase+0x214>
		printf ("Bad address format\n");
33d0f5ec:	e59f0058 	ldr	r0, [pc, #88]	; 33d0f64c <do_flerase+0x268>
33d0f5f0:	eb001e74 	bl	33d16fc8 <printf>
33d0f5f4:	ea000006 	b	33d0f614 <do_flerase+0x230>
		return 1;
	}

	if (addr_first >= addr_last) {
33d0f5f8:	e59d0008 	ldr	r0, [sp, #8]
33d0f5fc:	e59d1004 	ldr	r1, [sp, #4]
33d0f600:	e1500001 	cmp	r0, r1
33d0f604:	3a000004 	bcc	33d0f61c <do_flerase+0x238>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0f608:	e5961010 	ldr	r1, [r6, #16]
33d0f60c:	e59f003c 	ldr	r0, [pc, #60]	; 33d0f650 <do_flerase+0x26c>
33d0f610:	eb001e6c 	bl	33d16fc8 <printf>
		return 1;
33d0f614:	e3a00001 	mov	r0, #1	; 0x1
33d0f618:	ea000000 	b	33d0f620 <do_flerase+0x23c>
	}

	rcode = flash_sect_erase(addr_first, addr_last);
33d0f61c:	ebffff37 	bl	33d0f300 <flash_sect_erase>
	return rcode;
}
33d0f620:	e28dd024 	add	sp, sp, #36	; 0x24
33d0f624:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d0f628:	33d2889c 	.word	0x33d2889c
33d0f62c:	33d288a0 	.word	0x33d288a0
33d0f630:	33d62554 	.word	0x33d62554
33d0f634:	33d288b8 	.word	0x33d288b8
33d0f638:	33d288d4 	.word	0x33d288d4
33d0f63c:	33d288fc 	.word	0x33d288fc
33d0f640:	33d2891c 	.word	0x33d2891c
33d0f644:	33d28954 	.word	0x33d28954
33d0f648:	33d28824 	.word	0x33d28824
33d0f64c:	33d2895c 	.word	0x33d2895c
33d0f650:	33d27008 	.word	0x33d27008

33d0f654 <flash_sect_protect>:
	return rcode;
}


int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
{
33d0f654:	e92d4030 	push	{r4, r5, lr}
33d0f658:	e24dd010 	sub	sp, sp, #16	; 0x10
#endif
	int protected, i;
	int planned;
	int rcode;

	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
33d0f65c:	e28d3008 	add	r3, sp, #8	; 0x8
33d0f660:	e28dc004 	add	ip, sp, #4	; 0x4
	return rcode;
}


int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
{
33d0f664:	e1a05000 	mov	r5, r0
#endif
	int protected, i;
	int planned;
	int rcode;

	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
33d0f668:	e1a00001 	mov	r0, r1
33d0f66c:	e1a01002 	mov	r1, r2
33d0f670:	e28d200c 	add	r2, sp, #12	; 0xc
33d0f674:	e58dc000 	str	ip, [sp]
33d0f678:	ebfffe84 	bl	33d0f090 <flash_fill_sect_ranges>

	protected = 0;

	if (planned && (rcode == 0)) {
33d0f67c:	e59d3004 	ldr	r3, [sp, #4]
33d0f680:	e2533000 	subs	r3, r3, #0	; 0x0
33d0f684:	13a03001 	movne	r3, #1	; 0x1
33d0f688:	e3500000 	cmp	r0, #0	; 0x0
33d0f68c:	13a03000 	movne	r3, #0	; 0x0
33d0f690:	e3530000 	cmp	r3, #0	; 0x0
33d0f694:	e1a04000 	mov	r4, r0
	int planned;
	int rcode;

	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );

	protected = 0;
33d0f698:	e3a0e000 	mov	lr, #0	; 0x0

	if (planned && (rcode == 0)) {
33d0f69c:	0a00001a 	beq	33d0f70c <flash_sect_protect+0xb8>
		for (bank=0,info=&flash_info[0]; bank < CFG_MAX_FLASH_BANKS; ++bank, ++info) {
33d0f6a0:	e59fc084 	ldr	ip, [pc, #132]	; 33d0f72c <flash_sect_protect+0xd8>
			if (info->flash_id == FLASH_UNKNOWN) {
33d0f6a4:	e59f3084 	ldr	r3, [pc, #132]	; 33d0f730 <flash_sect_protect+0xdc>
33d0f6a8:	e59c2008 	ldr	r2, [ip, #8]
33d0f6ac:	e1520003 	cmp	r2, r3
33d0f6b0:	0a00000d 	beq	33d0f6ec <flash_sect_protect+0x98>
				continue;
			}

			if (s_first[bank]>=0 && s_first[bank]<=s_last[bank]) {
33d0f6b4:	e59d100c 	ldr	r1, [sp, #12]
33d0f6b8:	e151000e 	cmp	r1, lr
33d0f6bc:	ba00000a 	blt	33d0f6ec <flash_sect_protect+0x98>
33d0f6c0:	e59d0008 	ldr	r0, [sp, #8]
33d0f6c4:	e1510000 	cmp	r1, r0
33d0f6c8:	ca000007 	bgt	33d0f6ec <flash_sect_protect+0x98>
				debug ("%sProtecting sectors %d..%d in bank %ld\n",
					p ? "" : "Un-",
					s_first[bank], s_last[bank], bank+1);
				protected += s_last[bank] - s_first[bank] + 1;
33d0f6cc:	e0613000 	rsb	r3, r1, r0
33d0f6d0:	e283e001 	add	lr, r3, #1	; 0x1
				for (i=s_first[bank]; i<=s_last[bank]; ++i) {
33d0f6d4:	e1a02001 	mov	r2, r1
#if defined(CFG_FLASH_PROTECTION)
					if (flash_real_protect(info, i, p))
						rcode = 1;
					putc ('.');
#else
					info->protect[i] = p;
33d0f6d8:	e082300c 	add	r3, r2, ip
			if (s_first[bank]>=0 && s_first[bank]<=s_last[bank]) {
				debug ("%sProtecting sectors %d..%d in bank %ld\n",
					p ? "" : "Un-",
					s_first[bank], s_last[bank], bank+1);
				protected += s_last[bank] - s_first[bank] + 1;
				for (i=s_first[bank]; i<=s_last[bank]; ++i) {
33d0f6dc:	e2822001 	add	r2, r2, #1	; 0x1
33d0f6e0:	e1520000 	cmp	r2, r0
#if defined(CFG_FLASH_PROTECTION)
					if (flash_real_protect(info, i, p))
						rcode = 1;
					putc ('.');
#else
					info->protect[i] = p;
33d0f6e4:	e5c35058 	strb	r5, [r3, #88]
			if (s_first[bank]>=0 && s_first[bank]<=s_last[bank]) {
				debug ("%sProtecting sectors %d..%d in bank %ld\n",
					p ? "" : "Un-",
					s_first[bank], s_last[bank], bank+1);
				protected += s_last[bank] - s_first[bank] + 1;
				for (i=s_first[bank]; i<=s_last[bank]; ++i) {
33d0f6e8:	dafffffa 	ble	33d0f6d8 <flash_sect_protect+0x84>
		}
#if defined(CFG_FLASH_PROTECTION)
		puts (" done\n");
#endif	/* CFG_FLASH_PROTECTION */

		printf ("%sProtected %d sectors\n",
33d0f6ec:	e59f3040 	ldr	r3, [pc, #64]	; 33d0f734 <flash_sect_protect+0xe0>
33d0f6f0:	e3550000 	cmp	r5, #0	; 0x0
33d0f6f4:	e59f103c 	ldr	r1, [pc, #60]	; 33d0f738 <flash_sect_protect+0xe4>
33d0f6f8:	e1a0200e 	mov	r2, lr
33d0f6fc:	01a01003 	moveq	r1, r3
33d0f700:	e59f0034 	ldr	r0, [pc, #52]	; 33d0f73c <flash_sect_protect+0xe8>
33d0f704:	eb001e2f 	bl	33d16fc8 <printf>
33d0f708:	ea000004 	b	33d0f720 <flash_sect_protect+0xcc>
			p ? "" : "Un-", protected);
	} else if (rcode == 0) {
33d0f70c:	e3500000 	cmp	r0, #0	; 0x0
33d0f710:	1a000002 	bne	33d0f720 <flash_sect_protect+0xcc>
		puts ("Error: start and/or end address"
33d0f714:	e59f0024 	ldr	r0, [pc, #36]	; 33d0f740 <flash_sect_protect+0xec>
33d0f718:	eb001e23 	bl	33d16fac <puts>
			" not on sector boundary\n");
		rcode = 1;
33d0f71c:	e2844001 	add	r4, r4, #1	; 0x1
	}
	return rcode;
}
33d0f720:	e1a00004 	mov	r0, r4
33d0f724:	e28dd010 	add	sp, sp, #16	; 0x10
33d0f728:	e8bd8030 	pop	{r4, r5, pc}
33d0f72c:	33d62554 	.word	0x33d62554
33d0f730:	0000ffff 	.word	0x0000ffff
33d0f734:	33d28970 	.word	0x33d28970
33d0f738:	33d2a490 	.word	0x33d2a490
33d0f73c:	33d28198 	.word	0x33d28198
33d0f740:	33d28864 	.word	0x33d28864

33d0f744 <do_protect>:
	}
	return rcode;
}

int do_protect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0f744:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int rcode = 0;
#ifdef CONFIG_HAS_DATAFLASH
	int status;
#endif

	if (argc < 3) {
33d0f748:	e3520002 	cmp	r2, #2	; 0x2
	}
	return rcode;
}

int do_protect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d0f74c:	e24dd028 	sub	sp, sp, #40	; 0x28
33d0f750:	e1a05002 	mov	r5, r2
33d0f754:	e1a06000 	mov	r6, r0
33d0f758:	e1a04003 	mov	r4, r3
	int rcode = 0;
#ifdef CONFIG_HAS_DATAFLASH
	int status;
#endif

	if (argc < 3) {
33d0f75c:	da0000c5 	ble	33d0fa78 <do_protect+0x334>
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	if (strcmp(argv[1], "off") == 0) {
33d0f760:	e5930004 	ldr	r0, [r3, #4]
33d0f764:	e59f132c 	ldr	r1, [pc, #812]	; 33d0fa98 <do_protect+0x354>
33d0f768:	eb002a3e 	bl	33d1a068 <strcmp>
33d0f76c:	e3500000 	cmp	r0, #0	; 0x0
		p = 0;
33d0f770:	01a0a000 	moveq	sl, r0
	if (argc < 3) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	if (strcmp(argv[1], "off") == 0) {
33d0f774:	0a000005 	beq	33d0f790 <do_protect+0x4c>
		p = 0;
	} else if (strcmp(argv[1], "on") == 0) {
33d0f778:	e5940004 	ldr	r0, [r4, #4]
33d0f77c:	e59f1318 	ldr	r1, [pc, #792]	; 33d0fa9c <do_protect+0x358>
33d0f780:	eb002a38 	bl	33d1a068 <strcmp>
33d0f784:	e3500000 	cmp	r0, #0	; 0x0
33d0f788:	1a0000ba 	bne	33d0fa78 <do_protect+0x334>
		p = 1;
33d0f78c:	e3a0a001 	mov	sl, #1	; 0x1
			return 0;
		}
	}
#endif

	if (strcmp(argv[2], "all") == 0) {
33d0f790:	e5940008 	ldr	r0, [r4, #8]
33d0f794:	e59f1304 	ldr	r1, [pc, #772]	; 33d0faa0 <do_protect+0x35c>
33d0f798:	eb002a32 	bl	33d1a068 <strcmp>
33d0f79c:	e2507000 	subs	r7, r0, #0	; 0x0
33d0f7a0:	1a000018 	bne	33d0f808 <do_protect+0xc4>
33d0f7a4:	e59f12f8 	ldr	r1, [pc, #760]	; 33d0faa4 <do_protect+0x360>
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
			info = &flash_info[bank-1];
			if (info->flash_id == FLASH_UNKNOWN) {
33d0f7a8:	e59f32f8 	ldr	r3, [pc, #760]	; 33d0faa8 <do_protect+0x364>
33d0f7ac:	e5912008 	ldr	r2, [r1, #8]
33d0f7b0:	e1520003 	cmp	r2, r3
	}
#endif

	if (strcmp(argv[2], "all") == 0) {
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
			info = &flash_info[bank-1];
33d0f7b4:	e58d1020 	str	r1, [sp, #32]
		}
	}
#endif

	if (strcmp(argv[2], "all") == 0) {
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
33d0f7b8:	e3a05001 	mov	r5, #1	; 0x1
			info = &flash_info[bank-1];
			if (info->flash_id == FLASH_UNKNOWN) {
33d0f7bc:	0a00009d 	beq	33d0fa38 <do_protect+0x2f4>
				continue;
			}
			printf ("%sProtect Flash Bank # %ld\n",
33d0f7c0:	e59f32e4 	ldr	r3, [pc, #740]	; 33d0faac <do_protect+0x368>
33d0f7c4:	e35a0000 	cmp	sl, #0	; 0x0
33d0f7c8:	e59f12e0 	ldr	r1, [pc, #736]	; 33d0fab0 <do_protect+0x36c>
33d0f7cc:	e1a02005 	mov	r2, r5
33d0f7d0:	01a01003 	moveq	r1, r3
33d0f7d4:	e59f02d8 	ldr	r0, [pc, #728]	; 33d0fab4 <do_protect+0x370>
33d0f7d8:	eb001dfa 	bl	33d16fc8 <printf>
				p ? "" : "Un-", bank);

			for (i=0; i<info->sector_count; ++i) {
33d0f7dc:	e59d2020 	ldr	r2, [sp, #32]
33d0f7e0:	e1d230b4 	ldrh	r3, [r2, #4]
33d0f7e4:	e1a00007 	mov	r0, r7
33d0f7e8:	e1500003 	cmp	r0, r3
33d0f7ec:	aa000091 	bge	33d0fa38 <do_protect+0x2f4>
#if defined(CFG_FLASH_PROTECTION)
				if (flash_real_protect(info, i, p))
					rcode = 1;
				putc ('.');
#else
				info->protect[i] = p;
33d0f7f0:	e0803002 	add	r3, r0, r2
33d0f7f4:	e5c3a058 	strb	sl, [r3, #88]
				continue;
			}
			printf ("%sProtect Flash Bank # %ld\n",
				p ? "" : "Un-", bank);

			for (i=0; i<info->sector_count; ++i) {
33d0f7f8:	e59d2020 	ldr	r2, [sp, #32]
33d0f7fc:	e1d230b4 	ldrh	r3, [r2, #4]
33d0f800:	e2800001 	add	r0, r0, #1	; 0x1
33d0f804:	eafffff7 	b	33d0f7e8 <do_protect+0xa4>
#endif	/* CFG_FLASH_PROTECTION */
		}
		return rcode;
	}

	if ((n = abbrev_spec(argv[2], &info, &sect_first, &sect_last)) != 0) {
33d0f808:	e5940008 	ldr	r0, [r4, #8]
33d0f80c:	e28d1020 	add	r1, sp, #32	; 0x20
33d0f810:	e28d201c 	add	r2, sp, #28	; 0x1c
33d0f814:	e28d3018 	add	r3, sp, #24	; 0x18
33d0f818:	ebfffd5d 	bl	33d0ed94 <abbrev_spec>
33d0f81c:	e3500000 	cmp	r0, #0	; 0x0
33d0f820:	0a00001e 	beq	33d0f8a0 <do_protect+0x15c>
		if (n < 0) {
33d0f824:	aa000002 	bge	33d0f834 <do_protect+0xf0>
			puts ("Bad sector specification\n");
33d0f828:	e59f0288 	ldr	r0, [pc, #648]	; 33d0fab8 <do_protect+0x374>
33d0f82c:	eb001dde 	bl	33d16fac <puts>
33d0f830:	ea000093 	b	33d0fa84 <do_protect+0x340>
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %d\n",
33d0f834:	e59dc020 	ldr	ip, [sp, #32]
33d0f838:	e59f3264 	ldr	r3, [pc, #612]	; 33d0faa4 <do_protect+0x360>
33d0f83c:	e063c00c 	rsb	ip, r3, ip
33d0f840:	e1a0c14c 	asr	ip, ip, #2
33d0f844:	e08c318c 	add	r3, ip, ip, lsl #3
33d0f848:	e08cc083 	add	ip, ip, r3, lsl #1
33d0f84c:	e06cc48c 	rsb	ip, ip, ip, lsl #9
33d0f850:	e59f3254 	ldr	r3, [pc, #596]	; 33d0faac <do_protect+0x368>
33d0f854:	e35a0000 	cmp	sl, #0	; 0x0
33d0f858:	e08cc90c 	add	ip, ip, ip, lsl #18
33d0f85c:	e59f124c 	ldr	r1, [pc, #588]	; 33d0fab0 <do_protect+0x36c>
33d0f860:	e26cc001 	rsb	ip, ip, #1	; 0x1
33d0f864:	01a01003 	moveq	r1, r3
33d0f868:	e59f024c 	ldr	r0, [pc, #588]	; 33d0fabc <do_protect+0x378>
33d0f86c:	e59d201c 	ldr	r2, [sp, #28]
33d0f870:	e59d3018 	ldr	r3, [sp, #24]
33d0f874:	e58dc000 	str	ip, [sp]
33d0f878:	eb001dd2 	bl	33d16fc8 <printf>
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
33d0f87c:	e59d001c 	ldr	r0, [sp, #28]
33d0f880:	e59d3018 	ldr	r3, [sp, #24]
33d0f884:	e1500003 	cmp	r0, r3
33d0f888:	ca00006a 	bgt	33d0fa38 <do_protect+0x2f4>
#if defined(CFG_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
33d0f88c:	e59d3020 	ldr	r3, [sp, #32]
33d0f890:	e0803003 	add	r3, r0, r3
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %d\n",
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
33d0f894:	e2800001 	add	r0, r0, #1	; 0x1
#if defined(CFG_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
33d0f898:	e5c3a058 	strb	sl, [r3, #88]
33d0f89c:	eafffff7 	b	33d0f880 <do_protect+0x13c>
		return rcode;
	}

#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	/* protect on/off <part-id> */
	if ((argc == 3) && (id_parse(argv[2], NULL, &dev_type, &dev_num) == 0)) {
33d0f8a0:	e3550003 	cmp	r5, #3	; 0x3
33d0f8a4:	1a000036 	bne	33d0f984 <do_protect+0x240>
33d0f8a8:	e1a01000 	mov	r1, r0
33d0f8ac:	e28d2027 	add	r2, sp, #39	; 0x27
33d0f8b0:	e5940008 	ldr	r0, [r4, #8]
33d0f8b4:	e28d3026 	add	r3, sp, #38	; 0x26
33d0f8b8:	eb000497 	bl	33d10b1c <id_parse>
33d0f8bc:	e3500000 	cmp	r0, #0	; 0x0
33d0f8c0:	1a00006c 	bne	33d0fa78 <do_protect+0x334>
		mtdparts_init();
33d0f8c4:	eb0005e6 	bl	33d11064 <mtdparts_init>
		if (find_dev_and_part(argv[2], &dev, &pnum, &part) == 0) {
33d0f8c8:	e5940008 	ldr	r0, [r4, #8]
33d0f8cc:	e28d1014 	add	r1, sp, #20	; 0x14
33d0f8d0:	e28d2025 	add	r2, sp, #37	; 0x25
33d0f8d4:	e28d3010 	add	r3, sp, #16	; 0x10
33d0f8d8:	eb000578 	bl	33d10ec0 <find_dev_and_part>
33d0f8dc:	e3500000 	cmp	r0, #0	; 0x0
33d0f8e0:	1a000064 	bne	33d0fa78 <do_protect+0x334>
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
33d0f8e4:	e59d3014 	ldr	r3, [sp, #20]
33d0f8e8:	e5930008 	ldr	r0, [r3, #8]
33d0f8ec:	e5d03008 	ldrb	r3, [r0, #8]
33d0f8f0:	e3530001 	cmp	r3, #1	; 0x1
33d0f8f4:	1a00001c 	bne	33d0f96c <do_protect+0x228>
				bank = dev->id->num;
33d0f8f8:	e5d05009 	ldrb	r5, [r0, #9]
				info = &flash_info[bank];
33d0f8fc:	e59f21a0 	ldr	r2, [pc, #416]	; 33d0faa4 <do_protect+0x360>
33d0f900:	e0853085 	add	r3, r5, r5, lsl #1
33d0f904:	e0833183 	add	r3, r3, r3, lsl #3
33d0f908:	e0822103 	add	r2, r2, r3, lsl #2
33d0f90c:	e58d2020 	str	r2, [sp, #32]
				addr_first = part->offset + info->start[0];
33d0f910:	e59d1010 	ldr	r1, [sp, #16]
33d0f914:	e592300c 	ldr	r3, [r2, #12]
33d0f918:	e591e014 	ldr	lr, [r1, #20]
33d0f91c:	e08ee003 	add	lr, lr, r3
33d0f920:	e58de00c 	str	lr, [sp, #12]
				addr_last = addr_first + part->size - 1;
33d0f924:	e591c010 	ldr	ip, [r1, #16]

				printf ("%sProtect Flash Parition %s, "
33d0f928:	e59f3190 	ldr	r3, [pc, #400]	; 33d0fac0 <do_protect+0x37c>
		if (find_dev_and_part(argv[2], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;
33d0f92c:	e08ec00c 	add	ip, lr, ip

				printf ("%sProtect Flash Parition %s, "
33d0f930:	e35a0000 	cmp	sl, #0	; 0x0
33d0f934:	e5942004 	ldr	r2, [r4, #4]
33d0f938:	e59f1170 	ldr	r1, [pc, #368]	; 33d0fab0 <do_protect+0x36c>
		if (find_dev_and_part(argv[2], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;
33d0f93c:	e24cc001 	sub	ip, ip, #1	; 0x1

				printf ("%sProtect Flash Parition %s, "
33d0f940:	01a01003 	moveq	r1, r3
33d0f944:	e59f0178 	ldr	r0, [pc, #376]	; 33d0fac4 <do_protect+0x380>
33d0f948:	e1a03005 	mov	r3, r5
33d0f94c:	e58de000 	str	lr, [sp]
33d0f950:	e58dc004 	str	ip, [sp, #4]
		if (find_dev_and_part(argv[2], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;
33d0f954:	e58dc008 	str	ip, [sp, #8]

				printf ("%sProtect Flash Parition %s, "
33d0f958:	eb001d9a 	bl	33d16fc8 <printf>
						"bank %d, 0x%08lx - 0x%08lx\n",
						p ? "" : "Un", argv[1],
						bank, addr_first, addr_last);

				rcode = flash_sect_protect (p, addr_first, addr_last);
33d0f95c:	e59d100c 	ldr	r1, [sp, #12]
33d0f960:	e59d2008 	ldr	r2, [sp, #8]
33d0f964:	e1a0000a 	mov	r0, sl
33d0f968:	ea000047 	b	33d0fa8c <do_protect+0x348>
				return rcode;
			}

			printf("cannot %sprotect, not a NOR device\n",
33d0f96c:	e59f3154 	ldr	r3, [pc, #340]	; 33d0fac8 <do_protect+0x384>
33d0f970:	e59f1138 	ldr	r1, [pc, #312]	; 33d0fab0 <do_protect+0x36c>
33d0f974:	e35a0000 	cmp	sl, #0	; 0x0
33d0f978:	e59f014c 	ldr	r0, [pc, #332]	; 33d0facc <do_protect+0x388>
33d0f97c:	01a01003 	moveq	r1, r3
33d0f980:	ea00003e 	b	33d0fa80 <do_protect+0x33c>
			return 1;
		}
	}
#endif

	if (argc != 4) {
33d0f984:	e3550004 	cmp	r5, #4	; 0x4
33d0f988:	1a00003a 	bne	33d0fa78 <do_protect+0x334>
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	if (strcmp(argv[2], "bank") == 0) {
33d0f98c:	e59f113c 	ldr	r1, [pc, #316]	; 33d0fad0 <do_protect+0x38c>
33d0f990:	e5940008 	ldr	r0, [r4, #8]
33d0f994:	eb0029b3 	bl	33d1a068 <strcmp>
33d0f998:	e2507000 	subs	r7, r0, #0	; 0x0
33d0f99c:	e594100c 	ldr	r1, [r4, #12]
33d0f9a0:	1a000026 	bne	33d0fa40 <do_protect+0x2fc>
		bank = simple_strtoul(argv[3], NULL, 16);
33d0f9a4:	e1a00001 	mov	r0, r1
33d0f9a8:	e3a02010 	mov	r2, #16	; 0x10
33d0f9ac:	e1a01007 	mov	r1, r7
33d0f9b0:	eb002ae9 	bl	33d1a55c <simple_strtoul>
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
33d0f9b4:	e3500001 	cmp	r0, #1	; 0x1
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	if (strcmp(argv[2], "bank") == 0) {
		bank = simple_strtoul(argv[3], NULL, 16);
33d0f9b8:	e1a05000 	mov	r5, r0
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
33d0f9bc:	13a01001 	movne	r1, #1	; 0x1
33d0f9c0:	159f010c 	ldrne	r0, [pc, #268]	; 33d0fad4 <do_protect+0x390>
		return 1;
	}

	if (strcmp(argv[2], "bank") == 0) {
		bank = simple_strtoul(argv[3], NULL, 16);
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
33d0f9c4:	1a00002d 	bne	33d0fa80 <do_protect+0x33c>
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
				CFG_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("%sProtect Flash Bank # %ld\n",
33d0f9c8:	e59f30dc 	ldr	r3, [pc, #220]	; 33d0faac <do_protect+0x368>
33d0f9cc:	e35a0000 	cmp	sl, #0	; 0x0
33d0f9d0:	e59f10d8 	ldr	r1, [pc, #216]	; 33d0fab0 <do_protect+0x36c>
33d0f9d4:	e59f00d8 	ldr	r0, [pc, #216]	; 33d0fab4 <do_protect+0x370>
33d0f9d8:	01a01003 	moveq	r1, r3
33d0f9dc:	e1a02005 	mov	r2, r5
33d0f9e0:	eb001d78 	bl	33d16fc8 <printf>
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];
33d0f9e4:	e59f10b8 	ldr	r1, [pc, #184]	; 33d0faa4 <do_protect+0x360>

		if (info->flash_id == FLASH_UNKNOWN) {
33d0f9e8:	e59f30b8 	ldr	r3, [pc, #184]	; 33d0faa8 <do_protect+0x364>
33d0f9ec:	e5912008 	ldr	r2, [r1, #8]
				CFG_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("%sProtect Flash Bank # %ld\n",
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];
33d0f9f0:	e58d1020 	str	r1, [sp, #32]

		if (info->flash_id == FLASH_UNKNOWN) {
33d0f9f4:	e1520003 	cmp	r2, r3
			puts ("missing or unknown FLASH type\n");
			return 1;
		}
		for (i=0; i<info->sector_count; ++i) {
33d0f9f8:	11d130b4 	ldrhne	r3, [r1, #4]
33d0f9fc:	11a00007 	movne	r0, r7
		}
		printf ("%sProtect Flash Bank # %ld\n",
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];

		if (info->flash_id == FLASH_UNKNOWN) {
33d0fa00:	1a000003 	bne	33d0fa14 <do_protect+0x2d0>
			puts ("missing or unknown FLASH type\n");
33d0fa04:	e59f00cc 	ldr	r0, [pc, #204]	; 33d0fad8 <do_protect+0x394>
33d0fa08:	eb001d67 	bl	33d16fac <puts>
			return 1;
33d0fa0c:	e1a00005 	mov	r0, r5
33d0fa10:	ea00001e 	b	33d0fa90 <do_protect+0x34c>
		}
		for (i=0; i<info->sector_count; ++i) {
33d0fa14:	e1500003 	cmp	r0, r3
33d0fa18:	aa000006 	bge	33d0fa38 <do_protect+0x2f4>
#if defined(CFG_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
33d0fa1c:	e59d3020 	ldr	r3, [sp, #32]
33d0fa20:	e0803003 	add	r3, r0, r3
33d0fa24:	e5c3a058 	strb	sl, [r3, #88]

		if (info->flash_id == FLASH_UNKNOWN) {
			puts ("missing or unknown FLASH type\n");
			return 1;
		}
		for (i=0; i<info->sector_count; ++i) {
33d0fa28:	e59d3020 	ldr	r3, [sp, #32]
33d0fa2c:	e1d330b4 	ldrh	r3, [r3, #4]
33d0fa30:	e2800001 	add	r0, r0, #1	; 0x1
33d0fa34:	eafffff6 	b	33d0fa14 <do_protect+0x2d0>

#if defined(CFG_FLASH_PROTECTION)
		if (!rcode) puts (" done\n");
#endif	/* CFG_FLASH_PROTECTION */

		return rcode;
33d0fa38:	e3a00000 	mov	r0, #0	; 0x0
33d0fa3c:	ea000013 	b	33d0fa90 <do_protect+0x34c>
	}

	if (addr_spec(argv[2], argv[3], &addr_first, &addr_last) < 0){
33d0fa40:	e5940008 	ldr	r0, [r4, #8]
33d0fa44:	e28d200c 	add	r2, sp, #12	; 0xc
33d0fa48:	e28d3008 	add	r3, sp, #8	; 0x8
33d0fa4c:	ebfffd27 	bl	33d0eef0 <addr_spec>
33d0fa50:	e3500000 	cmp	r0, #0	; 0x0
33d0fa54:	aa000002 	bge	33d0fa64 <do_protect+0x320>
		printf("Bad address format\n");
33d0fa58:	e59f007c 	ldr	r0, [pc, #124]	; 33d0fadc <do_protect+0x398>
33d0fa5c:	eb001d59 	bl	33d16fc8 <printf>
33d0fa60:	ea000007 	b	33d0fa84 <do_protect+0x340>
		return 1;
	}

	if (addr_first >= addr_last) {
33d0fa64:	e59d100c 	ldr	r1, [sp, #12]
33d0fa68:	e59d2008 	ldr	r2, [sp, #8]
33d0fa6c:	e1510002 	cmp	r1, r2
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}
	rcode = flash_sect_protect (p, addr_first, addr_last);
33d0fa70:	31a0000a 	movcc	r0, sl
	if (addr_spec(argv[2], argv[3], &addr_first, &addr_last) < 0){
		printf("Bad address format\n");
		return 1;
	}

	if (addr_first >= addr_last) {
33d0fa74:	3a000004 	bcc	33d0fa8c <do_protect+0x348>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d0fa78:	e5961010 	ldr	r1, [r6, #16]
33d0fa7c:	e59f005c 	ldr	r0, [pc, #92]	; 33d0fae0 <do_protect+0x39c>
33d0fa80:	eb001d50 	bl	33d16fc8 <printf>
		return 1;
33d0fa84:	e3a00001 	mov	r0, #1	; 0x1
33d0fa88:	ea000000 	b	33d0fa90 <do_protect+0x34c>
	}
	rcode = flash_sect_protect (p, addr_first, addr_last);
33d0fa8c:	ebfffef0 	bl	33d0f654 <flash_sect_protect>
	return rcode;
}
33d0fa90:	e28dd028 	add	sp, sp, #40	; 0x28
33d0fa94:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d0fa98:	33d253f0 	.word	0x33d253f0
33d0fa9c:	33d27af0 	.word	0x33d27af0
33d0faa0:	33d2889c 	.word	0x33d2889c
33d0faa4:	33d62554 	.word	0x33d62554
33d0faa8:	0000ffff 	.word	0x0000ffff
33d0faac:	33d28970 	.word	0x33d28970
33d0fab0:	33d2a490 	.word	0x33d2a490
33d0fab4:	33d28974 	.word	0x33d28974
33d0fab8:	33d288b8 	.word	0x33d288b8
33d0fabc:	33d28990 	.word	0x33d28990
33d0fac0:	33d289bc 	.word	0x33d289bc
33d0fac4:	33d289c0 	.word	0x33d289c0
33d0fac8:	33d289fc 	.word	0x33d289fc
33d0facc:	33d28a00 	.word	0x33d28a00
33d0fad0:	33d28954 	.word	0x33d28954
33d0fad4:	33d28824 	.word	0x33d28824
33d0fad8:	33d28a24 	.word	0x33d28a24
33d0fadc:	33d2895c 	.word	0x33d2895c
33d0fae0:	33d27008 	.word	0x33d27008

33d0fae4 <evalexp>:
#define op_tbl_size (sizeof(op_table)/sizeof(op_table[0]))

extern int cmd_get_data_size(char* arg, int default_size);

static long evalexp(char *s, int w)
{
33d0fae4:	e92d4010 	push	{r4, lr}
	long l, *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
33d0fae8:	e5d03000 	ldrb	r3, [r0]
33d0faec:	e353002a 	cmp	r3, #42	; 0x2a
#define op_tbl_size (sizeof(op_table)/sizeof(op_table[0]))

extern int cmd_get_data_size(char* arg, int default_size);

static long evalexp(char *s, int w)
{
33d0faf0:	e1a04001 	mov	r4, r1
	long l, *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
33d0faf4:	e3a02010 	mov	r2, #16	; 0x10
33d0faf8:	e3a01000 	mov	r1, #0	; 0x0
static long evalexp(char *s, int w)
{
	long l, *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
33d0fafc:	1a000003 	bne	33d0fb10 <evalexp+0x2c>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
33d0fb00:	e2800001 	add	r0, r0, #1	; 0x1
33d0fb04:	eb002a94 	bl	33d1a55c <simple_strtoul>
		l = *p;
33d0fb08:	e5902000 	ldr	r2, [r0]
33d0fb0c:	ea000003 	b	33d0fb20 <evalexp+0x3c>
	} else {
		l = simple_strtoul(s, NULL, 16);
33d0fb10:	e3a02010 	mov	r2, #16	; 0x10
33d0fb14:	e3a01000 	mov	r1, #0	; 0x0
33d0fb18:	eb002a8f 	bl	33d1a55c <simple_strtoul>
33d0fb1c:	e1a02000 	mov	r2, r0
	}

	return (l & ((1 << (w * 8)) - 1));
33d0fb20:	e1a03184 	lsl	r3, r4, #3
}
33d0fb24:	e3e00000 	mvn	r0, #0	; 0x0
33d0fb28:	e1c20310 	bic	r0, r2, r0, lsl r3
33d0fb2c:	e8bd8010 	pop	{r4, pc}

33d0fb30 <evalstr>:

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
33d0fb30:	e5d03000 	ldrb	r3, [r0]
33d0fb34:	e353002a 	cmp	r3, #42	; 0x2a
		return (char *)simple_strtoul(&s[1], NULL, 16);
33d0fb38:	e3a01000 	mov	r1, #0	; 0x0
33d0fb3c:	e3a02010 	mov	r2, #16	; 0x10
}

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
33d0fb40:	11a0f00e 	movne	pc, lr
		return (char *)simple_strtoul(&s[1], NULL, 16);
33d0fb44:	e2800001 	add	r0, r0, #1	; 0x1
33d0fb48:	ea002a83 	b	33d1a55c <simple_strtoul>

33d0fb4c <binary_test>:
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
{
33d0fb4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d0fb50:	e1a09001 	mov	r9, r1
33d0fb54:	e1a0b002 	mov	fp, r2
33d0fb58:	e1a05003 	mov	r5, r3
33d0fb5c:	e1a0a000 	mov	sl, r0
	int len, i;
	op_tbl_t *optp;

	len = strlen(op);
33d0fb60:	eb00296a 	bl	33d1a110 <strlen>

	for (optp = (op_tbl_t *)&op_table, i = 0;
33d0fb64:	e59f41b4 	ldr	r4, [pc, #436]	; 33d0fd20 <binary_test+0x1d4>
int binary_test (char *op, char *arg1, char *arg2, int w)
{
	int len, i;
	op_tbl_t *optp;

	len = strlen(op);
33d0fb68:	e1a07000 	mov	r7, r0

	for (optp = (op_tbl_t *)&op_table, i = 0;
33d0fb6c:	e3a06000 	mov	r6, #0	; 0x0
	     i < op_tbl_size;
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
33d0fb70:	e5941000 	ldr	r1, [r4]
33d0fb74:	e1a02007 	mov	r2, r7
33d0fb78:	e1a0000a 	mov	r0, sl
33d0fb7c:	eb002945 	bl	33d1a098 <strncmp>
33d0fb80:	e3500000 	cmp	r0, #0	; 0x0
	int len, i;
	op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
33d0fb84:	e2866001 	add	r6, r6, #1	; 0x1
	     i < op_tbl_size;
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
33d0fb88:	1a00005c 	bne	33d0fd00 <binary_test+0x1b4>
33d0fb8c:	e5940000 	ldr	r0, [r4]
33d0fb90:	eb00295e 	bl	33d1a110 <strlen>
33d0fb94:	e1570000 	cmp	r7, r0
33d0fb98:	1a000058 	bne	33d0fd00 <binary_test+0x1b4>
			if (w == 0) {
33d0fb9c:	e3550000 	cmp	r5, #0	; 0x0
33d0fba0:	e5947004 	ldr	r7, [r4, #4]
33d0fba4:	1a00002c 	bne	33d0fc5c <binary_test+0x110>
static int stringcomp(char *s, char *t, int op)
{
	int n, p;
	char *l, *r;

	l = evalstr(s);
33d0fba8:	e1a00009 	mov	r0, r9
33d0fbac:	ebffffdf 	bl	33d0fb30 <evalstr>
33d0fbb0:	e1a06000 	mov	r6, r0
	r = evalstr(t);
33d0fbb4:	e1a0000b 	mov	r0, fp
33d0fbb8:	ebffffdc 	bl	33d0fb30 <evalstr>
33d0fbbc:	e1a05000 	mov	r5, r0

	/* we'll do a compare based on the length of the shortest string */
	n = min(strlen(l), strlen(r));
33d0fbc0:	e1a00006 	mov	r0, r6
33d0fbc4:	eb002951 	bl	33d1a110 <strlen>
33d0fbc8:	e1a04000 	mov	r4, r0
33d0fbcc:	e1a00005 	mov	r0, r5
33d0fbd0:	eb00294e 	bl	33d1a110 <strlen>

	p = strncmp(l, r, n);
33d0fbd4:	e1a01005 	mov	r1, r5

	l = evalstr(s);
	r = evalstr(t);

	/* we'll do a compare based on the length of the shortest string */
	n = min(strlen(l), strlen(r));
33d0fbd8:	e1500004 	cmp	r0, r4
33d0fbdc:	31a02000 	movcc	r2, r0
33d0fbe0:	21a02004 	movcs	r2, r4

	p = strncmp(l, r, n);
33d0fbe4:	e1a00006 	mov	r0, r6
33d0fbe8:	eb00292a 	bl	33d1a098 <strncmp>
	switch (op) {
33d0fbec:	e3570005 	cmp	r7, #5	; 0x5
33d0fbf0:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
33d0fbf4:	ea00003f 	b	33d0fcf8 <binary_test+0x1ac>
33d0fbf8:	33d0fc10 	.word	0x33d0fc10
33d0fbfc:	33d0fc1c 	.word	0x33d0fc1c
33d0fc00:	33d0fc28 	.word	0x33d0fc28
33d0fc04:	33d0fc30 	.word	0x33d0fc30
33d0fc08:	33d0fc40 	.word	0x33d0fc40
33d0fc0c:	33d0fc50 	.word	0x33d0fc50
	case EQ: return (p == 0);
33d0fc10:	e2700001 	rsbs	r0, r0, #1	; 0x1
33d0fc14:	33a00000 	movcc	r0, #0	; 0x0
33d0fc18:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (p != 0);
33d0fc1c:	e2500000 	subs	r0, r0, #0	; 0x0
33d0fc20:	13a00001 	movne	r0, #1	; 0x1
33d0fc24:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (p < 0);
33d0fc28:	e1a00fa0 	lsr	r0, r0, #31
33d0fc2c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (p > 0);
33d0fc30:	e3500000 	cmp	r0, #0	; 0x0
33d0fc34:	d3a00000 	movle	r0, #0	; 0x0
33d0fc38:	c3a00001 	movgt	r0, #1	; 0x1
33d0fc3c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (p <= 0);
33d0fc40:	e3500000 	cmp	r0, #0	; 0x0
33d0fc44:	c3a00000 	movgt	r0, #0	; 0x0
33d0fc48:	d3a00001 	movle	r0, #1	; 0x1
33d0fc4c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (p >= 0);
33d0fc50:	e1e00000 	mvn	r0, r0
33d0fc54:	e1a00fa0 	lsr	r0, r0, #31
33d0fc58:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
33d0fc5c:	e1a01005 	mov	r1, r5
33d0fc60:	e1a00009 	mov	r0, r9
33d0fc64:	ebffff9e 	bl	33d0fae4 <evalexp>
	r = evalexp (t, w);
33d0fc68:	e1a01005 	mov	r1, r5

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
33d0fc6c:	e1a04000 	mov	r4, r0
	r = evalexp (t, w);
33d0fc70:	e1a0000b 	mov	r0, fp
33d0fc74:	ebffff9a 	bl	33d0fae4 <evalexp>

	switch (op) {
33d0fc78:	e3570005 	cmp	r7, #5	; 0x5
33d0fc7c:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
33d0fc80:	ea00001c 	b	33d0fcf8 <binary_test+0x1ac>
33d0fc84:	33d0fc9c 	.word	0x33d0fc9c
33d0fc88:	33d0fcac 	.word	0x33d0fcac
33d0fc8c:	33d0fcb8 	.word	0x33d0fcb8
33d0fc90:	33d0fcc8 	.word	0x33d0fcc8
33d0fc94:	33d0fcd8 	.word	0x33d0fcd8
33d0fc98:	33d0fce8 	.word	0x33d0fce8
	case EQ: return (l == r);
33d0fc9c:	e1540000 	cmp	r4, r0
33d0fca0:	13a00000 	movne	r0, #0	; 0x0
33d0fca4:	03a00001 	moveq	r0, #1	; 0x1
33d0fca8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (l != r);
33d0fcac:	e0540000 	subs	r0, r4, r0
33d0fcb0:	13a00001 	movne	r0, #1	; 0x1
33d0fcb4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
33d0fcb8:	e1540000 	cmp	r4, r0
33d0fcbc:	a3a00000 	movge	r0, #0	; 0x0
33d0fcc0:	b3a00001 	movlt	r0, #1	; 0x1
33d0fcc4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (l > r);
33d0fcc8:	e1540000 	cmp	r4, r0
33d0fccc:	d3a00000 	movle	r0, #0	; 0x0
33d0fcd0:	c3a00001 	movgt	r0, #1	; 0x1
33d0fcd4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (l <= r);
33d0fcd8:	e1540000 	cmp	r4, r0
33d0fcdc:	c3a00000 	movgt	r0, #0	; 0x0
33d0fce0:	d3a00001 	movle	r0, #1	; 0x1
33d0fce4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (l >= r);
33d0fce8:	e1540000 	cmp	r4, r0
33d0fcec:	b3a00000 	movlt	r0, #0	; 0x0
33d0fcf0:	a3a00001 	movge	r0, #1	; 0x1
33d0fcf4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}
33d0fcf8:	e3a00000 	mov	r0, #0	; 0x0
	}
	return (0);
}

static int arithcomp (char *s, char *t, int op, int w)
{
33d0fcfc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	int len, i;
	op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
33d0fd00:	e356000c 	cmp	r6, #12	; 0xc
33d0fd04:	e2844008 	add	r4, r4, #8	; 0x8
33d0fd08:	9affff98 	bls	33d0fb70 <binary_test+0x24>
				return (arithcomp (arg1, arg2, optp->opcode, w));
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
33d0fd0c:	e1a0100a 	mov	r1, sl
33d0fd10:	e59f000c 	ldr	r0, [pc, #12]	; 33d0fd24 <binary_test+0x1d8>
33d0fd14:	eb001cab 	bl	33d16fc8 <printf>
	return 0;	/* op code not found */
33d0fd18:	e3a00000 	mov	r0, #0	; 0x0
}
33d0fd1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d0fd20:	33d3600c 	.word	0x33d3600c
33d0fd24:	33d28adc 	.word	0x33d28adc

33d0fd28 <do_itest>:
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4)){
33d0fd28:	e3520004 	cmp	r2, #4	; 0x4
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
{
33d0fd2c:	e92d4010 	push	{r4, lr}

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
33d0fd30:	e1a01002 	mov	r1, r2
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
{
33d0fd34:	e1a04003 	mov	r4, r3
33d0fd38:	e1a03000 	mov	r3, r0
	int	value, w;

	/* Validate arguments */
	if ((argc != 4)){
		printf("Usage:\n%s\n", cmdtp->usage);
33d0fd3c:	e59f0088 	ldr	r0, [pc, #136]	; 33d0fdcc <do_itest+0xa4>
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4)){
33d0fd40:	0a000003 	beq	33d0fd54 <do_itest+0x2c>
		printf("Usage:\n%s\n", cmdtp->usage);
33d0fd44:	e5931010 	ldr	r1, [r3, #16]
33d0fd48:	eb001c9e 	bl	33d16fc8 <printf>
		return 1;
33d0fd4c:	e3a00001 	mov	r0, #1	; 0x1
33d0fd50:	e8bd8010 	pop	{r4, pc}

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
33d0fd54:	e5940000 	ldr	r0, [r4]
33d0fd58:	eb000c77 	bl	33d12f3c <cmd_get_data_size>
33d0fd5c:	e2803002 	add	r3, r0, #2	; 0x2
33d0fd60:	e3530006 	cmp	r3, #6	; 0x6
33d0fd64:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d0fd68:	ea000011 	b	33d0fdb4 <do_itest+0x8c>
33d0fd6c:	33d0fd9c 	.word	0x33d0fd9c
33d0fd70:	33d0fdb4 	.word	0x33d0fdb4
33d0fd74:	33d0fdb4 	.word	0x33d0fdb4
33d0fd78:	33d0fd88 	.word	0x33d0fd88
33d0fd7c:	33d0fd88 	.word	0x33d0fd88
33d0fd80:	33d0fdb4 	.word	0x33d0fdb4
33d0fd84:	33d0fd88 	.word	0x33d0fd88
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
33d0fd88:	e1a03000 	mov	r3, r0
33d0fd8c:	e2840008 	add	r0, r4, #8	; 0x8
33d0fd90:	e8900005 	ldm	r0, {r0, r2}
33d0fd94:	e5941004 	ldr	r1, [r4, #4]
33d0fd98:	ea000003 	b	33d0fdac <do_itest+0x84>
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
33d0fd9c:	e2840008 	add	r0, r4, #8	; 0x8
33d0fda0:	e8900005 	ldm	r0, {r0, r2}
33d0fda4:	e5941004 	ldr	r1, [r4, #4]
33d0fda8:	e3a03000 	mov	r3, #0	; 0x0
33d0fdac:	ebffff66 	bl	33d0fb4c <binary_test>
		break;
33d0fdb0:	ea000002 	b	33d0fdc0 <do_itest+0x98>
	case -1:
	default:
		puts("Invalid data width specifier\n");
33d0fdb4:	e59f0014 	ldr	r0, [pc, #20]	; 33d0fdd0 <do_itest+0xa8>
33d0fdb8:	eb001c7b 	bl	33d16fac <puts>
		value = 0;
33d0fdbc:	e3a00000 	mov	r0, #0	; 0x0
		break;
	}

	return !value;
33d0fdc0:	e2700001 	rsbs	r0, r0, #1	; 0x1
33d0fdc4:	33a00000 	movcc	r0, #0	; 0x0
}
33d0fdc8:	e8bd8010 	pop	{r4, pc}
33d0fdcc:	33d27008 	.word	0x33d27008
33d0fdd0:	33d28af4 	.word	0x33d28af4

33d0fdd4 <memsize_parse>:
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
33d0fdd4:	e92d4010 	push	{r4, lr}
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
33d0fdd8:	e3a02000 	mov	r2, #0	; 0x0
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
33d0fddc:	e1a04001 	mov	r4, r1
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
33d0fde0:	eb0029dd 	bl	33d1a55c <simple_strtoul>

	switch (**retptr) {
33d0fde4:	e5943000 	ldr	r3, [r4]
33d0fde8:	e5d32000 	ldrb	r2, [r3]
33d0fdec:	e352004d 	cmp	r2, #77	; 0x4d
33d0fdf0:	0a00000f 	beq	33d0fe34 <memsize_parse+0x60>
33d0fdf4:	ca000004 	bgt	33d0fe0c <memsize_parse+0x38>
33d0fdf8:	e3520047 	cmp	r2, #71	; 0x47
33d0fdfc:	0a00000b 	beq	33d0fe30 <memsize_parse+0x5c>
33d0fe00:	e352004b 	cmp	r2, #75	; 0x4b
33d0fe04:	18bd8010 	popne	{r4, pc}
33d0fe08:	ea00000a 	b	33d0fe38 <memsize_parse+0x64>
33d0fe0c:	e352006b 	cmp	r2, #107	; 0x6b
33d0fe10:	0a000008 	beq	33d0fe38 <memsize_parse+0x64>
33d0fe14:	ca000002 	bgt	33d0fe24 <memsize_parse+0x50>
33d0fe18:	e3520067 	cmp	r2, #103	; 0x67
33d0fe1c:	18bd8010 	popne	{r4, pc}
33d0fe20:	ea000002 	b	33d0fe30 <memsize_parse+0x5c>
33d0fe24:	e352006d 	cmp	r2, #109	; 0x6d
33d0fe28:	18bd8010 	popne	{r4, pc}
33d0fe2c:	ea000000 	b	33d0fe34 <memsize_parse+0x60>
		case 'G':
		case 'g':
			ret <<= 10;
33d0fe30:	e1a00500 	lsl	r0, r0, #10
		case 'M':
		case 'm':
			ret <<= 10;
33d0fe34:	e1a00500 	lsl	r0, r0, #10
		case 'K':
		case 'k':
			ret <<= 10;
			(*retptr)++;
33d0fe38:	e2833001 	add	r3, r3, #1	; 0x1
		case 'M':
		case 'm':
			ret <<= 10;
		case 'K':
		case 'k':
			ret <<= 10;
33d0fe3c:	e1a00500 	lsl	r0, r0, #10
			(*retptr)++;
33d0fe40:	e5843000 	str	r3, [r4]
		default:
			break;
	}

	return ret;
}
33d0fe44:	e8bd8010 	pop	{r4, pc}

33d0fe48 <memsize_format>:
 *
 * @param buf output buffer
 * @param size size to be converted to string
 */
static void memsize_format(char *buf, u32 size)
{
33d0fe48:	e1a0c001 	mov	ip, r1
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
33d0fe4c:	e3cc3103 	bic	r3, ip, #-1073741824	; 0xc0000000
 *
 * @param buf output buffer
 * @param size size to be converted to string
 */
static void memsize_format(char *buf, u32 size)
{
33d0fe50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
33d0fe54:	e3530000 	cmp	r3, #0	; 0x0
		sprintf(buf, "%lug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
33d0fe58:	e3cce4ff 	bic	lr, ip, #-16777216	; 0xff000000
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%lug", size/SIZE_GB);
33d0fe5c:	e1a02f21 	lsr	r2, r1, #30
	else if ((size % SIZE_MB) == 0)
33d0fe60:	e3cee60f 	bic	lr, lr, #15728640	; 0xf00000
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%lug", size/SIZE_GB);
33d0fe64:	e59f1034 	ldr	r1, [pc, #52]	; 33d0fea0 <memsize_format+0x58>
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
33d0fe68:	0a00000a 	beq	33d0fe98 <memsize_format+0x50>
		sprintf(buf, "%lug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%lum", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
33d0fe6c:	e1a03b0c 	lsl	r3, ip, #22
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%lug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
33d0fe70:	e35e0000 	cmp	lr, #0	; 0x0
		sprintf(buf, "%lum", size/SIZE_MB);
33d0fe74:	e1a02a2c 	lsr	r2, ip, #20
33d0fe78:	e59f1024 	ldr	r1, [pc, #36]	; 33d0fea4 <memsize_format+0x5c>
	else if (size % SIZE_KB == 0)
33d0fe7c:	e1a03b23 	lsr	r3, r3, #22
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%lug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
33d0fe80:	0a000004 	beq	33d0fe98 <memsize_format+0x50>
		sprintf(buf, "%lum", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
33d0fe84:	e3530000 	cmp	r3, #0	; 0x0
		sprintf(buf, "%luk", size/SIZE_KB);
33d0fe88:	e59f1018 	ldr	r1, [pc, #24]	; 33d0fea8 <memsize_format+0x60>
	else
		sprintf(buf, "%lu", size);
33d0fe8c:	159f1018 	ldrne	r1, [pc, #24]	; 33d0feac <memsize_format+0x64>
	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%lug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%lum", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
		sprintf(buf, "%luk", size/SIZE_KB);
33d0fe90:	e1a0252c 	lsr	r2, ip, #10
	else
		sprintf(buf, "%lu", size);
33d0fe94:	11a0200c 	movne	r2, ip
}
33d0fe98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%lum", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
		sprintf(buf, "%luk", size/SIZE_KB);
	else
		sprintf(buf, "%lu", size);
33d0fe9c:	ea002b94 	b	33d1acf4 <sprintf>
33d0fea0:	33d29258 	.word	0x33d29258
33d0fea4:	33d29260 	.word	0x33d29260
33d0fea8:	33d29268 	.word	0x33d29268
33d0feac:	33d29270 	.word	0x33d29270

33d0feb0 <jffs2_part_info>:
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* jffs2_part_info(struct mtd_device *dev, unsigned int part_num)
{
33d0feb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
33d0feb4:	e3500000 	cmp	r0, #0	; 0x0
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* jffs2_part_info(struct mtd_device *dev, unsigned int part_num)
{
33d0feb8:	e24dd004 	sub	sp, sp, #4	; 0x4
33d0febc:	e1a0c001 	mov	ip, r1
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
33d0fec0:	0a00001c 	beq	33d0ff38 <jffs2_part_info+0x88>

	DEBUGF("\n--- jffs2_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
33d0fec4:	e1d030bc 	ldrh	r3, [r0, #12]
33d0fec8:	e1510003 	cmp	r1, r3
33d0fecc:	3a00000d 	bcc	33d0ff08 <jffs2_part_info+0x58>
		printf("invalid partition number %d for device %s%d (%s)\n",
33d0fed0:	e5902008 	ldr	r2, [r0, #8]
33d0fed4:	e5d2c008 	ldrb	ip, [r2, #8]
33d0fed8:	e59f0060 	ldr	r0, [pc, #96]	; 33d0ff40 <jffs2_part_info+0x90>
33d0fedc:	e592e010 	ldr	lr, [r2, #16]
33d0fee0:	e35c0002 	cmp	ip, #2	; 0x2
33d0fee4:	e5d23009 	ldrb	r3, [r2, #9]
33d0fee8:	e59f2054 	ldr	r2, [pc, #84]	; 33d0ff44 <jffs2_part_info+0x94>
33d0feec:	11a02000 	movne	r2, r0
33d0fef0:	e59f0050 	ldr	r0, [pc, #80]	; 33d0ff48 <jffs2_part_info+0x98>
33d0fef4:	e58de000 	str	lr, [sp]
33d0fef8:	eb001c32 	bl	33d16fc8 <printf>
33d0fefc:	ea00000c 	b	33d0ff34 <jffs2_part_info+0x84>
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
			return part;
33d0ff00:	e1a00002 	mov	r0, r2
33d0ff04:	ea00000b 	b	33d0ff38 <jffs2_part_info+0x88>
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
33d0ff08:	e5902010 	ldr	r2, [r0, #16]
33d0ff0c:	e2800010 	add	r0, r0, #16	; 0x10
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d0ff10:	e1520000 	cmp	r2, r0
				dev->id->num, dev->id->mtd_id);
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
33d0ff14:	e3a01000 	mov	r1, #0	; 0x0
33d0ff18:	0a000005 	beq	33d0ff34 <jffs2_part_info+0x84>
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
33d0ff1c:	e151000c 	cmp	r1, ip
33d0ff20:	e2811001 	add	r1, r1, #1	; 0x1
33d0ff24:	0afffff5 	beq	33d0ff00 <jffs2_part_info+0x50>
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
33d0ff28:	e5922000 	ldr	r2, [r2]
33d0ff2c:	e1520000 	cmp	r2, r0
33d0ff30:	eafffff8 	b	33d0ff18 <jffs2_part_info+0x68>
		if (part_num == num++) {
			return part;
		}
	}

	return NULL;
33d0ff34:	e3a00000 	mov	r0, #0	; 0x0
}
33d0ff38:	e28dd004 	add	sp, sp, #4	; 0x4
33d0ff3c:	e8bd8000 	pop	{pc}
33d0ff40:	33d29274 	.word	0x33d29274
33d0ff44:	33d29278 	.word	0x33d29278
33d0ff48:	33d29280 	.word	0x33d29280

33d0ff4c <index_partitions>:
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 */
static void index_partitions(void)
{
33d0ff4c:	e92d4010 	push	{r4, lr}
	struct list_head *dentry;
	struct mtd_device *dev;

	DEBUGF("--- index partitions ---\n");

	if (current_dev) {
33d0ff50:	e59fc0b8 	ldr	ip, [pc, #184]	; 33d10010 <index_partitions+0xc4>
33d0ff54:	e59c4000 	ldr	r4, [ip]
33d0ff58:	e3540000 	cmp	r4, #0	; 0x0
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 */
static void index_partitions(void)
{
33d0ff5c:	e24dd010 	sub	sp, sp, #16	; 0x10
	struct list_head *dentry;
	struct mtd_device *dev;

	DEBUGF("--- index partitions ---\n");

	if (current_dev) {
33d0ff60:	0a000022 	beq	33d0fff0 <index_partitions+0xa4>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
33d0ff64:	e59f20a8 	ldr	r2, [pc, #168]	; 33d10014 <index_partitions+0xc8>
33d0ff68:	e5921000 	ldr	r1, [r2]
	struct mtd_device *dev;

	DEBUGF("--- index partitions ---\n");

	if (current_dev) {
		mtddevnum = 0;
33d0ff6c:	e3a00000 	mov	r0, #0	; 0x0
33d0ff70:	e1510002 	cmp	r1, r2
33d0ff74:	0a000009 	beq	33d0ffa0 <index_partitions+0x54>
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_dev) {
33d0ff78:	e59c3000 	ldr	r3, [ip]
33d0ff7c:	e1510003 	cmp	r1, r3
33d0ff80:	0a00000d 	beq	33d0ffbc <index_partitions+0x70>
				mtddevnum += current_partnum;
				sprintf(buf, "%d", mtddevnum);
				setenv("mtddevnum", buf);
				break;
			}
			mtddevnum += dev->num_parts;
33d0ff84:	e1d130bc 	ldrh	r3, [r1, #12]

	DEBUGF("--- index partitions ---\n");

	if (current_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
33d0ff88:	e5911000 	ldr	r1, [r1]
				mtddevnum += current_partnum;
				sprintf(buf, "%d", mtddevnum);
				setenv("mtddevnum", buf);
				break;
			}
			mtddevnum += dev->num_parts;
33d0ff8c:	e0803003 	add	r3, r0, r3
33d0ff90:	e1a03803 	lsl	r3, r3, #16
33d0ff94:	e1510002 	cmp	r1, r2
33d0ff98:	e1a00823 	lsr	r0, r3, #16
33d0ff9c:	eafffff4 	b	33d0ff74 <index_partitions+0x28>
		}

		part = jffs2_part_info(current_dev, current_partnum);
33d0ffa0:	e59f3068 	ldr	r3, [pc, #104]	; 33d10010 <index_partitions+0xc4>
33d0ffa4:	e5930000 	ldr	r0, [r3]
33d0ffa8:	e59f3068 	ldr	r3, [pc, #104]	; 33d10018 <index_partitions+0xcc>
33d0ffac:	e5d31000 	ldrb	r1, [r3]
33d0ffb0:	ebffffbe 	bl	33d0feb0 <jffs2_part_info>
		setenv("mtddevname", part->name);
33d0ffb4:	e5901008 	ldr	r1, [r0, #8]
33d0ffb8:	ea000010 	b	33d10000 <index_partitions+0xb4>
	if (current_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_dev) {
				mtddevnum += current_partnum;
33d0ffbc:	e59f3054 	ldr	r3, [pc, #84]	; 33d10018 <index_partitions+0xcc>
33d0ffc0:	e5d32000 	ldrb	r2, [r3]
33d0ffc4:	e0802002 	add	r2, r0, r2
33d0ffc8:	e1a02802 	lsl	r2, r2, #16
				sprintf(buf, "%d", mtddevnum);
33d0ffcc:	e1a02822 	lsr	r2, r2, #16
33d0ffd0:	e1a0000d 	mov	r0, sp
33d0ffd4:	e59f1040 	ldr	r1, [pc, #64]	; 33d1001c <index_partitions+0xd0>
33d0ffd8:	eb002b45 	bl	33d1acf4 <sprintf>
				setenv("mtddevnum", buf);
33d0ffdc:	e1a0100d 	mov	r1, sp
33d0ffe0:	e59f0038 	ldr	r0, [pc, #56]	; 33d10020 <index_partitions+0xd4>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_dev) {
				mtddevnum += current_partnum;
				sprintf(buf, "%d", mtddevnum);
33d0ffe4:	e1a0400d 	mov	r4, sp
				setenv("mtddevnum", buf);
33d0ffe8:	eb0015fa 	bl	33d157d8 <setenv>
				break;
33d0ffec:	eaffffeb 	b	33d0ffa0 <index_partitions+0x54>
		part = jffs2_part_info(current_dev, current_partnum);
		setenv("mtddevname", part->name);

		DEBUGF("=> mtddevnum %d,\n=> mtddevname %s\n", mtddevnum, part->name);
	} else {
		setenv("mtddevnum", NULL);
33d0fff0:	e1a01004 	mov	r1, r4
33d0fff4:	e59f0024 	ldr	r0, [pc, #36]	; 33d10020 <index_partitions+0xd4>
33d0fff8:	eb0015f6 	bl	33d157d8 <setenv>
		setenv("mtddevname", NULL);
33d0fffc:	e1a01004 	mov	r1, r4
33d10000:	e59f001c 	ldr	r0, [pc, #28]	; 33d10024 <index_partitions+0xd8>
33d10004:	eb0015f3 	bl	33d157d8 <setenv>

		DEBUGF("=> mtddevnum NULL\n=> mtddevname NULL\n");
	}
}
33d10008:	e28dd010 	add	sp, sp, #16	; 0x10
33d1000c:	e8bd8010 	pop	{r4, pc}
33d10010:	33d608d8 	.word	0x33d608d8
33d10014:	33d608d0 	.word	0x33d608d0
33d10018:	33d608dc 	.word	0x33d608dc
33d1001c:	33d2586c 	.word	0x33d2586c
33d10020:	33d292b4 	.word	0x33d292b4
33d10024:	33d292c0 	.word	0x33d292c0

33d10028 <current_save>:

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
33d10028:	e92d4030 	push	{r4, r5, lr}
	char buf[16];

	DEBUGF("--- current_save ---\n");

	if (current_dev) {
33d1002c:	e59f3084 	ldr	r3, [pc, #132]	; 33d100b8 <current_save+0x90>
33d10030:	e5934000 	ldr	r4, [r3]

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
33d10034:	e24dd014 	sub	sp, sp, #20	; 0x14
	char buf[16];

	DEBUGF("--- current_save ---\n");

	if (current_dev) {
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_dev->id->type),
33d10038:	e28d5004 	add	r5, sp, #4	; 0x4
{
	char buf[16];

	DEBUGF("--- current_save ---\n");

	if (current_dev) {
33d1003c:	e3540000 	cmp	r4, #0	; 0x0
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_dev->id->type),
33d10040:	e1a00005 	mov	r0, r5
33d10044:	e59f1070 	ldr	r1, [pc, #112]	; 33d100bc <current_save+0x94>
{
	char buf[16];

	DEBUGF("--- current_save ---\n");

	if (current_dev) {
33d10048:	0a000012 	beq	33d10098 <current_save+0x70>
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_dev->id->type),
33d1004c:	e5942008 	ldr	r2, [r4, #8]
33d10050:	e59f3068 	ldr	r3, [pc, #104]	; 33d100c0 <current_save+0x98>
33d10054:	e5d2e008 	ldrb	lr, [r2, #8]
33d10058:	e59fc064 	ldr	ip, [pc, #100]	; 33d100c4 <current_save+0x9c>
33d1005c:	e5d34000 	ldrb	r4, [r3]
33d10060:	e35e0002 	cmp	lr, #2	; 0x2
33d10064:	e5d23009 	ldrb	r3, [r2, #9]
33d10068:	e59f2058 	ldr	r2, [pc, #88]	; 33d100c8 <current_save+0xa0>
33d1006c:	11a0200c 	movne	r2, ip
33d10070:	e58d4000 	str	r4, [sp]
33d10074:	eb002b1e 	bl	33d1acf4 <sprintf>
					current_dev->id->num, current_partnum);

		setenv("partition", buf);
33d10078:	e1a01005 	mov	r1, r5
33d1007c:	e59f0048 	ldr	r0, [pc, #72]	; 33d100cc <current_save+0xa4>
33d10080:	eb0015d4 	bl	33d157d8 <setenv>
		strncpy(last_partition, buf, 16);
33d10084:	e1a01005 	mov	r1, r5
33d10088:	e3a02010 	mov	r2, #16	; 0x10
33d1008c:	e59f003c 	ldr	r0, [pc, #60]	; 33d100d0 <current_save+0xa8>
33d10090:	eb0027d0 	bl	33d19fd8 <strncpy>
33d10094:	ea000004 	b	33d100ac <current_save+0x84>

		DEBUGF("=> partition %s\n", buf);
	} else {
		setenv("partition", NULL);
33d10098:	e59f002c 	ldr	r0, [pc, #44]	; 33d100cc <current_save+0xa4>
33d1009c:	e1a01004 	mov	r1, r4
33d100a0:	eb0015cc 	bl	33d157d8 <setenv>
		last_partition[0] = '\0';
33d100a4:	e59f3024 	ldr	r3, [pc, #36]	; 33d100d0 <current_save+0xa8>
33d100a8:	e5c34000 	strb	r4, [r3]

		DEBUGF("=> partition NULL\n");
	}
	index_partitions();
33d100ac:	ebffffa6 	bl	33d0ff4c <index_partitions>
33d100b0:	e28dd014 	add	sp, sp, #20	; 0x14
33d100b4:	e8bd8030 	pop	{r4, r5, pc}
33d100b8:	33d608d8 	.word	0x33d608d8
33d100bc:	33d292cc 	.word	0x33d292cc
33d100c0:	33d608dc 	.word	0x33d608dc
33d100c4:	33d29274 	.word	0x33d29274
33d100c8:	33d29278 	.word	0x33d29278
33d100cc:	33d292d4 	.word	0x33d292d4
33d100d0:	33d60b64 	.word	0x33d60b64

33d100d4 <part_validate>:
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
33d100d4:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	if (part->size == SIZE_REMAINING)
33d100d8:	e5913010 	ldr	r3, [r1, #16]
33d100dc:	e3730001 	cmn	r3, #1	; 0x1
		part->size = id->size - part->offset;
33d100e0:	0590300c 	ldreq	r3, [r0, #12]
33d100e4:	05912014 	ldreq	r2, [r1, #20]
33d100e8:	00623003 	rsbeq	r3, r2, r3
33d100ec:	05813010 	streq	r3, [r1, #16]

	if (part->offset > id->size) {
33d100f0:	e5917014 	ldr	r7, [r1, #20]
33d100f4:	e590300c 	ldr	r3, [r0, #12]
33d100f8:	e1570003 	cmp	r7, r3
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
33d100fc:	e1a06001 	mov	r6, r1
	if (part->size == SIZE_REMAINING)
		part->size = id->size - part->offset;

	if (part->offset > id->size) {
		printf("%s: offset %08lx beyond flash size %08lx\n",
33d10100:	81a02007 	movhi	r2, r7
33d10104:	85901010 	ldrhi	r1, [r0, #16]
33d10108:	859f01b4 	ldrhi	r0, [pc, #436]	; 33d102c4 <part_validate+0x1f0>
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
		part->size = id->size - part->offset;

	if (part->offset > id->size) {
33d1010c:	8a00000b 	bhi	33d10140 <part_validate+0x6c>
		printf("%s: offset %08lx beyond flash size %08lx\n",
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
33d10110:	e596a010 	ldr	sl, [r6, #16]
33d10114:	e087200a 	add	r2, r7, sl
33d10118:	e1520007 	cmp	r2, r7
33d1011c:	8a00000a 	bhi	33d1014c <part_validate+0x78>
		printf("%s%d: partition (%s) size too big\n",
33d10120:	e5d02008 	ldrb	r2, [r0, #8]
33d10124:	e59f319c 	ldr	r3, [pc, #412]	; 33d102c8 <part_validate+0x1f4>
33d10128:	e3520002 	cmp	r2, #2	; 0x2
33d1012c:	e59f1198 	ldr	r1, [pc, #408]	; 33d102cc <part_validate+0x1f8>
33d10130:	e5d02009 	ldrb	r2, [r0, #9]
33d10134:	11a01003 	movne	r1, r3
33d10138:	e59f0190 	ldr	r0, [pc, #400]	; 33d102d0 <part_validate+0x1fc>
33d1013c:	e5963008 	ldr	r3, [r6, #8]
33d10140:	eb001ba0 	bl	33d16fc8 <printf>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
33d10144:	e3a00001 	mov	r0, #1	; 0x1
33d10148:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (part->offset + part->size > id->size) {
33d1014c:	e1520003 	cmp	r2, r3
33d10150:	9a000003 	bls	33d10164 <part_validate+0x90>
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
33d10154:	e5901010 	ldr	r1, [r0, #16]
33d10158:	e59f0174 	ldr	r0, [pc, #372]	; 33d102d4 <part_validate+0x200>
33d1015c:	eb001b99 	bl	33d16fc8 <printf>
33d10160:	eafffff7 	b	33d10144 <part_validate+0x70>
		return 1;
	}

	if (id->type == MTD_DEV_TYPE_NAND)
33d10164:	e5d09008 	ldrb	r9, [r0, #8]
33d10168:	e20930ff 	and	r3, r9, #255	; 0xff
33d1016c:	e3530002 	cmp	r3, #2	; 0x2
33d10170:	1a000017 	bne	33d101d4 <part_validate+0x100>
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	/* info for NAND chips */
	nand_info_t *nand;

	nand = &nand_info[id->num];
33d10174:	e5d04009 	ldrb	r4, [r0, #9]
33d10178:	e59f3158 	ldr	r3, [pc, #344]	; 33d102d8 <part_validate+0x204>
33d1017c:	e0842104 	add	r2, r4, r4, lsl #2
33d10180:	e0842182 	add	r2, r4, r2, lsl #3
33d10184:	e0833182 	add	r3, r3, r2, lsl #3

	if ((unsigned long)(part->offset) % nand->erasesize) {
33d10188:	e593500c 	ldr	r5, [r3, #12]
33d1018c:	e1a00007 	mov	r0, r7
33d10190:	e1a01005 	mov	r1, r5
33d10194:	eb0039c1 	bl	33d1e8a0 <__umodsi3>
33d10198:	e3500000 	cmp	r0, #0	; 0x0
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
33d1019c:	11a02004 	movne	r2, r4
33d101a0:	15963008 	ldrne	r3, [r6, #8]
33d101a4:	159f0130 	ldrne	r0, [pc, #304]	; 33d102dc <part_validate+0x208>
	/* info for NAND chips */
	nand_info_t *nand;

	nand = &nand_info[id->num];

	if ((unsigned long)(part->offset) % nand->erasesize) {
33d101a8:	1a000007 	bne	33d101cc <part_validate+0xf8>
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->size % nand->erasesize) {
33d101ac:	e1a0000a 	mov	r0, sl
33d101b0:	e1a01005 	mov	r1, r5
33d101b4:	eb0039b9 	bl	33d1e8a0 <__umodsi3>
33d101b8:	e3500000 	cmp	r0, #0	; 0x0
33d101bc:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
		printf("%s%d: partition (%s) size alignment incorrect\n",
33d101c0:	e5963008 	ldr	r3, [r6, #8]
33d101c4:	e59f0114 	ldr	r0, [pc, #276]	; 33d102e0 <part_validate+0x20c>
33d101c8:	e1a02004 	mov	r2, r4
33d101cc:	e59f10f8 	ldr	r1, [pc, #248]	; 33d102cc <part_validate+0x1f8>
33d101d0:	eaffffda 	b	33d10140 <part_validate+0x6c>
		return 1;
	}

	if (id->type == MTD_DEV_TYPE_NAND)
		return part_validate_nand(id, part);
	else if (id->type == MTD_DEV_TYPE_NOR)
33d101d4:	e3530001 	cmp	r3, #1	; 0x1
		return part_validate_nor(id, part);
	else
		DEBUGF("part_validate: invalid dev type\n");

	return 1;
33d101d8:	13a00001 	movne	r0, #1	; 0x1
		return 1;
	}

	if (id->type == MTD_DEV_TYPE_NAND)
		return part_validate_nand(id, part);
	else if (id->type == MTD_DEV_TYPE_NOR)
33d101dc:	18bd86f0 	popne	{r4, r5, r6, r7, r9, sl, pc}
	flash_info_t *flash;
	int offset_aligned;
	u32 end_offset;
	int i;

	flash = &flash_info[id->num];
33d101e0:	e5d05009 	ldrb	r5, [r0, #9]
33d101e4:	e59f20f8 	ldr	r2, [pc, #248]	; 33d102e4 <part_validate+0x210>
33d101e8:	e0853085 	add	r3, r5, r5, lsl #1
33d101ec:	e0833183 	add	r3, r3, r3, lsl #3
33d101f0:	e0821103 	add	r1, r2, r3, lsl #2

	offset_aligned = 0;
	for (i = 0; i < flash->sector_count; i++) {
33d101f4:	e1d140b4 	ldrh	r4, [r1, #4]
	u32 end_offset;
	int i;

	flash = &flash_info[id->num];

	offset_aligned = 0;
33d101f8:	e3a0e000 	mov	lr, #0	; 0x0
	for (i = 0; i < flash->sector_count; i++) {
33d101fc:	e15e0004 	cmp	lr, r4
33d10200:	aa000009 	bge	33d1022c <part_validate+0x158>
33d10204:	e1a0c001 	mov	ip, r1
		if ((flash->start[i] - flash->start[0]) == part->offset) {
33d10208:	e59c300c 	ldr	r3, [ip, #12]
33d1020c:	e591200c 	ldr	r2, [r1, #12]
33d10210:	e0623003 	rsb	r3, r2, r3
33d10214:	e1530007 	cmp	r3, r7
	int i;

	flash = &flash_info[id->num];

	offset_aligned = 0;
	for (i = 0; i < flash->sector_count; i++) {
33d10218:	e28ee001 	add	lr, lr, #1	; 0x1
33d1021c:	e28cc004 	add	ip, ip, #4	; 0x4
		if ((flash->start[i] - flash->start[0]) == part->offset) {
33d10220:	0a000009 	beq	33d1024c <part_validate+0x178>
	int i;

	flash = &flash_info[id->num];

	offset_aligned = 0;
	for (i = 0; i < flash->sector_count; i++) {
33d10224:	e15e0004 	cmp	lr, r4
33d10228:	bafffff6 	blt	33d10208 <part_validate+0x134>
			offset_aligned = 1;
			break;
		}
	}
	if (offset_aligned == 0) {
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
33d1022c:	e59f3094 	ldr	r3, [pc, #148]	; 33d102c8 <part_validate+0x1f4>
33d10230:	e3590002 	cmp	r9, #2	; 0x2
33d10234:	e59f1090 	ldr	r1, [pc, #144]	; 33d102cc <part_validate+0x1f8>
33d10238:	e59f009c 	ldr	r0, [pc, #156]	; 33d102dc <part_validate+0x208>
33d1023c:	11a01003 	movne	r1, r3
33d10240:	e5963008 	ldr	r3, [r6, #8]
33d10244:	e1a02005 	mov	r2, r5
33d10248:	eaffffbc 	b	33d10140 <part_validate+0x6c>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	end_offset = part->offset + part->size;
	for (i = 0; i < flash->sector_count; i++) {
33d1024c:	e1d140b4 	ldrh	r4, [r1, #4]
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	end_offset = part->offset + part->size;
33d10250:	e5963014 	ldr	r3, [r6, #20]
	for (i = 0; i < flash->sector_count; i++) {
33d10254:	e3a0e000 	mov	lr, #0	; 0x0
33d10258:	e15e0004 	cmp	lr, r4
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	end_offset = part->offset + part->size;
33d1025c:	e083000a 	add	r0, r3, sl
	for (i = 0; i < flash->sector_count; i++) {
33d10260:	aa000009 	bge	33d1028c <part_validate+0x1b8>
33d10264:	e1a0c001 	mov	ip, r1
		if ((flash->start[i] - flash->start[0]) == end_offset)
33d10268:	e59c300c 	ldr	r3, [ip, #12]
33d1026c:	e591200c 	ldr	r2, [r1, #12]
33d10270:	e0623003 	rsb	r3, r2, r3
33d10274:	e1530000 	cmp	r3, r0
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	end_offset = part->offset + part->size;
	for (i = 0; i < flash->sector_count; i++) {
33d10278:	e28ee001 	add	lr, lr, #1	; 0x1
33d1027c:	e28cc004 	add	ip, ip, #4	; 0x4
		if ((flash->start[i] - flash->start[0]) == end_offset)
33d10280:	0a000008 	beq	33d102a8 <part_validate+0x1d4>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	end_offset = part->offset + part->size;
	for (i = 0; i < flash->sector_count; i++) {
33d10284:	e15e0004 	cmp	lr, r4
33d10288:	bafffff6 	blt	33d10268 <part_validate+0x194>
		if ((flash->start[i] - flash->start[0]) == end_offset)
			return 0;
	}

	if (flash->size == end_offset)
33d1028c:	e5913000 	ldr	r3, [r1]
33d10290:	e1530000 	cmp	r3, r0
33d10294:	0a000003 	beq	33d102a8 <part_validate+0x1d4>
		return 0;

	printf("%s%d: partition (%s) size alignment incorrect\n",
33d10298:	e3590002 	cmp	r9, #2	; 0x2
33d1029c:	059f1028 	ldreq	r1, [pc, #40]	; 33d102cc <part_validate+0x1f8>
33d102a0:	0a000003 	beq	33d102b4 <part_validate+0x1e0>
33d102a4:	ea000001 	b	33d102b0 <part_validate+0x1dc>
		return 1;
	}

	end_offset = part->offset + part->size;
	for (i = 0; i < flash->sector_count; i++) {
		if ((flash->start[i] - flash->start[0]) == end_offset)
33d102a8:	e3a00000 	mov	r0, #0	; 0x0
33d102ac:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (flash->size == end_offset)
		return 0;

	printf("%s%d: partition (%s) size alignment incorrect\n",
33d102b0:	e59f1010 	ldr	r1, [pc, #16]	; 33d102c8 <part_validate+0x1f4>
33d102b4:	e5963008 	ldr	r3, [r6, #8]
33d102b8:	e59f0020 	ldr	r0, [pc, #32]	; 33d102e0 <part_validate+0x20c>
33d102bc:	e1a02005 	mov	r2, r5
33d102c0:	eaffff9e 	b	33d10140 <part_validate+0x6c>
33d102c4:	33d292e0 	.word	0x33d292e0
33d102c8:	33d29274 	.word	0x33d29274
33d102cc:	33d29278 	.word	0x33d29278
33d102d0:	33d2930c 	.word	0x33d2930c
33d102d4:	33d29330 	.word	0x33d29330
33d102d8:	33d39920 	.word	0x33d39920
33d102dc:	33d29358 	.word	0x33d29358
33d102e0:	33d29390 	.word	0x33d29390
33d102e4:	33d62554 	.word	0x33d62554

33d102e8 <part_delall>:
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 */
static void part_delall(struct list_head *head)
{
33d102e8:	e92d4030 	push	{r4, r5, lr}
33d102ec:	e1a04000 	mov	r4, r0
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
33d102f0:	e5900000 	ldr	r0, [r0]
33d102f4:	e1500004 	cmp	r0, r4
33d102f8:	e5905000 	ldr	r5, [r0]
33d102fc:	08bd8030 	popeq	{r4, r5, pc}
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d10300:	e890000c 	ldm	r0, {r2, r3}
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10304:	e3a01000 	mov	r1, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d10308:	e5832000 	str	r2, [r3]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d1030c:	e5823004 	str	r3, [r2, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10310:	e5801000 	str	r1, [r0]
	entry->prev = (void *) 0;
33d10314:	e5801004 	str	r1, [r0, #4]

#ifdef CFG_NAND_LEGACY
		jffs2_free_cache(part_tmp);
#endif
		list_del(entry);
		free(part_tmp);
33d10318:	eb001c4d 	bl	33d17454 <free>
{
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
33d1031c:	e1550004 	cmp	r5, r4
33d10320:	e1a00005 	mov	r0, r5
33d10324:	e5955000 	ldr	r5, [r5]
33d10328:	1afffff4 	bne	33d10300 <part_delall+0x18>
33d1032c:	e8bd8030 	pop	{r4, r5, pc}

33d10330 <device_del>:
 *
 * @param dev device to be deleted
 * @return 0 on success, 1 otherwise
 */
static int device_del(struct mtd_device *dev)
{
33d10330:	e92d4030 	push	{r4, r5, lr}
33d10334:	e1a04000 	mov	r4, r0
	part_delall(&dev->parts);
33d10338:	e2800010 	add	r0, r0, #16	; 0x10
33d1033c:	ebffffe9 	bl	33d102e8 <part_delall>
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d10340:	e5942004 	ldr	r2, [r4, #4]
33d10344:	e5943000 	ldr	r3, [r4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10348:	e3a05000 	mov	r5, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d1034c:	e5823000 	str	r3, [r2]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d10350:	e5832004 	str	r2, [r3, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10354:	e5845000 	str	r5, [r4]
	entry->prev = (void *) 0;
33d10358:	e5845004 	str	r5, [r4, #4]
	list_del(&dev->link);
	free(dev);
33d1035c:	e1a00004 	mov	r0, r4
33d10360:	eb001c3b 	bl	33d17454 <free>

	if (dev == current_dev) {
33d10364:	e59f1044 	ldr	r1, [pc, #68]	; 33d103b0 <device_del+0x80>
33d10368:	e5913000 	ldr	r3, [r1]
33d1036c:	e1540003 	cmp	r4, r3
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d10370:	e59f203c 	ldr	r2, [pc, #60]	; 33d103b4 <device_del+0x84>
33d10374:	1a00000a 	bne	33d103a4 <device_del+0x74>
	return head->next == head;
33d10378:	e5923000 	ldr	r3, [r2]
33d1037c:	e1530002 	cmp	r3, r2
33d10380:	13a02000 	movne	r2, #0	; 0x0
33d10384:	03a02001 	moveq	r2, #1	; 0x1
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d10388:	e1520005 	cmp	r2, r5
		if (list_empty(&devices)) {
			current_dev = NULL;
		} else {
			/* reset first partition from first dev from the
			 * devices list as current */
			current_dev = list_entry(devices.next, struct mtd_device, link);
33d1038c:	05813000 	streq	r3, [r1]
			current_partnum = 0;
33d10390:	059f3020 	ldreq	r3, [pc, #32]	; 33d103b8 <device_del+0x88>
	free(dev);

	if (dev == current_dev) {
		/* we just deleted current device */
		if (list_empty(&devices)) {
			current_dev = NULL;
33d10394:	15815000 	strne	r5, [r1]
		} else {
			/* reset first partition from first dev from the
			 * devices list as current */
			current_dev = list_entry(devices.next, struct mtd_device, link);
			current_partnum = 0;
33d10398:	05c32000 	strbeq	r2, [r3]
		}
		current_save();
33d1039c:	ebffff21 	bl	33d10028 <current_save>
		return 0;
33d103a0:	ea000000 	b	33d103a8 <device_del+0x78>
	}

	index_partitions();
33d103a4:	ebfffee8 	bl	33d0ff4c <index_partitions>
	return 0;
}
33d103a8:	e3a00000 	mov	r0, #0	; 0x0
33d103ac:	e8bd8030 	pop	{r4, r5, pc}
33d103b0:	33d608d8 	.word	0x33d608d8
33d103b4:	33d608d0 	.word	0x33d608d0
33d103b8:	33d608dc 	.word	0x33d608dc

33d103bc <part_sort_add>:
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
33d103bc:	e92d4070 	push	{r4, r5, r6, lr}
33d103c0:	e1a04001 	mov	r4, r1
	struct list_head *entry;
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;
33d103c4:	e5840020 	str	r0, [r4, #32]
	return head->next == head;
33d103c8:	e5903010 	ldr	r3, [r0, #16]
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d103cc:	e2806010 	add	r6, r0, #16	; 0x10
	return head->next == head;
33d103d0:	e1530006 	cmp	r3, r6
33d103d4:	13a02000 	movne	r2, #0	; 0x0
33d103d8:	03a02001 	moveq	r2, #1	; 0x1
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d103dc:	e3520000 	cmp	r2, #0	; 0x0
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
33d103e0:	e1a05000 	mov	r5, r0
33d103e4:	0a00000b 	beq	33d10418 <part_sort_add+0x5c>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
33d103e8:	e5813000 	str	r3, [r1]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d103ec:	e5831004 	str	r1, [r3, #4]
	new->next = next;
	new->prev = prev;
33d103f0:	e5816004 	str	r6, [r1, #4]
	part->dev = dev;

	if (list_empty(&dev->parts)) {
		DEBUGF("part_sort_add: list empty\n");
		list_add(&part->link, &dev->parts);
		dev->num_parts++;
33d103f4:	e1d030bc 	ldrh	r3, [r0, #12]
33d103f8:	e2833001 	add	r3, r3, #1	; 0x1
33d103fc:	e1c030bc 	strh	r3, [r0, #12]
	prev->next = new;
33d10400:	e5851010 	str	r1, [r5, #16]
33d10404:	ea00002b 	b	33d104b8 <part_sort_add+0xfc>

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
			printf("cannot add second partition at offset 0\n");
33d10408:	e59f00ec 	ldr	r0, [pc, #236]	; 33d104fc <part_sort_add+0x140>
33d1040c:	eb001aed 	bl	33d16fc8 <printf>
			return 1;
33d10410:	e3a00001 	mov	r0, #1	; 0x1
33d10414:	e8bd8070 	pop	{r4, r5, r6, pc}

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_dev)
33d10418:	e59f30e0 	ldr	r3, [pc, #224]	; 33d10500 <part_sort_add+0x144>
33d1041c:	e5933000 	ldr	r3, [r3]
33d10420:	e1500003 	cmp	r0, r3
	}

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
33d10424:	e1a0c002 	mov	ip, r2
	if (dev == current_dev)
33d10428:	1a000003 	bne	33d1043c <part_sort_add+0x80>
		curr_pi = jffs2_part_info(current_dev, current_partnum);
33d1042c:	e59f30d0 	ldr	r3, [pc, #208]	; 33d10504 <part_sort_add+0x148>
33d10430:	e5d31000 	ldrb	r1, [r3]
33d10434:	ebfffe9d 	bl	33d0feb0 <jffs2_part_info>
33d10438:	e1a0c000 	mov	ip, r0

	list_for_each(entry, &dev->parts) {
33d1043c:	e5952010 	ldr	r2, [r5, #16]
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d10440:	e1520006 	cmp	r2, r6
33d10444:	0a000020 	beq	33d104cc <part_sort_add+0x110>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
33d10448:	e5943014 	ldr	r3, [r4, #20]
33d1044c:	e5921014 	ldr	r1, [r2, #20]
33d10450:	e1530001 	cmp	r3, r1
33d10454:	1a000001 	bne	33d10460 <part_sort_add+0xa4>
33d10458:	e3530000 	cmp	r3, #0	; 0x0
33d1045c:	0affffe9 	beq	33d10408 <part_sort_add+0x4c>
			printf("cannot add second partition at offset 0\n");
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
33d10460:	e1530001 	cmp	r3, r1
33d10464:	8a000016 	bhi	33d104c4 <part_sort_add+0x108>
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
33d10468:	e5923004 	ldr	r3, [r2, #4]
	next->prev = new;
	new->next = next;
33d1046c:	e5842000 	str	r2, [r4]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d10470:	e5824004 	str	r4, [r2, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
33d10474:	e5834000 	str	r4, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
33d10478:	e5843004 	str	r3, [r4, #4]
			list_add_tail(&part->link, entry);
			dev->num_parts++;
33d1047c:	e1d530bc 	ldrh	r3, [r5, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
33d10480:	e35c0000 	cmp	ip, #0	; 0x0
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
33d10484:	e2833001 	add	r3, r3, #1	; 0x1
33d10488:	e1c530bc 	strh	r3, [r5, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
33d1048c:	0a000009 	beq	33d104b8 <part_sort_add+0xfc>
33d10490:	e5922014 	ldr	r2, [r2, #20]
33d10494:	e59c3014 	ldr	r3, [ip, #20]
33d10498:	e1520003 	cmp	r2, r3
33d1049c:	8a000005 	bhi	33d104b8 <part_sort_add+0xfc>
				/* we are modyfing partitions for the current
				 * device, update current */
				current_partnum++;
33d104a0:	e59f205c 	ldr	r2, [pc, #92]	; 33d10504 <part_sort_add+0x148>
33d104a4:	e5d23000 	ldrb	r3, [r2]
33d104a8:	e2833001 	add	r3, r3, #1	; 0x1
33d104ac:	e5c23000 	strb	r3, [r2]
				current_save();
33d104b0:	ebfffedc 	bl	33d10028 <current_save>
33d104b4:	ea000000 	b	33d104bc <part_sort_add+0x100>
			} else {
				index_partitions();
33d104b8:	ebfffea3 	bl	33d0ff4c <index_partitions>
			}
			return 0;
33d104bc:	e3a00000 	mov	r0, #0	; 0x0
33d104c0:	e8bd8070 	pop	{r4, r5, r6, pc}
	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_dev)
		curr_pi = jffs2_part_info(current_dev, current_partnum);

	list_for_each(entry, &dev->parts) {
33d104c4:	e5922000 	ldr	r2, [r2]
33d104c8:	eaffffdc 	b	33d10440 <part_sort_add+0x84>
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
33d104cc:	e2853010 	add	r3, r5, #16	; 0x10
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
33d104d0:	e5932004 	ldr	r2, [r3, #4]
	next->prev = new;
	new->next = next;
33d104d4:	e5843000 	str	r3, [r4]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d104d8:	e5834004 	str	r4, [r3, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
33d104dc:	e5824000 	str	r4, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
33d104e0:	e5842004 	str	r2, [r4, #4]
			return 0;
		}
	}

	list_add_tail(&part->link, &dev->parts);
	dev->num_parts++;
33d104e4:	e1d530bc 	ldrh	r3, [r5, #12]
33d104e8:	e2833001 	add	r3, r3, #1	; 0x1
33d104ec:	e1c530bc 	strh	r3, [r5, #12]
	index_partitions();
33d104f0:	ebfffe95 	bl	33d0ff4c <index_partitions>
	return 0;
33d104f4:	e3a00000 	mov	r0, #0	; 0x0
}
33d104f8:	e8bd8070 	pop	{r4, r5, r6, pc}
33d104fc:	33d293c0 	.word	0x33d293c0
33d10500:	33d608d8 	.word	0x33d608d8
33d10504:	33d608dc 	.word	0x33d608dc

33d10508 <device_delall>:
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 */
static int device_delall(struct list_head *head)
{
33d10508:	e92d4070 	push	{r4, r5, r6, lr}
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
33d1050c:	e5904000 	ldr	r4, [r0]
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 */
static int device_delall(struct list_head *head)
{
33d10510:	e1a05000 	mov	r5, r0
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
33d10514:	e1540005 	cmp	r4, r5
33d10518:	e5946000 	ldr	r6, [r4]
33d1051c:	0a00000b 	beq	33d10550 <device_delall+0x48>
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d10520:	e894000c 	ldm	r4, {r2, r3}
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10524:	e3a01000 	mov	r1, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d10528:	e5832000 	str	r2, [r3]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d1052c:	e5823004 	str	r3, [r2, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10530:	e5841000 	str	r1, [r4]
	entry->prev = (void *) 0;
33d10534:	e5841004 	str	r1, [r4, #4]
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
33d10538:	e2840010 	add	r0, r4, #16	; 0x10
33d1053c:	ebffff69 	bl	33d102e8 <part_delall>
		free(dev_tmp);
33d10540:	e1a00004 	mov	r0, r4
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
33d10544:	e1a04006 	mov	r4, r6
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
		free(dev_tmp);
33d10548:	eb001bc1 	bl	33d17454 <free>
33d1054c:	eafffff0 	b	33d10514 <device_delall+0xc>
	}
	INIT_LIST_HEAD(&devices);
33d10550:	e59f300c 	ldr	r3, [pc, #12]	; 33d10564 <device_delall+0x5c>

	return 0;
}
33d10554:	e3a00000 	mov	r0, #0	; 0x0
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
		free(dev_tmp);
	}
	INIT_LIST_HEAD(&devices);
33d10558:	e5833004 	str	r3, [r3, #4]
33d1055c:	e5833000 	str	r3, [r3]

	return 0;
}
33d10560:	e8bd8070 	pop	{r4, r5, r6, pc}
33d10564:	33d608d0 	.word	0x33d608d0

33d10568 <device_find>:
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 */
static struct mtd_device* device_find(u8 type, u8 num)
{
33d10568:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
33d1056c:	e59fe048 	ldr	lr, [pc, #72]	; 33d105bc <device_find+0x54>
33d10570:	e59e2000 	ldr	r2, [lr]
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 */
static struct mtd_device* device_find(u8 type, u8 num)
{
33d10574:	e20000ff 	and	r0, r0, #255	; 0xff
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d10578:	e152000e 	cmp	r2, lr
33d1057c:	e20110ff 	and	r1, r1, #255	; 0xff
33d10580:	0a00000b 	beq	33d105b4 <device_find+0x4c>
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
		dev_tmp = list_entry(entry, struct mtd_device, link);

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
33d10584:	e592c008 	ldr	ip, [r2, #8]
33d10588:	e5dc3008 	ldrb	r3, [ip, #8]
33d1058c:	e1530000 	cmp	r3, r0
33d10590:	1a000004 	bne	33d105a8 <device_find+0x40>
33d10594:	e5dc3009 	ldrb	r3, [ip, #9]
33d10598:	e1530001 	cmp	r3, r1
33d1059c:	1a000001 	bne	33d105a8 <device_find+0x40>
			return dev_tmp;
33d105a0:	e1a00002 	mov	r0, r2
33d105a4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
static struct mtd_device* device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
33d105a8:	e5922000 	ldr	r2, [r2]
33d105ac:	e152000e 	cmp	r2, lr
33d105b0:	eafffff2 	b	33d10580 <device_find+0x18>

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
			return dev_tmp;
	}

	return NULL;
33d105b4:	e3a00000 	mov	r0, #0	; 0x0
}
33d105b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d105bc:	33d608d0 	.word	0x33d608d0

33d105c0 <devices_init>:
 * @return 0 on success, 1 otherwise
 */
static int devices_init(void)
{
	last_parts[0] = '\0';
	current_dev = NULL;
33d105c0:	e59f2020 	ldr	r2, [pc, #32]	; 33d105e8 <devices_init+0x28>
 *
 * @return 0 on success, 1 otherwise
 */
static int devices_init(void)
{
	last_parts[0] = '\0';
33d105c4:	e3a03000 	mov	r3, #0	; 0x0
 * Initialize global device list.
 *
 * @return 0 on success, 1 otherwise
 */
static int devices_init(void)
{
33d105c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	last_parts[0] = '\0';
	current_dev = NULL;
33d105cc:	e5823000 	str	r3, [r2]
 *
 * @return 0 on success, 1 otherwise
 */
static int devices_init(void)
{
	last_parts[0] = '\0';
33d105d0:	e59f2014 	ldr	r2, [pc, #20]	; 33d105ec <devices_init+0x2c>
33d105d4:	e5c23000 	strb	r3, [r2]
	current_dev = NULL;
	current_save();
33d105d8:	ebfffe92 	bl	33d10028 <current_save>

	return device_delall(&devices);
33d105dc:	e59f000c 	ldr	r0, [pc, #12]	; 33d105f0 <devices_init+0x30>
}
33d105e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
{
	last_parts[0] = '\0';
	current_dev = NULL;
	current_save();

	return device_delall(&devices);
33d105e4:	eaffffc7 	b	33d10508 <device_delall>
33d105e8:	33d608d8 	.word	0x33d608d8
33d105ec:	33d60964 	.word	0x33d60964
33d105f0:	33d608d0 	.word	0x33d608d0

33d105f4 <device_parse>:
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
33d105f4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u16 num_parts;
	u32 offset;
	int err = 1;

	p = mtd_dev;
	*retdev = NULL;
33d105f8:	e3a03000 	mov	r3, #0	; 0x0
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
33d105fc:	e24dd028 	sub	sp, sp, #40	; 0x28
33d10600:	e58d1010 	str	r1, [sp, #16]
33d10604:	e58d200c 	str	r2, [sp, #12]
	u16 num_parts;
	u32 offset;
	int err = 1;

	p = mtd_dev;
	*retdev = NULL;
33d10608:	e5823000 	str	r3, [r2]
	*ret = NULL;
33d1060c:	e5813000 	str	r3, [r1]
	struct part_info *part;
	struct mtdids *id;
	const char *mtd_id;
	unsigned int mtd_id_len;
	const char *p, *pend;
	LIST_HEAD(tmp_list);
33d10610:	e28d2020 	add	r2, sp, #32	; 0x20

	DEBUGF("===device_parse===\n");

	/* fetch <mtd-id> */
	mtd_id = p;
	if (!(p = strchr(mtd_id, ':'))) {
33d10614:	e3a0103a 	mov	r1, #58	; 0x3a
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
33d10618:	e1a06000 	mov	r6, r0
	struct part_info *part;
	struct mtdids *id;
	const char *mtd_id;
	unsigned int mtd_id_len;
	const char *p, *pend;
	LIST_HEAD(tmp_list);
33d1061c:	e58d2020 	str	r2, [sp, #32]
33d10620:	e58d2024 	str	r2, [sp, #36]
	struct list_head *entry, *n;
	u16 num_parts;
	u32 offset;
	int err = 1;

	p = mtd_dev;
33d10624:	e58d001c 	str	r0, [sp, #28]

	DEBUGF("===device_parse===\n");

	/* fetch <mtd-id> */
	mtd_id = p;
	if (!(p = strchr(mtd_id, ':'))) {
33d10628:	eb0026ac 	bl	33d1a0e0 <strchr>
33d1062c:	e3500000 	cmp	r0, #0	; 0x0
33d10630:	e58d001c 	str	r0, [sp, #28]
		printf("no <mtd-id> identifier\n");
33d10634:	059f04a4 	ldreq	r0, [pc, #1188]	; 33d10ae0 <device_parse+0x4ec>

	DEBUGF("===device_parse===\n");

	/* fetch <mtd-id> */
	mtd_id = p;
	if (!(p = strchr(mtd_id, ':'))) {
33d10638:	0a0000fe 	beq	33d10a38 <device_parse+0x444>
	struct mtdids *id;

	DEBUGF("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
33d1063c:	e59f74a0 	ldr	r7, [pc, #1184]	; 33d10ae4 <device_parse+0x4f0>
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
	p++;
33d10640:	e2803001 	add	r3, r0, #1	; 0x1
	struct mtdids *id;

	DEBUGF("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
33d10644:	e5974000 	ldr	r4, [r7]
	mtd_id = p;
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
33d10648:	e0665000 	rsb	r5, r6, r0
	p++;
33d1064c:	e58d301c 	str	r3, [sp, #28]
33d10650:	e1540007 	cmp	r4, r7
	mtd_id = p;
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
33d10654:	e285b001 	add	fp, r5, #1	; 0x1
33d10658:	0a00000e 	beq	33d10698 <device_parse+0xa4>
		id = list_entry(entry, struct mtdids, link);

		DEBUGF("entry: '%s' (len = %d)\n",
				id->mtd_id, strlen(id->mtd_id));

		if (mtd_id_len != strlen(id->mtd_id))
33d1065c:	e5940010 	ldr	r0, [r4, #16]
33d10660:	eb0026aa 	bl	33d1a110 <strlen>
33d10664:	e1550000 	cmp	r5, r0
			continue;
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
33d10668:	e1a01006 	mov	r1, r6
33d1066c:	e1a02005 	mov	r2, r5
		id = list_entry(entry, struct mtdids, link);

		DEBUGF("entry: '%s' (len = %d)\n",
				id->mtd_id, strlen(id->mtd_id));

		if (mtd_id_len != strlen(id->mtd_id))
33d10670:	1a000003 	bne	33d10684 <device_parse+0x90>
			continue;
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
33d10674:	e5940010 	ldr	r0, [r4, #16]
33d10678:	eb002686 	bl	33d1a098 <strncmp>
33d1067c:	e250a000 	subs	sl, r0, #0	; 0x0
33d10680:	0a000002 	beq	33d10690 <device_parse+0x9c>
	struct mtdids *id;

	DEBUGF("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
33d10684:	e5944000 	ldr	r4, [r4]
33d10688:	e1540007 	cmp	r4, r7
33d1068c:	eafffff1 	b	33d10658 <device_parse+0x64>
 * @param mtd_id string containing requested mtd_id
 * @param mtd_id_len length of supplied mtd_id
 * @return pointer to the id if it exists, NULL otherwise
 */
static struct mtdids* id_find_by_mtd_id(const char *mtd_id, unsigned int mtd_id_len)
{
33d10690:	e2549000 	subs	r9, r4, #0	; 0x0
33d10694:	1a000004 	bne	33d106ac <device_parse+0xb8>
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
		printf("invalid mtd device '%.*s'\n", mtd_id_len - 1, mtd_id);
33d10698:	e24b1001 	sub	r1, fp, #1	; 0x1
33d1069c:	e1a02006 	mov	r2, r6
33d106a0:	e59f0440 	ldr	r0, [pc, #1088]	; 33d10ae8 <device_parse+0x4f4>
33d106a4:	eb001a47 	bl	33d16fc8 <printf>
33d106a8:	ea0000e6 	b	33d10a48 <device_parse+0x454>
	}

	DEBUGF("dev type = %d (%s), dev num = %d, mtd-id = %s\n",
			id->type, MTD_DEV_TYPE(id->type),
			id->num, id->mtd_id);
	pend = strchr(p, ';');
33d106ac:	e3a0103b 	mov	r1, #59	; 0x3b
33d106b0:	e59d001c 	ldr	r0, [sp, #28]
33d106b4:	eb002689 	bl	33d1a0e0 <strchr>

	/* parse partitions */
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
33d106b8:	e5d91009 	ldrb	r1, [r9, #9]
33d106bc:	e5d90008 	ldrb	r0, [r9, #8]
33d106c0:	ebffffa8 	bl	33d10568 <device_find>


	/* parse partitions */
	num_parts = 0;

	offset = 0;
33d106c4:	e58da004 	str	sl, [sp, #4]
	pend = strchr(p, ';');
	DEBUGF("parsing partitions %.*s\n", (pend ? pend - p : strlen(p)), p);


	/* parse partitions */
	num_parts = 0;
33d106c8:	e58da008 	str	sl, [sp, #8]

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
33d106cc:	e2504000 	subs	r4, r0, #0	; 0x0
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
33d106d0:	15943014 	ldrne	r3, [r4, #20]
33d106d4:	158d3018 	strne	r3, [sp, #24]
		offset += part->size;

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
33d106d8:	e59d001c 	ldr	r0, [sp, #28]

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
		offset = part->offset + part->size;
33d106dc:	12832014 	addne	r2, r3, #20	; 0x14
33d106e0:	18120006 	ldmdane	r2, {r1, r2}
33d106e4:	10821001 	addne	r1, r2, r1
33d106e8:	158d1004 	strne	r1, [sp, #4]
		offset += part->size;

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
33d106ec:	e3500000 	cmp	r0, #0	; 0x0
33d106f0:	0a0000a6 	beq	33d10990 <device_parse+0x39c>
33d106f4:	e5d03000 	ldrb	r3, [r0]
33d106f8:	e3530000 	cmp	r3, #0	; 0x0
33d106fc:	0a0000a3 	beq	33d10990 <device_parse+0x39c>
33d10700:	e353003b 	cmp	r3, #59	; 0x3b
33d10704:	0a0000a1 	beq	33d10990 <device_parse+0x39c>
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
	*retpart = NULL;
33d10708:	e3a03000 	mov	r3, #0	; 0x0
	const char *name;
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
33d1070c:	e58d0014 	str	r0, [sp, #20]
	*retpart = NULL;
	*ret = NULL;
33d10710:	e58d301c 	str	r3, [sp, #28]
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
	*retpart = NULL;
33d10714:	e58d3018 	str	r3, [sp, #24]
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
33d10718:	e5d03000 	ldrb	r3, [r0]
33d1071c:	e353002d 	cmp	r3, #45	; 0x2d
		/* assign all remaining space to this partition */
		DEBUGF("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
33d10720:	02803001 	addeq	r3, r0, #1	; 0x1
 * @param ret output pointer to next char after parse completes (output)
 * @param retpart pointer to the allocated partition (output)
 * @return 0 on success, 1 otherwise
 */
static int part_parse(const char *const partdef, const char **ret, struct part_info **retpart)
{
33d10724:	e28d501c 	add	r5, sp, #28	; 0x1c

	/* fetch the partition size */
	if (*p == '-') {
		/* assign all remaining space to this partition */
		DEBUGF("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
33d10728:	03e0a000 	mvneq	sl, #0	; 0x0
		p++;
33d1072c:	058d3014 	streq	r3, [sp, #20]
	p = partdef;
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
33d10730:	0a000008 	beq	33d10758 <device_parse+0x164>
		/* assign all remaining space to this partition */
		DEBUGF("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
33d10734:	e28d1014 	add	r1, sp, #20	; 0x14
33d10738:	ebfffda5 	bl	33d0fdd4 <memsize_parse>
		if (size < MIN_PART_SIZE) {
33d1073c:	e3500a01 	cmp	r0, #4096	; 0x1000
		/* assign all remaining space to this partition */
		DEBUGF("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
33d10740:	e1a0a000 	mov	sl, r0
		if (size < MIN_PART_SIZE) {
33d10744:	2a000003 	bcs	33d10758 <device_parse+0x164>
			printf("partition size too small (%lx)\n", size);
33d10748:	e1a01000 	mov	r1, r0
33d1074c:	e59f0398 	ldr	r0, [pc, #920]	; 33d10aec <device_parse+0x4f8>
33d10750:	eb001a1c 	bl	33d16fc8 <printf>
33d10754:	ea00008d 	b	33d10990 <device_parse+0x39c>
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
33d10758:	e59d2014 	ldr	r2, [sp, #20]
33d1075c:	e5d23000 	ldrb	r3, [r2]
33d10760:	e3530040 	cmp	r3, #64	; 0x40
			return 1;
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
33d10764:	e3e0b000 	mvn	fp, #0	; 0x0
	if (*p == '@') {
33d10768:	1a000005 	bne	33d10784 <device_parse+0x190>
		p++;
33d1076c:	e2823001 	add	r3, r2, #1	; 0x1
		offset = memsize_parse(p, &p);
33d10770:	e1a00003 	mov	r0, r3
33d10774:	e28d1014 	add	r1, sp, #20	; 0x14
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
		p++;
33d10778:	e58d3014 	str	r3, [sp, #20]
		offset = memsize_parse(p, &p);
33d1077c:	ebfffd94 	bl	33d0fdd4 <memsize_parse>
33d10780:	e1a0b000 	mov	fp, r0
	}

	/* now look for the name */
	if (*p == '(') {
33d10784:	e59d2014 	ldr	r2, [sp, #20]
33d10788:	e5d23000 	ldrb	r3, [r2]
33d1078c:	e3530028 	cmp	r3, #40	; 0x28
			return 1;
		}
		p++;
	} else {
		/* 0x00000000@0x00000000 */
		name_len = 22;
33d10790:	13a07016 	movne	r7, #22	; 0x16
		name = NULL;
33d10794:	13a06000 	movne	r6, #0	; 0x0
		p++;
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
33d10798:	1a000010 	bne	33d107e0 <device_parse+0x1ec>
		name = ++p;
33d1079c:	e2823001 	add	r3, r2, #1	; 0x1
		if ((p = strchr(name, ')')) == NULL) {
33d107a0:	e1a00003 	mov	r0, r3
33d107a4:	e3a01029 	mov	r1, #41	; 0x29
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
		name = ++p;
33d107a8:	e1a06003 	mov	r6, r3
33d107ac:	e58d3014 	str	r3, [sp, #20]
		if ((p = strchr(name, ')')) == NULL) {
33d107b0:	eb00264a 	bl	33d1a0e0 <strchr>
33d107b4:	e3500000 	cmp	r0, #0	; 0x0
33d107b8:	e58d0014 	str	r0, [sp, #20]
			printf("no closing ) found in partition name\n");
33d107bc:	059f032c 	ldreq	r0, [pc, #812]	; 33d10af0 <device_parse+0x4fc>
33d107c0:	0a00002f 	beq	33d10884 <device_parse+0x290>
			return 1;
		}
		name_len = p - name + 1;
33d107c4:	e0663000 	rsb	r3, r6, r0
33d107c8:	e2837001 	add	r7, r3, #1	; 0x1
		if ((name_len - 1) == 0) {
33d107cc:	e3570001 	cmp	r7, #1	; 0x1
			printf("empty partition name\n");
33d107d0:	059f031c 	ldreq	r0, [pc, #796]	; 33d10af4 <device_parse+0x500>
33d107d4:	0a00002a 	beq	33d10884 <device_parse+0x290>
			return 1;
		}
		p++;
33d107d8:	e2803001 	add	r3, r0, #1	; 0x1
33d107dc:	e58d3014 	str	r3, [sp, #20]
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
33d107e0:	e59f1310 	ldr	r1, [pc, #784]	; 33d10af8 <device_parse+0x504>
33d107e4:	e59d0014 	ldr	r0, [sp, #20]
33d107e8:	e3a02002 	mov	r2, #2	; 0x2
33d107ec:	eb002629 	bl	33d1a098 <strncmp>
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
33d107f0:	e3a03000 	mov	r3, #0	; 0x0
	if (strncmp(p, "ro", 2) == 0) {
33d107f4:	e3500000 	cmp	r0, #0	; 0x0
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
33d107f8:	e58d3000 	str	r3, [sp]
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
33d107fc:	059d3014 	ldreq	r3, [sp, #20]
33d10800:	02833002 	addeq	r3, r3, #2	; 0x2
33d10804:	058d3014 	streq	r3, [sp, #20]
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
33d10808:	03a01001 	moveq	r1, #1	; 0x1
33d1080c:	058d1000 	streq	r1, [sp]
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
33d10810:	e59d3014 	ldr	r3, [sp, #20]
33d10814:	e5d31000 	ldrb	r1, [r3]
33d10818:	e351002c 	cmp	r1, #44	; 0x2c
33d1081c:	1a000008 	bne	33d10844 <device_parse+0x250>
		if (size == SIZE_REMAINING) {
33d10820:	e37a0001 	cmn	sl, #1	; 0x1
			*ret = NULL;
			printf("no partitions allowed after a fill-up partition\n");
33d10824:	059f02d0 	ldreq	r0, [pc, #720]	; 33d10afc <device_parse+0x508>
	}

	/* check for next partition definition */
	if (*p == ',') {
		if (size == SIZE_REMAINING) {
			*ret = NULL;
33d10828:	03a03000 	moveq	r3, #0	; 0x0
33d1082c:	05853000 	streq	r3, [r5]
33d10830:	0a000013 	beq	33d10884 <device_parse+0x290>
			printf("no partitions allowed after a fill-up partition\n");
			return 1;
		}
		*ret = ++p;
33d10834:	e2833001 	add	r3, r3, #1	; 0x1
33d10838:	e5853000 	str	r3, [r5]
33d1083c:	e58d3014 	str	r3, [sp, #20]
33d10840:	ea000009 	b	33d1086c <device_parse+0x278>
	} else if ((*p == ';') || (*p == '\0')) {
33d10844:	e3510000 	cmp	r1, #0	; 0x0
33d10848:	1351003b 	cmpne	r1, #59	; 0x3b
33d1084c:	13a04000 	movne	r4, #0	; 0x0
33d10850:	03a04001 	moveq	r4, #1	; 0x1
		*ret = p;
33d10854:	05853000 	streq	r3, [r5]
33d10858:	0a000003 	beq	33d1086c <device_parse+0x278>
	} else {
		printf("unexpected character '%c' at the end of partition\n", *p);
33d1085c:	e59f029c 	ldr	r0, [pc, #668]	; 33d10b00 <device_parse+0x50c>
33d10860:	eb0019d8 	bl	33d16fc8 <printf>
		*ret = NULL;
33d10864:	e5854000 	str	r4, [r5]
33d10868:	ea000048 	b	33d10990 <device_parse+0x39c>
		return 1;
	}

	/*  allocate memory */
	part = (struct part_info *)malloc(sizeof(struct part_info) + name_len);
33d1086c:	e2875024 	add	r5, r7, #36	; 0x24
33d10870:	e1a00005 	mov	r0, r5
33d10874:	eb001b7b 	bl	33d17668 <malloc>
	if (!part) {
33d10878:	e2504000 	subs	r4, r0, #0	; 0x0
33d1087c:	1a000002 	bne	33d1088c <device_parse+0x298>
		printf("out of memory\n");
33d10880:	e59f027c 	ldr	r0, [pc, #636]	; 33d10b04 <device_parse+0x510>
33d10884:	eb0019cf 	bl	33d16fc8 <printf>
33d10888:	ea000040 	b	33d10990 <device_parse+0x39c>
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
33d1088c:	e1a02005 	mov	r2, r5
33d10890:	e3a01000 	mov	r1, #0	; 0x0
33d10894:	eb0026be 	bl	33d1a394 <memset>
	part->size = size;
	part->offset = offset;
	part->mask_flags = mask_flags;
33d10898:	e59d2000 	ldr	r2, [sp]
	part->name = (char *)(part + 1);
33d1089c:	e2840024 	add	r0, r4, #36	; 0x24

	if (name) {
33d108a0:	e3560000 	cmp	r6, #0	; 0x0
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
	part->size = size;
	part->offset = offset;
	part->mask_flags = mask_flags;
33d108a4:	e584201c 	str	r2, [r4, #28]
	if (!part) {
		printf("out of memory\n");
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
	part->size = size;
33d108a8:	e584a010 	str	sl, [r4, #16]
	part->offset = offset;
33d108ac:	e584b014 	str	fp, [r4, #20]
	part->mask_flags = mask_flags;
	part->name = (char *)(part + 1);
33d108b0:	e5840008 	str	r0, [r4, #8]

	if (name) {
33d108b4:	0a000004 	beq	33d108cc <device_parse+0x2d8>
		/* copy user provided name */
		strncpy(part->name, name, name_len - 1);
33d108b8:	e1a01006 	mov	r1, r6
33d108bc:	e2472001 	sub	r2, r7, #1	; 0x1
33d108c0:	eb0025c4 	bl	33d19fd8 <strncpy>
		part->auto_name = 0;
33d108c4:	e3a03000 	mov	r3, #0	; 0x0
33d108c8:	ea000004 	b	33d108e0 <device_parse+0x2ec>
	} else {
		/* auto generated name in form of size@offset */
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
33d108cc:	e1a0300b 	mov	r3, fp
33d108d0:	e1a0200a 	mov	r2, sl
33d108d4:	e59f122c 	ldr	r1, [pc, #556]	; 33d10b08 <device_parse+0x514>
33d108d8:	eb002905 	bl	33d1acf4 <sprintf>
		part->auto_name = 1;
33d108dc:	e3a03001 	mov	r3, #1	; 0x1
33d108e0:	e5c4300c 	strb	r3, [r4, #12]
	}

	part->name[name_len - 1] = '\0';
33d108e4:	e5943008 	ldr	r3, [r4, #8]
33d108e8:	e3a02000 	mov	r2, #0	; 0x0
33d108ec:	e0833007 	add	r3, r3, r7
 * @param ret output pointer to next char after parse completes (output)
 * @param retpart pointer to the allocated partition (output)
 * @return 0 on success, 1 otherwise
 */
static int part_parse(const char *const partdef, const char **ret, struct part_info **retpart)
{
33d108f0:	e1540002 	cmp	r4, r2
		/* auto generated name in form of size@offset */
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
		part->auto_name = 1;
	}

	part->name[name_len - 1] = '\0';
33d108f4:	e5432001 	strb	r2, [r3, #-1]
	INIT_LIST_HEAD(&part->link);
33d108f8:	e5844000 	str	r4, [r4]
33d108fc:	e5844004 	str	r4, [r4, #4]

	DEBUGF("+ partition: name %-22s size 0x%08x offset 0x%08x mask flags %d\n",
			part->name, part->size,
			part->offset, part->mask_flags);

	*retpart = part;
33d10900:	e58d4018 	str	r4, [sp, #24]
 * @param ret output pointer to next char after parse completes (output)
 * @param retpart pointer to the allocated partition (output)
 * @return 0 on success, 1 otherwise
 */
static int part_parse(const char *const partdef, const char **ret, struct part_info **retpart)
{
33d10904:	0a000021 	beq	33d10990 <device_parse+0x39c>
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
33d10908:	e5942014 	ldr	r2, [r4, #20]
33d1090c:	e3720001 	cmn	r2, #1	; 0x1
			part->offset = offset;
33d10910:	059d1004 	ldreq	r1, [sp, #4]
33d10914:	05841014 	streq	r1, [r4, #20]
		else
			offset = part->offset;

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
33d10918:	e1a00009 	mov	r0, r9
33d1091c:	e59d1018 	ldr	r1, [sp, #24]

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
			part->offset = offset;
		else
			offset = part->offset;
33d10920:	158d2004 	strne	r2, [sp, #4]

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
33d10924:	ebfffdea 	bl	33d100d4 <part_validate>
33d10928:	e3500000 	cmp	r0, #0	; 0x0
33d1092c:	1a000017 	bne	33d10990 <device_parse+0x39c>
			break;

		offset += part->size;
33d10930:	e59d3018 	ldr	r3, [sp, #24]
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
33d10934:	e59d2024 	ldr	r2, [sp, #36]
	next->prev = new;
	new->next = next;
33d10938:	e28d1020 	add	r1, sp, #32	; 0x20
33d1093c:	e5831000 	str	r1, [r3]
33d10940:	e5931010 	ldr	r1, [r3, #16]
	new->prev = prev;
	prev->next = new;
33d10944:	e5823000 	str	r3, [r2]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d10948:	e58d3024 	str	r3, [sp, #36]
	new->next = next;
	new->prev = prev;
33d1094c:	e5832004 	str	r2, [r3, #4]

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
33d10950:	e59d2008 	ldr	r2, [sp, #8]
		err = 0;
33d10954:	e59d001c 	ldr	r0, [sp, #28]

		offset += part->size;

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
33d10958:	e2823001 	add	r3, r2, #1	; 0x1

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
			break;

		offset += part->size;
33d1095c:	e59d2004 	ldr	r2, [sp, #4]

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
33d10960:	e1a03803 	lsl	r3, r3, #16

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
			break;

		offset += part->size;
33d10964:	e0822001 	add	r2, r2, r1

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
33d10968:	e1a03823 	lsr	r3, r3, #16
		err = 0;
33d1096c:	e3500000 	cmp	r0, #0	; 0x0

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
			break;

		offset += part->size;
33d10970:	e98d000c 	stmib	sp, {r2, r3}

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
33d10974:	0a000008 	beq	33d1099c <device_parse+0x3a8>
33d10978:	e5d03000 	ldrb	r3, [r0]
33d1097c:	e3530000 	cmp	r3, #0	; 0x0
33d10980:	0a000005 	beq	33d1099c <device_parse+0x3a8>
33d10984:	e353003b 	cmp	r3, #59	; 0x3b
33d10988:	1affff5e 	bne	33d10708 <device_parse+0x114>
33d1098c:	ea000002 	b	33d1099c <device_parse+0x3a8>
	}
	if (err == 1) {
		part_delall(&tmp_list);
33d10990:	e28d0020 	add	r0, sp, #32	; 0x20
33d10994:	ebfffe53 	bl	33d102e8 <part_delall>
33d10998:	ea00002a 	b	33d10a48 <device_parse+0x454>
		return 1;
	}

	if (num_parts == 0) {
33d1099c:	e59d3008 	ldr	r3, [sp, #8]
33d109a0:	e3530000 	cmp	r3, #0	; 0x0
33d109a4:	1a000009 	bne	33d109d0 <device_parse+0x3dc>
		printf("no partitions for device %s%d (%s)\n",
33d109a8:	e5d92008 	ldrb	r2, [r9, #8]
33d109ac:	e59f3158 	ldr	r3, [pc, #344]	; 33d10b0c <device_parse+0x518>
33d109b0:	e3520002 	cmp	r2, #2	; 0x2
33d109b4:	e59f1154 	ldr	r1, [pc, #340]	; 33d10b10 <device_parse+0x51c>
33d109b8:	e59f0154 	ldr	r0, [pc, #340]	; 33d10b14 <device_parse+0x520>
33d109bc:	11a01003 	movne	r1, r3
33d109c0:	e5d92009 	ldrb	r2, [r9, #9]
33d109c4:	e5993010 	ldr	r3, [r9, #16]
33d109c8:	eb00197e 	bl	33d16fc8 <printf>
33d109cc:	ea00001d 	b	33d10a48 <device_parse+0x454>
	}

	DEBUGF("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
33d109d0:	e59d301c 	ldr	r3, [sp, #28]
33d109d4:	e3530000 	cmp	r3, #0	; 0x0
33d109d8:	0a000011 	beq	33d10a24 <device_parse+0x430>
		if (*p == ';') {
33d109dc:	e5d31000 	ldrb	r1, [r3]
33d109e0:	e351003b 	cmp	r1, #59	; 0x3b
			*ret = ++p;
33d109e4:	059d1010 	ldreq	r1, [sp, #16]
33d109e8:	02833001 	addeq	r3, r3, #1	; 0x1
33d109ec:	05813000 	streq	r3, [r1]
33d109f0:	058d301c 	streq	r3, [sp, #28]

	DEBUGF("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
		if (*p == ';') {
33d109f4:	0a00000a 	beq	33d10a24 <device_parse+0x430>
			*ret = ++p;
		} else if (*p == '\0') {
33d109f8:	e3510000 	cmp	r1, #0	; 0x0
			*ret = p;
33d109fc:	059d2010 	ldreq	r2, [sp, #16]
33d10a00:	05823000 	streq	r3, [r2]

	/* check for next device presence */
	if (p) {
		if (*p == ';') {
			*ret = ++p;
		} else if (*p == '\0') {
33d10a04:	0a000006 	beq	33d10a24 <device_parse+0x430>
			*ret = p;
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
33d10a08:	e59f0108 	ldr	r0, [pc, #264]	; 33d10b18 <device_parse+0x524>
33d10a0c:	eb00196d 	bl	33d16fc8 <printf>
			*ret = NULL;
33d10a10:	e59d1010 	ldr	r1, [sp, #16]
33d10a14:	e3a03000 	mov	r3, #0	; 0x0
			return 1;
33d10a18:	e3a00001 	mov	r0, #1	; 0x1
			*ret = ++p;
		} else if (*p == '\0') {
			*ret = p;
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
			*ret = NULL;
33d10a1c:	e5813000 	str	r3, [r1]
			return 1;
33d10a20:	ea00002c 	b	33d10ad8 <device_parse+0x4e4>
		}
	}

	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
33d10a24:	e3a00018 	mov	r0, #24	; 0x18
33d10a28:	eb001b0e 	bl	33d17668 <malloc>
33d10a2c:	e2504000 	subs	r4, r0, #0	; 0x0
33d10a30:	1a000006 	bne	33d10a50 <device_parse+0x45c>
		printf("out of memory\n");
33d10a34:	e59f00c8 	ldr	r0, [pc, #200]	; 33d10b04 <device_parse+0x510>
33d10a38:	eb001962 	bl	33d16fc8 <printf>
33d10a3c:	ea000001 	b	33d10a48 <device_parse+0x454>
	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
		part = list_entry(entry, struct part_info, link);
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
			device_del(dev);
33d10a40:	e1a00004 	mov	r0, r4
33d10a44:	ebfffe39 	bl	33d10330 <device_del>
			return 1;
33d10a48:	e3a00001 	mov	r0, #1	; 0x1
33d10a4c:	ea000021 	b	33d10ad8 <device_parse+0x4e4>
	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
33d10a50:	e3a02018 	mov	r2, #24	; 0x18
33d10a54:	e3a01000 	mov	r1, #0	; 0x0
33d10a58:	eb00264d 	bl	33d1a394 <memset>
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
33d10a5c:	e2843010 	add	r3, r4, #16	; 0x10
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
33d10a60:	e3a02000 	mov	r2, #0	; 0x0
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
33d10a64:	e5849008 	str	r9, [r4, #8]
	dev->num_parts = 0; /* part_sort_add increments num_parts */
33d10a68:	e1c420bc 	strh	r2, [r4, #12]
	INIT_LIST_HEAD(&dev->parts);
33d10a6c:	e5843010 	str	r3, [r4, #16]
	INIT_LIST_HEAD(&dev->link);
33d10a70:	e5844000 	str	r4, [r4]

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
33d10a74:	e59dc020 	ldr	ip, [sp, #32]
33d10a78:	e28d6020 	add	r6, sp, #32	; 0x20
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
33d10a7c:	e5833004 	str	r3, [r3, #4]
	INIT_LIST_HEAD(&dev->link);
33d10a80:	e5844004 	str	r4, [r4, #4]

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
33d10a84:	e15c0006 	cmp	ip, r6
33d10a88:	e59c5000 	ldr	r5, [ip]
33d10a8c:	0a00000e 	beq	33d10acc <device_parse+0x4d8>
		part = list_entry(entry, struct part_info, link);
33d10a90:	e58dc018 	str	ip, [sp, #24]
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d10a94:	e89c000c 	ldm	ip, {r2, r3}
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10a98:	e3a01000 	mov	r1, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d10a9c:	e5832000 	str	r2, [r3]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d10aa0:	e5823004 	str	r3, [r2, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d10aa4:	e58c1000 	str	r1, [ip]
	entry->prev = (void *) 0;
33d10aa8:	e58c1004 	str	r1, [ip, #4]
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
33d10aac:	e1a00004 	mov	r0, r4
33d10ab0:	e59d1018 	ldr	r1, [sp, #24]
33d10ab4:	ebfffe40 	bl	33d103bc <part_sort_add>
33d10ab8:	e3500000 	cmp	r0, #0	; 0x0
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
33d10abc:	e1a0c005 	mov	ip, r5
		part = list_entry(entry, struct part_info, link);
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
33d10ac0:	1affffde 	bne	33d10a40 <device_parse+0x44c>
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
33d10ac4:	e1550006 	cmp	r5, r6
33d10ac8:	eaffffee 	b	33d10a88 <device_parse+0x494>
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
33d10acc:	e59d300c 	ldr	r3, [sp, #12]
33d10ad0:	e5834000 	str	r4, [r3]

	DEBUGF("===\n\n");
	return 0;
33d10ad4:	e3a00000 	mov	r0, #0	; 0x0
}
33d10ad8:	e28dd028 	add	sp, sp, #40	; 0x28
33d10adc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d10ae0:	33d296ac 	.word	0x33d296ac
33d10ae4:	33d608c8 	.word	0x33d608c8
33d10ae8:	33d293ec 	.word	0x33d293ec
33d10aec:	33d29408 	.word	0x33d29408
33d10af0:	33d29428 	.word	0x33d29428
33d10af4:	33d29450 	.word	0x33d29450
33d10af8:	33d29468 	.word	0x33d29468
33d10afc:	33d2946c 	.word	0x33d2946c
33d10b00:	33d294a0 	.word	0x33d294a0
33d10b04:	33d294d4 	.word	0x33d294d4
33d10b08:	33d294e4 	.word	0x33d294e4
33d10b0c:	33d29274 	.word	0x33d29274
33d10b10:	33d29278 	.word	0x33d29278
33d10b14:	33d294f4 	.word	0x33d294f4
33d10b18:	33d29518 	.word	0x33d29518

33d10b1c <id_parse>:
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
33d10b1c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d10b20:	e1a04002 	mov	r4, r2
	const char *p = id;

	*dev_type = 0;
33d10b24:	e3a02000 	mov	r2, #0	; 0x0
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
33d10b28:	e24dd004 	sub	sp, sp, #4	; 0x4
	const char *p = id;

	*dev_type = 0;
33d10b2c:	e5c42000 	strb	r2, [r4]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
33d10b30:	e1a06001 	mov	r6, r1
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
33d10b34:	e2822004 	add	r2, r2, #4	; 0x4
33d10b38:	e59f10b4 	ldr	r1, [pc, #180]	; 33d10bf4 <id_parse+0xd8>
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
33d10b3c:	e1a07003 	mov	r7, r3
33d10b40:	e1a05000 	mov	r5, r0
	const char *p = id;
33d10b44:	e58d0000 	str	r0, [sp]

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
33d10b48:	eb002552 	bl	33d1a098 <strncmp>
33d10b4c:	e3500000 	cmp	r0, #0	; 0x0
33d10b50:	e59d0000 	ldr	r0, [sp]
		*dev_type = MTD_DEV_TYPE_NAND;
33d10b54:	03a03002 	moveq	r3, #2	; 0x2
		p += 4;
33d10b58:	02802004 	addeq	r2, r0, #4	; 0x4
{
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
		*dev_type = MTD_DEV_TYPE_NAND;
33d10b5c:	05c43000 	strbeq	r3, [r4]
		p += 4;
33d10b60:	058d2000 	streq	r2, [sp]
int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
33d10b64:	0a00000d 	beq	33d10ba0 <id_parse+0x84>
		*dev_type = MTD_DEV_TYPE_NAND;
		p += 4;
	} else if (strncmp(p, "nor", 3) == 0) {
33d10b68:	e59f1088 	ldr	r1, [pc, #136]	; 33d10bf8 <id_parse+0xdc>
33d10b6c:	e3a02003 	mov	r2, #3	; 0x3
33d10b70:	eb002548 	bl	33d1a098 <strncmp>
33d10b74:	e3500000 	cmp	r0, #0	; 0x0
33d10b78:	1a000005 	bne	33d10b94 <id_parse+0x78>
		*dev_type = MTD_DEV_TYPE_NOR;
		p += 3;
33d10b7c:	e59d3000 	ldr	r3, [sp]
	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
		*dev_type = MTD_DEV_TYPE_NAND;
		p += 4;
	} else if (strncmp(p, "nor", 3) == 0) {
		*dev_type = MTD_DEV_TYPE_NOR;
33d10b80:	e3a02001 	mov	r2, #1	; 0x1
		p += 3;
33d10b84:	e2833003 	add	r3, r3, #3	; 0x3
	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
		*dev_type = MTD_DEV_TYPE_NAND;
		p += 4;
	} else if (strncmp(p, "nor", 3) == 0) {
		*dev_type = MTD_DEV_TYPE_NOR;
33d10b88:	e5c42000 	strb	r2, [r4]
		p += 3;
33d10b8c:	e58d3000 	str	r3, [sp]
33d10b90:	ea000002 	b	33d10ba0 <id_parse+0x84>
	} else {
		printf("incorrect device type in %s\n", id);
33d10b94:	e59f0060 	ldr	r0, [pc, #96]	; 33d10bfc <id_parse+0xe0>
33d10b98:	e1a01005 	mov	r1, r5
33d10b9c:	ea000007 	b	33d10bc0 <id_parse+0xa4>
		return 1;
	}

	if (!isdigit(*p)) {
33d10ba0:	e59d0000 	ldr	r0, [sp]
33d10ba4:	e59f2054 	ldr	r2, [pc, #84]	; 33d10c00 <id_parse+0xe4>
33d10ba8:	e5d03000 	ldrb	r3, [r0]
33d10bac:	e7d23003 	ldrb	r3, [r2, r3]
33d10bb0:	e3130004 	tst	r3, #4	; 0x4
33d10bb4:	1a000004 	bne	33d10bcc <id_parse+0xb0>
		printf("incorrect device number in %s\n", id);
33d10bb8:	e59f0044 	ldr	r0, [pc, #68]	; 33d10c04 <id_parse+0xe8>
33d10bbc:	e1a01005 	mov	r1, r5
33d10bc0:	eb001900 	bl	33d16fc8 <printf>
		return 1;
33d10bc4:	e3a00001 	mov	r0, #1	; 0x1
33d10bc8:	ea000007 	b	33d10bec <id_parse+0xd0>
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
33d10bcc:	e1a0100d 	mov	r1, sp
33d10bd0:	e3a02000 	mov	r2, #0	; 0x0
33d10bd4:	eb002660 	bl	33d1a55c <simple_strtoul>
33d10bd8:	e5c70000 	strb	r0, [r7]
	if (ret_id)
33d10bdc:	e3560000 	cmp	r6, #0	; 0x0
		*ret_id = p;
33d10be0:	159d3000 	ldrne	r3, [sp]
33d10be4:	15863000 	strne	r3, [r6]
	return 0;
33d10be8:	e3a00000 	mov	r0, #0	; 0x0
}
33d10bec:	e28dd004 	add	sp, sp, #4	; 0x4
33d10bf0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d10bf4:	33d29278 	.word	0x33d29278
33d10bf8:	33d29274 	.word	0x33d29274
33d10bfc:	33d29548 	.word	0x33d29548
33d10c00:	33d3657c 	.word	0x33d3657c
33d10c04:	33d29568 	.word	0x33d29568

33d10c08 <generate_mtdparts_save>:
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 */
static int generate_mtdparts_save(char *buf, u32 buflen)
{
33d10c08:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
	return head->next == head;
33d10c0c:	e59f229c 	ldr	r2, [pc, #668]	; 33d10eb0 <generate_mtdparts_save+0x2a8>
33d10c10:	e5923000 	ldr	r3, [r2]
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d10c14:	e1530002 	cmp	r3, r2
	u32 maxlen = buflen - 1;

	DEBUGF("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
		buf[0] = '\0';
33d10c18:	03a03000 	moveq	r3, #0	; 0x0
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 */
static int generate_mtdparts_save(char *buf, u32 buflen)
{
33d10c1c:	e24dd030 	sub	sp, sp, #48	; 0x30
33d10c20:	e58d000c 	str	r0, [sp, #12]
	struct mtd_device *dev;
	struct part_info *part, *prev_part;
	char *p = buf;
	char tmpbuf[32];
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;
33d10c24:	e2416001 	sub	r6, r1, #1	; 0x1

	DEBUGF("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
		buf[0] = '\0';
33d10c28:	01a04003 	moveq	r4, r3
33d10c2c:	05c03000 	strbeq	r3, [r0]
33d10c30:	0a000091 	beq	33d10e7c <generate_mtdparts_save+0x274>
		return 0;
	}

	sprintf(p, "mtdparts=");
33d10c34:	e59f1278 	ldr	r1, [pc, #632]	; 33d10eb4 <generate_mtdparts_save+0x2ac>
33d10c38:	eb00282d 	bl	33d1acf4 <sprintf>
	p += 9;

	list_for_each(dentry, &devices) {
33d10c3c:	e59f326c 	ldr	r3, [pc, #620]	; 33d10eb0 <generate_mtdparts_save+0x2a8>
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
	p += 9;
33d10c40:	e59d200c 	ldr	r2, [sp, #12]

	list_for_each(dentry, &devices) {
33d10c44:	e593a000 	ldr	sl, [r3]
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
	p += 9;
33d10c48:	e2825009 	add	r5, r2, #9	; 0x9
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d10c4c:	e15a0003 	cmp	sl, r3
33d10c50:	0a000081 	beq	33d10e5c <generate_mtdparts_save+0x254>

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
33d10c54:	e59a3008 	ldr	r3, [sl, #8]
33d10c58:	e5930010 	ldr	r0, [r3, #16]
33d10c5c:	eb00252b 	bl	33d1a110 <strlen>
33d10c60:	e2804001 	add	r4, r0, #1	; 0x1
		if (len > maxlen)
33d10c64:	e1540006 	cmp	r4, r6
33d10c68:	8a00007f 	bhi	33d10e6c <generate_mtdparts_save+0x264>
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
33d10c6c:	e59a3008 	ldr	r3, [sl, #8]
33d10c70:	e1a02000 	mov	r2, r0
33d10c74:	e5931010 	ldr	r1, [r3, #16]
33d10c78:	e1a00005 	mov	r0, r5
33d10c7c:	eb0025d8 	bl	33d1a3e4 <memcpy>
		p += len - 1;
33d10c80:	e0852004 	add	r2, r5, r4
		*(p++) = ':';
33d10c84:	e3a0303a 	mov	r3, #58	; 0x3a
33d10c88:	e5423001 	strb	r3, [r2, #-1]
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
33d10c8c:	e3a09000 	mov	r9, #0	; 0x0
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
33d10c90:	e59a7010 	ldr	r7, [sl, #16]
33d10c94:	e28a3010 	add	r3, sl, #16	; 0x10
33d10c98:	e88d0208 	stm	sp, {r3, r9}
33d10c9c:	e1570003 	cmp	r7, r3
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
		*(p++) = ':';
		maxlen -= len;
33d10ca0:	e0646006 	rsb	r6, r4, r6
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
		*(p++) = ':';
33d10ca4:	e1a05002 	mov	r5, r2
33d10ca8:	0a00005e 	beq	33d10e28 <generate_mtdparts_save+0x220>
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
33d10cac:	e5972014 	ldr	r2, [r7, #20]
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
33d10cb0:	e28db010 	add	fp, sp, #16	; 0x10
33d10cb4:	e5971010 	ldr	r1, [r7, #16]
33d10cb8:	e1a0000b 	mov	r0, fp
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
33d10cbc:	e58d2008 	str	r2, [sp, #8]
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
33d10cc0:	ebfffc60 	bl	33d0fe48 <memsize_format>
			len = strlen(tmpbuf);
33d10cc4:	e1a0000b 	mov	r0, fp
33d10cc8:	eb002510 	bl	33d1a110 <strlen>
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
33d10ccc:	e59d3004 	ldr	r3, [sp, #4]

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
33d10cd0:	e1500006 	cmp	r0, r6
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
33d10cd4:	e2833001 	add	r3, r3, #1	; 0x1

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
33d10cd8:	e1a04000 	mov	r4, r0
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
33d10cdc:	e58d3004 	str	r3, [sp, #4]

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
33d10ce0:	8a000061 	bhi	33d10e6c <generate_mtdparts_save+0x264>
				goto cleanup;
			memcpy(p, tmpbuf, len);
33d10ce4:	e1a00005 	mov	r0, r5
33d10ce8:	e1a02004 	mov	r2, r4
33d10cec:	e1a0100b 	mov	r1, fp
33d10cf0:	eb0025bb 	bl	33d1a3e4 <memcpy>
			maxlen -= len;


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
33d10cf4:	e59d2008 	ldr	r2, [sp, #8]
33d10cf8:	e2793001 	rsbs	r3, r9, #1	; 0x1
33d10cfc:	33a03000 	movcc	r3, #0	; 0x0
33d10d00:	e3520000 	cmp	r2, #0	; 0x0
33d10d04:	03a03000 	moveq	r3, #0	; 0x0
33d10d08:	e3530000 	cmp	r3, #0	; 0x0
			len = strlen(tmpbuf);
			if (len > maxlen)
				goto cleanup;
			memcpy(p, tmpbuf, len);
			p += len;
			maxlen -= len;
33d10d0c:	e0646006 	rsb	r6, r4, r6
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
				goto cleanup;
			memcpy(p, tmpbuf, len);
			p += len;
33d10d10:	e0855004 	add	r5, r5, r4
			maxlen -= len;


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
33d10d14:	1a000007 	bne	33d10d38 <generate_mtdparts_save+0x130>
33d10d18:	e3590000 	cmp	r9, #0	; 0x0
33d10d1c:	0a000016 	beq	33d10d7c <generate_mtdparts_save+0x174>
33d10d20:	e2893014 	add	r3, r9, #20	; 0x14
33d10d24:	e813000c 	ldmda	r3, {r2, r3}
33d10d28:	e0832002 	add	r2, r3, r2
33d10d2c:	e5973014 	ldr	r3, [r7, #20]
33d10d30:	e1520003 	cmp	r2, r3
33d10d34:	0a000010 	beq	33d10d7c <generate_mtdparts_save+0x174>
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {

				memsize_format(tmpbuf, offset);
33d10d38:	e59d1008 	ldr	r1, [sp, #8]
33d10d3c:	e1a0000b 	mov	r0, fp
33d10d40:	ebfffc40 	bl	33d0fe48 <memsize_format>
				len = strlen(tmpbuf) + 1;
33d10d44:	e1a0000b 	mov	r0, fp
33d10d48:	eb0024f0 	bl	33d1a110 <strlen>
33d10d4c:	e2804001 	add	r4, r0, #1	; 0x1
				if (len > maxlen)
33d10d50:	e1540006 	cmp	r4, r6
33d10d54:	8a000044 	bhi	33d10e6c <generate_mtdparts_save+0x264>
					goto cleanup;
				*(p++) = '@';
33d10d58:	e3a03040 	mov	r3, #64	; 0x40
33d10d5c:	e4c53001 	strb	r3, [r5], #1
				memcpy(p, tmpbuf, len - 1);
33d10d60:	e1a02000 	mov	r2, r0
33d10d64:	e1a0100b 	mov	r1, fp
33d10d68:	e1a00005 	mov	r0, r5
33d10d6c:	eb00259c 	bl	33d1a3e4 <memcpy>
				p += len - 1;
33d10d70:	e0853004 	add	r3, r5, r4
				maxlen -= len;
33d10d74:	e0646006 	rsb	r6, r4, r6
				len = strlen(tmpbuf) + 1;
				if (len > maxlen)
					goto cleanup;
				*(p++) = '@';
				memcpy(p, tmpbuf, len - 1);
				p += len - 1;
33d10d78:	e2435001 	sub	r5, r3, #1	; 0x1
				maxlen -= len;
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
33d10d7c:	e5d7300c 	ldrb	r3, [r7, #12]
33d10d80:	e3530000 	cmp	r3, #0	; 0x0
33d10d84:	1a00000f 	bne	33d10dc8 <generate_mtdparts_save+0x1c0>
				len = strlen(part->name) + 2;
33d10d88:	e5970008 	ldr	r0, [r7, #8]
33d10d8c:	eb0024df 	bl	33d1a110 <strlen>
33d10d90:	e2804002 	add	r4, r0, #2	; 0x2
				if (len > maxlen)
33d10d94:	e1540006 	cmp	r4, r6
33d10d98:	8a000033 	bhi	33d10e6c <generate_mtdparts_save+0x264>
					goto cleanup;

				*(p++) = '(';
33d10d9c:	e3a03028 	mov	r3, #40	; 0x28
33d10da0:	e4c53001 	strb	r3, [r5], #1
				memcpy(p, part->name, len - 2);
33d10da4:	e1a02000 	mov	r2, r0
33d10da8:	e5971008 	ldr	r1, [r7, #8]
33d10dac:	e1a00005 	mov	r0, r5
33d10db0:	eb00258b 	bl	33d1a3e4 <memcpy>
				p += len - 2;
33d10db4:	e0852004 	add	r2, r5, r4
				*(p++) = ')';
33d10db8:	e3a03029 	mov	r3, #41	; 0x29
33d10dbc:	e5423002 	strb	r3, [r2, #-2]
				maxlen -= len;
33d10dc0:	e0646006 	rsb	r6, r4, r6
					goto cleanup;

				*(p++) = '(';
				memcpy(p, part->name, len - 2);
				p += len - 2;
				*(p++) = ')';
33d10dc4:	e2425001 	sub	r5, r2, #1	; 0x1
				maxlen -= len;
			}

			/* ro mask flag */
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
33d10dc8:	e597301c 	ldr	r3, [r7, #28]
33d10dcc:	e3530000 	cmp	r3, #0	; 0x0
33d10dd0:	0a000006 	beq	33d10df0 <generate_mtdparts_save+0x1e8>
				len = 2;
				if (len > maxlen)
33d10dd4:	e3560001 	cmp	r6, #1	; 0x1
33d10dd8:	9a000023 	bls	33d10e6c <generate_mtdparts_save+0x264>
					goto cleanup;
				*(p++) = 'r';
33d10ddc:	e3a03072 	mov	r3, #114	; 0x72
33d10de0:	e4c53001 	strb	r3, [r5], #1
				*(p++) = 'o';
33d10de4:	e2433003 	sub	r3, r3, #3	; 0x3
33d10de8:	e4c53001 	strb	r3, [r5], #1
				maxlen -= 2;
33d10dec:	e2466002 	sub	r6, r6, #2	; 0x2
			}

			/* print ',' separator if there are other partitions
			 * following */
			if (dev->num_parts > part_cnt) {
33d10df0:	e1da30bc 	ldrh	r3, [sl, #12]
33d10df4:	e59d2004 	ldr	r2, [sp, #4]
33d10df8:	e1530002 	cmp	r3, r2
33d10dfc:	9a000004 	bls	33d10e14 <generate_mtdparts_save+0x20c>
				if (1 > maxlen)
33d10e00:	e3560000 	cmp	r6, #0	; 0x0
33d10e04:	0a000018 	beq	33d10e6c <generate_mtdparts_save+0x264>
					goto cleanup;
				*(p++) = ',';
33d10e08:	e3a0302c 	mov	r3, #44	; 0x2c
33d10e0c:	e4c53001 	strb	r3, [r5], #1
				maxlen--;
33d10e10:	e2466001 	sub	r6, r6, #1	; 0x1
			}
			prev_part = part;
33d10e14:	e1a09007 	mov	r9, r7
33d10e18:	e59d3000 	ldr	r3, [sp]
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
33d10e1c:	e5977000 	ldr	r7, [r7]
33d10e20:	e1570003 	cmp	r7, r3
33d10e24:	eaffff9f 	b	33d10ca8 <generate_mtdparts_save+0xa0>
				maxlen--;
			}
			prev_part = part;
		}
		/* print ';' separator if there are other devices following */
		if (dentry->next != &devices) {
33d10e28:	e59a3000 	ldr	r3, [sl]
33d10e2c:	e59f207c 	ldr	r2, [pc, #124]	; 33d10eb0 <generate_mtdparts_save+0x2a8>
33d10e30:	e1530002 	cmp	r3, r2
33d10e34:	0a000004 	beq	33d10e4c <generate_mtdparts_save+0x244>
			if (1 > maxlen)
33d10e38:	e3560000 	cmp	r6, #0	; 0x0
33d10e3c:	0a00000a 	beq	33d10e6c <generate_mtdparts_save+0x264>
				goto cleanup;
			*(p++) = ';';
33d10e40:	e3a0303b 	mov	r3, #59	; 0x3b
33d10e44:	e4c53001 	strb	r3, [r5], #1
			maxlen--;
33d10e48:	e2466001 	sub	r6, r6, #1	; 0x1
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
33d10e4c:	e59aa000 	ldr	sl, [sl]
33d10e50:	e59f3058 	ldr	r3, [pc, #88]	; 33d10eb0 <generate_mtdparts_save+0x2a8>
33d10e54:	e15a0003 	cmp	sl, r3
33d10e58:	eaffff7c 	b	33d10c50 <generate_mtdparts_save+0x48>
		}
	}

	/* we still have at least one char left, as we decremented maxlen at
	 * the begining */
	*p = '\0';
33d10e5c:	e3a03000 	mov	r3, #0	; 0x0
33d10e60:	e1a04003 	mov	r4, r3
33d10e64:	e5c53000 	strb	r3, [r5]
33d10e68:	ea000003 	b	33d10e7c <generate_mtdparts_save+0x274>

	return 0;

cleanup:
	last_parts[0] = '\0';
33d10e6c:	e59f3044 	ldr	r3, [pc, #68]	; 33d10eb8 <generate_mtdparts_save+0x2b0>
33d10e70:	e3a02000 	mov	r2, #0	; 0x0
33d10e74:	e5c32000 	strb	r2, [r3]
33d10e78:	e3a04001 	mov	r4, #1	; 0x1
{
	int ret;

	ret = generate_mtdparts(buf, buflen);

	if ((buf[0] != '\0') && (ret == 0))
33d10e7c:	e59d300c 	ldr	r3, [sp, #12]
33d10e80:	e5d32000 	ldrb	r2, [r3]
33d10e84:	e2243001 	eor	r3, r4, #1	; 0x1
33d10e88:	e3520000 	cmp	r2, #0	; 0x0
33d10e8c:	03a01000 	moveq	r1, #0	; 0x0
33d10e90:	12031001 	andne	r1, r3, #1	; 0x1
33d10e94:	e3510000 	cmp	r1, #0	; 0x0
		setenv("mtdparts", buf);
33d10e98:	159d100c 	ldrne	r1, [sp, #12]
	else
		setenv("mtdparts", NULL);
33d10e9c:	e59f0018 	ldr	r0, [pc, #24]	; 33d10ebc <generate_mtdparts_save+0x2b4>
33d10ea0:	eb00124c 	bl	33d157d8 <setenv>

	return ret;
}
33d10ea4:	e1a00004 	mov	r0, r4
33d10ea8:	e28dd030 	add	sp, sp, #48	; 0x30
33d10eac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d10eb0:	33d608d0 	.word	0x33d608d0
33d10eb4:	33d29588 	.word	0x33d29588
33d10eb8:	33d60964 	.word	0x33d60964
33d10ebc:	33d27068 	.word	0x33d27068

33d10ec0 <find_dev_and_part>:
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
33d10ec0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u8 type, dnum, pnum;
	const char *p;

	DEBUGF("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
33d10ec4:	e59f917c 	ldr	r9, [pc, #380]	; 33d11048 <find_dev_and_part+0x188>
33d10ec8:	e5994000 	ldr	r4, [r9]
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
33d10ecc:	e24dd008 	sub	sp, sp, #8	; 0x8
33d10ed0:	e1540009 	cmp	r4, r9
33d10ed4:	e1a06000 	mov	r6, r0
33d10ed8:	e1a0a001 	mov	sl, r1
33d10edc:	e1a07002 	mov	r7, r2
33d10ee0:	e1a0b003 	mov	fp, r3
33d10ee4:	0a000016 	beq	33d10f44 <find_dev_and_part+0x84>
	const char *p;

	DEBUGF("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
33d10ee8:	e3a03000 	mov	r3, #0	; 0x0
33d10eec:	e5c73000 	strb	r3, [r7]
		*dev = list_entry(dentry, struct mtd_device, link);
33d10ef0:	e58a4000 	str	r4, [sl]
		list_for_each(pentry, &(*dev)->parts) {
33d10ef4:	e5945010 	ldr	r5, [r4, #16]
33d10ef8:	e2843010 	add	r3, r4, #16	; 0x10
33d10efc:	e1550003 	cmp	r5, r3
33d10f00:	0a00000c 	beq	33d10f38 <find_dev_and_part+0x78>
			*part = list_entry(pentry, struct part_info, link);
33d10f04:	e58b5000 	str	r5, [fp]
			if (strcmp((*part)->name, id) == 0)
33d10f08:	e1a01006 	mov	r1, r6
33d10f0c:	e5950008 	ldr	r0, [r5, #8]
33d10f10:	eb002454 	bl	33d1a068 <strcmp>
33d10f14:	e3500000 	cmp	r0, #0	; 0x0
33d10f18:	0a000048 	beq	33d11040 <find_dev_and_part+0x180>
				return 0;
			(*part_num)++;
33d10f1c:	e5d73000 	ldrb	r3, [r7]
33d10f20:	e2833001 	add	r3, r3, #1	; 0x1
33d10f24:	e5c73000 	strb	r3, [r7]
33d10f28:	e59a3000 	ldr	r3, [sl]
	DEBUGF("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
33d10f2c:	e5955000 	ldr	r5, [r5]
33d10f30:	e2833010 	add	r3, r3, #16	; 0x10
33d10f34:	eafffff0 	b	33d10efc <find_dev_and_part+0x3c>
	u8 type, dnum, pnum;
	const char *p;

	DEBUGF("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
33d10f38:	e5944000 	ldr	r4, [r4]
33d10f3c:	e1540009 	cmp	r4, r9
33d10f40:	eaffffe7 	b	33d10ee4 <find_dev_and_part+0x24>
			(*part_num)++;
		}
	}

	p = id;
	*dev = NULL;
33d10f44:	e3a03000 	mov	r3, #0	; 0x0
33d10f48:	e58a3000 	str	r3, [sl]
	*part = NULL;
	*part_num = 0;

	if (id_parse(p, &p, &type, &dnum) != 0)
33d10f4c:	e28d2007 	add	r2, sp, #7	; 0x7
		}
	}

	p = id;
	*dev = NULL;
	*part = NULL;
33d10f50:	e58b3000 	str	r3, [fp]
	*part_num = 0;

	if (id_parse(p, &p, &type, &dnum) != 0)
33d10f54:	e1a00006 	mov	r0, r6
	}

	p = id;
	*dev = NULL;
	*part = NULL;
	*part_num = 0;
33d10f58:	e5c73000 	strb	r3, [r7]

	if (id_parse(p, &p, &type, &dnum) != 0)
33d10f5c:	e1a0100d 	mov	r1, sp
33d10f60:	e28d3006 	add	r3, sp, #6	; 0x6
				return 0;
			(*part_num)++;
		}
	}

	p = id;
33d10f64:	e58d6000 	str	r6, [sp]
	*dev = NULL;
	*part = NULL;
	*part_num = 0;

	if (id_parse(p, &p, &type, &dnum) != 0)
33d10f68:	ebfffeeb 	bl	33d10b1c <id_parse>
33d10f6c:	e2502000 	subs	r2, r0, #0	; 0x0
33d10f70:	e1a0400d 	mov	r4, sp
33d10f74:	1a000023 	bne	33d11008 <find_dev_and_part+0x148>
		return 1;

	if ((*p++ != ',') || (*p == '\0')) {
33d10f78:	e59d0000 	ldr	r0, [sp]
33d10f7c:	e4d03001 	ldrb	r3, [r0], #1
33d10f80:	e353002c 	cmp	r3, #44	; 0x2c
33d10f84:	e58d0000 	str	r0, [sp]
33d10f88:	1a000002 	bne	33d10f98 <find_dev_and_part+0xd8>
33d10f8c:	e5d03000 	ldrb	r3, [r0]
33d10f90:	e3530000 	cmp	r3, #0	; 0x0
33d10f94:	1a000002 	bne	33d10fa4 <find_dev_and_part+0xe4>
		printf("no partition number specified\n");
33d10f98:	e59f00ac 	ldr	r0, [pc, #172]	; 33d1104c <find_dev_and_part+0x18c>
33d10f9c:	eb001809 	bl	33d16fc8 <printf>
33d10fa0:	ea000018 	b	33d11008 <find_dev_and_part+0x148>
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
33d10fa4:	e1a0100d 	mov	r1, sp
33d10fa8:	eb00256b 	bl	33d1a55c <simple_strtoul>
	if (*p != '\0') {
33d10fac:	e59d3000 	ldr	r3, [sp]
33d10fb0:	e5d35000 	ldrb	r5, [r3]
33d10fb4:	e3550000 	cmp	r5, #0	; 0x0

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
33d10fb8:	e20060ff 	and	r6, r0, #255	; 0xff
	if (*p != '\0') {
33d10fbc:	0a000003 	beq	33d10fd0 <find_dev_and_part+0x110>
		printf("unexpected trailing character '%c'\n", *p);
33d10fc0:	e1a01005 	mov	r1, r5
33d10fc4:	e59f0084 	ldr	r0, [pc, #132]	; 33d11050 <find_dev_and_part+0x190>
33d10fc8:	eb0017fe 	bl	33d16fc8 <printf>
33d10fcc:	ea00000d 	b	33d11008 <find_dev_and_part+0x148>
		return 1;
	}

	if ((*dev = device_find(type, dnum)) == NULL) {
33d10fd0:	e5dd0007 	ldrb	r0, [sp, #7]
33d10fd4:	e5dd1006 	ldrb	r1, [sp, #6]
33d10fd8:	ebfffd62 	bl	33d10568 <device_find>
33d10fdc:	e3500000 	cmp	r0, #0	; 0x0
33d10fe0:	e58a0000 	str	r0, [sl]
33d10fe4:	1a000009 	bne	33d11010 <find_dev_and_part+0x150>
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
33d10fe8:	e5dd2007 	ldrb	r2, [sp, #7]
33d10fec:	e59f3060 	ldr	r3, [pc, #96]	; 33d11054 <find_dev_and_part+0x194>
33d10ff0:	e3520002 	cmp	r2, #2	; 0x2
33d10ff4:	e59f105c 	ldr	r1, [pc, #92]	; 33d11058 <find_dev_and_part+0x198>
33d10ff8:	e59f005c 	ldr	r0, [pc, #92]	; 33d1105c <find_dev_and_part+0x19c>
33d10ffc:	11a01003 	movne	r1, r3
33d11000:	e5dd2006 	ldrb	r2, [sp, #6]
33d11004:	eb0017ef 	bl	33d16fc8 <printf>
		return 1;
33d11008:	e3a00001 	mov	r0, #1	; 0x1
33d1100c:	ea00000b 	b	33d11040 <find_dev_and_part+0x180>
	}

	if ((*part = jffs2_part_info(*dev, pnum)) == NULL) {
33d11010:	e1a01006 	mov	r1, r6
33d11014:	ebfffba5 	bl	33d0feb0 <jffs2_part_info>
33d11018:	e3500000 	cmp	r0, #0	; 0x0
33d1101c:	e58b0000 	str	r0, [fp]
33d11020:	e1a04000 	mov	r4, r0
		printf("no such partition\n");
		*dev = NULL;
		return 1;
	}

	*part_num = pnum;
33d11024:	15c76000 	strbne	r6, [r7]

	return 0;
33d11028:	11a00005 	movne	r0, r5
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = jffs2_part_info(*dev, pnum)) == NULL) {
33d1102c:	1a000003 	bne	33d11040 <find_dev_and_part+0x180>
		printf("no such partition\n");
33d11030:	e59f0028 	ldr	r0, [pc, #40]	; 33d11060 <find_dev_and_part+0x1a0>
33d11034:	eb0017e3 	bl	33d16fc8 <printf>
		*dev = NULL;
33d11038:	e58a4000 	str	r4, [sl]
		return 1;
33d1103c:	e3a00001 	mov	r0, #1	; 0x1
	}

	*part_num = pnum;

	return 0;
}
33d11040:	e28dd008 	add	sp, sp, #8	; 0x8
33d11044:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d11048:	33d608d0 	.word	0x33d608d0
33d1104c:	33d29594 	.word	0x33d29594
33d11050:	33d295b4 	.word	0x33d295b4
33d11054:	33d29274 	.word	0x33d29274
33d11058:	33d29278 	.word	0x33d29278
33d1105c:	33d295d8 	.word	0x33d295d8
33d11060:	33d295f0 	.word	0x33d295f0

33d11064 <mtdparts_init>:
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
33d11064:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	DEBUGF("\n---mtdparts_init---\n");
	if (!initialized) {
33d11068:	e59f55e8 	ldr	r5, [pc, #1512]	; 33d11658 <mtdparts_init+0x5f4>
33d1106c:	e5954000 	ldr	r4, [r5]
33d11070:	e3540000 	cmp	r4, #0	; 0x0
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
33d11074:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	DEBUGF("\n---mtdparts_init---\n");
	if (!initialized) {
33d11078:	1a000013 	bne	33d110cc <mtdparts_init+0x68>
		INIT_LIST_HEAD(&mtdids);
33d1107c:	e59f35d8 	ldr	r3, [pc, #1496]	; 33d1165c <mtdparts_init+0x5f8>
		INIT_LIST_HEAD(&devices);
33d11080:	e59fc5d8 	ldr	ip, [pc, #1496]	; 33d11660 <mtdparts_init+0x5fc>
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	DEBUGF("\n---mtdparts_init---\n");
	if (!initialized) {
		INIT_LIST_HEAD(&mtdids);
33d11084:	e5833004 	str	r3, [r3, #4]
33d11088:	e5833000 	str	r3, [r3]
		INIT_LIST_HEAD(&devices);
		memset(last_ids, 0, MTDIDS_MAXLEN);
33d1108c:	e1a01004 	mov	r1, r4
33d11090:	e3a02080 	mov	r2, #128	; 0x80
33d11094:	e59f05c8 	ldr	r0, [pc, #1480]	; 33d11664 <mtdparts_init+0x600>
	char tmp_ep[PARTITION_MAXLEN];

	DEBUGF("\n---mtdparts_init---\n");
	if (!initialized) {
		INIT_LIST_HEAD(&mtdids);
		INIT_LIST_HEAD(&devices);
33d11098:	e58cc004 	str	ip, [ip, #4]
33d1109c:	e58cc000 	str	ip, [ip]
		memset(last_ids, 0, MTDIDS_MAXLEN);
33d110a0:	eb0024bb 	bl	33d1a394 <memset>
		memset(last_parts, 0, MTDPARTS_MAXLEN);
33d110a4:	e1a01004 	mov	r1, r4
33d110a8:	e3a02c02 	mov	r2, #512	; 0x200
33d110ac:	e59f05b4 	ldr	r0, [pc, #1460]	; 33d11668 <mtdparts_init+0x604>
33d110b0:	eb0024b7 	bl	33d1a394 <memset>
		memset(last_partition, 0, PARTITION_MAXLEN);
33d110b4:	e1a01004 	mov	r1, r4
33d110b8:	e59f05ac 	ldr	r0, [pc, #1452]	; 33d1166c <mtdparts_init+0x608>
33d110bc:	e3a02010 	mov	r2, #16	; 0x10
33d110c0:	eb0024b3 	bl	33d1a394 <memset>
		initialized = 1;
33d110c4:	e3a03001 	mov	r3, #1	; 0x1
33d110c8:	e5853000 	str	r3, [r5]
	}

	/* get variables */
	ids = getenv("mtdids");
33d110cc:	e59f059c 	ldr	r0, [pc, #1436]	; 33d11670 <mtdparts_init+0x60c>
33d110d0:	eb0011de 	bl	33d15850 <getenv>
33d110d4:	e1a0a000 	mov	sl, r0
	parts = getenv("mtdparts");
33d110d8:	e59f0594 	ldr	r0, [pc, #1428]	; 33d11674 <mtdparts_init+0x610>
33d110dc:	eb0011db 	bl	33d15850 <getenv>
33d110e0:	e1a09000 	mov	r9, r0
	current_partition = getenv("partition");
33d110e4:	e59f058c 	ldr	r0, [pc, #1420]	; 33d11678 <mtdparts_init+0x614>
33d110e8:	eb0011d8 	bl	33d15850 <getenv>

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
33d110ec:	e3a03000 	mov	r3, #0	; 0x0
	if (current_partition)
33d110f0:	e3500000 	cmp	r0, #0	; 0x0
	parts = getenv("mtdparts");
	current_partition = getenv("partition");

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
33d110f4:	e5cd301c 	strb	r3, [sp, #28]
	if (current_partition)
		strncpy(tmp_ep, current_partition, PARTITION_MAXLEN);
33d110f8:	11a01000 	movne	r1, r0
33d110fc:	13a02010 	movne	r2, #16	; 0x10
33d11100:	128d001c 	addne	r0, sp, #28	; 0x1c
33d11104:	1b0023b3 	blne	33d19fd8 <strncpy>

	DEBUGF("last_partition : %s\n", last_partition);
	DEBUGF("env_partition  : %s\n", current_partition);

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
33d11108:	e35a0000 	cmp	sl, #0	; 0x0
		if (mtdids_default) {
			DEBUGF("mtdids variable not defined, using default\n");
			ids = mtdids_default;
33d1110c:	059fa568 	ldreq	sl, [pc, #1384]	; 33d1167c <mtdparts_init+0x618>
			setenv("mtdids", (char *)ids);
33d11110:	059f0558 	ldreq	r0, [pc, #1368]	; 33d11670 <mtdparts_init+0x60c>
33d11114:	01a0100a 	moveq	r1, sl
33d11118:	0b0011ae 	bleq	33d157d8 <setenv>
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
33d1111c:	e1a0000a 	mov	r0, sl
33d11120:	eb0023fa 	bl	33d1a110 <strlen>
33d11124:	e350007f 	cmp	r0, #127	; 0x7f
		printf("mtdids too long (> %d)\n", MTDIDS_MAXLEN);
33d11128:	859f0550 	ldrhi	r0, [pc, #1360]	; 33d11680 <mtdparts_init+0x61c>
33d1112c:	83a01080 	movhi	r1, #128	; 0x80
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
33d11130:	8a00000a 	bhi	33d11160 <mtdparts_init+0xfc>
		return 1;
	}

	/* do no try to use defaults when mtdparts variable is not defined,
	 * just check the length */
	if (!parts)
33d11134:	e3590000 	cmp	r9, #0	; 0x0
33d11138:	1a000002 	bne	33d11148 <mtdparts_init+0xe4>
		printf("mtdparts variable not set, see 'help mtdparts'\n");
33d1113c:	e59f0540 	ldr	r0, [pc, #1344]	; 33d11684 <mtdparts_init+0x620>
33d11140:	eb0017a0 	bl	33d16fc8 <printf>

	if (parts && (strlen(parts) > MTDPARTS_MAXLEN - 1)) {
33d11144:	ea000007 	b	33d11168 <mtdparts_init+0x104>
33d11148:	e1a00009 	mov	r0, r9
33d1114c:	eb0023ef 	bl	33d1a110 <strlen>
33d11150:	e3500c02 	cmp	r0, #512	; 0x200
33d11154:	3a000003 	bcc	33d11168 <mtdparts_init+0x104>
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
33d11158:	e59f0528 	ldr	r0, [pc, #1320]	; 33d11688 <mtdparts_init+0x624>
33d1115c:	e3a01c02 	mov	r1, #512	; 0x200
33d11160:	eb001798 	bl	33d16fc8 <printf>
33d11164:	ea000105 	b	33d11580 <mtdparts_init+0x51c>
		return 1;
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
33d11168:	e59f64f4 	ldr	r6, [pc, #1268]	; 33d11664 <mtdparts_init+0x600>
33d1116c:	e5d63000 	ldrb	r3, [r6]
33d11170:	e3530000 	cmp	r3, #0	; 0x0
33d11174:	0a00000d 	beq	33d111b0 <mtdparts_init+0x14c>
33d11178:	e1a00006 	mov	r0, r6
33d1117c:	e1a0100a 	mov	r1, sl
33d11180:	eb0023b8 	bl	33d1a068 <strcmp>
33d11184:	e3500000 	cmp	r0, #0	; 0x0
		ids_changed = 0;
33d11188:	058d0000 	streq	r0, [sp]
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
		return 1;
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
33d1118c:	0a0000a6 	beq	33d1142c <mtdparts_init+0x3c8>
33d11190:	ea000006 	b	33d111b0 <mtdparts_init+0x14c>
		/* parse 'nor'|'nand'<dev-num> */
		if (id_parse(p, &p, &type, &num) != 0)
			break;

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
33d11194:	e59f04f0 	ldr	r0, [pc, #1264]	; 33d1168c <mtdparts_init+0x628>
33d11198:	ea000000 	b	33d111a0 <mtdparts_init+0x13c>
			p++;
		} else {
			mtd_id_len = strlen(mtd_id) + 1;
		}
		if (mtd_id_len == 0) {
			printf("mtdids: no <mtd-id> identifier\n");
33d1119c:	e59f04ec 	ldr	r0, [pc, #1260]	; 33d11690 <mtdparts_init+0x62c>
33d111a0:	eb001788 	bl	33d16fc8 <printf>
			break;
33d111a4:	ea00008c 	b	33d113dc <mtdparts_init+0x378>
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
33d111a8:	e59f04e4 	ldr	r0, [pc, #1252]	; 33d11694 <mtdparts_init+0x630>
33d111ac:	eafffffb 	b	33d111a0 <mtdparts_init+0x13c>
	int ret = 1;

	DEBUGF("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
33d111b0:	e59f54a4 	ldr	r5, [pc, #1188]	; 33d1165c <mtdparts_init+0x5f8>

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
		ids_changed = 0;
	} else {
		ids_changed = 1;
33d111b4:	e3a03001 	mov	r3, #1	; 0x1
	int ret = 1;

	DEBUGF("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
33d111b8:	e5950000 	ldr	r0, [r5]

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
		ids_changed = 0;
	} else {
		ids_changed = 1;
33d111bc:	e58d3000 	str	r3, [sp]
 * @param ids mapping string
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdids(const char *const ids)
{
	const char *p = ids;
33d111c0:	e58da014 	str	sl, [sp, #20]
	int ret = 1;

	DEBUGF("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
33d111c4:	e1500005 	cmp	r0, r5
33d111c8:	e5904000 	ldr	r4, [r0]
33d111cc:	0a000009 	beq	33d111f8 <mtdparts_init+0x194>
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d111d0:	e890000c 	ldm	r0, {r2, r3}
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d111d4:	e3a01000 	mov	r1, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d111d8:	e5832000 	str	r2, [r3]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d111dc:	e5823004 	str	r3, [r2, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d111e0:	e5801000 	str	r1, [r0]
	entry->prev = (void *) 0;
33d111e4:	e5801004 	str	r1, [r0, #4]
		id_tmp = list_entry(entry, struct mtdids, link);
		DEBUGF("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
33d111e8:	eb001899 	bl	33d17454 <free>
	int ret = 1;

	DEBUGF("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
33d111ec:	e1a00004 	mov	r0, r4
33d111f0:	e1540005 	cmp	r4, r5
33d111f4:	eafffff3 	b	33d111c8 <mtdparts_init+0x164>
		DEBUGF("+ id %s%d\t%16d bytes\t%s\n",
				MTD_DEV_TYPE(id->type), id->num,
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
33d111f8:	e59d0014 	ldr	r0, [sp, #20]
		DEBUGF("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
	INIT_LIST_HEAD(&mtdids);
33d111fc:	e59f3458 	ldr	r3, [pc, #1112]	; 33d1165c <mtdparts_init+0x5f8>
		id_tmp = list_entry(entry, struct mtdids, link);
		DEBUGF("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
33d11200:	e3a02000 	mov	r2, #0	; 0x0
		DEBUGF("+ id %s%d\t%16d bytes\t%s\n",
				MTD_DEV_TYPE(id->type), id->num,
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
33d11204:	e3500000 	cmp	r0, #0	; 0x0
		id_tmp = list_entry(entry, struct mtdids, link);
		DEBUGF("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
33d11208:	e5c62000 	strb	r2, [r6]
	INIT_LIST_HEAD(&mtdids);
33d1120c:	e5833004 	str	r3, [r3, #4]
33d11210:	e5833000 	str	r3, [r3]
		DEBUGF("+ id %s%d\t%16d bytes\t%s\n",
				MTD_DEV_TYPE(id->type), id->num,
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
33d11214:	0a000070 	beq	33d113dc <mtdparts_init+0x378>
33d11218:	e5d03000 	ldrb	r3, [r0]
33d1121c:	e1530002 	cmp	r3, r2
33d11220:	0a00006d 	beq	33d113dc <mtdparts_init+0x378>

	while(p && (*p != '\0')) {

		ret = 1;
		/* parse 'nor'|'nand'<dev-num> */
		if (id_parse(p, &p, &type, &num) != 0)
33d11224:	e28d1014 	add	r1, sp, #20	; 0x14
33d11228:	e28d201b 	add	r2, sp, #27	; 0x1b
33d1122c:	e28d301a 	add	r3, sp, #26	; 0x1a
33d11230:	ebfffe39 	bl	33d10b1c <id_parse>
33d11234:	e3500000 	cmp	r0, #0	; 0x0
33d11238:	1a000067 	bne	33d113dc <mtdparts_init+0x378>
			break;

		if (*p != '=') {
33d1123c:	e59d2014 	ldr	r2, [sp, #20]
33d11240:	e5d23000 	ldrb	r3, [r2]
33d11244:	e353003d 	cmp	r3, #61	; 0x3d
33d11248:	1affffd1 	bne	33d11194 <mtdparts_init+0x130>
 *
 * @param dev device to validate
 * @return 0 if device is valid, 1 otherwise
 */
static int device_validate(u8 type, u8 num, u32 *size)
{
33d1124c:	e5dd101b 	ldrb	r1, [sp, #27]

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
			break;
		}
		p++;
33d11250:	e2823001 	add	r3, r2, #1	; 0x1
 * @param dev device to validate
 * @return 0 if device is valid, 1 otherwise
 */
static int device_validate(u8 type, u8 num, u32 *size)
{
	if (type == MTD_DEV_TYPE_NOR) {
33d11254:	e3510001 	cmp	r1, #1	; 0x1

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
			break;
		}
		p++;
33d11258:	e58d3014 	str	r3, [sp, #20]
 *
 * @param dev device to validate
 * @return 0 if device is valid, 1 otherwise
 */
static int device_validate(u8 type, u8 num, u32 *size)
{
33d1125c:	e5dd201a 	ldrb	r2, [sp, #26]
	if (type == MTD_DEV_TYPE_NOR) {
33d11260:	1a000007 	bne	33d11284 <mtdparts_init+0x220>
#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
		if (num < CFG_MAX_FLASH_BANKS) {
33d11264:	e3520000 	cmp	r2, #0	; 0x0
			extern flash_info_t flash_info[];
			*size = flash_info[num].size;
33d11268:	059f3428 	ldreq	r3, [pc, #1064]	; 33d11698 <mtdparts_init+0x634>
33d1126c:	0593b000 	ldreq	fp, [r3]
33d11270:	0a00000e 	beq	33d112b0 <mtdparts_init+0x24c>

			return 0;
		}

		printf("no such FLASH device: %s%d (valid range 0 ... %d\n",
33d11274:	e1a03000 	mov	r3, r0
33d11278:	e59f141c 	ldr	r1, [pc, #1052]	; 33d1169c <mtdparts_init+0x638>
33d1127c:	e59f041c 	ldr	r0, [pc, #1052]	; 33d116a0 <mtdparts_init+0x63c>
33d11280:	ea000008 	b	33d112a8 <mtdparts_init+0x244>
				MTD_DEV_TYPE(type), num, CFG_MAX_FLASH_BANKS - 1);
#else
		printf("support for FLASH devices not present\n");
#endif
	} else if (type == MTD_DEV_TYPE_NAND) {
33d11284:	e3510002 	cmp	r1, #2	; 0x2
33d11288:	1a000061 	bne	33d11414 <mtdparts_init+0x3b0>
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
		if (num < CFG_MAX_NAND_DEVICE) {
33d1128c:	e3520000 	cmp	r2, #0	; 0x0
#ifndef CFG_NAND_LEGACY
			*size = nand_info[num].size;
33d11290:	059f340c 	ldreq	r3, [pc, #1036]	; 33d116a4 <mtdparts_init+0x640>
33d11294:	0593b008 	ldreq	fp, [r3, #8]
33d11298:	0a000004 	beq	33d112b0 <mtdparts_init+0x24c>
			*size = nand_dev_desc[num].totlen;
#endif
			return 0;
		}

		printf("no such NAND device: %s%d (valid range 0 ... %d)\n",
33d1129c:	e1a03000 	mov	r3, r0
33d112a0:	e59f1400 	ldr	r1, [pc, #1024]	; 33d116a8 <mtdparts_init+0x644>
33d112a4:	e59f0400 	ldr	r0, [pc, #1024]	; 33d116ac <mtdparts_init+0x648>
33d112a8:	eb001746 	bl	33d16fc8 <printf>
			break;
		}
		p++;

		/* check if requested device exists */
		if (device_validate(type, num, &size) != 0)
33d112ac:	ea000058 	b	33d11414 <mtdparts_init+0x3b0>
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
33d112b0:	e59d7014 	ldr	r7, [sp, #20]
		if ((p = strchr(mtd_id, ',')) != NULL) {
33d112b4:	e3a0102c 	mov	r1, #44	; 0x2c
33d112b8:	e1a00007 	mov	r0, r7
33d112bc:	eb002387 	bl	33d1a0e0 <strchr>
33d112c0:	e3500000 	cmp	r0, #0	; 0x0
			mtd_id_len = p - mtd_id + 1;
33d112c4:	10673000 	rsbne	r3, r7, r0
			p++;
33d112c8:	12802001 	addne	r2, r0, #1	; 0x1
		if (device_validate(type, num, &size) != 0)
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
		if ((p = strchr(mtd_id, ',')) != NULL) {
33d112cc:	e58d0014 	str	r0, [sp, #20]
			mtd_id_len = p - mtd_id + 1;
33d112d0:	12836001 	addne	r6, r3, #1	; 0x1
			p++;
33d112d4:	158d2014 	strne	r2, [sp, #20]
		if (device_validate(type, num, &size) != 0)
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
		if ((p = strchr(mtd_id, ',')) != NULL) {
33d112d8:	1a000002 	bne	33d112e8 <mtdparts_init+0x284>
			mtd_id_len = p - mtd_id + 1;
			p++;
		} else {
			mtd_id_len = strlen(mtd_id) + 1;
33d112dc:	e1a00007 	mov	r0, r7
33d112e0:	eb00238a 	bl	33d1a110 <strlen>
33d112e4:	e2806001 	add	r6, r0, #1	; 0x1
		}
		if (mtd_id_len == 0) {
33d112e8:	e3560000 	cmp	r6, #0	; 0x0
33d112ec:	0affffaa 	beq	33d1119c <mtdparts_init+0x138>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
33d112f0:	e59f1364 	ldr	r1, [pc, #868]	; 33d1165c <mtdparts_init+0x5f8>
33d112f4:	e5910000 	ldr	r0, [r1]
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d112f8:	e1500001 	cmp	r0, r1
33d112fc:	0a000012 	beq	33d1134c <mtdparts_init+0x2e8>
			id_tmp = list_entry(entry, struct mtdids, link);
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
33d11300:	e5d02008 	ldrb	r2, [r0, #8]
33d11304:	e5dd301b 	ldrb	r3, [sp, #27]
33d11308:	e1520003 	cmp	r2, r3
33d1130c:	1a000003 	bne	33d11320 <mtdparts_init+0x2bc>
33d11310:	e5d02009 	ldrb	r2, [r0, #9]
33d11314:	e5dd301a 	ldrb	r3, [sp, #26]
33d11318:	e1520003 	cmp	r2, r3
33d1131c:	0a000001 	beq	33d11328 <mtdparts_init+0x2c4>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
33d11320:	e5900000 	ldr	r0, [r0]
33d11324:	eafffff3 	b	33d112f8 <mtdparts_init+0x294>
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
33d11328:	e5dd201b 	ldrb	r2, [sp, #27]
33d1132c:	e59f3368 	ldr	r3, [pc, #872]	; 33d1169c <mtdparts_init+0x638>
33d11330:	e3520002 	cmp	r2, #2	; 0x2
33d11334:	e59f136c 	ldr	r1, [pc, #876]	; 33d116a8 <mtdparts_init+0x644>
33d11338:	e59f0370 	ldr	r0, [pc, #880]	; 33d116b0 <mtdparts_init+0x64c>
33d1133c:	11a01003 	movne	r1, r3
33d11340:	e5dd201a 	ldrb	r2, [sp, #26]
33d11344:	eb00171f 	bl	33d16fc8 <printf>
					MTD_DEV_TYPE(type), num);
			break;
33d11348:	ea000023 	b	33d113dc <mtdparts_init+0x378>
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
33d1134c:	e2865014 	add	r5, r6, #20	; 0x14
33d11350:	e1a00005 	mov	r0, r5
33d11354:	eb0018c3 	bl	33d17668 <malloc>
33d11358:	e2504000 	subs	r4, r0, #0	; 0x0
33d1135c:	0affff91 	beq	33d111a8 <mtdparts_init+0x144>
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
33d11360:	e1a02005 	mov	r2, r5
33d11364:	e3a01000 	mov	r1, #0	; 0x0
33d11368:	eb002409 	bl	33d1a394 <memset>
		id->num = num;
33d1136c:	e5dd301a 	ldrb	r3, [sp, #26]
33d11370:	e5c43009 	strb	r3, [r4, #9]
		id->type = type;
33d11374:	e5dd301b 	ldrb	r3, [sp, #27]
		id->size = size;
		id->mtd_id = (char *)(id + 1);
33d11378:	e2840014 	add	r0, r4, #20	; 0x14
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
33d1137c:	e5c43008 	strb	r3, [r4, #8]
		id->size = size;
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
33d11380:	e2462001 	sub	r2, r6, #1	; 0x1
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
		id->size = size;
33d11384:	e584b00c 	str	fp, [r4, #12]
		id->mtd_id = (char *)(id + 1);
33d11388:	e5840010 	str	r0, [r4, #16]
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
33d1138c:	e1a01007 	mov	r1, r7
33d11390:	eb002310 	bl	33d19fd8 <strncpy>
		id->mtd_id[mtd_id_len - 1] = '\0';
33d11394:	e5943010 	ldr	r3, [r4, #16]
33d11398:	e3a02000 	mov	r2, #0	; 0x0
33d1139c:	e0833006 	add	r3, r3, r6
33d113a0:	e5432001 	strb	r2, [r3, #-1]
		INIT_LIST_HEAD(&id->link);
33d113a4:	e5844004 	str	r4, [r4, #4]
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
33d113a8:	e59f32ac 	ldr	r3, [pc, #684]	; 33d1165c <mtdparts_init+0x5f8>
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
33d113ac:	e5932004 	ldr	r2, [r3, #4]
	next->prev = new;
	new->next = next;
33d113b0:	e5843000 	str	r3, [r4]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d113b4:	e5834004 	str	r4, [r3, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
33d113b8:	e5824000 	str	r4, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
33d113bc:	e5842004 	str	r2, [r4, #4]
		DEBUGF("+ id %s%d\t%16d bytes\t%s\n",
				MTD_DEV_TYPE(id->type), id->num,
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
33d113c0:	e59d0014 	ldr	r0, [sp, #20]
33d113c4:	e3500000 	cmp	r0, #0	; 0x0
33d113c8:	0a000013 	beq	33d1141c <mtdparts_init+0x3b8>
33d113cc:	e5d03000 	ldrb	r3, [r0]
33d113d0:	e3530000 	cmp	r3, #0	; 0x0
33d113d4:	1affff92 	bne	33d11224 <mtdparts_init+0x1c0>
33d113d8:	ea00000f 	b	33d1141c <mtdparts_init+0x3b8>
	}
	if (ret == 1) {
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
33d113dc:	e59f5278 	ldr	r5, [pc, #632]	; 33d1165c <mtdparts_init+0x5f8>
33d113e0:	e5950000 	ldr	r0, [r5]
33d113e4:	e1500005 	cmp	r0, r5
33d113e8:	e5904000 	ldr	r4, [r0]
33d113ec:	0a000008 	beq	33d11414 <mtdparts_init+0x3b0>
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d113f0:	e890000c 	ldm	r0, {r2, r3}
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d113f4:	e3a01000 	mov	r1, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d113f8:	e5832000 	str	r2, [r3]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d113fc:	e5823004 	str	r3, [r2, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d11400:	e5801000 	str	r1, [r0]
	entry->prev = (void *) 0;
33d11404:	e5801004 	str	r1, [r0, #4]
			id_tmp = list_entry(entry, struct mtdids, link);
			list_del(entry);
			free(id_tmp);
33d11408:	eb001811 	bl	33d17454 <free>
		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
33d1140c:	e1a00004 	mov	r0, r4
33d11410:	eafffff3 	b	33d113e4 <mtdparts_init+0x380>
		ids_changed = 0;
	} else {
		ids_changed = 1;

		if (parse_mtdids(ids) != 0) {
			devices_init();
33d11414:	ebfffc69 	bl	33d105c0 <devices_init>
33d11418:	ea000058 	b	33d11580 <mtdparts_init+0x51c>
			return 1;
		}

		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
33d1141c:	e1a0100a 	mov	r1, sl
33d11420:	e59f023c 	ldr	r0, [pc, #572]	; 33d11664 <mtdparts_init+0x600>
33d11424:	e3a02080 	mov	r2, #128	; 0x80
33d11428:	eb0022ea 	bl	33d19fd8 <strncpy>
	}

	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
33d1142c:	e3590000 	cmp	r9, #0	; 0x0
33d11430:	0a000060 	beq	33d115b8 <mtdparts_init+0x554>
33d11434:	e59f022c 	ldr	r0, [pc, #556]	; 33d11668 <mtdparts_init+0x604>
33d11438:	e5d03000 	ldrb	r3, [r0]
33d1143c:	e3530000 	cmp	r3, #0	; 0x0
33d11440:	0a000006 	beq	33d11460 <mtdparts_init+0x3fc>
33d11444:	e1a01009 	mov	r1, r9
33d11448:	eb002306 	bl	33d1a068 <strcmp>
33d1144c:	e3500000 	cmp	r0, #0	; 0x0
33d11450:	1a000002 	bne	33d11460 <mtdparts_init+0x3fc>
33d11454:	e59d3000 	ldr	r3, [sp]
33d11458:	e3530000 	cmp	r3, #0	; 0x0
33d1145c:	0a000053 	beq	33d115b0 <mtdparts_init+0x54c>
 * @param mtdparts string specifing mtd partitions
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
33d11460:	e58d9010 	str	r9, [sp, #16]
	int err = 1;

	DEBUGF("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (devices_init() != 0) {
33d11464:	ebfffc55 	bl	33d105c0 <devices_init>
33d11468:	e3500000 	cmp	r0, #0	; 0x0
		printf("could not initialise device list\n");
33d1146c:	159f0240 	ldrne	r0, [pc, #576]	; 33d116b4 <mtdparts_init+0x650>
	int err = 1;

	DEBUGF("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (devices_init() != 0) {
33d11470:	1a000041 	bne	33d1157c <mtdparts_init+0x518>
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, devices_init may be updating env */
	p = getenv("mtdparts");
33d11474:	e59f01f8 	ldr	r0, [pc, #504]	; 33d11674 <mtdparts_init+0x610>
33d11478:	eb0010f4 	bl	33d15850 <getenv>

	if (strncmp(p, "mtdparts=", 9) != 0) {
33d1147c:	e59f1234 	ldr	r1, [pc, #564]	; 33d116b8 <mtdparts_init+0x654>
33d11480:	e3a02009 	mov	r2, #9	; 0x9
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, devices_init may be updating env */
	p = getenv("mtdparts");
33d11484:	e58d0010 	str	r0, [sp, #16]

	if (strncmp(p, "mtdparts=", 9) != 0) {
33d11488:	eb002302 	bl	33d1a098 <strncmp>
33d1148c:	e3500000 	cmp	r0, #0	; 0x0
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
33d11490:	159f0224 	ldrne	r0, [pc, #548]	; 33d116bc <mtdparts_init+0x658>
	}

	/* re-read 'mtdparts' variable, devices_init may be updating env */
	p = getenv("mtdparts");

	if (strncmp(p, "mtdparts=", 9) != 0) {
33d11494:	1a000038 	bne	33d1157c <mtdparts_init+0x518>
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;
33d11498:	e59d2010 	ldr	r2, [sp, #16]
33d1149c:	e2823009 	add	r3, r2, #9	; 0x9
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
			break;
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
33d114a0:	e2530000 	subs	r0, r3, #0	; 0x0

	if (strncmp(p, "mtdparts=", 9) != 0) {
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;
33d114a4:	e58d3010 	str	r3, [sp, #16]
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
			break;
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
33d114a8:	0a000028 	beq	33d11550 <mtdparts_init+0x4ec>
33d114ac:	e5d23009 	ldrb	r3, [r2, #9]
33d114b0:	e3530000 	cmp	r3, #0	; 0x0
33d114b4:	0a000025 	beq	33d11550 <mtdparts_init+0x4ec>
	}
	p += 9;

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
33d114b8:	e28d1010 	add	r1, sp, #16	; 0x10
33d114bc:	e28d200c 	add	r2, sp, #12	; 0xc
33d114c0:	ebfffc4b 	bl	33d105f4 <device_parse>
33d114c4:	e3500000 	cmp	r0, #0	; 0x0
33d114c8:	1a000020 	bne	33d11550 <mtdparts_init+0x4ec>
33d114cc:	e59d300c 	ldr	r3, [sp, #12]
33d114d0:	e3530000 	cmp	r3, #0	; 0x0
33d114d4:	0a00001d 	beq	33d11550 <mtdparts_init+0x4ec>

		DEBUGF("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
33d114d8:	e5933008 	ldr	r3, [r3, #8]
33d114dc:	e5d31009 	ldrb	r1, [r3, #9]
33d114e0:	e5d30008 	ldrb	r0, [r3, #8]
33d114e4:	ebfffc1f 	bl	33d10568 <device_find>
33d114e8:	e3500000 	cmp	r0, #0	; 0x0
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
33d114ec:	e59f116c 	ldr	r1, [pc, #364]	; 33d11660 <mtdparts_init+0x5fc>
33d114f0:	e59d200c 	ldr	r2, [sp, #12]
33d114f4:	0a000009 	beq	33d11520 <mtdparts_init+0x4bc>
			printf("device %s%d redefined, please correct mtdparts variable\n",
33d114f8:	e5920008 	ldr	r0, [r2, #8]
33d114fc:	e5d02008 	ldrb	r2, [r0, #8]
33d11500:	e59f3194 	ldr	r3, [pc, #404]	; 33d1169c <mtdparts_init+0x638>
33d11504:	e3520002 	cmp	r2, #2	; 0x2
33d11508:	e59f1198 	ldr	r1, [pc, #408]	; 33d116a8 <mtdparts_init+0x644>
33d1150c:	e5d02009 	ldrb	r2, [r0, #9]
33d11510:	11a01003 	movne	r1, r3
33d11514:	e59f01a4 	ldr	r0, [pc, #420]	; 33d116c0 <mtdparts_init+0x65c>
33d11518:	eb0016aa 	bl	33d16fc8 <printf>
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
			break;
33d1151c:	ea00000b 	b	33d11550 <mtdparts_init+0x4ec>
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
33d11520:	e5913004 	ldr	r3, [r1, #4]
	next->prev = new;
	new->next = next;
33d11524:	e5821000 	str	r1, [r2]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d11528:	e5812004 	str	r2, [r1, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
33d1152c:	e5832000 	str	r2, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
33d11530:	e5823004 	str	r3, [r2, #4]
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
33d11534:	e59d0010 	ldr	r0, [sp, #16]
33d11538:	e3500000 	cmp	r0, #0	; 0x0
33d1153c:	0a000006 	beq	33d1155c <mtdparts_init+0x4f8>
33d11540:	e5d03000 	ldrb	r3, [r0]
33d11544:	e3530000 	cmp	r3, #0	; 0x0
33d11548:	1affffda 	bne	33d114b8 <mtdparts_init+0x454>
33d1154c:	ea000002 	b	33d1155c <mtdparts_init+0x4f8>
	}
	if (err == 1) {
		device_delall(&devices);
33d11550:	e59f0108 	ldr	r0, [pc, #264]	; 33d11660 <mtdparts_init+0x5fc>
33d11554:	ebfffbeb 	bl	33d10508 <device_delall>
33d11558:	ea000008 	b	33d11580 <mtdparts_init+0x51c>
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d1155c:	e59f40fc 	ldr	r4, [pc, #252]	; 33d11660 <mtdparts_init+0x5fc>
	return head->next == head;
33d11560:	e5943000 	ldr	r3, [r4]
33d11564:	e1530004 	cmp	r3, r4
33d11568:	13a05000 	movne	r5, #0	; 0x0
33d1156c:	03a05001 	moveq	r5, #1	; 0x1
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d11570:	e3550000 	cmp	r5, #0	; 0x0
33d11574:	0a000003 	beq	33d11588 <mtdparts_init+0x524>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
			printf("mtdparts_init: no valid partitions\n");
33d11578:	e59f0144 	ldr	r0, [pc, #324]	; 33d116c4 <mtdparts_init+0x660>
33d1157c:	eb001691 	bl	33d16fc8 <printf>
			return 1;
33d11580:	e3a00001 	mov	r0, #1	; 0x1
33d11584:	ea000031 	b	33d11650 <mtdparts_init+0x5ec>
		}

		/* ok it's good, save new parts */
		strncpy(last_parts, parts, MTDPARTS_MAXLEN);
33d11588:	e3a02c02 	mov	r2, #512	; 0x200
33d1158c:	e59f00d4 	ldr	r0, [pc, #212]	; 33d11668 <mtdparts_init+0x604>
33d11590:	e1a01009 	mov	r1, r9
33d11594:	eb00228f 	bl	33d19fd8 <strncpy>

		/* reset first partition from first dev from the list as current */
		current_dev = list_entry(devices.next, struct mtd_device, link);
33d11598:	e5943000 	ldr	r3, [r4]
33d1159c:	e59f2124 	ldr	r2, [pc, #292]	; 33d116c8 <mtdparts_init+0x664>
33d115a0:	e5823000 	str	r3, [r2]
		current_partnum = 0;
33d115a4:	e59f3120 	ldr	r3, [pc, #288]	; 33d116cc <mtdparts_init+0x668>
33d115a8:	e5c35000 	strb	r5, [r3]
		current_save();
33d115ac:	ebfffa9d 	bl	33d10028 <current_save>
				MTD_DEV_TYPE(current_dev->id->type),
				current_dev->id->num, current_partnum);
	}

	/* mtdparts variable was reset to NULL, delete all devices/partitions */
	if (!parts && (last_parts[0] != '\0'))
33d115b0:	e3590000 	cmp	r9, #0	; 0x0
33d115b4:	1a000008 	bne	33d115dc <mtdparts_init+0x578>
33d115b8:	e59f30a8 	ldr	r3, [pc, #168]	; 33d11668 <mtdparts_init+0x604>
33d115bc:	e5d33000 	ldrb	r3, [r3]
33d115c0:	e3530000 	cmp	r3, #0	; 0x0
33d115c4:	0a000001 	beq	33d115d0 <mtdparts_init+0x56c>
		return devices_init();
33d115c8:	ebfffbfc 	bl	33d105c0 <devices_init>
33d115cc:	ea00001f 	b	33d11650 <mtdparts_init+0x5ec>

	/* do not process current partition if mtdparts variable is null */
	if (!parts)
33d115d0:	e3590000 	cmp	r9, #0	; 0x0
		return 0;
33d115d4:	01a00009 	moveq	r0, r9
	/* mtdparts variable was reset to NULL, delete all devices/partitions */
	if (!parts && (last_parts[0] != '\0'))
		return devices_init();

	/* do not process current partition if mtdparts variable is null */
	if (!parts)
33d115d8:	0a00001c 	beq	33d11650 <mtdparts_init+0x5ec>
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
33d115dc:	e5dd301c 	ldrb	r3, [sp, #28]
33d115e0:	e3530000 	cmp	r3, #0	; 0x0
33d115e4:	0a000013 	beq	33d11638 <mtdparts_init+0x5d4>
33d115e8:	e28d401c 	add	r4, sp, #28	; 0x1c
33d115ec:	e1a00004 	mov	r0, r4
33d115f0:	e59f1074 	ldr	r1, [pc, #116]	; 33d1166c <mtdparts_init+0x608>
33d115f4:	eb00229b 	bl	33d1a068 <strcmp>
33d115f8:	e3500000 	cmp	r0, #0	; 0x0
33d115fc:	0a00000d 	beq	33d11638 <mtdparts_init+0x5d4>
		struct mtd_device *cdev;
		u8 pnum;

		DEBUGF("--- getting current partition: %s\n", tmp_ep);

		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
33d11600:	e1a00004 	mov	r0, r4
33d11604:	e28d1008 	add	r1, sp, #8	; 0x8
33d11608:	e28d2019 	add	r2, sp, #25	; 0x19
33d1160c:	e28d3004 	add	r3, sp, #4	; 0x4
33d11610:	ebfffe2a 	bl	33d10ec0 <find_dev_and_part>
33d11614:	e3500000 	cmp	r0, #0	; 0x0
33d11618:	1a00000b 	bne	33d1164c <mtdparts_init+0x5e8>
			current_dev = cdev;
33d1161c:	e59d2008 	ldr	r2, [sp, #8]
33d11620:	e59f30a0 	ldr	r3, [pc, #160]	; 33d116c8 <mtdparts_init+0x664>
			current_partnum = pnum;
33d11624:	e5dd1019 	ldrb	r1, [sp, #25]
		u8 pnum;

		DEBUGF("--- getting current partition: %s\n", tmp_ep);

		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
			current_dev = cdev;
33d11628:	e5832000 	str	r2, [r3]
			current_partnum = pnum;
33d1162c:	e59f3098 	ldr	r3, [pc, #152]	; 33d116cc <mtdparts_init+0x668>
33d11630:	e5c31000 	strb	r1, [r3]
33d11634:	ea000003 	b	33d11648 <mtdparts_init+0x5e4>
			current_save();
		}
	} else if (getenv("partition") == NULL) {
33d11638:	e59f0038 	ldr	r0, [pc, #56]	; 33d11678 <mtdparts_init+0x614>
33d1163c:	eb001083 	bl	33d15850 <getenv>
33d11640:	e3500000 	cmp	r0, #0	; 0x0
33d11644:	1a000000 	bne	33d1164c <mtdparts_init+0x5e8>
		DEBUGF("no partition variable set, setting...\n");
		current_save();
33d11648:	ebfffa76 	bl	33d10028 <current_save>
	}

	return 0;
33d1164c:	e3a00000 	mov	r0, #0	; 0x0
}
33d11650:	e28dd02c 	add	sp, sp, #44	; 0x2c
33d11654:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d11658:	33d608e0 	.word	0x33d608e0
33d1165c:	33d608c8 	.word	0x33d608c8
33d11660:	33d608d0 	.word	0x33d608d0
33d11664:	33d608e4 	.word	0x33d608e4
33d11668:	33d60964 	.word	0x33d60964
33d1166c:	33d60b64 	.word	0x33d60b64
33d11670:	33d29604 	.word	0x33d29604
33d11674:	33d27068 	.word	0x33d27068
33d11678:	33d292d4 	.word	0x33d292d4
33d1167c:	33d2960c 	.word	0x33d2960c
33d11680:	33d29620 	.word	0x33d29620
33d11684:	33d29638 	.word	0x33d29638
33d11688:	33d29668 	.word	0x33d29668
33d1168c:	33d29684 	.word	0x33d29684
33d11690:	33d296a4 	.word	0x33d296a4
33d11694:	33d294d4 	.word	0x33d294d4
33d11698:	33d62554 	.word	0x33d62554
33d1169c:	33d29274 	.word	0x33d29274
33d116a0:	33d296c4 	.word	0x33d296c4
33d116a4:	33d39920 	.word	0x33d39920
33d116a8:	33d29278 	.word	0x33d29278
33d116ac:	33d296f8 	.word	0x33d296f8
33d116b0:	33d2972c 	.word	0x33d2972c
33d116b4:	33d29768 	.word	0x33d29768
33d116b8:	33d29588 	.word	0x33d29588
33d116bc:	33d2978c 	.word	0x33d2978c
33d116c0:	33d297c0 	.word	0x33d297c0
33d116c4:	33d297fc 	.word	0x33d297fc
33d116c8:	33d608d8 	.word	0x33d608d8
33d116cc:	33d608dc 	.word	0x33d608dc

33d116d0 <do_jffs2_fsload>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_fsload(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d116d0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	char *fsname;
	char *filename;
	int size;
	struct part_info *part;
	ulong offset = load_addr;
33d116d4:	e59f6150 	ldr	r6, [pc, #336]	; 33d1182c <do_jffs2_fsload+0x15c>
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_fsload(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d116d8:	e24dd00c 	sub	sp, sp, #12	; 0xc
	int size;
	struct part_info *part;
	ulong offset = load_addr;

	/* pre-set Boot file name */
	if ((filename = getenv("bootfile")) == NULL) {
33d116dc:	e59f014c 	ldr	r0, [pc, #332]	; 33d11830 <do_jffs2_fsload+0x160>
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_fsload(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d116e0:	e1a04003 	mov	r4, r3
33d116e4:	e1a05002 	mov	r5, r2
	char *fsname;
	char *filename;
	int size;
	struct part_info *part;
	ulong offset = load_addr;
33d116e8:	e596a000 	ldr	sl, [r6]

	/* pre-set Boot file name */
	if ((filename = getenv("bootfile")) == NULL) {
33d116ec:	eb001057 	bl	33d15850 <getenv>
		filename = "uImage";
33d116f0:	e59f313c 	ldr	r3, [pc, #316]	; 33d11834 <do_jffs2_fsload+0x164>
33d116f4:	e3500000 	cmp	r0, #0	; 0x0
33d116f8:	11a07000 	movne	r7, r0
33d116fc:	01a07003 	moveq	r7, r3
	}

	if (argc == 2) {
33d11700:	e3550002 	cmp	r5, #2	; 0x2
		filename = argv[1];
33d11704:	05947004 	ldreq	r7, [r4, #4]
	/* pre-set Boot file name */
	if ((filename = getenv("bootfile")) == NULL) {
		filename = "uImage";
	}

	if (argc == 2) {
33d11708:	0a000008 	beq	33d11730 <do_jffs2_fsload+0x60>
		filename = argv[1];
	}
	if (argc == 3) {
33d1170c:	e3550003 	cmp	r5, #3	; 0x3
33d11710:	1a000006 	bne	33d11730 <do_jffs2_fsload+0x60>
		offset = simple_strtoul(argv[1], NULL, 16);
33d11714:	e5940004 	ldr	r0, [r4, #4]
33d11718:	e3a01000 	mov	r1, #0	; 0x0
33d1171c:	e3a02010 	mov	r2, #16	; 0x10
33d11720:	eb00238d 	bl	33d1a55c <simple_strtoul>
		load_addr = offset;
33d11724:	e5860000 	str	r0, [r6]
		filename = argv[2];
33d11728:	e5947008 	ldr	r7, [r4, #8]

	if (argc == 2) {
		filename = argv[1];
	}
	if (argc == 3) {
		offset = simple_strtoul(argv[1], NULL, 16);
33d1172c:	e1a0a000 	mov	sl, r0
		load_addr = offset;
		filename = argv[2];
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
33d11730:	ebfffe4b 	bl	33d11064 <mtdparts_init>
33d11734:	e3500000 	cmp	r0, #0	; 0x0
33d11738:	1a000038 	bne	33d11820 <do_jffs2_fsload+0x150>
		return 1;

	if ((part = jffs2_part_info(current_dev, current_partnum))){
33d1173c:	e59f30f4 	ldr	r3, [pc, #244]	; 33d11838 <do_jffs2_fsload+0x168>
33d11740:	e5930000 	ldr	r0, [r3]
33d11744:	e59f30f0 	ldr	r3, [pc, #240]	; 33d1183c <do_jffs2_fsload+0x16c>
33d11748:	e5d31000 	ldrb	r1, [r3]
33d1174c:	ebfff9d7 	bl	33d0feb0 <jffs2_part_info>
33d11750:	e2504000 	subs	r4, r0, #0	; 0x0
33d11754:	0a000031 	beq	33d11820 <do_jffs2_fsload+0x150>

		/* check partition type for cramfs */
		fsname = (cramfs_check(part) ? "CRAMFS" : "JFFS2");
33d11758:	eb003747 	bl	33d1f47c <cramfs_check>
33d1175c:	e59f20dc 	ldr	r2, [pc, #220]	; 33d11840 <do_jffs2_fsload+0x170>
33d11760:	e59f30dc 	ldr	r3, [pc, #220]	; 33d11844 <do_jffs2_fsload+0x174>
33d11764:	e3500000 	cmp	r0, #0	; 0x0
33d11768:	01a06002 	moveq	r6, r2
33d1176c:	11a06003 	movne	r6, r3
		printf("### %s loading '%s' to 0x%lx\n", fsname, filename, offset);
33d11770:	e1a01006 	mov	r1, r6
33d11774:	e59f00cc 	ldr	r0, [pc, #204]	; 33d11848 <do_jffs2_fsload+0x178>
33d11778:	e1a02007 	mov	r2, r7
33d1177c:	e1a0300a 	mov	r3, sl
33d11780:	eb001610 	bl	33d16fc8 <printf>

		if (cramfs_check(part)) {
33d11784:	e1a00004 	mov	r0, r4
33d11788:	eb00373b 	bl	33d1f47c <cramfs_check>
33d1178c:	e3500000 	cmp	r0, #0	; 0x0
33d11790:	0a000004 	beq	33d117a8 <do_jffs2_fsload+0xd8>
			size = cramfs_load ((char *) offset, part, filename);
33d11794:	e1a01004 	mov	r1, r4
33d11798:	e1a0000a 	mov	r0, sl
33d1179c:	e1a02007 	mov	r2, r7
33d117a0:	eb00361c 	bl	33d1f018 <cramfs_load>
33d117a4:	ea000003 	b	33d117b8 <do_jffs2_fsload+0xe8>
		} else {
			/* if this is not cramfs assume jffs2 */
			size = jffs2_1pass_load((char *)offset, part, filename);
33d117a8:	e1a01004 	mov	r1, r4
33d117ac:	e1a0000a 	mov	r0, sl
33d117b0:	e1a02007 	mov	r2, r7
33d117b4:	eb003df5 	bl	33d20f90 <jffs2_1pass_load>
		}

		if (size > 0) {
33d117b8:	e3500000 	cmp	r0, #0	; 0x0

		if (cramfs_check(part)) {
			size = cramfs_load ((char *) offset, part, filename);
		} else {
			/* if this is not cramfs assume jffs2 */
			size = jffs2_1pass_load((char *)offset, part, filename);
33d117bc:	e1a05000 	mov	r5, r0
		}

		if (size > 0) {
33d117c0:	da00000d 	ble	33d117fc <do_jffs2_fsload+0x12c>
			char buf[10];
			printf("### %s load complete: %d bytes loaded to 0x%lx\n",
33d117c4:	e1a01006 	mov	r1, r6
33d117c8:	e1a0300a 	mov	r3, sl
33d117cc:	e1a02000 	mov	r2, r0
33d117d0:	e59f0074 	ldr	r0, [pc, #116]	; 33d1184c <do_jffs2_fsload+0x17c>
33d117d4:	eb0015fb 	bl	33d16fc8 <printf>
				fsname, size, offset);
			sprintf(buf, "%x", size);
33d117d8:	e1a0000d 	mov	r0, sp
33d117dc:	e59f106c 	ldr	r1, [pc, #108]	; 33d11850 <do_jffs2_fsload+0x180>
33d117e0:	e1a02005 	mov	r2, r5
33d117e4:	eb002542 	bl	33d1acf4 <sprintf>
			setenv("filesize", buf);
33d117e8:	e1a0100d 	mov	r1, sp
33d117ec:	e59f0060 	ldr	r0, [pc, #96]	; 33d11854 <do_jffs2_fsload+0x184>

		if (size > 0) {
			char buf[10];
			printf("### %s load complete: %d bytes loaded to 0x%lx\n",
				fsname, size, offset);
			sprintf(buf, "%x", size);
33d117f0:	e1a0400d 	mov	r4, sp
			setenv("filesize", buf);
33d117f4:	eb000ff7 	bl	33d157d8 <setenv>
33d117f8:	ea000004 	b	33d11810 <do_jffs2_fsload+0x140>
		} else {
			printf("### %s LOAD ERROR<%x> for %s!\n", fsname, size, filename);
33d117fc:	e1a01006 	mov	r1, r6
33d11800:	e1a03007 	mov	r3, r7
33d11804:	e59f004c 	ldr	r0, [pc, #76]	; 33d11858 <do_jffs2_fsload+0x188>
33d11808:	e1a02005 	mov	r2, r5
33d1180c:	eb0015ed 	bl	33d16fc8 <printf>
		}

		return !(size > 0);
33d11810:	e3550000 	cmp	r5, #0	; 0x0
33d11814:	c3a00000 	movgt	r0, #0	; 0x0
33d11818:	d3a00001 	movle	r0, #1	; 0x1
33d1181c:	ea000000 	b	33d11824 <do_jffs2_fsload+0x154>
	}
	return 1;
33d11820:	e3a00001 	mov	r0, #1	; 0x1
}
33d11824:	e28dd00c 	add	sp, sp, #12	; 0xc
33d11828:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d1182c:	33d35fec 	.word	0x33d35fec
33d11830:	33d25520 	.word	0x33d25520
33d11834:	33d29820 	.word	0x33d29820
33d11838:	33d608d8 	.word	0x33d608d8
33d1183c:	33d608dc 	.word	0x33d608dc
33d11840:	33d29828 	.word	0x33d29828
33d11844:	33d29830 	.word	0x33d29830
33d11848:	33d29838 	.word	0x33d29838
33d1184c:	33d29858 	.word	0x33d29858
33d11850:	33d27428 	.word	0x33d27428
33d11854:	33d25954 	.word	0x33d25954
33d11858:	33d29888 	.word	0x33d29888

33d1185c <do_jffs2_ls>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_ls(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d1185c:	e92d4030 	push	{r4, r5, lr}
	char *filename = "/";
	int ret;
	struct part_info *part;

	if (argc == 2)
33d11860:	e3520002 	cmp	r2, #2	; 0x2
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_ls(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	char *filename = "/";
33d11864:	e59f5064 	ldr	r5, [pc, #100]	; 33d118d0 <do_jffs2_ls+0x74>
	int ret;
	struct part_info *part;

	if (argc == 2)
		filename = argv[1];
33d11868:	05935004 	ldreq	r5, [r3, #4]

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
33d1186c:	ebfffdfc 	bl	33d11064 <mtdparts_init>
33d11870:	e3500000 	cmp	r0, #0	; 0x0
		return 1;
33d11874:	13a00001 	movne	r0, #1	; 0x1

	if (argc == 2)
		filename = argv[1];

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
33d11878:	18bd8030 	popne	{r4, r5, pc}
		return 1;

	if ((part = jffs2_part_info(current_dev, current_partnum))){
33d1187c:	e59f3050 	ldr	r3, [pc, #80]	; 33d118d4 <do_jffs2_ls+0x78>
33d11880:	e5930000 	ldr	r0, [r3]
33d11884:	e59f304c 	ldr	r3, [pc, #76]	; 33d118d8 <do_jffs2_ls+0x7c>
33d11888:	e5d31000 	ldrb	r1, [r3]
33d1188c:	ebfff987 	bl	33d0feb0 <jffs2_part_info>
33d11890:	e2504000 	subs	r4, r0, #0	; 0x0
			ret = jffs2_1pass_ls(part, filename);
		}

		return ret ? 0 : 1;
	}
	return 1;
33d11894:	03a00001 	moveq	r0, #1	; 0x1

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
		return 1;

	if ((part = jffs2_part_info(current_dev, current_partnum))){
33d11898:	08bd8030 	popeq	{r4, r5, pc}

		/* check partition type for cramfs */
		if (cramfs_check(part)) {
33d1189c:	eb0036f6 	bl	33d1f47c <cramfs_check>
33d118a0:	e3500000 	cmp	r0, #0	; 0x0
33d118a4:	0a000003 	beq	33d118b8 <do_jffs2_ls+0x5c>
			ret = cramfs_ls (part, filename);
33d118a8:	e1a00004 	mov	r0, r4
33d118ac:	e1a01005 	mov	r1, r5
33d118b0:	eb003665 	bl	33d1f24c <cramfs_ls>
33d118b4:	ea000002 	b	33d118c4 <do_jffs2_ls+0x68>
		} else {
			/* if this is not cramfs assume jffs2 */
			ret = jffs2_1pass_ls(part, filename);
33d118b8:	e1a00004 	mov	r0, r4
33d118bc:	e1a01005 	mov	r1, r5
33d118c0:	eb003b89 	bl	33d206ec <jffs2_1pass_ls>
		}

		return ret ? 0 : 1;
33d118c4:	e2700001 	rsbs	r0, r0, #1	; 0x1
33d118c8:	33a00000 	movcc	r0, #0	; 0x0
33d118cc:	e8bd8030 	pop	{r4, r5, pc}
33d118d0:	33d298a8 	.word	0x33d298a8
33d118d4:	33d608d8 	.word	0x33d608d8
33d118d8:	33d608dc 	.word	0x33d608dc

33d118dc <do_jffs2_fsinfo>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_fsinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d118dc:	e92d4010 	push	{r4, lr}
	struct part_info *part;
	char *fsname;
	int ret;

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
33d118e0:	ebfffddf 	bl	33d11064 <mtdparts_init>
33d118e4:	e3500000 	cmp	r0, #0	; 0x0
		return 1;
33d118e8:	e3a00001 	mov	r0, #1	; 0x1
	struct part_info *part;
	char *fsname;
	int ret;

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
33d118ec:	18bd8010 	popne	{r4, pc}
		return 1;

	if ((part = jffs2_part_info(current_dev, current_partnum))){
33d118f0:	e59f3064 	ldr	r3, [pc, #100]	; 33d1195c <do_jffs2_fsinfo+0x80>
33d118f4:	e5d31000 	ldrb	r1, [r3]
33d118f8:	e59f3060 	ldr	r3, [pc, #96]	; 33d11960 <do_jffs2_fsinfo+0x84>
33d118fc:	e5930000 	ldr	r0, [r3]
33d11900:	ebfff96a 	bl	33d0feb0 <jffs2_part_info>
33d11904:	e2504000 	subs	r4, r0, #0	; 0x0
			ret = jffs2_1pass_info(part);
		}

		return ret ? 0 : 1;
	}
	return 1;
33d11908:	03a00001 	moveq	r0, #1	; 0x1

	/* make sure we are in sync with env variables */
	if (mtdparts_init() !=0)
		return 1;

	if ((part = jffs2_part_info(current_dev, current_partnum))){
33d1190c:	08bd8010 	popeq	{r4, pc}

		/* check partition type for cramfs */
		fsname = (cramfs_check(part) ? "CRAMFS" : "JFFS2");
33d11910:	eb0036d9 	bl	33d1f47c <cramfs_check>
33d11914:	e59f3048 	ldr	r3, [pc, #72]	; 33d11964 <do_jffs2_fsinfo+0x88>
33d11918:	e3500000 	cmp	r0, #0	; 0x0
33d1191c:	e59f1044 	ldr	r1, [pc, #68]	; 33d11968 <do_jffs2_fsinfo+0x8c>
		printf("### filesystem type is %s\n", fsname);
33d11920:	e59f0044 	ldr	r0, [pc, #68]	; 33d1196c <do_jffs2_fsinfo+0x90>
		return 1;

	if ((part = jffs2_part_info(current_dev, current_partnum))){

		/* check partition type for cramfs */
		fsname = (cramfs_check(part) ? "CRAMFS" : "JFFS2");
33d11924:	11a01003 	movne	r1, r3
		printf("### filesystem type is %s\n", fsname);
33d11928:	eb0015a6 	bl	33d16fc8 <printf>

		if (cramfs_check(part)) {
33d1192c:	e1a00004 	mov	r0, r4
33d11930:	eb0036d1 	bl	33d1f47c <cramfs_check>
33d11934:	e3500000 	cmp	r0, #0	; 0x0
			ret = cramfs_info (part);
33d11938:	e1a00004 	mov	r0, r4

		/* check partition type for cramfs */
		fsname = (cramfs_check(part) ? "CRAMFS" : "JFFS2");
		printf("### filesystem type is %s\n", fsname);

		if (cramfs_check(part)) {
33d1193c:	0a000001 	beq	33d11948 <do_jffs2_fsinfo+0x6c>
			ret = cramfs_info (part);
33d11940:	eb00369b 	bl	33d1f3b4 <cramfs_info>
33d11944:	ea000001 	b	33d11950 <do_jffs2_fsinfo+0x74>
		} else {
			/* if this is not cramfs assume jffs2 */
			ret = jffs2_1pass_info(part);
33d11948:	e1a00004 	mov	r0, r4
33d1194c:	eb003e8b 	bl	33d21380 <jffs2_1pass_info>
		}

		return ret ? 0 : 1;
33d11950:	e2700001 	rsbs	r0, r0, #1	; 0x1
33d11954:	33a00000 	movcc	r0, #0	; 0x0
33d11958:	e8bd8010 	pop	{r4, pc}
33d1195c:	33d608dc 	.word	0x33d608dc
33d11960:	33d608d8 	.word	0x33d608d8
33d11964:	33d29830 	.word	0x33d29830
33d11968:	33d29828 	.word	0x33d29828
33d1196c:	33d298ac 	.word	0x33d298ac

33d11970 <do_jffs2_chpart>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_chpart(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d11970:	e92d4030 	push	{r4, r5, lr}
33d11974:	e24dd00c 	sub	sp, sp, #12	; 0xc
33d11978:	e1a04002 	mov	r4, r2
33d1197c:	e1a05003 	mov	r5, r3
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
33d11980:	ebfffdb7 	bl	33d11064 <mtdparts_init>
33d11984:	e3500000 	cmp	r0, #0	; 0x0
		return 1;
33d11988:	e3a00001 	mov	r0, #1	; 0x1
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
33d1198c:	1a000020 	bne	33d11a14 <do_jffs2_chpart+0xa4>
		return 1;

	if (argc < 2) {
33d11990:	e3540001 	cmp	r4, #1	; 0x1
		printf("no partition id specified\n");
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
33d11994:	e28d1004 	add	r1, sp, #4	; 0x4
33d11998:	e28d200b 	add	r2, sp, #11	; 0xb
33d1199c:	e1a0300d 	mov	r3, sp

	if (mtdparts_init() !=0)
		return 1;

	if (argc < 2) {
		printf("no partition id specified\n");
33d119a0:	e59f0074 	ldr	r0, [pc, #116]	; 33d11a1c <do_jffs2_chpart+0xac>
	u8 pnum;

	if (mtdparts_init() !=0)
		return 1;

	if (argc < 2) {
33d119a4:	ca000002 	bgt	33d119b4 <do_jffs2_chpart+0x44>
		printf("no partition id specified\n");
33d119a8:	eb001586 	bl	33d16fc8 <printf>
		return 1;
33d119ac:	e3a00001 	mov	r0, #1	; 0x1
33d119b0:	ea000017 	b	33d11a14 <do_jffs2_chpart+0xa4>
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
33d119b4:	e5950004 	ldr	r0, [r5, #4]
33d119b8:	ebfffd40 	bl	33d10ec0 <find_dev_and_part>
33d119bc:	e2504000 	subs	r4, r0, #0	; 0x0
		return 1;
33d119c0:	e3a00001 	mov	r0, #1	; 0x1
	if (argc < 2) {
		printf("no partition id specified\n");
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
33d119c4:	1a000012 	bne	33d11a14 <do_jffs2_chpart+0xa4>
		return 1;

	current_dev = dev;
33d119c8:	e59d2004 	ldr	r2, [sp, #4]
33d119cc:	e59f304c 	ldr	r3, [pc, #76]	; 33d11a20 <do_jffs2_chpart+0xb0>
	current_partnum = pnum;
33d119d0:	e5dd100b 	ldrb	r1, [sp, #11]
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
		return 1;

	current_dev = dev;
33d119d4:	e5832000 	str	r2, [r3]
	current_partnum = pnum;
33d119d8:	e59f3044 	ldr	r3, [pc, #68]	; 33d11a24 <do_jffs2_chpart+0xb4>
33d119dc:	e5c31000 	strb	r1, [r3]
	current_save();
33d119e0:	ebfff990 	bl	33d10028 <current_save>

	printf("partition changed to %s%d,%d\n",
33d119e4:	e59d3004 	ldr	r3, [sp, #4]
33d119e8:	e5930008 	ldr	r0, [r3, #8]
33d119ec:	e5d02008 	ldrb	r2, [r0, #8]
33d119f0:	e59f3030 	ldr	r3, [pc, #48]	; 33d11a28 <do_jffs2_chpart+0xb8>
33d119f4:	e3520002 	cmp	r2, #2	; 0x2
33d119f8:	e59f102c 	ldr	r1, [pc, #44]	; 33d11a2c <do_jffs2_chpart+0xbc>
33d119fc:	e5d02009 	ldrb	r2, [r0, #9]
33d11a00:	11a01003 	movne	r1, r3
33d11a04:	e59f0024 	ldr	r0, [pc, #36]	; 33d11a30 <do_jffs2_chpart+0xc0>
33d11a08:	e5dd300b 	ldrb	r3, [sp, #11]
33d11a0c:	eb00156d 	bl	33d16fc8 <printf>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
33d11a10:	e1a00004 	mov	r0, r4
}
33d11a14:	e28dd00c 	add	sp, sp, #12	; 0xc
33d11a18:	e8bd8030 	pop	{r4, r5, pc}
33d11a1c:	33d298c8 	.word	0x33d298c8
33d11a20:	33d608d8 	.word	0x33d608d8
33d11a24:	33d608dc 	.word	0x33d608dc
33d11a28:	33d29274 	.word	0x33d29274
33d11a2c:	33d29278 	.word	0x33d29278
33d11a30:	33d298e4 	.word	0x33d298e4

33d11a34 <do_jffs2_mtdparts>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d11a34:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}

	if (argc == 2) {
33d11a38:	e3520002 	cmp	r2, #2	; 0x2
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_jffs2_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d11a3c:	e24dd05c 	sub	sp, sp, #92	; 0x5c
33d11a40:	e1a06002 	mov	r6, r2
33d11a44:	e1a07000 	mov	r7, r0
33d11a48:	e1a05003 	mov	r5, r3

	if (argc == 2) {
33d11a4c:	1a00001b 	bne	33d11ac0 <do_jffs2_mtdparts+0x8c>
		if (strcmp(argv[1], "default") == 0) {
33d11a50:	e5930004 	ldr	r0, [r3, #4]
33d11a54:	e59f14f0 	ldr	r1, [pc, #1264]	; 33d11f4c <do_jffs2_mtdparts+0x518>
33d11a58:	eb002182 	bl	33d1a068 <strcmp>
33d11a5c:	e2504000 	subs	r4, r0, #0	; 0x0
33d11a60:	1a00000b 	bne	33d11a94 <do_jffs2_mtdparts+0x60>
			setenv("mtdids", (char *)mtdids_default);
33d11a64:	e59f04e4 	ldr	r0, [pc, #1252]	; 33d11f50 <do_jffs2_mtdparts+0x51c>
33d11a68:	e59f14e4 	ldr	r1, [pc, #1252]	; 33d11f54 <do_jffs2_mtdparts+0x520>
33d11a6c:	eb000f59 	bl	33d157d8 <setenv>
			setenv("mtdparts", (char *)mtdparts_default);
33d11a70:	e59f04e0 	ldr	r0, [pc, #1248]	; 33d11f58 <do_jffs2_mtdparts+0x524>
33d11a74:	e59f14e0 	ldr	r1, [pc, #1248]	; 33d11f5c <do_jffs2_mtdparts+0x528>
33d11a78:	eb000f56 	bl	33d157d8 <setenv>
			setenv("partition", NULL);
33d11a7c:	e59f04dc 	ldr	r0, [pc, #1244]	; 33d11f60 <do_jffs2_mtdparts+0x52c>
33d11a80:	e1a01004 	mov	r1, r4
33d11a84:	eb000f53 	bl	33d157d8 <setenv>

			mtdparts_init();
33d11a88:	ebfffd75 	bl	33d11064 <mtdparts_init>
			return 0;
33d11a8c:	e1a00004 	mov	r0, r4
33d11a90:	ea00012b 	b	33d11f44 <do_jffs2_mtdparts+0x510>
		} else if (strcmp(argv[1], "delall") == 0) {
33d11a94:	e5950004 	ldr	r0, [r5, #4]
33d11a98:	e59f14c4 	ldr	r1, [pc, #1220]	; 33d11f64 <do_jffs2_mtdparts+0x530>
33d11a9c:	eb002171 	bl	33d1a068 <strcmp>
33d11aa0:	e2504000 	subs	r4, r0, #0	; 0x0
33d11aa4:	1a000005 	bne	33d11ac0 <do_jffs2_mtdparts+0x8c>
			/* this may be the first run, initialize lists if needed */
			mtdparts_init();
33d11aa8:	ebfffd6d 	bl	33d11064 <mtdparts_init>

			setenv("mtdparts", NULL);
33d11aac:	e1a01004 	mov	r1, r4
33d11ab0:	e59f04a0 	ldr	r0, [pc, #1184]	; 33d11f58 <do_jffs2_mtdparts+0x524>
33d11ab4:	eb000f47 	bl	33d157d8 <setenv>

			/* devices_init() calls current_save() */
			return devices_init();
33d11ab8:	ebfffac0 	bl	33d105c0 <devices_init>
33d11abc:	ea000120 	b	33d11f44 <do_jffs2_mtdparts+0x510>
		}
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() != 0)
33d11ac0:	ebfffd67 	bl	33d11064 <mtdparts_init>
33d11ac4:	e3500000 	cmp	r0, #0	; 0x0
33d11ac8:	1a00011c 	bne	33d11f40 <do_jffs2_mtdparts+0x50c>
		return 1;

	if (argc == 1) {
33d11acc:	e3560001 	cmp	r6, #1	; 0x1
33d11ad0:	1a000052 	bne	33d11c20 <do_jffs2_mtdparts+0x1ec>
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	DEBUGF("\n---list_partitions---\n");
	list_for_each(dentry, &devices) {
33d11ad4:	e59fa48c 	ldr	sl, [pc, #1164]	; 33d11f68 <do_jffs2_mtdparts+0x534>
33d11ad8:	e59a5000 	ldr	r5, [sl]
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d11adc:	e155000a 	cmp	r5, sl
33d11ae0:	0a000022 	beq	33d11b70 <do_jffs2_mtdparts+0x13c>
		dev = list_entry(dentry, struct mtd_device, link);
		printf("\ndevice %s%d <%s>, # parts = %d\n",
33d11ae4:	e5952008 	ldr	r2, [r5, #8]
33d11ae8:	e5d2c008 	ldrb	ip, [r2, #8]
33d11aec:	e59f0478 	ldr	r0, [pc, #1144]	; 33d11f6c <do_jffs2_mtdparts+0x538>
33d11af0:	e35c0002 	cmp	ip, #2	; 0x2
33d11af4:	e1d5e0bc 	ldrh	lr, [r5, #12]
33d11af8:	e5923010 	ldr	r3, [r2, #16]
33d11afc:	e59f146c 	ldr	r1, [pc, #1132]	; 33d11f70 <do_jffs2_mtdparts+0x53c>
33d11b00:	e5d22009 	ldrb	r2, [r2, #9]
33d11b04:	11a01000 	movne	r1, r0
33d11b08:	e59f0464 	ldr	r0, [pc, #1124]	; 33d11f74 <do_jffs2_mtdparts+0x540>
33d11b0c:	e58de000 	str	lr, [sp]
33d11b10:	eb00152c 	bl	33d16fc8 <printf>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\t\tsize\t\toffset\t\tmask_flags\n");
33d11b14:	e59f045c 	ldr	r0, [pc, #1116]	; 33d11f78 <do_jffs2_mtdparts+0x544>
33d11b18:	eb00152a 	bl	33d16fc8 <printf>

		/* list partitions for given device */
		part_num = 0;
		list_for_each(pentry, &dev->parts) {
33d11b1c:	e5950010 	ldr	r0, [r5, #16]
33d11b20:	e2857010 	add	r7, r5, #16	; 0x10
33d11b24:	e1500007 	cmp	r0, r7
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\t\tsize\t\toffset\t\tmask_flags\n");

		/* list partitions for given device */
		part_num = 0;
33d11b28:	e3a06000 	mov	r6, #0	; 0x0
33d11b2c:	0a00000d 	beq	33d11b68 <do_jffs2_mtdparts+0x134>
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
33d11b30:	e5901014 	ldr	r1, [r0, #20]
33d11b34:	e5902008 	ldr	r2, [r0, #8]
33d11b38:	e5903010 	ldr	r3, [r0, #16]
33d11b3c:	e58d1000 	str	r1, [sp]
33d11b40:	e590c01c 	ldr	ip, [r0, #28]
		printf(" #: name\t\t\tsize\t\toffset\t\tmask_flags\n");

		/* list partitions for given device */
		part_num = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
33d11b44:	e1a04000 	mov	r4, r0
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
33d11b48:	e1a01006 	mov	r1, r6
33d11b4c:	e59f0428 	ldr	r0, [pc, #1064]	; 33d11f7c <do_jffs2_mtdparts+0x548>
33d11b50:	e58dc004 	str	ip, [sp, #4]
33d11b54:	eb00151b 	bl	33d16fc8 <printf>
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\t\tsize\t\toffset\t\tmask_flags\n");

		/* list partitions for given device */
		part_num = 0;
		list_for_each(pentry, &dev->parts) {
33d11b58:	e5940000 	ldr	r0, [r4]
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					part->offset, part->mask_flags);

			part_num++;
33d11b5c:	e2866001 	add	r6, r6, #1	; 0x1
33d11b60:	e1500007 	cmp	r0, r7
33d11b64:	eafffff0 	b	33d11b2c <do_jffs2_mtdparts+0xf8>
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	DEBUGF("\n---list_partitions---\n");
	list_for_each(dentry, &devices) {
33d11b68:	e5955000 	ldr	r5, [r5]
33d11b6c:	eaffffda 	b	33d11adc <do_jffs2_mtdparts+0xa8>
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d11b70:	e59f23f0 	ldr	r2, [pc, #1008]	; 33d11f68 <do_jffs2_mtdparts+0x534>
	return head->next == head;
33d11b74:	e5923000 	ldr	r3, [r2]
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d11b78:	e1530002 	cmp	r3, r2

			part_num++;
		}
	}
	if (list_empty(&devices))
		printf("no partitions defined\n");
33d11b7c:	059f03fc 	ldreq	r0, [pc, #1020]	; 33d11f80 <do_jffs2_mtdparts+0x54c>
33d11b80:	0b001510 	bleq	33d16fc8 <printf>

	/* current_dev is not NULL only when we have non empty device list */
	if (current_dev) {
33d11b84:	e59f53f8 	ldr	r5, [pc, #1016]	; 33d11f84 <do_jffs2_mtdparts+0x550>
33d11b88:	e5950000 	ldr	r0, [r5]
33d11b8c:	e3500000 	cmp	r0, #0	; 0x0
33d11b90:	0a000018 	beq	33d11bf8 <do_jffs2_mtdparts+0x1c4>
		part = jffs2_part_info(current_dev, current_partnum);
33d11b94:	e59f63ec 	ldr	r6, [pc, #1004]	; 33d11f88 <do_jffs2_mtdparts+0x554>
33d11b98:	e5d61000 	ldrb	r1, [r6]
33d11b9c:	ebfff8c3 	bl	33d0feb0 <jffs2_part_info>
		if (part) {
33d11ba0:	e2504000 	subs	r4, r0, #0	; 0x0
33d11ba4:	0a000011 	beq	33d11bf0 <do_jffs2_mtdparts+0x1bc>
			printf("\nactive partition: %s%d,%d - (%s) 0x%08lx @ 0x%08lx\n",
33d11ba8:	e5953000 	ldr	r3, [r5]
33d11bac:	e5941008 	ldr	r1, [r4, #8]
33d11bb0:	e5933008 	ldr	r3, [r3, #8]
33d11bb4:	e5d3e008 	ldrb	lr, [r3, #8]
33d11bb8:	e5d32009 	ldrb	r2, [r3, #9]
33d11bbc:	e58d1000 	str	r1, [sp]
33d11bc0:	e5943010 	ldr	r3, [r4, #16]
33d11bc4:	e58d3004 	str	r3, [sp, #4]
33d11bc8:	e59f039c 	ldr	r0, [pc, #924]	; 33d11f6c <do_jffs2_mtdparts+0x538>
33d11bcc:	e594c014 	ldr	ip, [r4, #20]
33d11bd0:	e35e0002 	cmp	lr, #2	; 0x2
33d11bd4:	e5d63000 	ldrb	r3, [r6]
33d11bd8:	e59f1390 	ldr	r1, [pc, #912]	; 33d11f70 <do_jffs2_mtdparts+0x53c>
33d11bdc:	11a01000 	movne	r1, r0
33d11be0:	e59f03a4 	ldr	r0, [pc, #932]	; 33d11f8c <do_jffs2_mtdparts+0x558>
33d11be4:	e58dc008 	str	ip, [sp, #8]
33d11be8:	eb0014f6 	bl	33d16fc8 <printf>
33d11bec:	ea000001 	b	33d11bf8 <do_jffs2_mtdparts+0x1c4>
					MTD_DEV_TYPE(current_dev->id->type),
					current_dev->id->num, current_partnum,
					part->name, part->size, part->offset);
		} else {
			printf("could not get current partition info\n\n");
33d11bf0:	e59f0398 	ldr	r0, [pc, #920]	; 33d11f90 <do_jffs2_mtdparts+0x55c>
33d11bf4:	eb0014f3 	bl	33d16fc8 <printf>
		}
	}

	printf("\ndefaults:\n");
33d11bf8:	e59f0394 	ldr	r0, [pc, #916]	; 33d11f94 <do_jffs2_mtdparts+0x560>
33d11bfc:	eb0014f1 	bl	33d16fc8 <printf>
	printf("mtdids  : %s\n", mtdids_default);
33d11c00:	e59f0390 	ldr	r0, [pc, #912]	; 33d11f98 <do_jffs2_mtdparts+0x564>
33d11c04:	e59f1348 	ldr	r1, [pc, #840]	; 33d11f54 <do_jffs2_mtdparts+0x520>
33d11c08:	eb0014ee 	bl	33d16fc8 <printf>
	printf("mtdparts: %s\n", mtdparts_default);
33d11c0c:	e59f0388 	ldr	r0, [pc, #904]	; 33d11f9c <do_jffs2_mtdparts+0x568>
33d11c10:	e59f1344 	ldr	r1, [pc, #836]	; 33d11f5c <do_jffs2_mtdparts+0x528>
33d11c14:	eb0014eb 	bl	33d16fc8 <printf>
	if (mtdparts_init() != 0)
		return 1;

	if (argc == 1) {
		list_partitions();
		return 0;
33d11c18:	e3a00000 	mov	r0, #0	; 0x0
33d11c1c:	ea0000c8 	b	33d11f44 <do_jffs2_mtdparts+0x510>
	}

	/* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] */
	if (((argc == 5) || (argc == 6)) && (strcmp(argv[1], "add") == 0)) {
33d11c20:	e2463005 	sub	r3, r6, #5	; 0x5
33d11c24:	e3530001 	cmp	r3, #1	; 0x1
33d11c28:	8a00007a 	bhi	33d11e18 <do_jffs2_mtdparts+0x3e4>
33d11c2c:	e5950004 	ldr	r0, [r5, #4]
33d11c30:	e59f1368 	ldr	r1, [pc, #872]	; 33d11fa0 <do_jffs2_mtdparts+0x56c>
33d11c34:	eb00210b 	bl	33d1a068 <strcmp>
33d11c38:	e3500000 	cmp	r0, #0	; 0x0
33d11c3c:	1a000075 	bne	33d11e18 <do_jffs2_mtdparts+0x3e4>
		struct mtd_device *dev;
		struct mtd_device *dev_tmp;
		struct mtdids *id;
		struct part_info *p;

		if (id_parse(argv[2], NULL, &type, &num) != 0)
33d11c40:	e1a01000 	mov	r1, r0
33d11c44:	e28d201b 	add	r2, sp, #27	; 0x1b
33d11c48:	e5950008 	ldr	r0, [r5, #8]
33d11c4c:	e28d301a 	add	r3, sp, #26	; 0x1a
33d11c50:	ebfffbb1 	bl	33d10b1c <id_parse>
33d11c54:	e3500000 	cmp	r0, #0	; 0x0
33d11c58:	1a0000b8 	bne	33d11f40 <do_jffs2_mtdparts+0x50c>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
33d11c5c:	e59f1340 	ldr	r1, [pc, #832]	; 33d11fa4 <do_jffs2_mtdparts+0x570>
33d11c60:	e5912000 	ldr	r2, [r1]
 * Search global mtdids list and find id of requested type and number.
 *
 * @return pointer to the id if it exists, NULL otherwise
 */
static struct mtdids* id_find(u8 type, u8 num)
{
33d11c64:	e5ddc01b 	ldrb	ip, [sp, #27]
33d11c68:	e5dd001a 	ldrb	r0, [sp, #26]
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifndef ARCH_HAS_PREFETCH
#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x) {;}
33d11c6c:	e1520001 	cmp	r2, r1
33d11c70:	0a00000a 	beq	33d11ca0 <do_jffs2_mtdparts+0x26c>
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
		id = list_entry(entry, struct mtdids, link);

		if ((id->type == type) && (id->num == num))
33d11c74:	e5d23008 	ldrb	r3, [r2, #8]
33d11c78:	e153000c 	cmp	r3, ip
33d11c7c:	1a000002 	bne	33d11c8c <do_jffs2_mtdparts+0x258>
33d11c80:	e5d23009 	ldrb	r3, [r2, #9]
33d11c84:	e1530000 	cmp	r3, r0
33d11c88:	0a000002 	beq	33d11c98 <do_jffs2_mtdparts+0x264>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
33d11c8c:	e5922000 	ldr	r2, [r2]
33d11c90:	e1520001 	cmp	r2, r1
33d11c94:	eafffff5 	b	33d11c70 <do_jffs2_mtdparts+0x23c>
 * Search global mtdids list and find id of requested type and number.
 *
 * @return pointer to the id if it exists, NULL otherwise
 */
static struct mtdids* id_find(u8 type, u8 num)
{
33d11c98:	e2526000 	subs	r6, r2, #0	; 0x0
33d11c9c:	1a000002 	bne	33d11cac <do_jffs2_mtdparts+0x278>

		if (id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
33d11ca0:	e5951008 	ldr	r1, [r5, #8]
33d11ca4:	e59f02fc 	ldr	r0, [pc, #764]	; 33d11fa8 <do_jffs2_mtdparts+0x574>
33d11ca8:	ea0000a3 	b	33d11f3c <do_jffs2_mtdparts+0x508>
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
33d11cac:	e5960010 	ldr	r0, [r6, #16]
33d11cb0:	eb002116 	bl	33d1a110 <strlen>
33d11cb4:	e2803001 	add	r3, r0, #1	; 0x1
		len += strlen(argv[3]);		/* size@offset */
33d11cb8:	e595000c 	ldr	r0, [r5, #12]
		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
33d11cbc:	e20340ff 	and	r4, r3, #255	; 0xff
		len += strlen(argv[3]);		/* size@offset */
33d11cc0:	eb002112 	bl	33d1a110 <strlen>
33d11cc4:	e0843000 	add	r3, r4, r0
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
33d11cc8:	e5950010 	ldr	r0, [r5, #16]
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
33d11ccc:	e20340ff 	and	r4, r3, #255	; 0xff
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
33d11cd0:	eb00210e 	bl	33d1a110 <strlen>
		if (argv[5] && (strlen(argv[5]) == 2))
33d11cd4:	e5953014 	ldr	r3, [r5, #20]
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
33d11cd8:	e0840000 	add	r0, r4, r0
33d11cdc:	e2800002 	add	r0, r0, #2	; 0x2
		if (argv[5] && (strlen(argv[5]) == 2))
33d11ce0:	e3530000 	cmp	r3, #0	; 0x0
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
33d11ce4:	e20040ff 	and	r4, r0, #255	; 0xff
		if (argv[5] && (strlen(argv[5]) == 2))
33d11ce8:	0a000004 	beq	33d11d00 <do_jffs2_mtdparts+0x2cc>
33d11cec:	e1a00003 	mov	r0, r3
33d11cf0:	eb002106 	bl	33d1a110 <strlen>
33d11cf4:	e3500002 	cmp	r0, #2	; 0x2
			len += 2;		/* 'ro' */
33d11cf8:	02843002 	addeq	r3, r4, #2	; 0x2
33d11cfc:	020340ff 	andeq	r4, r3, #255	; 0xff

		if (len >= PART_ADD_DESC_MAXLEN) {
33d11d00:	e354003f 	cmp	r4, #63	; 0x3f
			printf("too long partition description\n");
33d11d04:	859f02a0 	ldrhi	r0, [pc, #672]	; 33d11fac <do_jffs2_mtdparts+0x578>
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
			len += 2;		/* 'ro' */

		if (len >= PART_ADD_DESC_MAXLEN) {
33d11d08:	8a000040 	bhi	33d11e10 <do_jffs2_mtdparts+0x3dc>
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
33d11d0c:	e595c014 	ldr	ip, [r5, #20]
33d11d10:	e59f1298 	ldr	r1, [pc, #664]	; 33d11fb0 <do_jffs2_mtdparts+0x57c>
33d11d14:	e595e010 	ldr	lr, [r5, #16]
33d11d18:	e35c0000 	cmp	ip, #0	; 0x0
33d11d1c:	e28d401c 	add	r4, sp, #28	; 0x1c
33d11d20:	01a0c001 	moveq	ip, r1
33d11d24:	e5962010 	ldr	r2, [r6, #16]
33d11d28:	e595300c 	ldr	r3, [r5, #12]
33d11d2c:	e59f1280 	ldr	r1, [pc, #640]	; 33d11fb4 <do_jffs2_mtdparts+0x580>
33d11d30:	e1a00004 	mov	r0, r4
33d11d34:	e58de000 	str	lr, [sp]
33d11d38:	e58dc004 	str	ip, [sp, #4]
33d11d3c:	eb0023ec 	bl	33d1acf4 <sprintf>
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		DEBUGF("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
33d11d40:	e1a00004 	mov	r0, r4
33d11d44:	e3a01000 	mov	r1, #0	; 0x0
33d11d48:	e28d2014 	add	r2, sp, #20	; 0x14
33d11d4c:	ebfffa28 	bl	33d105f4 <device_parse>
33d11d50:	e3500000 	cmp	r0, #0	; 0x0
33d11d54:	1a000079 	bne	33d11f40 <do_jffs2_mtdparts+0x50c>
33d11d58:	e59d3014 	ldr	r3, [sp, #20]
33d11d5c:	e3530000 	cmp	r3, #0	; 0x0
33d11d60:	0a000076 	beq	33d11f40 <do_jffs2_mtdparts+0x50c>
			return 1;

		DEBUGF("+ %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		if ((dev_tmp = device_find(dev->id->type, dev->id->num)) == NULL) {
33d11d64:	e5933008 	ldr	r3, [r3, #8]
33d11d68:	e5d31009 	ldrb	r1, [r3, #9]
33d11d6c:	e5d30008 	ldrb	r0, [r3, #8]
33d11d70:	ebfff9fc 	bl	33d10568 <device_find>
33d11d74:	e2504000 	subs	r4, r0, #0	; 0x0
33d11d78:	e59d1014 	ldr	r1, [sp, #20]
33d11d7c:	1a00000f 	bne	33d11dc0 <do_jffs2_mtdparts+0x38c>
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d11d80:	e59f21e0 	ldr	r2, [pc, #480]	; 33d11f68 <do_jffs2_mtdparts+0x534>
	return head->next == head;
33d11d84:	e5923000 	ldr	r3, [r2]
/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
33d11d88:	e1530002 	cmp	r3, r2
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
		current_dev = dev;
		current_partnum = 0;
33d11d8c:	059f31f4 	ldreq	r3, [pc, #500]	; 33d11f88 <do_jffs2_mtdparts+0x554>
33d11d90:	05c34000 	strbeq	r4, [r3]
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
		current_dev = dev;
33d11d94:	059f31e8 	ldreq	r3, [pc, #488]	; 33d11f84 <do_jffs2_mtdparts+0x550>
33d11d98:	05831000 	streq	r1, [r3]
 *
 * @param dev device to be added
 */
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;
33d11d9c:	e1a00004 	mov	r0, r4
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
33d11da0:	e5923004 	ldr	r3, [r2, #4]

	if (list_empty(&devices)) {
		current_dev = dev;
		current_partnum = 0;
		current_save_needed = 1;
33d11da4:	03a00001 	moveq	r0, #1	; 0x1
	}

	list_add_tail(&dev->link, &devices);

	if (current_save_needed > 0)
33d11da8:	e3500000 	cmp	r0, #0	; 0x0
	next->prev = new;
	new->next = next;
33d11dac:	e5812000 	str	r2, [r1]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
33d11db0:	e5821004 	str	r1, [r2, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
33d11db4:	e5831000 	str	r1, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
33d11db8:	e5813004 	str	r3, [r1, #4]
33d11dbc:	ea00004e 	b	33d11efc <do_jffs2_mtdparts+0x4c8>

		if ((dev_tmp = device_find(dev->id->type, dev->id->num)) == NULL) {
			device_add(dev);
		} else {
			/* merge new partition with existing ones*/
			p = list_entry(dev->parts.next, struct part_info, link);
33d11dc0:	e5915010 	ldr	r5, [r1, #16]
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
33d11dc4:	e5940008 	ldr	r0, [r4, #8]
33d11dc8:	e1a01005 	mov	r1, r5
33d11dcc:	ebfff8c0 	bl	33d100d4 <part_validate>
33d11dd0:	e3500000 	cmp	r0, #0	; 0x0
33d11dd4:	1a000004 	bne	33d11dec <do_jffs2_mtdparts+0x3b8>
		return 1;

	/* partition is ok, add it to the list */
	if (part_sort_add(dev, part) != 0)
33d11dd8:	e1a00004 	mov	r0, r4
33d11ddc:	e1a01005 	mov	r1, r5
33d11de0:	ebfff975 	bl	33d103bc <part_sort_add>
33d11de4:	e3500000 	cmp	r0, #0	; 0x0
33d11de8:	0a000002 	beq	33d11df8 <do_jffs2_mtdparts+0x3c4>
			device_add(dev);
		} else {
			/* merge new partition with existing ones*/
			p = list_entry(dev->parts.next, struct part_info, link);
			if (part_add(dev_tmp, p) != 0) {
				device_del(dev);
33d11dec:	e59d0014 	ldr	r0, [sp, #20]
33d11df0:	ebfff94e 	bl	33d10330 <device_del>
33d11df4:	ea000051 	b	33d11f40 <do_jffs2_mtdparts+0x50c>
				return 1;
			}
		}

		if (generate_mtdparts_save(last_parts, MTDPARTS_MAXLEN) != 0) {
33d11df8:	e59f01b8 	ldr	r0, [pc, #440]	; 33d11fb8 <do_jffs2_mtdparts+0x584>
33d11dfc:	e3a01c02 	mov	r1, #512	; 0x200
33d11e00:	ebfffb80 	bl	33d10c08 <generate_mtdparts_save>
33d11e04:	e3500000 	cmp	r0, #0	; 0x0
33d11e08:	0a00004d 	beq	33d11f44 <do_jffs2_mtdparts+0x510>
			printf("generated mtdparts too long, reseting to null\n");
33d11e0c:	e59f01a8 	ldr	r0, [pc, #424]	; 33d11fbc <do_jffs2_mtdparts+0x588>
33d11e10:	eb00146c 	bl	33d16fc8 <printf>
33d11e14:	ea000049 	b	33d11f40 <do_jffs2_mtdparts+0x50c>

		return 0;
	}

	/* mtdparts del part-id */
	if ((argc == 3) && (strcmp(argv[1], "del") == 0)) {
33d11e18:	e3560003 	cmp	r6, #3	; 0x3
33d11e1c:	1a000044 	bne	33d11f34 <do_jffs2_mtdparts+0x500>
33d11e20:	e5950004 	ldr	r0, [r5, #4]
33d11e24:	e59f1194 	ldr	r1, [pc, #404]	; 33d11fc0 <do_jffs2_mtdparts+0x58c>
33d11e28:	eb00208e 	bl	33d1a068 <strcmp>
33d11e2c:	e3500000 	cmp	r0, #0	; 0x0
33d11e30:	1a00003f 	bne	33d11f34 <do_jffs2_mtdparts+0x500>
 *
 * @param id string describing device and partition
 * @return 0 on success, 1 otherwise
 */
static int delete_partition(const char *id)
{
33d11e34:	e5954008 	ldr	r4, [r5, #8]
	u8 pnum;
	struct mtd_device *dev;
	struct part_info *part;

	if (find_dev_and_part(id, &dev, &pnum, &part) == 0) {
33d11e38:	e28d1010 	add	r1, sp, #16	; 0x10
33d11e3c:	e1a00004 	mov	r0, r4
33d11e40:	e28d2019 	add	r2, sp, #25	; 0x19
33d11e44:	e28d300c 	add	r3, sp, #12	; 0xc
33d11e48:	ebfffc1c 	bl	33d10ec0 <find_dev_and_part>
33d11e4c:	e3500000 	cmp	r0, #0	; 0x0
33d11e50:	1a000034 	bne	33d11f28 <do_jffs2_mtdparts+0x4f4>
 * @param dev device to delete partition from
 * @param part partition to delete
 * @return 0 on success, 1 otherwise
 */
static int part_del(struct mtd_device *dev, struct part_info *part)
{
33d11e54:	e59d5010 	ldr	r5, [sp, #16]
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
33d11e58:	e1d560bc 	ldrh	r6, [r5, #12]
33d11e5c:	e3560001 	cmp	r6, #1	; 0x1
 * @param part partition to delete
 * @return 0 on success, 1 otherwise
 */
static int part_del(struct mtd_device *dev, struct part_info *part)
{
	u8 current_save_needed = 0;
33d11e60:	e1a07000 	mov	r7, r0
 * @param dev device to delete partition from
 * @param part partition to delete
 * @return 0 on success, 1 otherwise
 */
static int part_del(struct mtd_device *dev, struct part_info *part)
{
33d11e64:	e59d400c 	ldr	r4, [sp, #12]
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
33d11e68:	0a000028 	beq	33d11f10 <do_jffs2_mtdparts+0x4dc>
		return device_del(dev);

	/* otherwise just delete this partition */

	if (dev == current_dev) {
33d11e6c:	e59f3110 	ldr	r3, [pc, #272]	; 33d11f84 <do_jffs2_mtdparts+0x550>
33d11e70:	e5933000 	ldr	r3, [r3]
33d11e74:	e1550003 	cmp	r5, r3
33d11e78:	1a000012 	bne	33d11ec8 <do_jffs2_mtdparts+0x494>
		/* we are modyfing partitions for the current device,
		 * update current */
		struct part_info *curr_pi;
		curr_pi = jffs2_part_info(current_dev, current_partnum);
33d11e7c:	e59f6104 	ldr	r6, [pc, #260]	; 33d11f88 <do_jffs2_mtdparts+0x554>
33d11e80:	e1a00005 	mov	r0, r5
33d11e84:	e5d61000 	ldrb	r1, [r6]
33d11e88:	ebfff808 	bl	33d0feb0 <jffs2_part_info>

		if (curr_pi) {
33d11e8c:	e3500000 	cmp	r0, #0	; 0x0
33d11e90:	0a00000c 	beq	33d11ec8 <do_jffs2_mtdparts+0x494>
			if (curr_pi == part) {
33d11e94:	e1500004 	cmp	r0, r4
33d11e98:	1a000003 	bne	33d11eac <do_jffs2_mtdparts+0x478>
				printf("current partition deleted, resetting current to 0\n");
33d11e9c:	e59f0120 	ldr	r0, [pc, #288]	; 33d11fc4 <do_jffs2_mtdparts+0x590>
33d11ea0:	eb001448 	bl	33d16fc8 <printf>
				current_partnum = 0;
33d11ea4:	e5c67000 	strb	r7, [r6]
33d11ea8:	ea000005 	b	33d11ec4 <do_jffs2_mtdparts+0x490>
			} else if (part->offset <= curr_pi->offset) {
33d11eac:	e5943014 	ldr	r3, [r4, #20]
33d11eb0:	e5902014 	ldr	r2, [r0, #20]
33d11eb4:	e1530002 	cmp	r3, r2
				current_partnum--;
33d11eb8:	95d63000 	ldrbls	r3, [r6]
33d11ebc:	92433001 	subls	r3, r3, #1	; 0x1
33d11ec0:	95c63000 	strbls	r3, [r6]
			}
			current_save_needed = 1;
33d11ec4:	e3a07001 	mov	r7, #1	; 0x1
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
33d11ec8:	e5943000 	ldr	r3, [r4]
33d11ecc:	e5942004 	ldr	r2, [r4, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d11ed0:	e3a01000 	mov	r1, #0	; 0x0
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
33d11ed4:	e5823000 	str	r3, [r2]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
33d11ed8:	e5832004 	str	r2, [r3, #4]
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (void *) 0;
33d11edc:	e5841000 	str	r1, [r4]
	entry->prev = (void *) 0;
33d11ee0:	e5841004 	str	r1, [r4, #4]

#ifdef CFG_NAND_LEGACY
	jffs2_free_cache(part);
#endif
	list_del(&part->link);
	free(part);
33d11ee4:	e1a00004 	mov	r0, r4
33d11ee8:	eb001559 	bl	33d17454 <free>
	dev->num_parts--;
33d11eec:	e1d530bc 	ldrh	r3, [r5, #12]
33d11ef0:	e2433001 	sub	r3, r3, #1	; 0x1
33d11ef4:	e1c530bc 	strh	r3, [r5, #12]

	if (current_save_needed > 0)
33d11ef8:	e3570000 	cmp	r7, #0	; 0x0
33d11efc:	0a000001 	beq	33d11f08 <do_jffs2_mtdparts+0x4d4>
		current_save();
33d11f00:	ebfff848 	bl	33d10028 <current_save>
33d11f04:	eaffffbb 	b	33d11df8 <do_jffs2_mtdparts+0x3c4>
	else
		index_partitions();
33d11f08:	ebfff80f 	bl	33d0ff4c <index_partitions>
33d11f0c:	eaffffb9 	b	33d11df8 <do_jffs2_mtdparts+0x3c4>
static int part_del(struct mtd_device *dev, struct part_info *part)
{
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
33d11f10:	e1a00005 	mov	r0, r5
33d11f14:	ebfff905 	bl	33d10330 <device_del>
 * @param dev device to delete partition from
 * @param part partition to delete
 * @return 0 on success, 1 otherwise
 */
static int part_del(struct mtd_device *dev, struct part_info *part)
{
33d11f18:	e3500000 	cmp	r0, #0	; 0x0

		DEBUGF("delete_partition: device = %s%d, partition %d = (%s) 0x%08lx@0x%08lx\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
33d11f1c:	11a00006 	movne	r0, r6
 * @param dev device to delete partition from
 * @param part partition to delete
 * @return 0 on success, 1 otherwise
 */
static int part_del(struct mtd_device *dev, struct part_info *part)
{
33d11f20:	1a000007 	bne	33d11f44 <do_jffs2_mtdparts+0x510>
33d11f24:	eaffffb3 	b	33d11df8 <do_jffs2_mtdparts+0x3c4>
			return 1;
		}
		return 0;
	}

	printf("partition %s not found\n", id);
33d11f28:	e59f0098 	ldr	r0, [pc, #152]	; 33d11fc8 <do_jffs2_mtdparts+0x594>
33d11f2c:	e1a01004 	mov	r1, r4
33d11f30:	ea000001 	b	33d11f3c <do_jffs2_mtdparts+0x508>
		DEBUGF("del: part-id = %s\n", argv[2]);

		return delete_partition(argv[2]);
	}

	printf ("Usage:\n%s\n", cmdtp->usage);
33d11f34:	e5971010 	ldr	r1, [r7, #16]
33d11f38:	e59f008c 	ldr	r0, [pc, #140]	; 33d11fcc <do_jffs2_mtdparts+0x598>
33d11f3c:	eb001421 	bl	33d16fc8 <printf>
	return 1;
33d11f40:	e3a00001 	mov	r0, #1	; 0x1
}
33d11f44:	e28dd05c 	add	sp, sp, #92	; 0x5c
33d11f48:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d11f4c:	33d29904 	.word	0x33d29904
33d11f50:	33d29604 	.word	0x33d29604
33d11f54:	33d2960c 	.word	0x33d2960c
33d11f58:	33d27068 	.word	0x33d27068
33d11f5c:	33d2990c 	.word	0x33d2990c
33d11f60:	33d292d4 	.word	0x33d292d4
33d11f64:	33d29970 	.word	0x33d29970
33d11f68:	33d608d0 	.word	0x33d608d0
33d11f6c:	33d29274 	.word	0x33d29274
33d11f70:	33d29278 	.word	0x33d29278
33d11f74:	33d29978 	.word	0x33d29978
33d11f78:	33d2999c 	.word	0x33d2999c
33d11f7c:	33d299c4 	.word	0x33d299c4
33d11f80:	33d299e0 	.word	0x33d299e0
33d11f84:	33d608d8 	.word	0x33d608d8
33d11f88:	33d608dc 	.word	0x33d608dc
33d11f8c:	33d299f8 	.word	0x33d299f8
33d11f90:	33d29a30 	.word	0x33d29a30
33d11f94:	33d29a58 	.word	0x33d29a58
33d11f98:	33d29a64 	.word	0x33d29a64
33d11f9c:	33d29a74 	.word	0x33d29a74
33d11fa0:	33d29a84 	.word	0x33d29a84
33d11fa4:	33d608c8 	.word	0x33d608c8
33d11fa8:	33d29a88 	.word	0x33d29a88
33d11fac:	33d29ab8 	.word	0x33d29ab8
33d11fb0:	33d2a490 	.word	0x33d2a490
33d11fb4:	33d28b14 	.word	0x33d28b14
33d11fb8:	33d60964 	.word	0x33d60964
33d11fbc:	33d28b20 	.word	0x33d28b20
33d11fc0:	33d28b50 	.word	0x33d28b50
33d11fc4:	33d28b54 	.word	0x33d28b54
33d11fc8:	33d28b88 	.word	0x33d28b88
33d11fcc:	33d27008 	.word	0x33d27008

33d11fd0 <do_load_serial>:

/* -------------------------------------------------------------------- */

#if (CONFIG_COMMANDS & CFG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d11fd0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    int load_baudrate, current_baudrate;

    load_baudrate = current_baudrate = gd->baudrate;
#endif

    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
33d11fd4:	e59f02bc 	ldr	r0, [pc, #700]	; 33d12298 <do_load_serial+0x2c8>

/* -------------------------------------------------------------------- */

#if (CONFIG_COMMANDS & CFG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d11fd8:	e24ddfce 	sub	sp, sp, #824	; 0x338
33d11fdc:	e1a04002 	mov	r4, r2
33d11fe0:	e1a05003 	mov	r5, r3
    int load_baudrate, current_baudrate;

    load_baudrate = current_baudrate = gd->baudrate;
#endif

    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
33d11fe4:	eb000e19 	bl	33d15850 <getenv>
/* -------------------------------------------------------------------- */

#if (CONFIG_COMMANDS & CFG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
    ulong offset = 0;
33d11fe8:	e3a0b000 	mov	fp, #0	; 0x0
    int load_baudrate, current_baudrate;

    load_baudrate = current_baudrate = gd->baudrate;
#endif

    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
33d11fec:	e3500000 	cmp	r0, #0	; 0x0
{
    ulong offset = 0;
    ulong addr;
    int i;
    char *env_echo;
    int rcode = 0;
33d11ff0:	e58db004 	str	fp, [sp, #4]
    int load_baudrate, current_baudrate;

    load_baudrate = current_baudrate = gd->baudrate;
#endif

    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
33d11ff4:	0a000003 	beq	33d12008 <do_load_serial+0x38>
33d11ff8:	e5d03000 	ldrb	r3, [r0]
33d11ffc:	e3530031 	cmp	r3, #49	; 0x31
        do_echo = 1;
33d12000:	03a02001 	moveq	r2, #1	; 0x1
    int load_baudrate, current_baudrate;

    load_baudrate = current_baudrate = gd->baudrate;
#endif

    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
33d12004:	0a000000 	beq	33d1200c <do_load_serial+0x3c>
        do_echo = 1;
    } else {
        do_echo = 0;
33d12008:	e3a02000 	mov	r2, #0	; 0x0
33d1200c:	e59f3288 	ldr	r3, [pc, #648]	; 33d1229c <do_load_serial+0x2cc>
            if (getc() == '\r')
                break;
        }
    }
#else   /* ! CFG_LOADS_BAUD_CHANGE */
    if (argc == 2) {
33d12010:	e3540002 	cmp	r4, #2	; 0x2
#endif

    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
        do_echo = 1;
    } else {
        do_echo = 0;
33d12014:	e5832000 	str	r2, [r3]
            if (getc() == '\r')
                break;
        }
    }
#else   /* ! CFG_LOADS_BAUD_CHANGE */
    if (argc == 2) {
33d12018:	1a000004 	bne	33d12030 <do_load_serial+0x60>
        offset = simple_strtoul(argv[1], NULL, 16);
33d1201c:	e5950004 	ldr	r0, [r5, #4]
33d12020:	e3a01000 	mov	r1, #0	; 0x0
33d12024:	e3a02010 	mov	r2, #16	; 0x10
33d12028:	eb00214b 	bl	33d1a55c <simple_strtoul>
33d1202c:	e58d0004 	str	r0, [sp, #4]
    }
#endif  /* CFG_LOADS_BAUD_CHANGE */

    printf ("## Ready for S-Record download ...\n");
33d12030:	e59f0268 	ldr	r0, [pc, #616]	; 33d122a0 <do_load_serial+0x2d0>
33d12034:	eb0013e3 	bl	33d16fc8 <printf>
    ulong   addr;               /* load address from S-Record   */
    ulong   size;               /* number of bytes transferred  */
    char    buf[32];
    ulong   store_addr;
    ulong   start_addr = ~0;
    ulong   end_addr   =  0;
33d12038:	e3a0a000 	mov	sl, #0	; 0x0
    int type;               /* return code for record type  */
    ulong   addr;               /* load address from S-Record   */
    ulong   size;               /* number of bytes transferred  */
    char    buf[32];
    ulong   store_addr;
    ulong   start_addr = ~0;
33d1203c:	e3e07000 	mvn	r7, #0	; 0x0
    ulong   end_addr   =  0;
    int line_count =  0;
33d12040:	e1a0900a 	mov	r9, sl
    return (~0);            /* Download aborted     */
}

static int
read_record (char *buf, ulong len)
{
33d12044:	e28d6e13 	add	r6, sp, #304	; 0x130
    char *p;
    char c;

    --len;  /* always leave room for terminating '\0' byte */

    for (p=buf; p < buf+len; ++p) {
33d12048:	e28d3fcd 	add	r3, sp, #820	; 0x334
33d1204c:	e1560003 	cmp	r6, r3
33d12050:	e1a05006 	mov	r5, r6
33d12054:	2a000021 	bcs	33d120e0 <do_load_serial+0x110>
        c = getc();     /* read character       */
33d12058:	eb0013bd 	bl	33d16f54 <getc>
        if (do_echo)
33d1205c:	e59f3238 	ldr	r3, [pc, #568]	; 33d1229c <do_load_serial+0x2cc>
33d12060:	e5933000 	ldr	r3, [r3]
33d12064:	e3530000 	cmp	r3, #0	; 0x0
    char c;

    --len;  /* always leave room for terminating '\0' byte */

    for (p=buf; p < buf+len; ++p) {
        c = getc();     /* read character       */
33d12068:	e20040ff 	and	r4, r0, #255	; 0xff
        if (do_echo)
            putc (c);   /* ... and echo it      */
33d1206c:	11a00004 	movne	r0, r4
33d12070:	1b0013c3 	blne	33d16f84 <putc>

        switch (c) {
33d12074:	e3540003 	cmp	r4, #3	; 0x3
33d12078:	0a00006f 	beq	33d1223c <do_load_serial+0x26c>
33d1207c:	ca000002 	bgt	33d1208c <do_load_serial+0xbc>
33d12080:	e3540000 	cmp	r4, #0	; 0x0
33d12084:	0a00006c 	beq	33d1223c <do_load_serial+0x26c>
33d12088:	ea000007 	b	33d120ac <do_load_serial+0xdc>
33d1208c:	e354000a 	cmp	r4, #10	; 0xa
33d12090:	0a000001 	beq	33d1209c <do_load_serial+0xcc>
33d12094:	e354000d 	cmp	r4, #13	; 0xd
33d12098:	1a000003 	bne	33d120ac <do_load_serial+0xdc>
        case '\r':
        case '\n':
            *p = '\0';
33d1209c:	e3a03000 	mov	r3, #0	; 0x0
33d120a0:	e0662005 	rsb	r2, r6, r5
33d120a4:	e5c53000 	strb	r3, [r5]
33d120a8:	ea00000f 	b	33d120ec <do_load_serial+0x11c>
            return (p - buf);
        case '\0':
        case 0x03:          /* ^C - Control C       */
            return (-1);
        default:
            *p = c;
33d120ac:	e5c54000 	strb	r4, [r5]
        }

        /* Check for the console hangup (if any different from serial) */
        if (gd->jt[XF_getc] != getc) {
33d120b0:	e5983020 	ldr	r3, [r8, #32]
33d120b4:	e5932004 	ldr	r2, [r3, #4]
33d120b8:	e59f31e4 	ldr	r3, [pc, #484]	; 33d122a4 <do_load_serial+0x2d4>
33d120bc:	e1520003 	cmp	r2, r3
33d120c0:	0a000002 	beq	33d120d0 <do_load_serial+0x100>
        if (ctrlc()) {
33d120c4:	eb0013d8 	bl	33d1702c <ctrlc>
33d120c8:	e3500000 	cmp	r0, #0	; 0x0
33d120cc:	1a00005a 	bne	33d1223c <do_load_serial+0x26c>
    char *p;
    char c;

    --len;  /* always leave room for terminating '\0' byte */

    for (p=buf; p < buf+len; ++p) {
33d120d0:	e2855001 	add	r5, r5, #1	; 0x1
33d120d4:	e2863f81 	add	r3, r6, #516	; 0x204
33d120d8:	e1550003 	cmp	r5, r3
33d120dc:	eaffffdc 	b	33d12054 <do_load_serial+0x84>
        }
        }
    }

    /* line too long - truncate */
    *p = '\0';
33d120e0:	e3a03000 	mov	r3, #0	; 0x0
33d120e4:	e5c53000 	strb	r3, [r5]
33d120e8:	e0662005 	rsb	r2, r6, r5
    return (~0);            /* Download aborted     */
}

static int
read_record (char *buf, ulong len)
{
33d120ec:	e3520000 	cmp	r2, #0	; 0x0
33d120f0:	ba000051 	blt	33d1223c <do_load_serial+0x26c>
    ulong   start_addr = ~0;
    ulong   end_addr   =  0;
    int line_count =  0;

    while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
        type = srec_decode (record, &binlen, &addr, binbuf);
33d120f4:	e28d5030 	add	r5, sp, #48	; 0x30
33d120f8:	e1a00006 	mov	r0, r6
33d120fc:	e28d100c 	add	r1, sp, #12	; 0xc
33d12100:	e28d2008 	add	r2, sp, #8	; 0x8
33d12104:	e1a03005 	mov	r3, r5
33d12108:	eb001ba8 	bl	33d18fb0 <srec_decode>

        if (type < 0) {
33d1210c:	e3500000 	cmp	r0, #0	; 0x0
33d12110:	ba000049 	blt	33d1223c <do_load_serial+0x26c>
            return (~0);        /* Invalid S-Record     */
        }

        switch (type) {
33d12114:	e2403001 	sub	r3, r0, #1	; 0x1
33d12118:	e3530008 	cmp	r3, #8	; 0x8
33d1211c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d12120:	ea000038 	b	33d12208 <do_load_serial+0x238>
33d12124:	33d12148 	.word	0x33d12148
33d12128:	33d12148 	.word	0x33d12148
33d1212c:	33d12148 	.word	0x33d12148
33d12130:	33d12208 	.word	0x33d12208
33d12134:	33d12208 	.word	0x33d12208
33d12138:	33d12208 	.word	0x33d12208
33d1213c:	33d121ac 	.word	0x33d121ac
33d12140:	33d121ac 	.word	0x33d121ac
33d12144:	33d121ac 	.word	0x33d121ac
        case SREC_DATA2:
        case SREC_DATA3:
        case SREC_DATA4:
            store_addr = addr + offset;
33d12148:	e99d000c 	ldmib	sp, {r2, r3}
33d1214c:	e0834002 	add	r4, r3, r2
#ifndef CFG_NO_FLASH
            if (addr2info(store_addr)) {
33d12150:	e1a00004 	mov	r0, r4
33d12154:	eb0019da 	bl	33d188c4 <addr2info>
33d12158:	e3500000 	cmp	r0, #0	; 0x0
33d1215c:	e59d200c 	ldr	r2, [sp, #12]
33d12160:	0a000006 	beq	33d12180 <do_load_serial+0x1b0>
            int rc;

            rc = flash_write((char *)binbuf,store_addr,binlen);
33d12164:	e1a00005 	mov	r0, r5
33d12168:	e1a01004 	mov	r1, r4
33d1216c:	eb0019e6 	bl	33d1890c <flash_write>
            if (rc != 0) {
33d12170:	e3500000 	cmp	r0, #0	; 0x0
33d12174:	0a000004 	beq	33d1218c <do_load_serial+0x1bc>
                flash_perror (rc);
33d12178:	eb001a45 	bl	33d18a94 <flash_perror>
33d1217c:	ea00002e 	b	33d1223c <do_load_serial+0x26c>
                return (~0);
            }
            } else
#endif
            {
            memcpy ((char *)(store_addr), binbuf, binlen);
33d12180:	e1a01005 	mov	r1, r5
33d12184:	e1a00004 	mov	r0, r4
33d12188:	eb002095 	bl	33d1a3e4 <memcpy>
            }
            if ((store_addr) < start_addr)
            start_addr = store_addr;
            if ((store_addr + binlen - 1) > end_addr)
33d1218c:	e59d300c 	ldr	r3, [sp, #12]
33d12190:	e0843003 	add	r3, r4, r3
33d12194:	e2433001 	sub	r3, r3, #1	; 0x1
#endif
            {
            memcpy ((char *)(store_addr), binbuf, binlen);
            }
            if ((store_addr) < start_addr)
            start_addr = store_addr;
33d12198:	e1570004 	cmp	r7, r4
33d1219c:	21a07004 	movcs	r7, r4
            if ((store_addr + binlen - 1) > end_addr)
33d121a0:	e1530009 	cmp	r3, r9
            end_addr = store_addr + binlen - 1;
33d121a4:	81a09003 	movhi	r9, r3
33d121a8:	ea000016 	b	33d12208 <do_load_serial+0x238>
            break;
        case SREC_END2:
        case SREC_END3:
        case SREC_END4:
            udelay (10000);
            size = end_addr - start_addr + 1;
33d121ac:	e0674009 	rsb	r4, r7, r9
33d121b0:	e2844001 	add	r4, r4, #1	; 0x1
            end_addr = store_addr + binlen - 1;
            break;
        case SREC_END2:
        case SREC_END3:
        case SREC_END4:
            udelay (10000);
33d121b4:	e59f00ec 	ldr	r0, [pc, #236]	; 33d122a8 <do_load_serial+0x2d8>
33d121b8:	ebffbb13 	bl	33d00e0c <udelay>
            size = end_addr - start_addr + 1;
            printf ("\n"
33d121bc:	e1a03004 	mov	r3, r4
33d121c0:	e1a02009 	mov	r2, r9
33d121c4:	e59f00e0 	ldr	r0, [pc, #224]	; 33d122ac <do_load_serial+0x2dc>
33d121c8:	e1a01007 	mov	r1, r7
                "## Last  Load Addr = 0x%08lX\n"
                "## Total Size      = 0x%08lX = %ld Bytes\n",
                start_addr, end_addr, size, size
            );
            flush_cache (start_addr, size);
            sprintf(buf, "%lX", size);
33d121cc:	e28d5010 	add	r5, sp, #16	; 0x10
        case SREC_END2:
        case SREC_END3:
        case SREC_END4:
            udelay (10000);
            size = end_addr - start_addr + 1;
            printf ("\n"
33d121d0:	e58d4000 	str	r4, [sp]
33d121d4:	eb00137b 	bl	33d16fc8 <printf>
                "## First Load Addr = 0x%08lX\n"
                "## Last  Load Addr = 0x%08lX\n"
                "## Total Size      = 0x%08lX = %ld Bytes\n",
                start_addr, end_addr, size, size
            );
            flush_cache (start_addr, size);
33d121d8:	e1a00007 	mov	r0, r7
33d121dc:	e1a01004 	mov	r1, r4
33d121e0:	eb0032c9 	bl	33d1ed0c <flush_cache>
            sprintf(buf, "%lX", size);
33d121e4:	e1a02004 	mov	r2, r4
33d121e8:	e59f10c0 	ldr	r1, [pc, #192]	; 33d122b0 <do_load_serial+0x2e0>
33d121ec:	e1a00005 	mov	r0, r5
33d121f0:	eb0022bf 	bl	33d1acf4 <sprintf>
            setenv("filesize", buf);
33d121f4:	e1a01005 	mov	r1, r5
33d121f8:	e59f00b4 	ldr	r0, [pc, #180]	; 33d122b4 <do_load_serial+0x2e4>
33d121fc:	eb000d75 	bl	33d157d8 <setenv>
33d12200:	e59d5008 	ldr	r5, [sp, #8]
33d12204:	ea00000d 	b	33d12240 <do_load_serial+0x270>
        case SREC_START:
            break;
        default:
            break;
        }
        if (!do_echo) { /* print a '.' every 100 lines */
33d12208:	e59f308c 	ldr	r3, [pc, #140]	; 33d1229c <do_load_serial+0x2cc>
33d1220c:	e5933000 	ldr	r3, [r3]
33d12210:	e3530000 	cmp	r3, #0	; 0x0
33d12214:	1affff8a 	bne	33d12044 <do_load_serial+0x74>
            if ((++line_count % 100) == 0)
33d12218:	e28aa001 	add	sl, sl, #1	; 0x1
33d1221c:	e1a0000a 	mov	r0, sl
33d12220:	e3a01064 	mov	r1, #100	; 0x64
33d12224:	eb00315d 	bl	33d1e7a0 <__modsi3>
33d12228:	e3500000 	cmp	r0, #0	; 0x0
33d1222c:	1affff84 	bne	33d12044 <do_load_serial+0x74>
                putc ('.');
33d12230:	e280002e 	add	r0, r0, #46	; 0x2e
33d12234:	eb001352 	bl	33d16f84 <putc>
33d12238:	eaffff81 	b	33d12044 <do_load_serial+0x74>
        }
    }
33d1223c:	e3e05000 	mvn	r5, #0	; 0x0
33d12240:	e3a04063 	mov	r4, #99	; 0x63
     * Gather any trailing characters (for instance, the ^D which
     * is sent by 'cu' after sending a file), and give the
     * box some time (100 * 1 ms)
     */
    for (i=0; i<100; ++i) {
        if (tstc()) {
33d12244:	eb001348 	bl	33d16f6c <tstc>
33d12248:	e3500000 	cmp	r0, #0	; 0x0
            (void) getc();
33d1224c:	1b001340 	blne	33d16f54 <getc>
        }
        udelay(1000);
33d12250:	e3a00ffa 	mov	r0, #1000	; 0x3e8
33d12254:	ebffbaec 	bl	33d00e0c <udelay>
33d12258:	e2544001 	subs	r4, r4, #1	; 0x1
33d1225c:	5afffff8 	bpl	33d12244 <do_load_serial+0x274>
    }

    if (addr == ~0) {
33d12260:	e3750001 	cmn	r5, #1	; 0x1
33d12264:	1a000003 	bne	33d12278 <do_load_serial+0x2a8>
        printf ("## S-Record download aborted\n");
33d12268:	e59f0048 	ldr	r0, [pc, #72]	; 33d122b8 <do_load_serial+0x2e8>
33d1226c:	eb001355 	bl	33d16fc8 <printf>
        rcode = 1;
33d12270:	e3a0b001 	mov	fp, #1	; 0x1
33d12274:	ea000004 	b	33d1228c <do_load_serial+0x2bc>
    } else {
        printf ("## Start Addr      = 0x%08lX\n", addr);
33d12278:	e59f003c 	ldr	r0, [pc, #60]	; 33d122bc <do_load_serial+0x2ec>
33d1227c:	e1a01005 	mov	r1, r5
33d12280:	eb001350 	bl	33d16fc8 <printf>
        load_addr = addr;
33d12284:	e59f3034 	ldr	r3, [pc, #52]	; 33d122c0 <do_load_serial+0x2f0>
33d12288:	e5835000 	str	r5, [r3]
                break;
        }
    }
#endif
    return rcode;
}
33d1228c:	e1a0000b 	mov	r0, fp
33d12290:	e28ddfce 	add	sp, sp, #824	; 0x338
33d12294:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d12298:	33d29c84 	.word	0x33d29c84
33d1229c:	33d36074 	.word	0x33d36074
33d122a0:	33d29c90 	.word	0x33d29c90
33d122a4:	33d16f54 	.word	0x33d16f54
33d122a8:	00002710 	.word	0x00002710
33d122ac:	33d29cb4 	.word	0x33d29cb4
33d122b0:	33d2596c 	.word	0x33d2596c
33d122b4:	33d25954 	.word	0x33d25954
33d122b8:	33d29d1c 	.word	0x33d29d1c
33d122bc:	33d29d3c 	.word	0x33d29d3c
33d122c0:	33d35fec 	.word	0x33d35fec

33d122c4 <send_pad>:

    return offset;
}

void send_pad (void)
{
33d122c4:	e92d4010 	push	{r4, lr}
    int count = his_pad_count;
33d122c8:	e59f3028 	ldr	r3, [pc, #40]	; 33d122f8 <send_pad+0x34>
33d122cc:	e5934000 	ldr	r4, [r3]

    while (count-- > 0)
        putc (his_pad_char);
33d122d0:	e3540000 	cmp	r4, #0	; 0x0
33d122d4:	e2444001 	sub	r4, r4, #1	; 0x1
33d122d8:	d8bd8010 	pople	{r4, pc}
33d122dc:	e59f3018 	ldr	r3, [pc, #24]	; 33d122fc <send_pad+0x38>
33d122e0:	e5d30000 	ldrb	r0, [r3]
33d122e4:	eb001326 	bl	33d16f84 <putc>
33d122e8:	e3540000 	cmp	r4, #0	; 0x0
33d122ec:	e2444001 	sub	r4, r4, #1	; 0x1
33d122f0:	cafffff9 	bgt	33d122dc <send_pad+0x18>
33d122f4:	e8bd8010 	pop	{r4, pc}
33d122f8:	33d60b9c 	.word	0x33d60b9c
33d122fc:	33d60ba0 	.word	0x33d60ba0

33d12300 <ktrans>:
}

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
    if ((in & 0x60) == 0x40) {
33d12300:	e2003060 	and	r3, r0, #96	; 0x60
33d12304:	e3530040 	cmp	r3, #64	; 0x40
        return (char) (in & ~0x40);
    } else if ((in & 0x7f) == 0x3f) {
33d12308:	e200207f 	and	r2, r0, #127	; 0x7f

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
    if ((in & 0x60) == 0x40) {
        return (char) (in & ~0x40);
33d1230c:	e20030bf 	and	r3, r0, #191	; 0xbf
        putc (his_pad_char);
}

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
33d12310:	e20000ff 	and	r0, r0, #255	; 0xff
    if ((in & 0x60) == 0x40) {
33d12314:	0a000002 	beq	33d12324 <ktrans+0x24>
        return (char) (in & ~0x40);
    } else if ((in & 0x7f) == 0x3f) {
33d12318:	e352003f 	cmp	r2, #63	; 0x3f
        return (char) (in | 0x40);
33d1231c:	e3803040 	orr	r3, r0, #64	; 0x40
    } else
        return in;
33d12320:	11a03000 	movne	r3, r0
}
33d12324:	e1a00003 	mov	r0, r3
33d12328:	e1a0f00e 	mov	pc, lr

33d1232c <chk1>:
int chk1 (char *buffer)
{
    int total = 0;

    while (*buffer) {
        total += *buffer++;
33d1232c:	e5d03000 	ldrb	r3, [r0]
33d12330:	e3530000 	cmp	r3, #0	; 0x0
        return in;
}

int chk1 (char *buffer)
{
    int total = 0;
33d12334:	e3a02000 	mov	r2, #0	; 0x0

    while (*buffer) {
        total += *buffer++;
33d12338:	0a000003 	beq	33d1234c <chk1+0x20>
33d1233c:	e0822003 	add	r2, r2, r3
33d12340:	e5f03001 	ldrb	r3, [r0, #1]!
33d12344:	e3530000 	cmp	r3, #0	; 0x0
33d12348:	eafffffa 	b	33d12338 <chk1+0xc>
    }
    return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
33d1234c:	e1a00c02 	lsl	r0, r2, #24
33d12350:	e0820f20 	add	r0, r2, r0, lsr #30
}
33d12354:	e200003f 	and	r0, r0, #63	; 0x3f
33d12358:	e1a0f00e 	mov	pc, lr

33d1235c <s1_sendpacket>:

void s1_sendpacket (char *packet)
{
33d1235c:	e92d4010 	push	{r4, lr}
33d12360:	e1a04000 	mov	r4, r0
    send_pad ();
33d12364:	ebffffd6 	bl	33d122c4 <send_pad>
    while (*packet) {
        putc (*packet++);
33d12368:	e5d40000 	ldrb	r0, [r4]
33d1236c:	e3500000 	cmp	r0, #0	; 0x0
33d12370:	08bd8010 	popeq	{r4, pc}
33d12374:	eb001302 	bl	33d16f84 <putc>
33d12378:	e5f40001 	ldrb	r0, [r4, #1]!
33d1237c:	e3500000 	cmp	r0, #0	; 0x0
33d12380:	1afffffb 	bne	33d12374 <s1_sendpacket+0x18>
33d12384:	e8bd8010 	pop	{r4, pc}

33d12388 <send_ack>:
    }
}

static char a_b[24];
void send_ack (int n)
{
33d12388:	e92d4030 	push	{r4, r5, lr}
    a_b[0] = START_CHAR;
33d1238c:	e59f4050 	ldr	r4, [pc, #80]	; 33d123e4 <send_ack+0x5c>
33d12390:	e3a03001 	mov	r3, #1	; 0x1
33d12394:	e5c43000 	strb	r3, [r4]
    a_b[1] = tochar (3);
33d12398:	e2833022 	add	r3, r3, #34	; 0x22
    a_b[2] = tochar (n);
33d1239c:	e2802020 	add	r2, r0, #32	; 0x20
    a_b[3] = ACK_TYPE;
    a_b[4] = '\0';
33d123a0:	e3a05000 	mov	r5, #0	; 0x0

static char a_b[24];
void send_ack (int n)
{
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
33d123a4:	e5c43001 	strb	r3, [r4, #1]
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[4] = '\0';
    a_b[4] = tochar (chk1 (&a_b[1]));
33d123a8:	e2840001 	add	r0, r4, #1	; 0x1
void send_ack (int n)
{
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
33d123ac:	e2833036 	add	r3, r3, #54	; 0x36
static char a_b[24];
void send_ack (int n)
{
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
33d123b0:	e5c42002 	strb	r2, [r4, #2]
    a_b[3] = ACK_TYPE;
33d123b4:	e5c43003 	strb	r3, [r4, #3]
    a_b[4] = '\0';
33d123b8:	e5c45004 	strb	r5, [r4, #4]
    a_b[4] = tochar (chk1 (&a_b[1]));
33d123bc:	ebffffda 	bl	33d1232c <chk1>
    a_b[5] = his_eol;
33d123c0:	e59f3020 	ldr	r3, [pc, #32]	; 33d123e8 <send_ack+0x60>
33d123c4:	e5d32000 	ldrb	r2, [r3]
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[4] = '\0';
    a_b[4] = tochar (chk1 (&a_b[1]));
33d123c8:	e2803020 	add	r3, r0, #32	; 0x20
    a_b[5] = his_eol;
    a_b[6] = '\0';
    s1_sendpacket (a_b);
33d123cc:	e1a00004 	mov	r0, r4
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[4] = '\0';
    a_b[4] = tochar (chk1 (&a_b[1]));
33d123d0:	e5c43004 	strb	r3, [r4, #4]
    a_b[5] = his_eol;
33d123d4:	e5c42005 	strb	r2, [r4, #5]
    a_b[6] = '\0';
33d123d8:	e5c45006 	strb	r5, [r4, #6]
    s1_sendpacket (a_b);
33d123dc:	e8bd4030 	pop	{r4, r5, lr}
33d123e0:	eaffffdd 	b	33d1235c <s1_sendpacket>
33d123e4:	33d60bc4 	.word	0x33d60bc4
33d123e8:	33d60b98 	.word	0x33d60b98

33d123ec <send_nack>:
}

void send_nack (int n)
{
33d123ec:	e92d4030 	push	{r4, r5, lr}
    a_b[0] = START_CHAR;
33d123f0:	e59f4050 	ldr	r4, [pc, #80]	; 33d12448 <send_nack+0x5c>
33d123f4:	e3a03001 	mov	r3, #1	; 0x1
33d123f8:	e5c43000 	strb	r3, [r4]
    a_b[1] = tochar (3);
33d123fc:	e2833022 	add	r3, r3, #34	; 0x22
    a_b[2] = tochar (n);
33d12400:	e2802020 	add	r2, r0, #32	; 0x20
    a_b[3] = NACK_TYPE;
    a_b[4] = '\0';
33d12404:	e3a05000 	mov	r5, #0	; 0x0
}

void send_nack (int n)
{
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
33d12408:	e5c43001 	strb	r3, [r4, #1]
    a_b[2] = tochar (n);
    a_b[3] = NACK_TYPE;
    a_b[4] = '\0';
    a_b[4] = tochar (chk1 (&a_b[1]));
33d1240c:	e2840001 	add	r0, r4, #1	; 0x1
void send_nack (int n)
{
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
    a_b[3] = NACK_TYPE;
33d12410:	e283302b 	add	r3, r3, #43	; 0x2b

void send_nack (int n)
{
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
33d12414:	e5c42002 	strb	r2, [r4, #2]
    a_b[3] = NACK_TYPE;
33d12418:	e5c43003 	strb	r3, [r4, #3]
    a_b[4] = '\0';
33d1241c:	e5c45004 	strb	r5, [r4, #4]
    a_b[4] = tochar (chk1 (&a_b[1]));
33d12420:	ebffffc1 	bl	33d1232c <chk1>
    a_b[5] = his_eol;
33d12424:	e59f3020 	ldr	r3, [pc, #32]	; 33d1244c <send_nack+0x60>
33d12428:	e5d32000 	ldrb	r2, [r3]
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
    a_b[3] = NACK_TYPE;
    a_b[4] = '\0';
    a_b[4] = tochar (chk1 (&a_b[1]));
33d1242c:	e2803020 	add	r3, r0, #32	; 0x20
    a_b[5] = his_eol;
    a_b[6] = '\0';
    s1_sendpacket (a_b);
33d12430:	e1a00004 	mov	r0, r4
    a_b[0] = START_CHAR;
    a_b[1] = tochar (3);
    a_b[2] = tochar (n);
    a_b[3] = NACK_TYPE;
    a_b[4] = '\0';
    a_b[4] = tochar (chk1 (&a_b[1]));
33d12434:	e5c43004 	strb	r3, [r4, #4]
    a_b[5] = his_eol;
33d12438:	e5c42005 	strb	r2, [r4, #5]
    a_b[6] = '\0';
33d1243c:	e5c45006 	strb	r5, [r4, #6]
    s1_sendpacket (a_b);
33d12440:	e8bd4030 	pop	{r4, r5, lr}
33d12444:	eaffffc4 	b	33d1235c <s1_sendpacket>
33d12448:	33d60bc4 	.word	0x33d60bc4
33d1244c:	33d60b98 	.word	0x33d60b98

33d12450 <bin_data_init>:
int os_data_header[8];
static void bin_data_init (void)
{
    os_data_state = 0;
    os_data_count = 0;
    os_data_addr = bin_start_address;
33d12450:	e59f3020 	ldr	r3, [pc, #32]	; 33d12478 <bin_data_init+0x28>
33d12454:	e5931000 	ldr	r1, [r3]
static char *bin_start_address;
int os_data_header[8];
static void bin_data_init (void)
{
    os_data_state = 0;
    os_data_count = 0;
33d12458:	e59f301c 	ldr	r3, [pc, #28]	; 33d1247c <bin_data_init+0x2c>
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;
int os_data_header[8];
static void bin_data_init (void)
{
    os_data_state = 0;
33d1245c:	e3a02000 	mov	r2, #0	; 0x0
    os_data_count = 0;
33d12460:	e5832000 	str	r2, [r3]
    os_data_addr = bin_start_address;
33d12464:	e59f3014 	ldr	r3, [pc, #20]	; 33d12480 <bin_data_init+0x30>
33d12468:	e5831000 	str	r1, [r3]
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;
int os_data_header[8];
static void bin_data_init (void)
{
    os_data_state = 0;
33d1246c:	e59f3010 	ldr	r3, [pc, #16]	; 33d12484 <bin_data_init+0x34>
33d12470:	e5832000 	str	r2, [r3]
    os_data_count = 0;
    os_data_addr = bin_start_address;
33d12474:	e1a0f00e 	mov	pc, lr
33d12478:	33d60bf0 	.word	0x33d60bf0
33d1247c:	33d60b74 	.word	0x33d60b74
33d12480:	33d60be8 	.word	0x33d60be8
33d12484:	33d60bdc 	.word	0x33d60bdc

33d12488 <bin_data_char>:
    os_data_count = os_data_count_saved;
    os_data_addr = os_data_addr_saved;
}
static void bin_data_char (char new_char)
{
    switch (os_data_state) {
33d12488:	e59f3030 	ldr	r3, [pc, #48]	; 33d124c0 <bin_data_char+0x38>
33d1248c:	e5933000 	ldr	r3, [r3]
33d12490:	e3530000 	cmp	r3, #0	; 0x0
    case 0:                 /* data */
        *os_data_addr++ = new_char;
33d12494:	e59f1028 	ldr	r1, [pc, #40]	; 33d124c4 <bin_data_char+0x3c>
        --os_data_count;
33d12498:	e59fc028 	ldr	ip, [pc, #40]	; 33d124c8 <bin_data_char+0x40>
    os_data_state = os_data_state_saved;
    os_data_count = os_data_count_saved;
    os_data_addr = os_data_addr_saved;
}
static void bin_data_char (char new_char)
{
33d1249c:	e20000ff 	and	r0, r0, #255	; 0xff
    switch (os_data_state) {
33d124a0:	11a0f00e 	movne	pc, lr
    case 0:                 /* data */
        *os_data_addr++ = new_char;
33d124a4:	e5912000 	ldr	r2, [r1]
33d124a8:	e4c20001 	strb	r0, [r2], #1
        --os_data_count;
33d124ac:	e59c3000 	ldr	r3, [ip]
33d124b0:	e2433001 	sub	r3, r3, #1	; 0x1
}
static void bin_data_char (char new_char)
{
    switch (os_data_state) {
    case 0:                 /* data */
        *os_data_addr++ = new_char;
33d124b4:	e5812000 	str	r2, [r1]
        --os_data_count;
33d124b8:	e58c3000 	str	r3, [ip]
33d124bc:	e1a0f00e 	mov	pc, lr
33d124c0:	33d60bdc 	.word	0x33d60bdc
33d124c4:	33d60be8 	.word	0x33d60be8
33d124c8:	33d60b74 	.word	0x33d60b74

33d124cc <k_data_init>:

/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
    k_data_escape = 0;
33d124cc:	e59f2018 	ldr	r2, [pc, #24]	; 33d124ec <k_data_init+0x20>
33d124d0:	e3a03000 	mov	r3, #0	; 0x0


/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
33d124d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    k_data_escape = 0;
33d124d8:	e5823000 	str	r3, [r2]
    os_data_init ();
33d124dc:	e59f300c 	ldr	r3, [pc, #12]	; 33d124f0 <k_data_init+0x24>
33d124e0:	e1a0e00f 	mov	lr, pc
33d124e4:	e593f000 	ldr	pc, [r3]
33d124e8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d124ec:	33d60bf4 	.word	0x33d60bf4
33d124f0:	33d60ba4 	.word	0x33d60ba4

33d124f4 <k_data_save>:
}
void k_data_save (void)
{
    k_data_escape_saved = k_data_escape;
33d124f4:	e59f303c 	ldr	r3, [pc, #60]	; 33d12538 <k_data_save+0x44>
33d124f8:	e5932000 	ldr	r2, [r3]
    os_data_count = 0;
    os_data_addr = bin_start_address;
}
static void os_data_save (void)
{
    os_data_state_saved = os_data_state;
33d124fc:	e59f3038 	ldr	r3, [pc, #56]	; 33d1253c <k_data_save+0x48>
33d12500:	e5931000 	ldr	r1, [r3]
    os_data_count_saved = os_data_count;
33d12504:	e59f3034 	ldr	r3, [pc, #52]	; 33d12540 <k_data_save+0x4c>
33d12508:	e5930000 	ldr	r0, [r3]
    os_data_addr_saved = os_data_addr;
33d1250c:	e59f3030 	ldr	r3, [pc, #48]	; 33d12544 <k_data_save+0x50>
33d12510:	e593c000 	ldr	ip, [r3]
    k_data_escape = 0;
    os_data_init ();
}
void k_data_save (void)
{
    k_data_escape_saved = k_data_escape;
33d12514:	e59f302c 	ldr	r3, [pc, #44]	; 33d12548 <k_data_save+0x54>
33d12518:	e5832000 	str	r2, [r3]
    os_data_count = 0;
    os_data_addr = bin_start_address;
}
static void os_data_save (void)
{
    os_data_state_saved = os_data_state;
33d1251c:	e59f3028 	ldr	r3, [pc, #40]	; 33d1254c <k_data_save+0x58>
33d12520:	e5831000 	str	r1, [r3]
    os_data_count_saved = os_data_count;
33d12524:	e59f3024 	ldr	r3, [pc, #36]	; 33d12550 <k_data_save+0x5c>
33d12528:	e5830000 	str	r0, [r3]
    os_data_addr_saved = os_data_addr;
33d1252c:	e59f3020 	ldr	r3, [pc, #32]	; 33d12554 <k_data_save+0x60>
33d12530:	e583c000 	str	ip, [r3]
33d12534:	e1a0f00e 	mov	pc, lr
33d12538:	33d60bf4 	.word	0x33d60bf4
33d1253c:	33d60bdc 	.word	0x33d60bdc
33d12540:	33d60b74 	.word	0x33d60b74
33d12544:	33d60be8 	.word	0x33d60be8
33d12548:	33d60bf8 	.word	0x33d60bf8
33d1254c:	33d60be0 	.word	0x33d60be0
33d12550:	33d60be4 	.word	0x33d60be4
33d12554:	33d60bec 	.word	0x33d60bec

33d12558 <k_data_restore>:
    k_data_escape_saved = k_data_escape;
    os_data_save ();
}
void k_data_restore (void)
{
    k_data_escape = k_data_escape_saved;
33d12558:	e59f303c 	ldr	r3, [pc, #60]	; 33d1259c <k_data_restore+0x44>
33d1255c:	e5932000 	ldr	r2, [r3]
    os_data_count_saved = os_data_count;
    os_data_addr_saved = os_data_addr;
}
static void os_data_restore (void)
{
    os_data_state = os_data_state_saved;
33d12560:	e59f3038 	ldr	r3, [pc, #56]	; 33d125a0 <k_data_restore+0x48>
33d12564:	e5931000 	ldr	r1, [r3]
    os_data_count = os_data_count_saved;
33d12568:	e59f3034 	ldr	r3, [pc, #52]	; 33d125a4 <k_data_restore+0x4c>
33d1256c:	e5930000 	ldr	r0, [r3]
    os_data_addr = os_data_addr_saved;
33d12570:	e59f3030 	ldr	r3, [pc, #48]	; 33d125a8 <k_data_restore+0x50>
33d12574:	e593c000 	ldr	ip, [r3]
    k_data_escape_saved = k_data_escape;
    os_data_save ();
}
void k_data_restore (void)
{
    k_data_escape = k_data_escape_saved;
33d12578:	e59f302c 	ldr	r3, [pc, #44]	; 33d125ac <k_data_restore+0x54>
33d1257c:	e5832000 	str	r2, [r3]
    os_data_count_saved = os_data_count;
    os_data_addr_saved = os_data_addr;
}
static void os_data_restore (void)
{
    os_data_state = os_data_state_saved;
33d12580:	e59f3028 	ldr	r3, [pc, #40]	; 33d125b0 <k_data_restore+0x58>
33d12584:	e5831000 	str	r1, [r3]
    os_data_count = os_data_count_saved;
33d12588:	e59f3024 	ldr	r3, [pc, #36]	; 33d125b4 <k_data_restore+0x5c>
33d1258c:	e5830000 	str	r0, [r3]
    os_data_addr = os_data_addr_saved;
33d12590:	e59f3020 	ldr	r3, [pc, #32]	; 33d125b8 <k_data_restore+0x60>
33d12594:	e583c000 	str	ip, [r3]
33d12598:	e1a0f00e 	mov	pc, lr
33d1259c:	33d60bf8 	.word	0x33d60bf8
33d125a0:	33d60be0 	.word	0x33d60be0
33d125a4:	33d60be4 	.word	0x33d60be4
33d125a8:	33d60bec 	.word	0x33d60bec
33d125ac:	33d60bf4 	.word	0x33d60bf4
33d125b0:	33d60bdc 	.word	0x33d60bdc
33d125b4:	33d60b74 	.word	0x33d60b74
33d125b8:	33d60be8 	.word	0x33d60be8

33d125bc <k_data_char>:
{
    k_data_escape = k_data_escape_saved;
    os_data_restore ();
}
void k_data_char (char new_char)
{
33d125bc:	e92d4010 	push	{r4, lr}
    if (k_data_escape) {
33d125c0:	e59f405c 	ldr	r4, [pc, #92]	; 33d12624 <k_data_char+0x68>
33d125c4:	e5943000 	ldr	r3, [r4]
{
    k_data_escape = k_data_escape_saved;
    os_data_restore ();
}
void k_data_char (char new_char)
{
33d125c8:	e20020ff 	and	r2, r0, #255	; 0xff
    if (k_data_escape) {
33d125cc:	e3530000 	cmp	r3, #0	; 0x0
        /* last char was escape - translate this character */
        os_data_char (ktrans (new_char));
33d125d0:	e1a00002 	mov	r0, r2
    k_data_escape = k_data_escape_saved;
    os_data_restore ();
}
void k_data_char (char new_char)
{
    if (k_data_escape) {
33d125d4:	0a000006 	beq	33d125f4 <k_data_char+0x38>
        /* last char was escape - translate this character */
        os_data_char (ktrans (new_char));
33d125d8:	ebffff48 	bl	33d12300 <ktrans>
33d125dc:	e59f3044 	ldr	r3, [pc, #68]	; 33d12628 <k_data_char+0x6c>
33d125e0:	e20000ff 	and	r0, r0, #255	; 0xff
33d125e4:	e1a0e00f 	mov	lr, pc
33d125e8:	e593f000 	ldr	pc, [r3]
        k_data_escape = 0;
33d125ec:	e3a03000 	mov	r3, #0	; 0x0
33d125f0:	ea000005 	b	33d1260c <k_data_char+0x50>
    } else {
        if (new_char == his_quote) {
33d125f4:	e59f3030 	ldr	r3, [pc, #48]	; 33d1262c <k_data_char+0x70>
33d125f8:	e5d33000 	ldrb	r3, [r3]
33d125fc:	e1530002 	cmp	r3, r2
            /* this char is escape - remember */
            k_data_escape = 1;
        } else {
            /* otherwise send this char as-is */
            os_data_char (new_char);
33d12600:	e1a00002 	mov	r0, r2
    if (k_data_escape) {
        /* last char was escape - translate this character */
        os_data_char (ktrans (new_char));
        k_data_escape = 0;
    } else {
        if (new_char == his_quote) {
33d12604:	1a000002 	bne	33d12614 <k_data_char+0x58>
            /* this char is escape - remember */
            k_data_escape = 1;
33d12608:	e3a03001 	mov	r3, #1	; 0x1
33d1260c:	e5843000 	str	r3, [r4]
33d12610:	e8bd8010 	pop	{r4, pc}
        } else {
            /* otherwise send this char as-is */
            os_data_char (new_char);
33d12614:	e59f300c 	ldr	r3, [pc, #12]	; 33d12628 <k_data_char+0x6c>
33d12618:	e1a0e00f 	mov	lr, pc
33d1261c:	e593f000 	ldr	pc, [r3]
33d12620:	e8bd8010 	pop	{r4, pc}
33d12624:	33d60bf4 	.word	0x33d60bf4
33d12628:	33d60ba8 	.word	0x33d60ba8
33d1262c:	33d60ba1 	.word	0x33d60ba1

33d12630 <handle_send_packet>:
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
33d12630:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    int length = 3;
    int bytes;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
33d12634:	e59f91f0 	ldr	r9, [pc, #496]	; 33d1282c <handle_send_packet+0x1fc>
    his_pad_count = 0;
    his_pad_char = '\0';
    his_quote = K_ESCAPE;

    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
33d12638:	e59f11f0 	ldr	r1, [pc, #496]	; 33d12830 <handle_send_packet+0x200>
{
    int length = 3;
    int bytes;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
33d1263c:	e3a0300d 	mov	r3, #13	; 0xd
    his_pad_count = 0;
33d12640:	e59fb1ec 	ldr	fp, [pc, #492]	; 33d12834 <handle_send_packet+0x204>
{
    int length = 3;
    int bytes;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
33d12644:	e5c93000 	strb	r3, [r9]
    his_pad_count = 0;
    his_pad_char = '\0';
33d12648:	e59f31e8 	ldr	r3, [pc, #488]	; 33d12838 <handle_send_packet+0x208>
    his_quote = K_ESCAPE;

    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
33d1264c:	e591c000 	ldr	ip, [r1]
    int length = 3;
    int bytes;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
33d12650:	e3a02000 	mov	r2, #0	; 0x0
    his_pad_char = '\0';
    his_quote = K_ESCAPE;

    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
33d12654:	e59fe1e0 	ldr	lr, [pc, #480]	; 33d1283c <handle_send_packet+0x20c>
    int bytes;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
    his_pad_char = '\0';
33d12658:	e5c32000 	strb	r2, [r3]
    int length = 3;
    int bytes;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
33d1265c:	e58b2000 	str	r2, [fp]
    his_pad_char = '\0';
    his_quote = K_ESCAPE;
33d12660:	e59f21d8 	ldr	r2, [pc, #472]	; 33d12840 <handle_send_packet+0x210>
33d12664:	e3a03023 	mov	r3, #35	; 0x23

    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
33d12668:	e15c000e 	cmp	ip, lr

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
    his_pad_char = '\0';
    his_quote = K_ESCAPE;
33d1266c:	e5c23000 	strb	r3, [r2]

    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
        --send_ptr;
33d12670:	024c3001 	subeq	r3, ip, #1	; 0x1
33d12674:	05813000 	streq	r3, [r1]
    bytes = send_ptr - send_parms;  /* how many bytes we'll process */
33d12678:	e5913000 	ldr	r3, [r1]
33d1267c:	e24e7013 	sub	r7, lr, #19	; 0x13
33d12680:	e0674003 	rsb	r4, r7, r3
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
33d12684:	e24dd004 	sub	sp, sp, #4	; 0x4
    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
        --send_ptr;
    bytes = send_ptr - send_parms;  /* how many bytes we'll process */
    do {
        if (bytes-- <= 0)
33d12688:	e3540000 	cmp	r4, #0	; 0x0
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
33d1268c:	e58d0000 	str	r0, [sp]
    int length = 3;
33d12690:	e3a06003 	mov	r6, #3	; 0x3
    /* ignore last character if it filled the buffer */
    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
        --send_ptr;
    bytes = send_ptr - send_parms;  /* how many bytes we'll process */
    do {
        if (bytes-- <= 0)
33d12694:	e2444001 	sub	r4, r4, #1	; 0x1
33d12698:	da000049 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle MAXL - max length */
        /* ignore what he says - most I'll take (here) is 94 */
        a_b[++length] = tochar (94);
33d1269c:	e59f51a0 	ldr	r5, [pc, #416]	; 33d12844 <handle_send_packet+0x214>
        if (bytes-- <= 0)
33d126a0:	e3540000 	cmp	r4, #0	; 0x0
    do {
        if (bytes-- <= 0)
            break;
        /* handle MAXL - max length */
        /* ignore what he says - most I'll take (here) is 94 */
        a_b[++length] = tochar (94);
33d126a4:	e3a0a07e 	mov	sl, #126	; 0x7e
33d126a8:	e5c5a004 	strb	sl, [r5, #4]
        if (bytes-- <= 0)
33d126ac:	e2444001 	sub	r4, r4, #1	; 0x1
    do {
        if (bytes-- <= 0)
            break;
        /* handle MAXL - max length */
        /* ignore what he says - most I'll take (here) is 94 */
        a_b[++length] = tochar (94);
33d126b0:	e3a06004 	mov	r6, #4	; 0x4
        if (bytes-- <= 0)
33d126b4:	da000042 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle TIME - time you should wait for my packets */
        /* ignore what he says - don't wait for my ack longer than 1 second */
        a_b[++length] = tochar (1);
        if (bytes-- <= 0)
33d126b8:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = tochar (94);
        if (bytes-- <= 0)
            break;
        /* handle TIME - time you should wait for my packets */
        /* ignore what he says - don't wait for my ack longer than 1 second */
        a_b[++length] = tochar (1);
33d126bc:	e3a03021 	mov	r3, #33	; 0x21
33d126c0:	e5c53005 	strb	r3, [r5, #5]
        if (bytes-- <= 0)
33d126c4:	e2444001 	sub	r4, r4, #1	; 0x1
        a_b[++length] = tochar (94);
        if (bytes-- <= 0)
            break;
        /* handle TIME - time you should wait for my packets */
        /* ignore what he says - don't wait for my ack longer than 1 second */
        a_b[++length] = tochar (1);
33d126c8:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d126cc:	da00003c 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle NPAD - number of pad chars I need */
        /* remember what he says - I need none */
        his_pad_count = untochar (send_parms[2]);
33d126d0:	e5d73002 	ldrb	r3, [r7, #2]
33d126d4:	e2433020 	sub	r3, r3, #32	; 0x20
        a_b[++length] = tochar (0);
        if (bytes-- <= 0)
33d126d8:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = tochar (1);
        if (bytes-- <= 0)
            break;
        /* handle NPAD - number of pad chars I need */
        /* remember what he says - I need none */
        his_pad_count = untochar (send_parms[2]);
33d126dc:	e20330ff 	and	r3, r3, #255	; 0xff
        a_b[++length] = tochar (0);
33d126e0:	e3a02020 	mov	r2, #32	; 0x20
        a_b[++length] = tochar (1);
        if (bytes-- <= 0)
            break;
        /* handle NPAD - number of pad chars I need */
        /* remember what he says - I need none */
        his_pad_count = untochar (send_parms[2]);
33d126e4:	e58b3000 	str	r3, [fp]
        a_b[++length] = tochar (0);
33d126e8:	e5c52006 	strb	r2, [r5, #6]
        if (bytes-- <= 0)
33d126ec:	e2444001 	sub	r4, r4, #1	; 0x1
        if (bytes-- <= 0)
            break;
        /* handle NPAD - number of pad chars I need */
        /* remember what he says - I need none */
        his_pad_count = untochar (send_parms[2]);
        a_b[++length] = tochar (0);
33d126f0:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d126f4:	da000032 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle PADC - pad chars I need */
        /* remember what he says - I need none */
        his_pad_char = ktrans (send_parms[3]);
33d126f8:	e5d70003 	ldrb	r0, [r7, #3]
33d126fc:	ebfffeff 	bl	33d12300 <ktrans>
33d12700:	e59f3130 	ldr	r3, [pc, #304]	; 33d12838 <handle_send_packet+0x208>
        a_b[++length] = 0x40;   /* He should ignore this */
        if (bytes-- <= 0)
33d12704:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = tochar (0);
        if (bytes-- <= 0)
            break;
        /* handle PADC - pad chars I need */
        /* remember what he says - I need none */
        his_pad_char = ktrans (send_parms[3]);
33d12708:	e5c30000 	strb	r0, [r3]
        a_b[++length] = 0x40;   /* He should ignore this */
33d1270c:	e3a03040 	mov	r3, #64	; 0x40
33d12710:	e5c53007 	strb	r3, [r5, #7]
        if (bytes-- <= 0)
33d12714:	e2444001 	sub	r4, r4, #1	; 0x1
        if (bytes-- <= 0)
            break;
        /* handle PADC - pad chars I need */
        /* remember what he says - I need none */
        his_pad_char = ktrans (send_parms[3]);
        a_b[++length] = 0x40;   /* He should ignore this */
33d12718:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d1271c:	da000028 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle EOL - end of line he needs */
        /* remember what he says - I need CR */
        his_eol = untochar (send_parms[4]);
33d12720:	e5d73004 	ldrb	r3, [r7, #4]
33d12724:	e2433020 	sub	r3, r3, #32	; 0x20
        a_b[++length] = tochar (END_CHAR);
        if (bytes-- <= 0)
33d12728:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = 0x40;   /* He should ignore this */
        if (bytes-- <= 0)
            break;
        /* handle EOL - end of line he needs */
        /* remember what he says - I need CR */
        his_eol = untochar (send_parms[4]);
33d1272c:	e5c93000 	strb	r3, [r9]
        a_b[++length] = tochar (END_CHAR);
33d12730:	e3a0302d 	mov	r3, #45	; 0x2d
33d12734:	e5c53008 	strb	r3, [r5, #8]
        if (bytes-- <= 0)
33d12738:	e2444001 	sub	r4, r4, #1	; 0x1
        if (bytes-- <= 0)
            break;
        /* handle EOL - end of line he needs */
        /* remember what he says - I need CR */
        his_eol = untochar (send_parms[4]);
        a_b[++length] = tochar (END_CHAR);
33d1273c:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d12740:	da00001f 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle QCTL - quote control char he'll use */
        /* remember what he says - I'll use '#' */
        his_quote = send_parms[5];
33d12744:	e5d72005 	ldrb	r2, [r7, #5]
33d12748:	e59f30f0 	ldr	r3, [pc, #240]	; 33d12840 <handle_send_packet+0x210>
        a_b[++length] = '#';
        if (bytes-- <= 0)
33d1274c:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = tochar (END_CHAR);
        if (bytes-- <= 0)
            break;
        /* handle QCTL - quote control char he'll use */
        /* remember what he says - I'll use '#' */
        his_quote = send_parms[5];
33d12750:	e5c32000 	strb	r2, [r3]
        a_b[++length] = '#';
33d12754:	e3a02023 	mov	r2, #35	; 0x23
33d12758:	e5c52009 	strb	r2, [r5, #9]
        if (bytes-- <= 0)
33d1275c:	e2444001 	sub	r4, r4, #1	; 0x1
        if (bytes-- <= 0)
            break;
        /* handle QCTL - quote control char he'll use */
        /* remember what he says - I'll use '#' */
        his_quote = send_parms[5];
        a_b[++length] = '#';
33d12760:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d12764:	da000016 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle QBIN - 8-th bit prefixing */
        /* ignore what he says - I refuse */
        a_b[++length] = 'N';
        if (bytes-- <= 0)
33d12768:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = '#';
        if (bytes-- <= 0)
            break;
        /* handle QBIN - 8-th bit prefixing */
        /* ignore what he says - I refuse */
        a_b[++length] = 'N';
33d1276c:	e3a0204e 	mov	r2, #78	; 0x4e
33d12770:	e5c5200a 	strb	r2, [r5, #10]
        if (bytes-- <= 0)
33d12774:	e2444001 	sub	r4, r4, #1	; 0x1
        a_b[++length] = '#';
        if (bytes-- <= 0)
            break;
        /* handle QBIN - 8-th bit prefixing */
        /* ignore what he says - I refuse */
        a_b[++length] = 'N';
33d12778:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d1277c:	da000010 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle CHKT - the clock check type */
        /* ignore what he says - I do type 1 (for now) */
        a_b[++length] = '1';
        if (bytes-- <= 0)
33d12780:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = 'N';
        if (bytes-- <= 0)
            break;
        /* handle CHKT - the clock check type */
        /* ignore what he says - I do type 1 (for now) */
        a_b[++length] = '1';
33d12784:	e3a03031 	mov	r3, #49	; 0x31
33d12788:	e5c5300b 	strb	r3, [r5, #11]
        if (bytes-- <= 0)
33d1278c:	e2444001 	sub	r4, r4, #1	; 0x1
        a_b[++length] = 'N';
        if (bytes-- <= 0)
            break;
        /* handle CHKT - the clock check type */
        /* ignore what he says - I do type 1 (for now) */
        a_b[++length] = '1';
33d12790:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d12794:	da00000a 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle REPT - the repeat prefix */
        /* ignore what he says - I refuse (for now) */
        a_b[++length] = 'N';
        if (bytes-- <= 0)
33d12798:	e3540000 	cmp	r4, #0	; 0x0
        a_b[++length] = '1';
        if (bytes-- <= 0)
            break;
        /* handle REPT - the repeat prefix */
        /* ignore what he says - I refuse (for now) */
        a_b[++length] = 'N';
33d1279c:	e5c5200c 	strb	r2, [r5, #12]
33d127a0:	e2866001 	add	r6, r6, #1	; 0x1
        if (bytes-- <= 0)
33d127a4:	da000006 	ble	33d127c4 <handle_send_packet+0x194>
            break;
        /* handle CAPAS - the capabilities mask */
        /* ignore what he says - I only do long packets - I don't do windows */
        a_b[++length] = tochar (2); /* only long packets */
33d127a8:	e243300f 	sub	r3, r3, #15	; 0xf
33d127ac:	e5c5300d 	strb	r3, [r5, #13]
        a_b[++length] = tochar (0); /* no windows */
33d127b0:	e3a03020 	mov	r3, #32	; 0x20
        a_b[++length] = tochar (94);    /* large packet msb */
        a_b[++length] = tochar (94);    /* large packet lsb */
33d127b4:	e5c5a010 	strb	sl, [r5, #16]
        if (bytes-- <= 0)
            break;
        /* handle CAPAS - the capabilities mask */
        /* ignore what he says - I only do long packets - I don't do windows */
        a_b[++length] = tochar (2); /* only long packets */
        a_b[++length] = tochar (0); /* no windows */
33d127b8:	e5c5300e 	strb	r3, [r5, #14]
        a_b[++length] = tochar (94);    /* large packet msb */
33d127bc:	e5c5a00f 	strb	sl, [r5, #15]
        a_b[++length] = tochar (94);    /* large packet lsb */
33d127c0:	e2866004 	add	r6, r6, #4	; 0x4
    } while (0);

    a_b[0] = START_CHAR;
33d127c4:	e59f4078 	ldr	r4, [pc, #120]	; 33d12844 <handle_send_packet+0x214>
    a_b[1] = tochar (length);
    a_b[2] = tochar (n);
33d127c8:	e59d2000 	ldr	r2, [sp]
        a_b[++length] = tochar (0); /* no windows */
        a_b[++length] = tochar (94);    /* large packet msb */
        a_b[++length] = tochar (94);    /* large packet lsb */
    } while (0);

    a_b[0] = START_CHAR;
33d127cc:	e3a03001 	mov	r3, #1	; 0x1
    a_b[1] = tochar (length);
    a_b[2] = tochar (n);
33d127d0:	e2821020 	add	r1, r2, #32	; 0x20
        a_b[++length] = tochar (0); /* no windows */
        a_b[++length] = tochar (94);    /* large packet msb */
        a_b[++length] = tochar (94);    /* large packet lsb */
    } while (0);

    a_b[0] = START_CHAR;
33d127d4:	e5c43000 	strb	r3, [r4]
    a_b[1] = tochar (length);
33d127d8:	e2862020 	add	r2, r6, #32	; 0x20
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[++length] = '\0';
33d127dc:	e3a05000 	mov	r5, #0	; 0x0
33d127e0:	e2866001 	add	r6, r6, #1	; 0x1
    } while (0);

    a_b[0] = START_CHAR;
    a_b[1] = tochar (length);
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
33d127e4:	e2833058 	add	r3, r3, #88	; 0x58
33d127e8:	e5c43003 	strb	r3, [r4, #3]
        a_b[++length] = tochar (94);    /* large packet msb */
        a_b[++length] = tochar (94);    /* large packet lsb */
    } while (0);

    a_b[0] = START_CHAR;
    a_b[1] = tochar (length);
33d127ec:	e5c42001 	strb	r2, [r4, #1]
    a_b[2] = tochar (n);
33d127f0:	e5c41002 	strb	r1, [r4, #2]
    a_b[3] = ACK_TYPE;
    a_b[++length] = '\0';
    a_b[length] = tochar (chk1 (&a_b[1]));
33d127f4:	e2840001 	add	r0, r4, #1	; 0x1

    a_b[0] = START_CHAR;
    a_b[1] = tochar (length);
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[++length] = '\0';
33d127f8:	e7c45006 	strb	r5, [r4, r6]
    a_b[length] = tochar (chk1 (&a_b[1]));
33d127fc:	ebfffeca 	bl	33d1232c <chk1>
    a_b[++length] = his_eol;
33d12800:	e5d93000 	ldrb	r3, [r9]
    a_b[0] = START_CHAR;
    a_b[1] = tochar (length);
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[++length] = '\0';
    a_b[length] = tochar (chk1 (&a_b[1]));
33d12804:	e2800020 	add	r0, r0, #32	; 0x20
33d12808:	e7c40006 	strb	r0, [r4, r6]
    a_b[++length] = his_eol;
33d1280c:	e2866001 	add	r6, r6, #1	; 0x1
33d12810:	e7c43006 	strb	r3, [r4, r6]
    a_b[++length] = '\0';
    s1_sendpacket (a_b);
33d12814:	e1a00004 	mov	r0, r4
    a_b[2] = tochar (n);
    a_b[3] = ACK_TYPE;
    a_b[++length] = '\0';
    a_b[length] = tochar (chk1 (&a_b[1]));
    a_b[++length] = his_eol;
    a_b[++length] = '\0';
33d12818:	e2866001 	add	r6, r6, #1	; 0x1
33d1281c:	e7c45006 	strb	r5, [r4, r6]
    s1_sendpacket (a_b);
33d12820:	e28dd004 	add	sp, sp, #4	; 0x4
33d12824:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
33d12828:	eafffecb 	b	33d1235c <s1_sendpacket>
33d1282c:	33d60b98 	.word	0x33d60b98
33d12830:	33d60bc0 	.word	0x33d60bc0
33d12834:	33d60b9c 	.word	0x33d60b9c
33d12838:	33d60ba0 	.word	0x33d60ba0
33d1283c:	33d60bbf 	.word	0x33d60bbf
33d12840:	33d60ba1 	.word	0x33d60ba1
33d12844:	33d60bc4 	.word	0x33d60bc4

33d12848 <getcxmodem>:
        ++z;
    }
    return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
33d12848:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    if (tstc())
33d1284c:	eb0011c6 	bl	33d16f6c <tstc>
33d12850:	e3500000 	cmp	r0, #0	; 0x0
        return (getc());
    return -1;
}
33d12854:	03e00000 	mvneq	r0, #0	; 0x0
    }
    return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
    if (tstc())
33d12858:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
        return (getc());
    return -1;
}
33d1285c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
    return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
    if (tstc())
        return (getc());
33d12860:	ea0011bb 	b	33d16f54 <getc>

33d12864 <do_load_serial_bin>:
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d12864:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

    /* pre-set offset from CFG_LOAD_ADDR */
    offset = CFG_LOAD_ADDR;

    /* pre-set offset from $loadaddr */
    if ((s = getenv("loadaddr")) != NULL) {
33d12868:	e59f0654 	ldr	r0, [pc, #1620]	; 33d12ec4 <do_load_serial_bin+0x660>
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d1286c:	e24dde89 	sub	sp, sp, #2192	; 0x890
33d12870:	e1a05002 	mov	r5, r2
33d12874:	e1a04003 	mov	r4, r3

    /* pre-set offset from CFG_LOAD_ADDR */
    offset = CFG_LOAD_ADDR;

    /* pre-set offset from $loadaddr */
    if ((s = getenv("loadaddr")) != NULL) {
33d12878:	eb000bf4 	bl	33d15850 <getenv>
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
    ulong offset = 0;
33d1287c:	e3a02000 	mov	r2, #0	; 0x0
    int load_baudrate, current_baudrate;
    int rcode = 0;
    char *s;

    /* pre-set offset from CFG_LOAD_ADDR */
    offset = CFG_LOAD_ADDR;
33d12880:	e3a03437 	mov	r3, #922746880	; 0x37000000

    /* pre-set offset from $loadaddr */
    if ((s = getenv("loadaddr")) != NULL) {
33d12884:	e3500000 	cmp	r0, #0	; 0x0
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
    ulong offset = 0;
33d12888:	e58d2004 	str	r2, [sp, #4]
    int load_baudrate, current_baudrate;
    int rcode = 0;
    char *s;

    /* pre-set offset from CFG_LOAD_ADDR */
    offset = CFG_LOAD_ADDR;
33d1288c:	e58d300c 	str	r3, [sp, #12]

    /* pre-set offset from $loadaddr */
    if ((s = getenv("loadaddr")) != NULL) {
33d12890:	0a000003 	beq	33d128a4 <do_load_serial_bin+0x40>
        offset = simple_strtoul(s, NULL, 16);
33d12894:	e1a01002 	mov	r1, r2
33d12898:	e2822010 	add	r2, r2, #16	; 0x10
33d1289c:	eb001f2e 	bl	33d1a55c <simple_strtoul>
33d128a0:	e58d000c 	str	r0, [sp, #12]
    }

    load_baudrate = current_baudrate = gd->baudrate;
33d128a4:	e5982008 	ldr	r2, [r8, #8]

    if (argc >= 2) {
33d128a8:	e3550001 	cmp	r5, #1	; 0x1
    /* pre-set offset from $loadaddr */
    if ((s = getenv("loadaddr")) != NULL) {
        offset = simple_strtoul(s, NULL, 16);
    }

    load_baudrate = current_baudrate = gd->baudrate;
33d128ac:	e58d2008 	str	r2, [sp, #8]
33d128b0:	e1a0b002 	mov	fp, r2

    if (argc >= 2) {
33d128b4:	da000004 	ble	33d128cc <do_load_serial_bin+0x68>
        offset = simple_strtoul(argv[1], NULL, 16);
33d128b8:	e5940004 	ldr	r0, [r4, #4]
33d128bc:	e59d1004 	ldr	r1, [sp, #4]
33d128c0:	e3a02010 	mov	r2, #16	; 0x10
33d128c4:	eb001f24 	bl	33d1a55c <simple_strtoul>
33d128c8:	e58d000c 	str	r0, [sp, #12]
    }
    if (argc == 3) {
33d128cc:	e3550003 	cmp	r5, #3	; 0x3
33d128d0:	1a000006 	bne	33d128f0 <do_load_serial_bin+0x8c>
        load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
33d128d4:	e5940008 	ldr	r0, [r4, #8]
33d128d8:	e59d1004 	ldr	r1, [sp, #4]
33d128dc:	e3a0200a 	mov	r2, #10	; 0xa
33d128e0:	eb001f1d 	bl	33d1a55c <simple_strtoul>

        /* default to current baudrate */
        if (load_baudrate == 0)
            load_baudrate = current_baudrate;
33d128e4:	e3500000 	cmp	r0, #0	; 0x0
33d128e8:	e59db008 	ldr	fp, [sp, #8]
33d128ec:	11a0b000 	movne	fp, r0
    }

    if (load_baudrate != current_baudrate) {
33d128f0:	e59d3008 	ldr	r3, [sp, #8]
33d128f4:	e15b0003 	cmp	fp, r3
33d128f8:	0a00000b 	beq	33d1292c <do_load_serial_bin+0xc8>
        printf ("## Switch baudrate to %d bps and press ENTER ...\n",
33d128fc:	e1a0100b 	mov	r1, fp
33d12900:	e59f05c0 	ldr	r0, [pc, #1472]	; 33d12ec8 <do_load_serial_bin+0x664>
33d12904:	eb0011af 	bl	33d16fc8 <printf>
            load_baudrate);
        udelay(50000);
33d12908:	e59f05bc 	ldr	r0, [pc, #1468]	; 33d12ecc <do_load_serial_bin+0x668>
33d1290c:	ebffb93e 	bl	33d00e0c <udelay>
        gd->baudrate = load_baudrate;
33d12910:	e588b008 	str	fp, [r8, #8]
        serial_setbrg ();
33d12914:	eb002e6a 	bl	33d1e2c4 <serial_setbrg>
        udelay(50000);
33d12918:	e59f05ac 	ldr	r0, [pc, #1452]	; 33d12ecc <do_load_serial_bin+0x668>
33d1291c:	ebffb93a 	bl	33d00e0c <udelay>
        for (;;) {
            if (getc() == '\r')
33d12920:	eb00118b 	bl	33d16f54 <getc>
33d12924:	e350000d 	cmp	r0, #13	; 0xd
33d12928:	1afffffc 	bne	33d12920 <do_load_serial_bin+0xbc>
                break;
        }
    }

    /* support xmodem, www.embedsky.net */
    if (strcmp(argv[0],"loadx")==0) {
33d1292c:	e5940000 	ldr	r0, [r4]
33d12930:	e59f1598 	ldr	r1, [pc, #1432]	; 33d12ed0 <do_load_serial_bin+0x66c>
33d12934:	eb001dcb 	bl	33d1a068 <strcmp>
33d12938:	e2505000 	subs	r5, r0, #0	; 0x0
33d1293c:	1a00003c 	bne	33d12a34 <do_load_serial_bin+0x1d0>
        printf ("## Ready for binary (xmodem) download "
33d12940:	e59f058c 	ldr	r0, [pc, #1420]	; 33d12ed4 <do_load_serial_bin+0x670>
33d12944:	e59d100c 	ldr	r1, [sp, #12]
33d12948:	e1a0200b 	mov	r2, fp
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_xmodem;
    res = xyzModem_stream_open (&info, &err);
33d1294c:	e28d9020 	add	r9, sp, #32	; 0x20
        }
    }

    /* support xmodem, www.embedsky.net */
    if (strcmp(argv[0],"loadx")==0) {
        printf ("## Ready for binary (xmodem) download "
33d12950:	eb00119c 	bl	33d16fc8 <printf>
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_xmodem;
    res = xyzModem_stream_open (&info, &err);
33d12954:	e249900c 	sub	r9, r9, #12	; 0xc
33d12958:	e28d0e86 	add	r0, sp, #2144	; 0x860
    char xmodemBuf[1024];
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_xmodem;
33d1295c:	e3a03001 	mov	r3, #1	; 0x1
    res = xyzModem_stream_open (&info, &err);
33d12960:	e2800004 	add	r0, r0, #4	; 0x4
33d12964:	e1a01009 	mov	r1, r9
    char xmodemBuf[1024];
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_xmodem;
33d12968:	e58d3868 	str	r3, [sp, #2152]
    res = xyzModem_stream_open (&info, &err);
33d1296c:	eb001b5c 	bl	33d196e4 <xyzModem_stream_open>
    if (!res) {
33d12970:	e3500000 	cmp	r0, #0	; 0x0
    int err;
    int res;
    connection_info_t info;
    char xmodemBuf[1024];
    ulong store_addr = ~0;
    ulong addr = 0;
33d12974:	e1a07005 	mov	r7, r5

    size = 0;
33d12978:	e1a0a005 	mov	sl, r5
    info.mode = xyzModem_xmodem;
    res = xyzModem_stream_open (&info, &err);
    if (!res) {
33d1297c:	1a00001c 	bne	33d129f4 <do_load_serial_bin+0x190>

        while ((res =
33d12980:	ea00000f 	b	33d129c4 <do_load_serial_bin+0x160>
            xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
            size += res;
            addr += res;
#ifndef CFG_NO_FLASH
            if (addr2info (store_addr)) {
33d12984:	eb0017ce 	bl	33d188c4 <addr2info>
33d12988:	e3500000 	cmp	r0, #0	; 0x0
                int rc;

                rc = flash_write ((char *) xmodemBuf,
33d1298c:	e1a01005 	mov	r1, r5
33d12990:	e1a02004 	mov	r2, r4
33d12994:	e1a00006 	mov	r0, r6
    if (!res) {

        while ((res =
            xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
            size += res;
33d12998:	e0877004 	add	r7, r7, r4
            addr += res;
33d1299c:	e08aa004 	add	sl, sl, r4
#ifndef CFG_NO_FLASH
            if (addr2info (store_addr)) {
33d129a0:	0a000003 	beq	33d129b4 <do_load_serial_bin+0x150>
                int rc;

                rc = flash_write ((char *) xmodemBuf,
33d129a4:	eb0017d8 	bl	33d1890c <flash_write>
                          store_addr, res);
                if (rc != 0) {
33d129a8:	e3500000 	cmp	r0, #0	; 0x0
33d129ac:	0a000004 	beq	33d129c4 <do_load_serial_bin+0x160>
33d129b0:	ea00003f 	b	33d12ab4 <do_load_serial_bin+0x250>
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), xmodemBuf,
33d129b4:	e1a00005 	mov	r0, r5
33d129b8:	e1a01006 	mov	r1, r6
33d129bc:	e1a02004 	mov	r2, r4
33d129c0:	eb001e87 	bl	33d1a3e4 <memcpy>
    res = xyzModem_stream_open (&info, &err);
    if (!res) {

        while ((res =
            xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
33d129c4:	e59d200c 	ldr	r2, [sp, #12]
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), xmodemBuf,
33d129c8:	e28d6e47 	add	r6, sp, #1136	; 0x470
33d129cc:	e246600c 	sub	r6, r6, #12	; 0xc
    res = xyzModem_stream_open (&info, &err);
    if (!res) {

        while ((res =
            xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
33d129d0:	e08a5002 	add	r5, sl, r2
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), xmodemBuf,
33d129d4:	e3a01b01 	mov	r1, #1024	; 0x400
33d129d8:	e1a02009 	mov	r2, r9
33d129dc:	e1a00006 	mov	r0, r6
33d129e0:	eb001b9c 	bl	33d19858 <xyzModem_stream_read>
33d129e4:	e2504000 	subs	r4, r0, #0	; 0x0
            xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
            size += res;
            addr += res;
#ifndef CFG_NO_FLASH
            if (addr2info (store_addr)) {
33d129e8:	e1a00005 	mov	r0, r5
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), xmodemBuf,
33d129ec:	caffffe4 	bgt	33d12984 <do_load_serial_bin+0x120>
33d129f0:	ea000004 	b	33d12a08 <do_load_serial_bin+0x1a4>
                    res);
            }

        }
    } else {
        printf ("%s\n", xyzModem_error (err));
33d129f4:	e59d0014 	ldr	r0, [sp, #20]
33d129f8:	eb001c8c 	bl	33d19c30 <xyzModem_error>
33d129fc:	e1a01000 	mov	r1, r0
33d12a00:	e59f04d0 	ldr	r0, [pc, #1232]	; 33d12ed8 <do_load_serial_bin+0x674>
33d12a04:	eb00116f 	bl	33d16fc8 <printf>
    }

    xyzModem_stream_close (&err);
33d12a08:	e28d0020 	add	r0, sp, #32	; 0x20
33d12a0c:	e240000c 	sub	r0, r0, #12	; 0xc
33d12a10:	eb001c3a 	bl	33d19b00 <xyzModem_stream_close>
    xyzModem_stream_terminate (false, &getcxmodem);
33d12a14:	e3a00000 	mov	r0, #0	; 0x0
33d12a18:	e59f14bc 	ldr	r1, [pc, #1212]	; 33d12edc <do_load_serial_bin+0x678>
33d12a1c:	eb001c4d 	bl	33d19b58 <xyzModem_stream_terminate>


    flush_cache (offset, size);
33d12a20:	e59d000c 	ldr	r0, [sp, #12]
33d12a24:	e1a01007 	mov	r1, r7
33d12a28:	eb0030b7 	bl	33d1ed0c <flush_cache>

    printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
    sprintf (buf, "%X", size);
33d12a2c:	e28d4e87 	add	r4, sp, #2160	; 0x870
33d12a30:	ea000040 	b	33d12b38 <do_load_serial_bin+0x2d4>
            offset,
            load_baudrate);

        addr = load_serial_xmodem (offset);

    } else if (strcmp(argv[0],"loady")==0) {
33d12a34:	e5940000 	ldr	r0, [r4]
33d12a38:	e59f14a0 	ldr	r1, [pc, #1184]	; 33d12ee0 <do_load_serial_bin+0x67c>
33d12a3c:	eb001d89 	bl	33d1a068 <strcmp>
33d12a40:	e2504000 	subs	r4, r0, #0	; 0x0
33d12a44:	1a000047 	bne	33d12b68 <do_load_serial_bin+0x304>
        printf ("## Ready for binary (ymodem) download "
33d12a48:	e59f0494 	ldr	r0, [pc, #1172]	; 33d12ee4 <do_load_serial_bin+0x680>
33d12a4c:	e59d100c 	ldr	r1, [sp, #12]
33d12a50:	e1a0200b 	mov	r2, fp
33d12a54:	eb00115b 	bl	33d16fc8 <printf>
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_ymodem;
    res = xyzModem_stream_open (&info, &err);
33d12a58:	e28d9010 	add	r9, sp, #16	; 0x10
33d12a5c:	e28d0d11 	add	r0, sp, #1088	; 0x440
    char ymodemBuf[1024];
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_ymodem;
33d12a60:	e3a03002 	mov	r3, #2	; 0x2
    res = xyzModem_stream_open (&info, &err);
33d12a64:	e2400008 	sub	r0, r0, #8	; 0x8
33d12a68:	e1a01009 	mov	r1, r9
    char ymodemBuf[1024];
    ulong store_addr = ~0;
    ulong addr = 0;

    size = 0;
    info.mode = xyzModem_ymodem;
33d12a6c:	e58d343c 	str	r3, [sp, #1084]
    res = xyzModem_stream_open (&info, &err);
33d12a70:	eb001b1b 	bl	33d196e4 <xyzModem_stream_open>
    if (!res) {
33d12a74:	e3500000 	cmp	r0, #0	; 0x0
    int err;
    int res;
    connection_info_t info;
    char ymodemBuf[1024];
    ulong store_addr = ~0;
    ulong addr = 0;
33d12a78:	e1a07004 	mov	r7, r4

    size = 0;
33d12a7c:	e1a0a004 	mov	sl, r4
    info.mode = xyzModem_ymodem;
    res = xyzModem_stream_open (&info, &err);
    if (!res) {
33d12a80:	1a00001d 	bne	33d12afc <do_load_serial_bin+0x298>

        while ((res =
33d12a84:	ea000010 	b	33d12acc <do_load_serial_bin+0x268>
            xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
            size += res;
            addr += res;
#ifndef CFG_NO_FLASH
            if (addr2info (store_addr)) {
33d12a88:	eb00178d 	bl	33d188c4 <addr2info>
33d12a8c:	e3500000 	cmp	r0, #0	; 0x0
                int rc;

                rc = flash_write ((char *) ymodemBuf,
33d12a90:	e1a01005 	mov	r1, r5
33d12a94:	e1a02004 	mov	r2, r4
33d12a98:	e1a00006 	mov	r0, r6
    if (!res) {

        while ((res =
            xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
            size += res;
33d12a9c:	e0877004 	add	r7, r7, r4
            addr += res;
33d12aa0:	e08aa004 	add	sl, sl, r4
#ifndef CFG_NO_FLASH
            if (addr2info (store_addr)) {
33d12aa4:	0a000004 	beq	33d12abc <do_load_serial_bin+0x258>
                int rc;

                rc = flash_write ((char *) ymodemBuf,
33d12aa8:	eb001797 	bl	33d1890c <flash_write>
                          store_addr, res);
                if (rc != 0) {
33d12aac:	e3500000 	cmp	r0, #0	; 0x0
33d12ab0:	0a000005 	beq	33d12acc <do_load_serial_bin+0x268>
                    flash_perror (rc);
33d12ab4:	eb0017f6 	bl	33d18a94 <flash_perror>
33d12ab8:	ea0000ee 	b	33d12e78 <do_load_serial_bin+0x614>
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), ymodemBuf,
33d12abc:	e1a00005 	mov	r0, r5
33d12ac0:	e1a01006 	mov	r1, r6
33d12ac4:	e1a02004 	mov	r2, r4
33d12ac8:	eb001e45 	bl	33d1a3e4 <memcpy>
33d12acc:	e28d6040 	add	r6, sp, #64	; 0x40
    res = xyzModem_stream_open (&info, &err);
    if (!res) {

        while ((res =
            xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
33d12ad0:	e59d300c 	ldr	r3, [sp, #12]
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), ymodemBuf,
33d12ad4:	e2466008 	sub	r6, r6, #8	; 0x8
33d12ad8:	e3a01b01 	mov	r1, #1024	; 0x400
33d12adc:	e1a02009 	mov	r2, r9
33d12ae0:	e1a00006 	mov	r0, r6
    res = xyzModem_stream_open (&info, &err);
    if (!res) {

        while ((res =
            xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
33d12ae4:	e08a5003 	add	r5, sl, r3
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), ymodemBuf,
33d12ae8:	eb001b5a 	bl	33d19858 <xyzModem_stream_read>
33d12aec:	e2504000 	subs	r4, r0, #0	; 0x0
            xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
            store_addr = addr + offset;
            size += res;
            addr += res;
#ifndef CFG_NO_FLASH
            if (addr2info (store_addr)) {
33d12af0:	e1a00005 	mov	r0, r5
                    return (~0);
                }
            } else
#endif
            {
                memcpy ((char *) (store_addr), ymodemBuf,
33d12af4:	caffffe3 	bgt	33d12a88 <do_load_serial_bin+0x224>
33d12af8:	ea000004 	b	33d12b10 <do_load_serial_bin+0x2ac>
                    res);
            }

        }
    } else {
        printf ("%s\n", xyzModem_error (err));
33d12afc:	e59d0010 	ldr	r0, [sp, #16]
33d12b00:	eb001c4a 	bl	33d19c30 <xyzModem_error>
33d12b04:	e1a01000 	mov	r1, r0
33d12b08:	e59f03c8 	ldr	r0, [pc, #968]	; 33d12ed8 <do_load_serial_bin+0x674>
33d12b0c:	eb00112d 	bl	33d16fc8 <printf>
    }

    xyzModem_stream_close (&err);
33d12b10:	e28d0010 	add	r0, sp, #16	; 0x10
33d12b14:	eb001bf9 	bl	33d19b00 <xyzModem_stream_close>
    xyzModem_stream_terminate (false, &getcxmodem);
33d12b18:	e3a00000 	mov	r0, #0	; 0x0
33d12b1c:	e59f13b8 	ldr	r1, [pc, #952]	; 33d12edc <do_load_serial_bin+0x678>
33d12b20:	eb001c0c 	bl	33d19b58 <xyzModem_stream_terminate>


    flush_cache (offset, size);
33d12b24:	e59d000c 	ldr	r0, [sp, #12]
33d12b28:	e1a01007 	mov	r1, r7
33d12b2c:	eb003076 	bl	33d1ed0c <flush_cache>

    printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
    sprintf (buf, "%X", size);
33d12b30:	e28d4e45 	add	r4, sp, #1104	; 0x450
33d12b34:	e244400c 	sub	r4, r4, #12	; 0xc
    xyzModem_stream_terminate (false, &getcxmodem);


    flush_cache (offset, size);

    printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
33d12b38:	e1a01007 	mov	r1, r7
33d12b3c:	e1a02007 	mov	r2, r7
33d12b40:	e59f03a0 	ldr	r0, [pc, #928]	; 33d12ee8 <do_load_serial_bin+0x684>
33d12b44:	eb00111f 	bl	33d16fc8 <printf>
    sprintf (buf, "%X", size);
33d12b48:	e1a02007 	mov	r2, r7
33d12b4c:	e1a00004 	mov	r0, r4
33d12b50:	e59f1394 	ldr	r1, [pc, #916]	; 33d12eec <do_load_serial_bin+0x688>
33d12b54:	eb002066 	bl	33d1acf4 <sprintf>
    setenv ("filesize", buf);
33d12b58:	e1a01004 	mov	r1, r4
33d12b5c:	e59f038c 	ldr	r0, [pc, #908]	; 33d12ef0 <do_load_serial_bin+0x68c>
33d12b60:	eb000b1c 	bl	33d157d8 <setenv>

    return offset;
}

static ulong load_serial_ymodem (ulong offset)
{
33d12b64:	ea0000c3 	b	33d12e78 <do_load_serial_bin+0x614>

        addr = load_serial_ymodem (offset);

    } else {

        printf ("## Ready for binary (kermit) download "
33d12b68:	e59f0384 	ldr	r0, [pc, #900]	; 33d12ef4 <do_load_serial_bin+0x690>
33d12b6c:	e59d100c 	ldr	r1, [sp, #12]
33d12b70:	e1a0200b 	mov	r2, fp
33d12b74:	eb001113 	bl	33d16fc8 <printf>
    }
}
static void set_kerm_bin_mode (unsigned long *addr)
{
    bin_start_address = (char *) addr;
    os_data_init = bin_data_init;
33d12b78:	e59f2378 	ldr	r2, [pc, #888]	; 33d12ef8 <do_load_serial_bin+0x694>
33d12b7c:	e59f3378 	ldr	r3, [pc, #888]	; 33d12efc <do_load_serial_bin+0x698>
33d12b80:	e5832000 	str	r2, [r3]
    os_data_char = bin_data_char;
33d12b84:	e59f2374 	ldr	r2, [pc, #884]	; 33d12f00 <do_load_serial_bin+0x69c>
33d12b88:	e59f3374 	ldr	r3, [pc, #884]	; 33d12f04 <do_load_serial_bin+0x6a0>
33d12b8c:	e5832000 	str	r2, [r3]
    int n, last_n;
    int z = 0;
    int len_lo, len_hi;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
33d12b90:	e59f3370 	ldr	r3, [pc, #880]	; 33d12f08 <do_load_serial_bin+0x6a4>
33d12b94:	e3a0200d 	mov	r2, #13	; 0xd
33d12b98:	e5c32000 	strb	r2, [r3]
    his_pad_count = 0;
    his_pad_char = '\0';
    his_quote = K_ESCAPE;
33d12b9c:	e59f3368 	ldr	r3, [pc, #872]	; 33d12f0c <do_load_serial_bin+0x6a8>
33d12ba0:	e2822016 	add	r2, r2, #22	; 0x16
33d12ba4:	e5c32000 	strb	r2, [r3]
    int z = 0;
    int len_lo, len_hi;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
33d12ba8:	e59f3360 	ldr	r3, [pc, #864]	; 33d12f10 <do_load_serial_bin+0x6ac>
    char k_state, k_state_saved;
    int sum;
    int done;
    int length;
    int n, last_n;
    int z = 0;
33d12bac:	e3a01000 	mov	r1, #0	; 0x0
    int len_lo, len_hi;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
33d12bb0:	e5831000 	str	r1, [r3]
    his_pad_char = '\0';
33d12bb4:	e59f3358 	ldr	r3, [pc, #856]	; 33d12f14 <do_load_serial_bin+0x6b0>
        break;
    }
}
static void set_kerm_bin_mode (unsigned long *addr)
{
    bin_start_address = (char *) addr;
33d12bb8:	e59f2358 	ldr	r2, [pc, #856]	; 33d12f18 <do_load_serial_bin+0x6b4>
    int len_lo, len_hi;

    /* initialize some protocol parameters */
    his_eol = END_CHAR;     /* default end of line character */
    his_pad_count = 0;
    his_pad_char = '\0';
33d12bbc:	e5c31000 	strb	r1, [r3]
        break;
    }
}
static void set_kerm_bin_mode (unsigned long *addr)
{
    bin_start_address = (char *) addr;
33d12bc0:	e59d300c 	ldr	r3, [sp, #12]
33d12bc4:	e5823000 	str	r3, [r2]
    his_pad_count = 0;
    his_pad_char = '\0';
    his_quote = K_ESCAPE;

    /* initialize the k_recv and k_data state machine */
    done = 0;
33d12bc8:	e1a09001 	mov	r9, r1
    k_state = 0;
    k_data_init ();
33d12bcc:	ebfffe3e 	bl	33d124cc <k_data_init>
    k_state_saved = k_state;
    k_data_save ();
33d12bd0:	ebfffe47 	bl	33d124f4 <k_data_save>
    n = 0;              /* just to get rid of a warning */
    last_n = -1;
33d12bd4:	e3e02000 	mvn	r2, #0	; 0x0
33d12bd8:	e58d2000 	str	r2, [sp]
    done = 0;
    k_state = 0;
    k_data_init ();
    k_state_saved = k_state;
    k_data_save ();
    n = 0;              /* just to get rid of a warning */
33d12bdc:	e1a07009 	mov	r7, r9
     */

    /* enter main loop */
    while (!done) {
        /* set the send packet pointer to begining of send packet parms */
        send_ptr = send_parms;
33d12be0:	e59fa334 	ldr	sl, [pc, #820]	; 33d12f1c <do_load_serial_bin+0x6b8>
33d12be4:	e59f3334 	ldr	r3, [pc, #820]	; 33d12f20 <do_load_serial_bin+0x6bc>
33d12be8:	e58a3000 	str	r3, [sl]
#endif

        /* get a packet */
        /* wait for the starting character or ^C */
        for (;;) {
            switch (getc ()) {
33d12bec:	eb0010d8 	bl	33d16f54 <getc>
33d12bf0:	e3500001 	cmp	r0, #1	; 0x1
33d12bf4:	0a000003 	beq	33d12c08 <do_load_serial_bin+0x3a4>
33d12bf8:	e3500003 	cmp	r0, #3	; 0x3
33d12bfc:	1afffffa 	bne	33d12bec <do_load_serial_bin+0x388>
            case START_CHAR:    /* start packet */
                goto START;
            case ETX_CHAR:      /* ^C waiting for packet */
33d12c00:	e3a05000 	mov	r5, #0	; 0x0
33d12c04:	ea000073 	b	33d12dd8 <do_load_serial_bin+0x574>
            }
        }
START:
        /* get length of packet */
        sum = 0;
        new_char = getc ();
33d12c08:	eb0010d1 	bl	33d16f54 <getc>
        if ((new_char & 0xE0) == 0)
33d12c0c:	e31000e0 	tst	r0, #224	; 0xe0
            }
        }
START:
        /* get length of packet */
        sum = 0;
        new_char = getc ();
33d12c10:	e20010ff 	and	r1, r0, #255	; 0xff
        if ((new_char & 0xE0) == 0)
33d12c14:	0a00005b 	beq	33d12d88 <do_load_serial_bin+0x524>
            goto packet_error;
        sum += new_char & 0xff;
        length = untochar (new_char);
33d12c18:	e2413020 	sub	r3, r1, #32	; 0x20
        /* get length of packet */
        sum = 0;
        new_char = getc ();
        if ((new_char & 0xE0) == 0)
            goto packet_error;
        sum += new_char & 0xff;
33d12c1c:	e1a05001 	mov	r5, r1
        length = untochar (new_char);
33d12c20:	e20340ff 	and	r4, r3, #255	; 0xff
        /* get sequence number */
        new_char = getc ();
33d12c24:	eb0010ca 	bl	33d16f54 <getc>
        if ((new_char & 0xE0) == 0)
33d12c28:	e31000e0 	tst	r0, #224	; 0xe0
        if ((new_char & 0xE0) == 0)
            goto packet_error;
        sum += new_char & 0xff;
        length = untochar (new_char);
        /* get sequence number */
        new_char = getc ();
33d12c2c:	e20010ff 	and	r1, r0, #255	; 0xff
        if ((new_char & 0xE0) == 0)
33d12c30:	0a000054 	beq	33d12d88 <do_load_serial_bin+0x524>
            goto packet_error;
        sum += new_char & 0xff;
        n = untochar (new_char);
33d12c34:	e2413020 	sub	r3, r1, #32	; 0x20
33d12c38:	e20370ff 	and	r7, r3, #255	; 0xff
         * received.  Handling an invalid sequence number adds another layer
         * of complexity that may not be needed - yet!  At this time, I'm hoping
         * that I don't need to buffer the incoming data packets and can write
         * the data into memory in real time.
         */
        if (n == last_n) {
33d12c3c:	e59d3000 	ldr	r3, [sp]
33d12c40:	e1570003 	cmp	r7, r3
        length = untochar (new_char);
        /* get sequence number */
        new_char = getc ();
        if ((new_char & 0xE0) == 0)
            goto packet_error;
        sum += new_char & 0xff;
33d12c44:	e0855001 	add	r5, r5, r1
        n = untochar (new_char);
        --length;
33d12c48:	e2444001 	sub	r4, r4, #1	; 0x1
         * received.  Handling an invalid sequence number adds another layer
         * of complexity that may not be needed - yet!  At this time, I'm hoping
         * that I don't need to buffer the incoming data packets and can write
         * the data into memory in real time.
         */
        if (n == last_n) {
33d12c4c:	1a000001 	bne	33d12c58 <do_load_serial_bin+0x3f4>
            /* same sequence number, restore the previous state */
            k_state = k_state_saved;
            k_data_restore ();
33d12c50:	ebfffe40 	bl	33d12558 <k_data_restore>
33d12c54:	ea000001 	b	33d12c60 <do_load_serial_bin+0x3fc>
        } else {
            /* new sequence number, checkpoint the download */
            last_n = n;
33d12c58:	e58d7000 	str	r7, [sp]
            k_state_saved = k_state;
            k_data_save ();
33d12c5c:	ebfffe24 	bl	33d124f4 <k_data_save>
        }
        /* END NEW CODE */

        /* get packet type */
        new_char = getc ();
33d12c60:	eb0010bb 	bl	33d16f54 <getc>
        if ((new_char & 0xE0) == 0)
33d12c64:	e31000e0 	tst	r0, #224	; 0xe0
            k_data_save ();
        }
        /* END NEW CODE */

        /* get packet type */
        new_char = getc ();
33d12c68:	e20010ff 	and	r1, r0, #255	; 0xff
        if ((new_char & 0xE0) == 0)
33d12c6c:	0a000045 	beq	33d12d88 <do_load_serial_bin+0x524>
            goto packet_error;
        sum += new_char & 0xff;
        k_state = new_char;
        --length;
33d12c70:	e2444001 	sub	r4, r4, #1	; 0x1
        /* check for extended length */
        if (length == -2) {
33d12c74:	e3740002 	cmn	r4, #2	; 0x2

        /* get packet type */
        new_char = getc ();
        if ((new_char & 0xE0) == 0)
            goto packet_error;
        sum += new_char & 0xff;
33d12c78:	e0855001 	add	r5, r5, r1
        k_state = new_char;
33d12c7c:	e1a06001 	mov	r6, r1
        --length;
        /* check for extended length */
        if (length == -2) {
33d12c80:	1a00001b 	bne	33d12cf4 <do_load_serial_bin+0x490>
            /* (length byte was 0, decremented twice) */
            /* get the two length bytes */
            new_char = getc ();
33d12c84:	eb0010b2 	bl	33d16f54 <getc>
            if ((new_char & 0xE0) == 0)
33d12c88:	e31000e0 	tst	r0, #224	; 0xe0
        --length;
        /* check for extended length */
        if (length == -2) {
            /* (length byte was 0, decremented twice) */
            /* get the two length bytes */
            new_char = getc ();
33d12c8c:	e20010ff 	and	r1, r0, #255	; 0xff
            if ((new_char & 0xE0) == 0)
33d12c90:	0a00003c 	beq	33d12d88 <do_load_serial_bin+0x524>
                goto packet_error;
            sum += new_char & 0xff;
            len_hi = untochar (new_char);
33d12c94:	e2413020 	sub	r3, r1, #32	; 0x20
            /* (length byte was 0, decremented twice) */
            /* get the two length bytes */
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            sum += new_char & 0xff;
33d12c98:	e0855001 	add	r5, r5, r1
            len_hi = untochar (new_char);
33d12c9c:	e20340ff 	and	r4, r3, #255	; 0xff
            new_char = getc ();
33d12ca0:	eb0010ab 	bl	33d16f54 <getc>
            if ((new_char & 0xE0) == 0)
33d12ca4:	e31000e0 	tst	r0, #224	; 0xe0
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            sum += new_char & 0xff;
            len_hi = untochar (new_char);
            new_char = getc ();
33d12ca8:	e20010ff 	and	r1, r0, #255	; 0xff
            if ((new_char & 0xE0) == 0)
33d12cac:	0a000035 	beq	33d12d88 <do_load_serial_bin+0x524>
                goto packet_error;
            sum += new_char & 0xff;
            len_lo = untochar (new_char);
33d12cb0:	e2413020 	sub	r3, r1, #32	; 0x20
            length = len_hi * 95 + len_lo;
33d12cb4:	e0842084 	add	r2, r4, r4, lsl #1
33d12cb8:	e0642282 	rsb	r2, r4, r2, lsl #5
            len_hi = untochar (new_char);
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            sum += new_char & 0xff;
            len_lo = untochar (new_char);
33d12cbc:	e20330ff 	and	r3, r3, #255	; 0xff
            sum += new_char & 0xff;
            len_hi = untochar (new_char);
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            sum += new_char & 0xff;
33d12cc0:	e0855001 	add	r5, r5, r1
            len_lo = untochar (new_char);
            length = len_hi * 95 + len_lo;
33d12cc4:	e0824003 	add	r4, r2, r3
            /* check header checksum */
            new_char = getc ();
33d12cc8:	eb0010a1 	bl	33d16f54 <getc>
            if ((new_char & 0xE0) == 0)
33d12ccc:	e31000e0 	tst	r0, #224	; 0xe0
                goto packet_error;
            sum += new_char & 0xff;
            len_lo = untochar (new_char);
            length = len_hi * 95 + len_lo;
            /* check header checksum */
            new_char = getc ();
33d12cd0:	e20010ff 	and	r1, r0, #255	; 0xff
            if ((new_char & 0xE0) == 0)
33d12cd4:	0a00002b 	beq	33d12d88 <do_load_serial_bin+0x524>
                goto packet_error;
            if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
33d12cd8:	e1a03c05 	lsl	r3, r5, #24
33d12cdc:	e0853f23 	add	r3, r5, r3, lsr #30
33d12ce0:	e203303f 	and	r3, r3, #63	; 0x3f
33d12ce4:	e2833020 	add	r3, r3, #32	; 0x20
33d12ce8:	e1510003 	cmp	r1, r3
                goto packet_error;
            sum += new_char & 0xff;
33d12cec:	00855001 	addeq	r5, r5, r1
            length = len_hi * 95 + len_lo;
            /* check header checksum */
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
33d12cf0:	1a000024 	bne	33d12d88 <do_load_serial_bin+0x524>
            } else if (k_state == SEND_TYPE) {
                /* save send pack in buffer as is */
                *send_ptr++ = new_char;
                /* if too much data, back off the pointer */
                if (send_ptr >= &send_parms[SEND_DATA_SIZE])
                    --send_ptr;
33d12cf4:	e3540001 	cmp	r4, #1	; 0x1
33d12cf8:	da000014 	ble	33d12d50 <do_load_serial_bin+0x4ec>
            sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
        }
        /* bring in rest of packet */
        while (length > 1) {
            new_char = getc ();
33d12cfc:	eb001094 	bl	33d16f54 <getc>
            if ((new_char & 0xE0) == 0)
33d12d00:	e31000e0 	tst	r0, #224	; 0xe0
            sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
        }
        /* bring in rest of packet */
        while (length > 1) {
            new_char = getc ();
33d12d04:	e20010ff 	and	r1, r0, #255	; 0xff
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            sum += new_char & 0xff;
            --length;
33d12d08:	e2444001 	sub	r4, r4, #1	; 0x1
            if (k_state == DATA_TYPE) {
                /* pass on the data if this is a data packet */
                k_data_char (new_char);
33d12d0c:	e1a00001 	mov	r0, r1
/* --length; */ /* new length includes only data and block check to come */
        }
        /* bring in rest of packet */
        while (length > 1) {
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
33d12d10:	0a00001c 	beq	33d12d88 <do_load_serial_bin+0x524>
                goto packet_error;
            sum += new_char & 0xff;
            --length;
            if (k_state == DATA_TYPE) {
33d12d14:	e3560044 	cmp	r6, #68	; 0x44
        /* bring in rest of packet */
        while (length > 1) {
            new_char = getc ();
            if ((new_char & 0xE0) == 0)
                goto packet_error;
            sum += new_char & 0xff;
33d12d18:	e0855001 	add	r5, r5, r1
            --length;
            if (k_state == DATA_TYPE) {
33d12d1c:	1a000001 	bne	33d12d28 <do_load_serial_bin+0x4c4>
                /* pass on the data if this is a data packet */
                k_data_char (new_char);
33d12d20:	ebfffe25 	bl	33d125bc <k_data_char>
33d12d24:	eafffff2 	b	33d12cf4 <do_load_serial_bin+0x490>
            } else if (k_state == SEND_TYPE) {
33d12d28:	e3560053 	cmp	r6, #83	; 0x53
33d12d2c:	1afffff0 	bne	33d12cf4 <do_load_serial_bin+0x490>
                /* save send pack in buffer as is */
                *send_ptr++ = new_char;
33d12d30:	e59a3000 	ldr	r3, [sl]
                /* if too much data, back off the pointer */
                if (send_ptr >= &send_parms[SEND_DATA_SIZE])
33d12d34:	e59f21e8 	ldr	r2, [pc, #488]	; 33d12f24 <do_load_serial_bin+0x6c0>
            if (k_state == DATA_TYPE) {
                /* pass on the data if this is a data packet */
                k_data_char (new_char);
            } else if (k_state == SEND_TYPE) {
                /* save send pack in buffer as is */
                *send_ptr++ = new_char;
33d12d38:	e4c31001 	strb	r1, [r3], #1
                /* if too much data, back off the pointer */
                if (send_ptr >= &send_parms[SEND_DATA_SIZE])
33d12d3c:	e1530002 	cmp	r3, r2
                    --send_ptr;
33d12d40:	e2432001 	sub	r2, r3, #1	; 0x1
            if (k_state == DATA_TYPE) {
                /* pass on the data if this is a data packet */
                k_data_char (new_char);
            } else if (k_state == SEND_TYPE) {
                /* save send pack in buffer as is */
                *send_ptr++ = new_char;
33d12d44:	e58a3000 	str	r3, [sl]
                /* if too much data, back off the pointer */
                if (send_ptr >= &send_parms[SEND_DATA_SIZE])
                    --send_ptr;
33d12d48:	258a2000 	strcs	r2, [sl]
33d12d4c:	eaffffe8 	b	33d12cf4 <do_load_serial_bin+0x490>
            }
        }
        /* get and validate checksum character */
        new_char = getc ();
33d12d50:	eb00107f 	bl	33d16f54 <getc>
        if ((new_char & 0xE0) == 0)
33d12d54:	e31000e0 	tst	r0, #224	; 0xe0
                if (send_ptr >= &send_parms[SEND_DATA_SIZE])
                    --send_ptr;
            }
        }
        /* get and validate checksum character */
        new_char = getc ();
33d12d58:	e20010ff 	and	r1, r0, #255	; 0xff
        if ((new_char & 0xE0) == 0)
33d12d5c:	0a000009 	beq	33d12d88 <do_load_serial_bin+0x524>
            goto packet_error;
        if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
33d12d60:	e1a03c05 	lsl	r3, r5, #24
33d12d64:	e0853f23 	add	r3, r5, r3, lsr #30
33d12d68:	e203303f 	and	r3, r3, #63	; 0x3f
33d12d6c:	e2833020 	add	r3, r3, #32	; 0x20
33d12d70:	e1510003 	cmp	r1, r3
33d12d74:	1a000003 	bne	33d12d88 <do_load_serial_bin+0x524>
            goto packet_error;
        /* get END_CHAR */
        new_char = getc ();
33d12d78:	eb001075 	bl	33d16f54 <getc>
33d12d7c:	e20010ff 	and	r1, r0, #255	; 0xff
        if (new_char != END_CHAR) {
33d12d80:	e351000d 	cmp	r1, #13	; 0xd
33d12d84:	0a000003 	beq	33d12d98 <do_load_serial_bin+0x534>
          packet_error:
            /* restore state machines */
            k_state = k_state_saved;
            k_data_restore ();
33d12d88:	ebfffdf2 	bl	33d12558 <k_data_restore>
            /* send a negative acknowledge packet in */
            send_nack (n);
33d12d8c:	e1a00007 	mov	r0, r7
33d12d90:	ebfffd95 	bl	33d123ec <send_nack>
33d12d94:	ea000008 	b	33d12dbc <do_load_serial_bin+0x558>
        } else if (k_state == SEND_TYPE) {
33d12d98:	e3560053 	cmp	r6, #83	; 0x53
33d12d9c:	1a000002 	bne	33d12dac <do_load_serial_bin+0x548>
            /* crack the protocol parms, build an appropriate ack packet */
            handle_send_packet (n);
33d12da0:	e1a00007 	mov	r0, r7
33d12da4:	ebfffe21 	bl	33d12630 <handle_send_packet>
33d12da8:	ea000003 	b	33d12dbc <do_load_serial_bin+0x558>
        } else {
            /* send simple acknowledge packet in */
            send_ack (n);
33d12dac:	e1a00007 	mov	r0, r7
33d12db0:	ebfffd74 	bl	33d12388 <send_ack>
            /* quit if end of transmission */
            if (k_state == BREAK_TYPE)
                done = 1;
33d12db4:	e3560042 	cmp	r6, #66	; 0x42
33d12db8:	03a09001 	moveq	r9, #1	; 0x1
        }
        ++z;
33d12dbc:	e3590000 	cmp	r9, #0	; 0x0
33d12dc0:	0affff86 	beq	33d12be0 <do_load_serial_bin+0x37c>
    }
33d12dc4:	e59f214c 	ldr	r2, [pc, #332]	; 33d12f18 <do_load_serial_bin+0x6b4>
33d12dc8:	e5923000 	ldr	r3, [r2]
33d12dcc:	e59f2154 	ldr	r2, [pc, #340]	; 33d12f28 <do_load_serial_bin+0x6c4>
33d12dd0:	e5922000 	ldr	r2, [r2]
33d12dd4:	e0635002 	rsb	r5, r3, r2
33d12dd8:	e3a04063 	mov	r4, #99	; 0x63
     * Gather any trailing characters (for instance, the ^D which
     * is sent by 'cu' after sending a file), and give the
     * box some time (100 * 1 ms)
     */
    for (i=0; i<100; ++i) {
        if (tstc()) {
33d12ddc:	eb001062 	bl	33d16f6c <tstc>
33d12de0:	e3500000 	cmp	r0, #0	; 0x0
            (void) getc();
33d12de4:	1b00105a 	blne	33d16f54 <getc>
        }
        udelay(1000);
33d12de8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
33d12dec:	ebffb806 	bl	33d00e0c <udelay>
33d12df0:	e2544001 	subs	r4, r4, #1	; 0x1
33d12df4:	5afffff8 	bpl	33d12ddc <do_load_serial_bin+0x578>
    }

    flush_cache (offset, size);
33d12df8:	e59d000c 	ldr	r0, [sp, #12]
33d12dfc:	e1a01005 	mov	r1, r5

    printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
    sprintf(buf, "%X", size);
33d12e00:	e28d4020 	add	r4, sp, #32	; 0x20
            (void) getc();
        }
        udelay(1000);
    }

    flush_cache (offset, size);
33d12e04:	eb002fc0 	bl	33d1ed0c <flush_cache>

    printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
    sprintf(buf, "%X", size);
33d12e08:	e2444008 	sub	r4, r4, #8	; 0x8
        udelay(1000);
    }

    flush_cache (offset, size);

    printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
33d12e0c:	e59f00d4 	ldr	r0, [pc, #212]	; 33d12ee8 <do_load_serial_bin+0x684>
33d12e10:	e1a01005 	mov	r1, r5
33d12e14:	e1a02005 	mov	r2, r5
33d12e18:	eb00106a 	bl	33d16fc8 <printf>
    sprintf(buf, "%X", size);
33d12e1c:	e1a02005 	mov	r2, r5
33d12e20:	e59f10c4 	ldr	r1, [pc, #196]	; 33d12eec <do_load_serial_bin+0x688>
33d12e24:	e1a00004 	mov	r0, r4
33d12e28:	eb001fb1 	bl	33d1acf4 <sprintf>
    setenv("filesize", buf);
33d12e2c:	e1a01004 	mov	r1, r4
33d12e30:	e59f00b8 	ldr	r0, [pc, #184]	; 33d12ef0 <do_load_serial_bin+0x68c>
33d12e34:	eb000a67 	bl	33d157d8 <setenv>
            "to 0x%08lX at %d bps...\n",
            offset,
            load_baudrate);
        addr = load_serial_bin (offset);

        if (addr == ~0) {
33d12e38:	e59d300c 	ldr	r3, [sp, #12]
33d12e3c:	e3730001 	cmn	r3, #1	; 0x1
33d12e40:	e59f40e4 	ldr	r4, [pc, #228]	; 33d12f2c <do_load_serial_bin+0x6c8>
33d12e44:	1a000006 	bne	33d12e64 <do_load_serial_bin+0x600>
            load_addr = 0;
33d12e48:	e2833001 	add	r3, r3, #1	; 0x1
            printf ("## Binary (kermit) download aborted\n");
33d12e4c:	e59f00dc 	ldr	r0, [pc, #220]	; 33d12f30 <do_load_serial_bin+0x6cc>
            offset,
            load_baudrate);
        addr = load_serial_bin (offset);

        if (addr == ~0) {
            load_addr = 0;
33d12e50:	e5843000 	str	r3, [r4]
            printf ("## Binary (kermit) download aborted\n");
33d12e54:	eb00105b 	bl	33d16fc8 <printf>
            rcode = 1;
33d12e58:	e3a02001 	mov	r2, #1	; 0x1
33d12e5c:	e58d2004 	str	r2, [sp, #4]
33d12e60:	ea000004 	b	33d12e78 <do_load_serial_bin+0x614>
        } else {
            printf ("## Start Addr      = 0x%08lX\n", addr);
33d12e64:	e59f00c8 	ldr	r0, [pc, #200]	; 33d12f34 <do_load_serial_bin+0x6d0>
33d12e68:	e59d100c 	ldr	r1, [sp, #12]
33d12e6c:	eb001055 	bl	33d16fc8 <printf>
            load_addr = addr;
33d12e70:	e59d300c 	ldr	r3, [sp, #12]
33d12e74:	e5843000 	str	r3, [r4]
        }
    }
    if (load_baudrate != current_baudrate) {
33d12e78:	e59d2008 	ldr	r2, [sp, #8]
33d12e7c:	e15b0002 	cmp	fp, r2
33d12e80:	0a00000c 	beq	33d12eb8 <do_load_serial_bin+0x654>
        printf ("## Switch baudrate to %d bps and press ESC ...\n",
33d12e84:	e1a01002 	mov	r1, r2
33d12e88:	e59f00a8 	ldr	r0, [pc, #168]	; 33d12f38 <do_load_serial_bin+0x6d4>
33d12e8c:	eb00104d 	bl	33d16fc8 <printf>
            current_baudrate);
        udelay (50000);
33d12e90:	e59f0034 	ldr	r0, [pc, #52]	; 33d12ecc <do_load_serial_bin+0x668>
33d12e94:	ebffb7dc 	bl	33d00e0c <udelay>
        gd->baudrate = current_baudrate;
33d12e98:	e59d3008 	ldr	r3, [sp, #8]
33d12e9c:	e5883008 	str	r3, [r8, #8]
        serial_setbrg ();
33d12ea0:	eb002d07 	bl	33d1e2c4 <serial_setbrg>
        udelay (50000);
33d12ea4:	e59f0020 	ldr	r0, [pc, #32]	; 33d12ecc <do_load_serial_bin+0x668>
33d12ea8:	ebffb7d7 	bl	33d00e0c <udelay>
        for (;;) {
            if (getc() == 0x1B) /* ESC */
33d12eac:	eb001028 	bl	33d16f54 <getc>
33d12eb0:	e350001b 	cmp	r0, #27	; 0x1b
33d12eb4:	1afffffc 	bne	33d12eac <do_load_serial_bin+0x648>
            rcode = autoscript (load_addr);
        }
    }
#endif
    return rcode;
}
33d12eb8:	e59d0004 	ldr	r0, [sp, #4]
33d12ebc:	e28dde89 	add	sp, sp, #2192	; 0x890
33d12ec0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d12ec4:	33d25514 	.word	0x33d25514
33d12ec8:	33d29d5c 	.word	0x33d29d5c
33d12ecc:	0000c350 	.word	0x0000c350
33d12ed0:	33d29b7c 	.word	0x33d29b7c
33d12ed4:	33d29d90 	.word	0x33d29d90
33d12ed8:	33d2ad00 	.word	0x33d2ad00
33d12edc:	33d12848 	.word	0x33d12848
33d12ee0:	33d29ad8 	.word	0x33d29ad8
33d12ee4:	33d29dd0 	.word	0x33d29dd0
33d12ee8:	33d29e10 	.word	0x33d29e10
33d12eec:	33d29e38 	.word	0x33d29e38
33d12ef0:	33d25954 	.word	0x33d25954
33d12ef4:	33d29e3c 	.word	0x33d29e3c
33d12ef8:	33d12450 	.word	0x33d12450
33d12efc:	33d60ba4 	.word	0x33d60ba4
33d12f00:	33d12488 	.word	0x33d12488
33d12f04:	33d60ba8 	.word	0x33d60ba8
33d12f08:	33d60b98 	.word	0x33d60b98
33d12f0c:	33d60ba1 	.word	0x33d60ba1
33d12f10:	33d60b9c 	.word	0x33d60b9c
33d12f14:	33d60ba0 	.word	0x33d60ba0
33d12f18:	33d60bf0 	.word	0x33d60bf0
33d12f1c:	33d60bc0 	.word	0x33d60bc0
33d12f20:	33d60bac 	.word	0x33d60bac
33d12f24:	33d60bc0 	.word	0x33d60bc0
33d12f28:	33d60be8 	.word	0x33d60be8
33d12f2c:	33d35fec 	.word	0x33d35fec
33d12f30:	33d29e7c 	.word	0x33d29e7c
33d12f34:	33d29d3c 	.word	0x33d29d3c
33d12f38:	33d29ea4 	.word	0x33d29ea4

33d12f3c <cmd_get_data_size>:
			CFG_CMD_I2C	| \
			CFG_CMD_ITEST	| \
			CFG_CMD_PCI	| \
			CMD_CMD_PORTIO	) )
int cmd_get_data_size(char* arg, int default_size)
{
33d12f3c:	e92d4030 	push	{r4, r5, lr}
33d12f40:	e1a05001 	mov	r5, r1
33d12f44:	e1a04000 	mov	r4, r0
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
33d12f48:	eb001c70 	bl	33d1a110 <strlen>
	if (len > 2 && arg[len-2] == '.') {
33d12f4c:	e3500002 	cmp	r0, #2	; 0x2
33d12f50:	da000014 	ble	33d12fa8 <cmd_get_data_size+0x6c>
33d12f54:	e0840000 	add	r0, r4, r0
33d12f58:	e5503002 	ldrb	r3, [r0, #-2]
33d12f5c:	e353002e 	cmp	r3, #46	; 0x2e
33d12f60:	1a000010 	bne	33d12fa8 <cmd_get_data_size+0x6c>
		switch(arg[len-1]) {
33d12f64:	e5500001 	ldrb	r0, [r0, #-1]
33d12f68:	e350006c 	cmp	r0, #108	; 0x6c
		case 'b':
			return 1;
		case 'w':
			return 2;
		case 'l':
			return 4;
33d12f6c:	03a00004 	moveq	r0, #4	; 0x4
{
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
	if (len > 2 && arg[len-2] == '.') {
		switch(arg[len-1]) {
33d12f70:	08bd8030 	popeq	{r4, r5, pc}
33d12f74:	ca000003 	bgt	33d12f88 <cmd_get_data_size+0x4c>
33d12f78:	e3500062 	cmp	r0, #98	; 0x62
		case 'b':
			return 1;
33d12f7c:	03a00001 	moveq	r0, #1	; 0x1
{
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
	if (len > 2 && arg[len-2] == '.') {
		switch(arg[len-1]) {
33d12f80:	08bd8030 	popeq	{r4, r5, pc}
33d12f84:	ea000005 	b	33d12fa0 <cmd_get_data_size+0x64>
33d12f88:	e3500073 	cmp	r0, #115	; 0x73
		case 'w':
			return 2;
		case 'l':
			return 4;
		case 's':
			return -2;
33d12f8c:	03e00001 	mvneq	r0, #1	; 0x1
{
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
	if (len > 2 && arg[len-2] == '.') {
		switch(arg[len-1]) {
33d12f90:	08bd8030 	popeq	{r4, r5, pc}
33d12f94:	e3500077 	cmp	r0, #119	; 0x77
		case 'b':
			return 1;
		case 'w':
			return 2;
33d12f98:	03a00002 	moveq	r0, #2	; 0x2
{
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
	if (len > 2 && arg[len-2] == '.') {
		switch(arg[len-1]) {
33d12f9c:	08bd8030 	popeq	{r4, r5, pc}
		case 'l':
			return 4;
		case 's':
			return -2;
		default:
			return -1;
33d12fa0:	e3e00000 	mvn	r0, #0	; 0x0
33d12fa4:	e8bd8030 	pop	{r4, r5, pc}
		}
	}
	return default_size;
33d12fa8:	e1a00005 	mov	r0, r5
}
33d12fac:	e8bd8030 	pop	{r4, r5, pc}

33d12fb0 <do_mem_md>:
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d12fb0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d12fb4:	e1a04003 	mov	r4, r3
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
33d12fb8:	e59f31d8 	ldr	r3, [pc, #472]	; 33d13198 <do_mem_md+0x1e8>
33d12fbc:	e5935000 	ldr	r5, [r3]
	size = dp_last_size;
	length = dp_last_length;
33d12fc0:	e59f31d4 	ldr	r3, [pc, #468]	; 33d1319c <do_mem_md+0x1ec>
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d12fc4:	e24dd020 	sub	sp, sp, #32	; 0x20
33d12fc8:	e1a06002 	mov	r6, r2
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;

	if (argc < 2) {
33d12fcc:	e3520001 	cmp	r2, #1	; 0x1
{
	ulong	addr, length;
	ulong	i, nbytes, linebytes;
	u_char	*cp;
	int	size;
	int rc = 0;
33d12fd0:	e3a02000 	mov	r2, #0	; 0x0
33d12fd4:	e58d2008 	str	r2, [sp, #8]
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;
33d12fd8:	e5933000 	ldr	r3, [r3]

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
33d12fdc:	e59f21bc 	ldr	r2, [pc, #444]	; 33d131a0 <do_mem_md+0x1f0>
	length = dp_last_length;
33d12fe0:	e58d300c 	str	r3, [sp, #12]

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
33d12fe4:	e5927000 	ldr	r7, [r2]
	length = dp_last_length;

	if (argc < 2) {
33d12fe8:	ca000003 	bgt	33d12ffc <do_mem_md+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d12fec:	e5901010 	ldr	r1, [r0, #16]
33d12ff0:	e59f01ac 	ldr	r0, [pc, #428]	; 33d131a4 <do_mem_md+0x1f4>
33d12ff4:	eb000ff3 	bl	33d16fc8 <printf>
33d12ff8:	ea000006 	b	33d13018 <do_mem_md+0x68>
		return 1;
	}

	if ((flag & CMD_FLAG_REPEAT) == 0) {
33d12ffc:	e3110001 	tst	r1, #1	; 0x1
33d13000:	1a000017 	bne	33d13064 <do_mem_md+0xb4>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
33d13004:	e5940000 	ldr	r0, [r4]
33d13008:	e3a01004 	mov	r1, #4	; 0x4
33d1300c:	ebffffca 	bl	33d12f3c <cmd_get_data_size>
33d13010:	e2507000 	subs	r7, r0, #0	; 0x0
33d13014:	aa000004 	bge	33d1302c <do_mem_md+0x7c>
			return 1;
33d13018:	e3a00001 	mov	r0, #1	; 0x1
33d1301c:	ea00005b 	b	33d13190 <do_mem_md+0x1e0>
			cp++;
		}
		putc ('\n');
		nbytes -= linebytes;
		if (ctrlc()) {
			rc = 1;
33d13020:	e3a02001 	mov	r2, #1	; 0x1
33d13024:	e58d2008 	str	r2, [sp, #8]
			break;
33d13028:	ea000050 	b	33d13170 <do_mem_md+0x1c0>
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
33d1302c:	e5940004 	ldr	r0, [r4, #4]
33d13030:	e59d1008 	ldr	r1, [sp, #8]
33d13034:	e3a02010 	mov	r2, #16	; 0x10
33d13038:	eb001d47 	bl	33d1a55c <simple_strtoul>
		addr += base_address;
33d1303c:	e59f3164 	ldr	r3, [pc, #356]	; 33d131a8 <do_mem_md+0x1f8>
33d13040:	e5933000 	ldr	r3, [r3]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
33d13044:	e3560002 	cmp	r6, #2	; 0x2
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
		addr += base_address;
33d13048:	e0805003 	add	r5, r0, r3

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
33d1304c:	da000004 	ble	33d13064 <do_mem_md+0xb4>
			length = simple_strtoul(argv[2], NULL, 16);
33d13050:	e5940008 	ldr	r0, [r4, #8]
33d13054:	e59d1008 	ldr	r1, [sp, #8]
33d13058:	e3a02010 	mov	r2, #16	; 0x10
33d1305c:	eb001d3e 	bl	33d1a55c <simple_strtoul>
33d13060:	e58d000c 	str	r0, [sp, #12]
	/* Print the lines.
	 *
	 * We buffer all read data, so we can make sure data is read only
	 * once, and all accesses are with the specified bus width.
	 */
	nbytes = length * size;
33d13064:	e59d900c 	ldr	r9, [sp, #12]
33d13068:	e0090997 	mul	r9, r7, r9
	do {
		char	linebuf[DISP_LINE_LEN];
		uint	*uip = (uint   *)linebuf;
33d1306c:	e28db010 	add	fp, sp, #16	; 0x10
		ushort	*usp = (ushort *)linebuf;
		u_char	*ucp = (u_char *)linebuf;
#ifdef CONFIG_HAS_DATAFLASH
		int rc;
#endif
		printf("%08lx:", addr);
33d13070:	e59f0134 	ldr	r0, [pc, #308]	; 33d131ac <do_mem_md+0x1fc>
33d13074:	e1a01005 	mov	r1, r5
33d13078:	eb000fd2 	bl	33d16fc8 <printf>
		linebytes = (nbytes>DISP_LINE_LEN)?DISP_LINE_LEN:nbytes;
33d1307c:	e3590010 	cmp	r9, #16	; 0x10
33d13080:	31a0a009 	movcc	sl, r9
33d13084:	23a0a010 	movcs	sl, #16	; 0x10
				addr += size;
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
33d13088:	e3a06000 	mov	r6, #0	; 0x0
	 * once, and all accesses are with the specified bus width.
	 */
	nbytes = length * size;
	do {
		char	linebuf[DISP_LINE_LEN];
		uint	*uip = (uint   *)linebuf;
33d1308c:	e58db000 	str	fp, [sp]
		ushort	*usp = (ushort *)linebuf;
33d13090:	e58db004 	str	fp, [sp, #4]
				addr += size;
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
33d13094:	e156000a 	cmp	r6, sl
	nbytes = length * size;
	do {
		char	linebuf[DISP_LINE_LEN];
		uint	*uip = (uint   *)linebuf;
		ushort	*usp = (ushort *)linebuf;
		u_char	*ucp = (u_char *)linebuf;
33d13098:	e1a0400b 	mov	r4, fp
				addr += size;
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
33d1309c:	2a000018 	bcs	33d13104 <do_mem_md+0x154>
			if (size == 4) {
33d130a0:	e3570004 	cmp	r7, #4	; 0x4
				printf(" %08x", (*uip++ = *((uint *)addr)));
33d130a4:	e59f0104 	ldr	r0, [pc, #260]	; 33d131b0 <do_mem_md+0x200>
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
			if (size == 4) {
33d130a8:	1a000005 	bne	33d130c4 <do_mem_md+0x114>
				printf(" %08x", (*uip++ = *((uint *)addr)));
33d130ac:	e5953000 	ldr	r3, [r5]
33d130b0:	e59d2004 	ldr	r2, [sp, #4]
33d130b4:	e4823004 	str	r3, [r2], #4
33d130b8:	e1a01003 	mov	r1, r3
33d130bc:	e58d2004 	str	r2, [sp, #4]
33d130c0:	ea00000a 	b	33d130f0 <do_mem_md+0x140>
			} else if (size == 2) {
33d130c4:	e3570002 	cmp	r7, #2	; 0x2
				printf(" %04x", (*usp++ = *((ushort *)addr)));
33d130c8:	059d3000 	ldreq	r3, [sp]
33d130cc:	01d520b0 	ldrheq	r2, [r5]
			} else {
				printf(" %02x", (*ucp++ = *((u_char *)addr)));
33d130d0:	15d53000 	ldrbne	r3, [r5]
#endif
		for (i=0; i<linebytes; i+= size) {
			if (size == 4) {
				printf(" %08x", (*uip++ = *((uint *)addr)));
			} else if (size == 2) {
				printf(" %04x", (*usp++ = *((ushort *)addr)));
33d130d4:	01c320b0 	strheq	r2, [r3]
			} else {
				printf(" %02x", (*ucp++ = *((u_char *)addr)));
33d130d8:	15c43000 	strbne	r3, [r4]
#endif
		for (i=0; i<linebytes; i+= size) {
			if (size == 4) {
				printf(" %08x", (*uip++ = *((uint *)addr)));
			} else if (size == 2) {
				printf(" %04x", (*usp++ = *((ushort *)addr)));
33d130dc:	00d310b2 	ldrheq	r1, [r3], #2
33d130e0:	e59f00cc 	ldr	r0, [pc, #204]	; 33d131b4 <do_mem_md+0x204>
33d130e4:	058d3000 	streq	r3, [sp]
			} else {
				printf(" %02x", (*ucp++ = *((u_char *)addr)));
33d130e8:	159f00c8 	ldrne	r0, [pc, #200]	; 33d131b8 <do_mem_md+0x208>
33d130ec:	14d41001 	ldrbne	r1, [r4], #1
33d130f0:	eb000fb4 	bl	33d16fc8 <printf>
				addr += size;
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
33d130f4:	e0866007 	add	r6, r6, r7
			} else if (size == 2) {
				printf(" %04x", (*usp++ = *((ushort *)addr)));
			} else {
				printf(" %02x", (*ucp++ = *((u_char *)addr)));
			}
			addr += size;
33d130f8:	e0855007 	add	r5, r5, r7
				addr += size;
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
33d130fc:	e156000a 	cmp	r6, sl
33d13100:	eaffffe5 	b	33d1309c <do_mem_md+0xec>
			addr += size;
		}
#ifdef CONFIG_HAS_DATAFLASH
		}
#endif
		puts ("    ");
33d13104:	e59f00b0 	ldr	r0, [pc, #176]	; 33d131bc <do_mem_md+0x20c>
		cp = (u_char *)linebuf;
		for (i=0; i<linebytes; i++) {
33d13108:	e3a06000 	mov	r6, #0	; 0x0
			addr += size;
		}
#ifdef CONFIG_HAS_DATAFLASH
		}
#endif
		puts ("    ");
33d1310c:	eb000fa6 	bl	33d16fac <puts>
		cp = (u_char *)linebuf;
33d13110:	e1a0400b 	mov	r4, fp
		for (i=0; i<linebytes; i++) {
33d13114:	e156000a 	cmp	r6, sl
33d13118:	2a00000c 	bcs	33d13150 <do_mem_md+0x1a0>
			if ((*cp < 0x20) || (*cp > 0x7e))
33d1311c:	e5d41000 	ldrb	r1, [r4]
33d13120:	e2413020 	sub	r3, r1, #32	; 0x20
33d13124:	e353005e 	cmp	r3, #94	; 0x5e
				putc ('.');
33d13128:	e3a0002e 	mov	r0, #46	; 0x2e
		}
#endif
		puts ("    ");
		cp = (u_char *)linebuf;
		for (i=0; i<linebytes; i++) {
			if ((*cp < 0x20) || (*cp > 0x7e))
33d1312c:	9a000001 	bls	33d13138 <do_mem_md+0x188>
				putc ('.');
33d13130:	eb000f93 	bl	33d16f84 <putc>
33d13134:	ea000001 	b	33d13140 <do_mem_md+0x190>
			else
				printf("%c", *cp);
33d13138:	e59f0080 	ldr	r0, [pc, #128]	; 33d131c0 <do_mem_md+0x210>
33d1313c:	eb000fa1 	bl	33d16fc8 <printf>
#ifdef CONFIG_HAS_DATAFLASH
		}
#endif
		puts ("    ");
		cp = (u_char *)linebuf;
		for (i=0; i<linebytes; i++) {
33d13140:	e2866001 	add	r6, r6, #1	; 0x1
			if ((*cp < 0x20) || (*cp > 0x7e))
				putc ('.');
			else
				printf("%c", *cp);
			cp++;
33d13144:	e2844001 	add	r4, r4, #1	; 0x1
#ifdef CONFIG_HAS_DATAFLASH
		}
#endif
		puts ("    ");
		cp = (u_char *)linebuf;
		for (i=0; i<linebytes; i++) {
33d13148:	e156000a 	cmp	r6, sl
33d1314c:	eafffff1 	b	33d13118 <do_mem_md+0x168>
				putc ('.');
			else
				printf("%c", *cp);
			cp++;
		}
		putc ('\n');
33d13150:	e3a0000a 	mov	r0, #10	; 0xa
33d13154:	eb000f8a 	bl	33d16f84 <putc>
		nbytes -= linebytes;
		if (ctrlc()) {
33d13158:	eb000fb3 	bl	33d1702c <ctrlc>
33d1315c:	e3500000 	cmp	r0, #0	; 0x0
			else
				printf("%c", *cp);
			cp++;
		}
		putc ('\n');
		nbytes -= linebytes;
33d13160:	e06a9009 	rsb	r9, sl, r9
		if (ctrlc()) {
33d13164:	1affffad 	bne	33d13020 <do_mem_md+0x70>
			rc = 1;
			break;
		}
	} while (nbytes > 0);
33d13168:	e3590000 	cmp	r9, #0	; 0x0
33d1316c:	1affffbe 	bne	33d1306c <do_mem_md+0xbc>

	dp_last_addr = addr;
33d13170:	e59f3020 	ldr	r3, [pc, #32]	; 33d13198 <do_mem_md+0x1e8>
	dp_last_length = length;
33d13174:	e59f2020 	ldr	r2, [pc, #32]	; 33d1319c <do_mem_md+0x1ec>
			rc = 1;
			break;
		}
	} while (nbytes > 0);

	dp_last_addr = addr;
33d13178:	e5835000 	str	r5, [r3]
	dp_last_length = length;
33d1317c:	e59d300c 	ldr	r3, [sp, #12]
33d13180:	e5823000 	str	r3, [r2]
	dp_last_size = size;
33d13184:	e59f2014 	ldr	r2, [pc, #20]	; 33d131a0 <do_mem_md+0x1f0>
	return (rc);
33d13188:	e59d0008 	ldr	r0, [sp, #8]
		}
	} while (nbytes > 0);

	dp_last_addr = addr;
	dp_last_length = length;
	dp_last_size = size;
33d1318c:	e5827000 	str	r7, [r2]
	return (rc);
}
33d13190:	e28dd020 	add	sp, sp, #32	; 0x20
33d13194:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d13198:	33d60bfc 	.word	0x33d60bfc
33d1319c:	33d36078 	.word	0x33d36078
33d131a0:	33d60c00 	.word	0x33d60c00
33d131a4:	33d27008 	.word	0x33d27008
33d131a8:	33d60c0c 	.word	0x33d60c0c
33d131ac:	33d2a330 	.word	0x33d2a330
33d131b0:	33d2a338 	.word	0x33d2a338
33d131b4:	33d2a340 	.word	0x33d2a340
33d131b8:	33d2a348 	.word	0x33d2a348
33d131bc:	33d2a350 	.word	0x33d2a350
33d131c0:	33d2a358 	.word	0x33d2a358

33d131c4 <do_mem_mw>:
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d131c4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d131c8:	e1a0a002 	mov	sl, r2
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4)) {
33d131cc:	e2422003 	sub	r2, r2, #3	; 0x3
33d131d0:	e3520001 	cmp	r2, #1	; 0x1
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d131d4:	e1a04003 	mov	r4, r3
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4)) {
33d131d8:	9a000003 	bls	33d131ec <do_mem_mw+0x28>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d131dc:	e5901010 	ldr	r1, [r0, #16]
33d131e0:	e59f00a0 	ldr	r0, [pc, #160]	; 33d13288 <do_mem_mw+0xc4>
33d131e4:	eb000f77 	bl	33d16fc8 <printf>
33d131e8:	ea000004 	b	33d13200 <do_mem_mw+0x3c>
		return 1;
	}

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
33d131ec:	e5930000 	ldr	r0, [r3]
33d131f0:	e3a01004 	mov	r1, #4	; 0x4
33d131f4:	ebffff50 	bl	33d12f3c <cmd_get_data_size>
33d131f8:	e2507000 	subs	r7, r0, #0	; 0x0
33d131fc:	ca000001 	bgt	33d13208 <do_mem_mw+0x44>
		return 1;
33d13200:	e3a00001 	mov	r0, #1	; 0x1
33d13204:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
33d13208:	e3a01000 	mov	r1, #0	; 0x0
33d1320c:	e3a02010 	mov	r2, #16	; 0x10
33d13210:	e5940004 	ldr	r0, [r4, #4]
33d13214:	eb001cd0 	bl	33d1a55c <simple_strtoul>
	addr += base_address;
33d13218:	e59f306c 	ldr	r3, [pc, #108]	; 33d1328c <do_mem_mw+0xc8>
33d1321c:	e5933000 	ldr	r3, [r3]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
33d13220:	e3a01000 	mov	r1, #0	; 0x0
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
33d13224:	e0805003 	add	r5, r0, r3

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
33d13228:	e3a02010 	mov	r2, #16	; 0x10
33d1322c:	e5940008 	ldr	r0, [r4, #8]
33d13230:	eb001cc9 	bl	33d1a55c <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
33d13234:	e35a0004 	cmp	sl, #4	; 0x4
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
33d13238:	e1a06000 	mov	r6, r0

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
33d1323c:	13a00001 	movne	r0, #1	; 0x1
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
33d13240:	0594000c 	ldreq	r0, [r4, #12]
33d13244:	03a01000 	moveq	r1, #0	; 0x0
33d13248:	03a02010 	moveq	r2, #16	; 0x10
33d1324c:	0b001cc2 	bleq	33d1a55c <simple_strtoul>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
			*((ushort *)addr) = (ushort)writeval;
		else
			*((u_char *)addr) = (u_char)writeval;
		addr += size;
33d13250:	e2400001 	sub	r0, r0, #1	; 0x1
33d13254:	e3700001 	cmn	r0, #1	; 0x1
33d13258:	0a000008 	beq	33d13280 <do_mem_mw+0xbc>
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
33d1325c:	e3570004 	cmp	r7, #4	; 0x4
			*((ulong  *)addr) = (ulong )writeval;
33d13260:	05856000 	streq	r6, [r5]
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
33d13264:	0a000002 	beq	33d13274 <do_mem_mw+0xb0>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
33d13268:	e3570002 	cmp	r7, #2	; 0x2
			*((ushort *)addr) = (ushort)writeval;
33d1326c:	01c560b0 	strheq	r6, [r5]
		else
			*((u_char *)addr) = (u_char)writeval;
33d13270:	15c56000 	strbne	r6, [r5]
		addr += size;
33d13274:	e2400001 	sub	r0, r0, #1	; 0x1
33d13278:	e0855007 	add	r5, r5, r7
33d1327c:	eafffff4 	b	33d13254 <do_mem_mw+0x90>
	}
	return 0;
33d13280:	e3a00000 	mov	r0, #0	; 0x0
}
33d13284:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d13288:	33d27008 	.word	0x33d27008
33d1328c:	33d60c0c 	.word	0x33d60c0c

33d13290 <do_mem_cmp>:
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13290:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;

	if (argc != 4) {
33d13294:	e3520004 	cmp	r2, #4	; 0x4
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13298:	e24dd004 	sub	sp, sp, #4	; 0x4
33d1329c:	e1a01002 	mov	r1, r2
33d132a0:	e1a06003 	mov	r6, r3
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
33d132a4:	e3a0a000 	mov	sl, #0	; 0x0

	if (argc != 4) {
33d132a8:	0a000003 	beq	33d132bc <do_mem_cmp+0x2c>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d132ac:	e5901010 	ldr	r1, [r0, #16]
33d132b0:	e59f0168 	ldr	r0, [pc, #360]	; 33d13420 <do_mem_cmp+0x190>
33d132b4:	eb000f43 	bl	33d16fc8 <printf>
33d132b8:	ea000003 	b	33d132cc <do_mem_cmp+0x3c>
		return 1;
	}

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
33d132bc:	e5930000 	ldr	r0, [r3]
33d132c0:	ebffff1d 	bl	33d12f3c <cmd_get_data_size>
33d132c4:	e2507000 	subs	r7, r0, #0	; 0x0
33d132c8:	aa000008 	bge	33d132f0 <do_mem_cmp+0x60>
		return 1;
33d132cc:	e3a00001 	mov	r0, #1	; 0x1
33d132d0:	ea000050 	b	33d13418 <do_mem_cmp+0x188>
		}
		else {
			u_char byte1 = *(u_char *)addr1;
			u_char byte2 = *(u_char *)addr2;
			if (byte1 != byte2) {
				printf("byte at 0x%08lx (0x%02x) "
33d132d4:	e1a01005 	mov	r1, r5
33d132d8:	e1a03004 	mov	r3, r4
33d132dc:	e59f0140 	ldr	r0, [pc, #320]	; 33d13424 <do_mem_cmp+0x194>
33d132e0:	e58dc000 	str	ip, [sp]
33d132e4:	eb000f37 	bl	33d16fc8 <printf>
					"!= byte at 0x%08lx (0x%02x)\n",
					addr1, byte1, addr2, byte2);
				rcode = 1;
33d132e8:	e3a0a001 	mov	sl, #1	; 0x1
				break;
33d132ec:	ea000038 	b	33d133d4 <do_mem_cmp+0x144>
	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr1 = simple_strtoul(argv[1], NULL, 16);
33d132f0:	e1a0100a 	mov	r1, sl
33d132f4:	e3a02010 	mov	r2, #16	; 0x10
33d132f8:	e5960004 	ldr	r0, [r6, #4]
33d132fc:	eb001c96 	bl	33d1a55c <simple_strtoul>
	addr1 += base_address;
33d13300:	e59f4120 	ldr	r4, [pc, #288]	; 33d13428 <do_mem_cmp+0x198>
33d13304:	e5943000 	ldr	r3, [r4]

	addr2 = simple_strtoul(argv[2], NULL, 16);
33d13308:	e1a0100a 	mov	r1, sl
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
33d1330c:	e0805003 	add	r5, r0, r3

	addr2 = simple_strtoul(argv[2], NULL, 16);
33d13310:	e3a02010 	mov	r2, #16	; 0x10
33d13314:	e5960008 	ldr	r0, [r6, #8]
33d13318:	eb001c8f 	bl	33d1a55c <simple_strtoul>
	addr2 += base_address;
33d1331c:	e5943000 	ldr	r3, [r4]

	count = simple_strtoul(argv[3], NULL, 16);
33d13320:	e1a0100a 	mov	r1, sl

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;

	addr2 = simple_strtoul(argv[2], NULL, 16);
	addr2 += base_address;
33d13324:	e0804003 	add	r4, r0, r3

	count = simple_strtoul(argv[3], NULL, 16);
33d13328:	e3a02010 	mov	r2, #16	; 0x10
33d1332c:	e596000c 	ldr	r0, [r6, #12]
33d13330:	eb001c89 	bl	33d1a55c <simple_strtoul>
				break;
			}
		}
		ngood++;
		addr1 += size;
		addr2 += size;
33d13334:	e2400001 	sub	r0, r0, #1	; 0x1
33d13338:	e3700001 	cmn	r0, #1	; 0x1
		puts ("Comparison with DataFlash space not supported.\n\r");
		return 0;
	}
#endif

	ngood = 0;
33d1333c:	e1a0600a 	mov	r6, sl
				break;
			}
		}
		ngood++;
		addr1 += size;
		addr2 += size;
33d13340:	0a000023 	beq	33d133d4 <do_mem_cmp+0x144>
#endif

	ngood = 0;

	while (count-- > 0) {
		if (size == 4) {
33d13344:	e3570004 	cmp	r7, #4	; 0x4
				break;
			}
		}
		ngood++;
		addr1 += size;
		addr2 += size;
33d13348:	e2400001 	sub	r0, r0, #1	; 0x1
#endif

	ngood = 0;

	while (count-- > 0) {
		if (size == 4) {
33d1334c:	1a00000a 	bne	33d1337c <do_mem_cmp+0xec>
			ulong word1 = *(ulong *)addr1;
33d13350:	e5952000 	ldr	r2, [r5]
			ulong word2 = *(ulong *)addr2;
33d13354:	e594c000 	ldr	ip, [r4]
			if (word1 != word2) {
33d13358:	e152000c 	cmp	r2, ip
33d1335c:	0a000017 	beq	33d133c0 <do_mem_cmp+0x130>
				printf("word at 0x%08lx (0x%08lx) "
33d13360:	e1a01005 	mov	r1, r5
33d13364:	e1a03004 	mov	r3, r4
33d13368:	e59f00bc 	ldr	r0, [pc, #188]	; 33d1342c <do_mem_cmp+0x19c>
33d1336c:	e58dc000 	str	ip, [sp]
33d13370:	eb000f14 	bl	33d16fc8 <printf>
					"!= word at 0x%08lx (0x%08lx)\n",
					addr1, word1, addr2, word2);
				rcode = 1;
33d13374:	e3a0a001 	mov	sl, #1	; 0x1
				break;
33d13378:	ea00001c 	b	33d133f0 <do_mem_cmp+0x160>
			}
		}
		else if (size == 2) {
33d1337c:	e3570002 	cmp	r7, #2	; 0x2
33d13380:	1a00000a 	bne	33d133b0 <do_mem_cmp+0x120>
			ushort hword1 = *(ushort *)addr1;
33d13384:	e1d520b0 	ldrh	r2, [r5]
			ushort hword2 = *(ushort *)addr2;
33d13388:	e1d4c0b0 	ldrh	ip, [r4]
			if (hword1 != hword2) {
33d1338c:	e152000c 	cmp	r2, ip
33d13390:	0a00000a 	beq	33d133c0 <do_mem_cmp+0x130>
				printf("halfword at 0x%08lx (0x%04x) "
33d13394:	e1a01005 	mov	r1, r5
33d13398:	e1a03004 	mov	r3, r4
33d1339c:	e59f008c 	ldr	r0, [pc, #140]	; 33d13430 <do_mem_cmp+0x1a0>
33d133a0:	e58dc000 	str	ip, [sp]
33d133a4:	eb000f07 	bl	33d16fc8 <printf>
					"!= halfword at 0x%08lx (0x%04x)\n",
					addr1, hword1, addr2, hword2);
				rcode = 1;
33d133a8:	e3a0a001 	mov	sl, #1	; 0x1
				break;
33d133ac:	ea00000d 	b	33d133e8 <do_mem_cmp+0x158>
			}
		}
		else {
			u_char byte1 = *(u_char *)addr1;
33d133b0:	e5d52000 	ldrb	r2, [r5]
			u_char byte2 = *(u_char *)addr2;
33d133b4:	e5d4c000 	ldrb	ip, [r4]
			if (byte1 != byte2) {
33d133b8:	e152000c 	cmp	r2, ip
33d133bc:	1affffc4 	bne	33d132d4 <do_mem_cmp+0x44>
				break;
			}
		}
		ngood++;
		addr1 += size;
		addr2 += size;
33d133c0:	e3700001 	cmn	r0, #1	; 0x1
					addr1, byte1, addr2, byte2);
				rcode = 1;
				break;
			}
		}
		ngood++;
33d133c4:	e2866001 	add	r6, r6, #1	; 0x1
		addr1 += size;
33d133c8:	e0855007 	add	r5, r5, r7
		addr2 += size;
33d133cc:	e0844007 	add	r4, r4, r7
33d133d0:	eaffffda 	b	33d13340 <do_mem_cmp+0xb0>
	}

	printf("Total of %ld %s%s were the same\n",
33d133d4:	e3570004 	cmp	r7, #4	; 0x4
33d133d8:	0a000004 	beq	33d133f0 <do_mem_cmp+0x160>
33d133dc:	e3570002 	cmp	r7, #2	; 0x2
33d133e0:	159f004c 	ldrne	r0, [pc, #76]	; 33d13434 <do_mem_cmp+0x1a4>
33d133e4:	1a000002 	bne	33d133f4 <do_mem_cmp+0x164>
33d133e8:	e59f0048 	ldr	r0, [pc, #72]	; 33d13438 <do_mem_cmp+0x1a8>
33d133ec:	ea000000 	b	33d133f4 <do_mem_cmp+0x164>
33d133f0:	e59f0044 	ldr	r0, [pc, #68]	; 33d1343c <do_mem_cmp+0x1ac>
33d133f4:	e59f2044 	ldr	r2, [pc, #68]	; 33d13440 <do_mem_cmp+0x1b0>
33d133f8:	e3560001 	cmp	r6, #1	; 0x1
33d133fc:	e59f3040 	ldr	r3, [pc, #64]	; 33d13444 <do_mem_cmp+0x1b4>
33d13400:	e1a01006 	mov	r1, r6
33d13404:	11a03002 	movne	r3, r2
33d13408:	e1a02000 	mov	r2, r0
33d1340c:	e59f0034 	ldr	r0, [pc, #52]	; 33d13448 <do_mem_cmp+0x1b8>
33d13410:	eb000eec 	bl	33d16fc8 <printf>
		ngood, size == 4 ? "word" : size == 2 ? "halfword" : "byte",
		ngood == 1 ? "" : "s");
	return rcode;
33d13414:	e1a0000a 	mov	r0, sl
}
33d13418:	e28dd004 	add	sp, sp, #4	; 0x4
33d1341c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d13420:	33d27008 	.word	0x33d27008
33d13424:	33d2a35c 	.word	0x33d2a35c
33d13428:	33d60c0c 	.word	0x33d60c0c
33d1342c:	33d2a394 	.word	0x33d2a394
33d13430:	33d2a3cc 	.word	0x33d2a3cc
33d13434:	33d2a40c 	.word	0x33d2a40c
33d13438:	33d2a414 	.word	0x33d2a414
33d1343c:	33d2a418 	.word	0x33d2a418
33d13440:	33d2ad20 	.word	0x33d2ad20
33d13444:	33d2a490 	.word	0x33d2a490
33d13448:	33d29ed4 	.word	0x33d29ed4

33d1344c <do_mem_cp>:
int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4) {
33d1344c:	e3520004 	cmp	r2, #4	; 0x4
		ngood == 1 ? "" : "s");
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13450:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d13454:	e1a01002 	mov	r1, r2
33d13458:	e1a06003 	mov	r6, r3
	ulong	addr, dest, count;
	int	size;

	if (argc != 4) {
33d1345c:	0a000003 	beq	33d13470 <do_mem_cp+0x24>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d13460:	e5901010 	ldr	r1, [r0, #16]
33d13464:	e59f0100 	ldr	r0, [pc, #256]	; 33d1356c <do_mem_cp+0x120>
33d13468:	eb000ed6 	bl	33d16fc8 <printf>
33d1346c:	ea000018 	b	33d134d4 <do_mem_cp+0x88>
		return 1;
	}

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
33d13470:	e5930000 	ldr	r0, [r3]
33d13474:	ebfffeb0 	bl	33d12f3c <cmd_get_data_size>
33d13478:	e250a000 	subs	sl, r0, #0	; 0x0
33d1347c:	ba000014 	blt	33d134d4 <do_mem_cp+0x88>
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
33d13480:	e3a01000 	mov	r1, #0	; 0x0
33d13484:	e3a02010 	mov	r2, #16	; 0x10
33d13488:	e5960004 	ldr	r0, [r6, #4]
33d1348c:	eb001c32 	bl	33d1a55c <simple_strtoul>
	addr += base_address;
33d13490:	e59f40d8 	ldr	r4, [pc, #216]	; 33d13570 <do_mem_cp+0x124>
33d13494:	e5943000 	ldr	r3, [r4]

	dest = simple_strtoul(argv[2], NULL, 16);
33d13498:	e3a01000 	mov	r1, #0	; 0x0
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
33d1349c:	e0807003 	add	r7, r0, r3

	dest = simple_strtoul(argv[2], NULL, 16);
33d134a0:	e3a02010 	mov	r2, #16	; 0x10
33d134a4:	e5960008 	ldr	r0, [r6, #8]
33d134a8:	eb001c2b 	bl	33d1a55c <simple_strtoul>
	dest += base_address;
33d134ac:	e5943000 	ldr	r3, [r4]

	count = simple_strtoul(argv[3], NULL, 16);
33d134b0:	e3a01000 	mov	r1, #0	; 0x0

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
33d134b4:	e0805003 	add	r5, r0, r3

	count = simple_strtoul(argv[3], NULL, 16);
33d134b8:	e3a02010 	mov	r2, #16	; 0x10
33d134bc:	e596000c 	ldr	r0, [r6, #12]
33d134c0:	eb001c25 	bl	33d1a55c <simple_strtoul>

	if (count == 0) {
33d134c4:	e2504000 	subs	r4, r0, #0	; 0x0
33d134c8:	1a000003 	bne	33d134dc <do_mem_cp+0x90>
		puts ("Zero length ???\n");
33d134cc:	e59f00a0 	ldr	r0, [pc, #160]	; 33d13574 <do_mem_cp+0x128>
33d134d0:	eb000eb5 	bl	33d16fac <puts>
		return 1;
33d134d4:	e3a00001 	mov	r0, #1	; 0x1
33d134d8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

#ifndef CFG_NO_FLASH
	/* check if we are copying to Flash */
	if ( (addr2info(dest) != NULL)
33d134dc:	e1a00005 	mov	r0, r5
33d134e0:	eb0014f7 	bl	33d188c4 <addr2info>
33d134e4:	e3500000 	cmp	r0, #0	; 0x0
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
		dest += size;
33d134e8:	02444001 	subeq	r4, r4, #1	; 0x1
		return 1;
	}

#ifndef CFG_NO_FLASH
	/* check if we are copying to Flash */
	if ( (addr2info(dest) != NULL)
33d134ec:	0a00000d 	beq	33d13528 <do_mem_cp+0xdc>
	   && (!addr_dataflash(addr))
#endif
	   ) {
		int rc;

		puts ("Copy to Flash... ");
33d134f0:	e59f0080 	ldr	r0, [pc, #128]	; 33d13578 <do_mem_cp+0x12c>
33d134f4:	eb000eac 	bl	33d16fac <puts>

		rc = flash_write ((char *)addr, dest, count*size);
33d134f8:	e002049a 	mul	r2, sl, r4
33d134fc:	e1a00007 	mov	r0, r7
33d13500:	e1a01005 	mov	r1, r5
33d13504:	eb001500 	bl	33d1890c <flash_write>
		if (rc != 0) {
33d13508:	e2504000 	subs	r4, r0, #0	; 0x0
33d1350c:	0a000001 	beq	33d13518 <do_mem_cp+0xcc>
			flash_perror (rc);
33d13510:	eb00155f 	bl	33d18a94 <flash_perror>
33d13514:	eaffffee 	b	33d134d4 <do_mem_cp+0x88>
			return (1);
		}
		puts ("done\n");
33d13518:	e59f005c 	ldr	r0, [pc, #92]	; 33d1357c <do_mem_cp+0x130>
33d1351c:	eb000ea2 	bl	33d16fac <puts>
		return 0;
33d13520:	e1a00004 	mov	r0, r4
33d13524:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
		dest += size;
33d13528:	e3740001 	cmn	r4, #1	; 0x1
33d1352c:	0a00000c 	beq	33d13564 <do_mem_cp+0x118>
		return 1;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
33d13530:	e35a0004 	cmp	sl, #4	; 0x4
			*((ulong  *)dest) = *((ulong  *)addr);
33d13534:	05973000 	ldreq	r3, [r7]
33d13538:	05853000 	streq	r3, [r5]
		return 1;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
33d1353c:	0a000004 	beq	33d13554 <do_mem_cp+0x108>
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
33d13540:	e35a0002 	cmp	sl, #2	; 0x2
			*((ushort *)dest) = *((ushort *)addr);
33d13544:	01d730b0 	ldrheq	r3, [r7]
		else
			*((u_char *)dest) = *((u_char *)addr);
33d13548:	15d73000 	ldrbne	r3, [r7]

	while (count-- > 0) {
		if (size == 4)
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
33d1354c:	01c530b0 	strheq	r3, [r5]
		else
			*((u_char *)dest) = *((u_char *)addr);
33d13550:	15c53000 	strbne	r3, [r5]
		addr += size;
		dest += size;
33d13554:	e2444001 	sub	r4, r4, #1	; 0x1
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
33d13558:	e087700a 	add	r7, r7, sl
		dest += size;
33d1355c:	e085500a 	add	r5, r5, sl
33d13560:	eafffff0 	b	33d13528 <do_mem_cp+0xdc>
	}
	return 0;
33d13564:	e3a00000 	mov	r0, #0	; 0x0
}
33d13568:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d1356c:	33d27008 	.word	0x33d27008
33d13570:	33d60c0c 	.word	0x33d60c0c
33d13574:	33d2a420 	.word	0x33d2a420
33d13578:	33d2a434 	.word	0x33d2a434
33d1357c:	33d2a448 	.word	0x33d2a448

33d13580 <do_mem_base>:

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc > 1) {
33d13580:	e3520001 	cmp	r2, #1	; 0x1
	}
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13584:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (argc > 1) {
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
33d13588:	e3a01000 	mov	r1, #0	; 0x0
33d1358c:	e3a02010 	mov	r2, #16	; 0x10
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc > 1) {
33d13590:	da000003 	ble	33d135a4 <do_mem_base+0x24>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
33d13594:	e5930004 	ldr	r0, [r3, #4]
33d13598:	eb001bef 	bl	33d1a55c <simple_strtoul>
33d1359c:	e59f3018 	ldr	r3, [pc, #24]	; 33d135bc <do_mem_base+0x3c>
33d135a0:	e5830000 	str	r0, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
33d135a4:	e59f3010 	ldr	r3, [pc, #16]	; 33d135bc <do_mem_base+0x3c>
33d135a8:	e59f0010 	ldr	r0, [pc, #16]	; 33d135c0 <do_mem_base+0x40>
33d135ac:	e5931000 	ldr	r1, [r3]
33d135b0:	eb000e84 	bl	33d16fc8 <printf>
	return 0;
}
33d135b4:	e3a00000 	mov	r0, #0	; 0x0
33d135b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d135bc:	33d60c0c 	.word	0x33d60c0c
33d135c0:	33d2a450 	.word	0x33d2a450

33d135c4 <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3) {
33d135c4:	e3520002 	cmp	r2, #2	; 0x2
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d135c8:	e92d4070 	push	{r4, r5, r6, lr}
33d135cc:	e1a04003 	mov	r4, r3
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3) {
33d135d0:	ca000003 	bgt	33d135e4 <do_mem_loop+0x20>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d135d4:	e5901010 	ldr	r1, [r0, #16]
33d135d8:	e59f00e4 	ldr	r0, [pc, #228]	; 33d136c4 <do_mem_loop+0x100>
33d135dc:	eb000e79 	bl	33d16fc8 <printf>
		return 1;
33d135e0:	ea000035 	b	33d136bc <do_mem_loop+0xf8>
	}

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
33d135e4:	e5930000 	ldr	r0, [r3]
33d135e8:	e3a01004 	mov	r1, #4	; 0x4
33d135ec:	ebfffe52 	bl	33d12f3c <cmd_get_data_size>
33d135f0:	e2505000 	subs	r5, r0, #0	; 0x0
33d135f4:	ba000030 	blt	33d136bc <do_mem_loop+0xf8>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
33d135f8:	e3a01000 	mov	r1, #0	; 0x0
33d135fc:	e3a02010 	mov	r2, #16	; 0x10
33d13600:	e5940004 	ldr	r0, [r4, #4]
33d13604:	eb001bd4 	bl	33d1a55c <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
33d13608:	e3a01000 	mov	r1, #0	; 0x0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
33d1360c:	e1a06000 	mov	r6, r0

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
33d13610:	e3a02010 	mov	r2, #16	; 0x10
33d13614:	e5940008 	ldr	r0, [r4, #8]
33d13618:	eb001bcf 	bl	33d1a55c <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
33d1361c:	e3500001 	cmp	r0, #1	; 0x1
33d13620:	1a000009 	bne	33d1364c <do_mem_loop+0x88>
		if (size == 4) {
33d13624:	e3550004 	cmp	r5, #4	; 0x4
33d13628:	1a000001 	bne	33d13634 <do_mem_loop+0x70>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
33d1362c:	e5962000 	ldr	r2, [r6]
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
		if (size == 4) {
			longp = (uint *)addr;
			for (;;)
33d13630:	eafffffd 	b	33d1362c <do_mem_loop+0x68>
				i = *longp;
		}
		if (size == 2) {
33d13634:	e3550002 	cmp	r5, #2	; 0x2
33d13638:	1a000001 	bne	33d13644 <do_mem_loop+0x80>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
33d1363c:	e1d630b0 	ldrh	r3, [r6]
			for (;;)
				i = *longp;
		}
		if (size == 2) {
			shortp = (ushort *)addr;
			for (;;)
33d13640:	eafffffd 	b	33d1363c <do_mem_loop+0x78>
				i = *shortp;
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
33d13644:	e5d63000 	ldrb	r3, [r6]
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
		}
		cp = (u_char *)addr;
		for (;;)
33d13648:	eafffffd 	b	33d13644 <do_mem_loop+0x80>
			i = *cp;
	}

	if (size == 4) {
33d1364c:	e3550004 	cmp	r5, #4	; 0x4
33d13650:	1a000007 	bne	33d13674 <do_mem_loop+0xb0>
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
				junk = *longp++;
33d13654:	e2402001 	sub	r2, r0, #1	; 0x1
33d13658:	e3720001 	cmn	r2, #1	; 0x1
			i = *cp;
	}

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
33d1365c:	e1a01006 	mov	r1, r6
			i = length;
			while (i-- > 0)
				junk = *longp++;
33d13660:	0afffffb 	beq	33d13654 <do_mem_loop+0x90>
33d13664:	e2422001 	sub	r2, r2, #1	; 0x1
33d13668:	e4913004 	ldr	r3, [r1], #4
33d1366c:	e3720001 	cmn	r2, #1	; 0x1
33d13670:	eafffffa 	b	33d13660 <do_mem_loop+0x9c>
		}
	}
	if (size == 2) {
33d13674:	e3550002 	cmp	r5, #2	; 0x2
33d13678:	1a000007 	bne	33d1369c <do_mem_loop+0xd8>
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
				junk = *shortp++;
33d1367c:	e2402001 	sub	r2, r0, #1	; 0x1
33d13680:	e3720001 	cmn	r2, #1	; 0x1
				junk = *longp++;
		}
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
33d13684:	e1a01006 	mov	r1, r6
			i = length;
			while (i-- > 0)
				junk = *shortp++;
33d13688:	0afffffb 	beq	33d1367c <do_mem_loop+0xb8>
33d1368c:	e2422001 	sub	r2, r2, #1	; 0x1
33d13690:	e0d130b2 	ldrh	r3, [r1], #2
33d13694:	e3720001 	cmn	r2, #1	; 0x1
33d13698:	eafffffa 	b	33d13688 <do_mem_loop+0xc4>
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			junk = *cp++;
33d1369c:	e2402001 	sub	r2, r0, #1	; 0x1
33d136a0:	e3720001 	cmn	r2, #1	; 0x1
			while (i-- > 0)
				junk = *shortp++;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
33d136a4:	e1a01006 	mov	r1, r6
		i = length;
		while (i-- > 0)
			junk = *cp++;
33d136a8:	0afffffb 	beq	33d1369c <do_mem_loop+0xd8>
33d136ac:	e2422001 	sub	r2, r2, #1	; 0x1
33d136b0:	e4d13001 	ldrb	r3, [r1], #1
33d136b4:	e3720001 	cmn	r2, #1	; 0x1
33d136b8:	eafffffa 	b	33d136a8 <do_mem_loop+0xe4>
	}
}
33d136bc:	e3a00001 	mov	r0, #1	; 0x1
33d136c0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d136c4:	33d27008 	.word	0x33d27008

33d136c8 <do_mem_mtest>:
	ulong	incr;
	ulong	pattern;
	int     rcode = 0;
#endif

	if (argc > 1) {
33d136c8:	e3520001 	cmp	r2, #1	; 0x1
 * Perform a memory test. A more complete alternative test can be
 * configured using CFG_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d136cc:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d136d0:	e1a04002 	mov	r4, r2
33d136d4:	e1a05003 	mov	r5, r3
#endif

	if (argc > 1) {
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	} else {
		start = (ulong *)CFG_MEMTEST_START;
33d136d8:	d3a0a203 	movle	sl, #805306368	; 0x30000000
	ulong	incr;
	ulong	pattern;
	int     rcode = 0;
#endif

	if (argc > 1) {
33d136dc:	da000004 	ble	33d136f4 <do_mem_mtest+0x2c>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
33d136e0:	e5930004 	ldr	r0, [r3, #4]
33d136e4:	e3a01000 	mov	r1, #0	; 0x0
33d136e8:	e3a02010 	mov	r2, #16	; 0x10
33d136ec:	eb001b9a 	bl	33d1a55c <simple_strtoul>
33d136f0:	e1a0a000 	mov	sl, r0
	} else {
		start = (ulong *)CFG_MEMTEST_START;
	}

	if (argc > 2) {
33d136f4:	e3540002 	cmp	r4, #2	; 0x2
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	} else {
		end = (ulong *)(CFG_MEMTEST_END);
33d136f8:	d59f70d8 	ldrle	r7, [pc, #216]	; 33d137d8 <do_mem_mtest+0x110>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	} else {
		start = (ulong *)CFG_MEMTEST_START;
	}

	if (argc > 2) {
33d136fc:	da000004 	ble	33d13714 <do_mem_mtest+0x4c>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
33d13700:	e5950008 	ldr	r0, [r5, #8]
33d13704:	e3a01000 	mov	r1, #0	; 0x0
33d13708:	e3a02010 	mov	r2, #16	; 0x10
33d1370c:	eb001b92 	bl	33d1a55c <simple_strtoul>
33d13710:	e1a07000 	mov	r7, r0
	} else {
		end = (ulong *)(CFG_MEMTEST_END);
	}

	if (argc > 3) {
33d13714:	e3540003 	cmp	r4, #3	; 0x3
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
	} else {
		pattern = 0;
33d13718:	d3a06000 	movle	r6, #0	; 0x0
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	} else {
		end = (ulong *)(CFG_MEMTEST_END);
	}

	if (argc > 3) {
33d1371c:	da000004 	ble	33d13734 <do_mem_mtest+0x6c>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
33d13720:	e595000c 	ldr	r0, [r5, #12]
33d13724:	e3a01000 	mov	r1, #0	; 0x0
33d13728:	e3a02010 	mov	r2, #16	; 0x10
33d1372c:	eb001b8a 	bl	33d1a55c <simple_strtoul>
33d13730:	e1a06000 	mov	r6, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
33d13734:	e3a09001 	mov	r9, #1	; 0x1
	for (;;) {
		if (ctrlc()) {
33d13738:	eb000e3b 	bl	33d1702c <ctrlc>
33d1373c:	e3500000 	cmp	r0, #0	; 0x0
33d13740:	1a000020 	bne	33d137c8 <do_mem_mtest+0x100>
			putc ('\n');
			return 1;
		}

		printf ("\rPattern %08lX  Writing..."
33d13744:	e59f0090 	ldr	r0, [pc, #144]	; 33d137dc <do_mem_mtest+0x114>
33d13748:	e1a01006 	mov	r1, r6
33d1374c:	e59f208c 	ldr	r2, [pc, #140]	; 33d137e0 <do_mem_mtest+0x118>
33d13750:	eb000e1c 	bl	33d16fc8 <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
33d13754:	e1a0400a 	mov	r4, sl
33d13758:	e15a0007 	cmp	sl, r7
33d1375c:	e1a05006 	mov	r5, r6
33d13760:	2a000003 	bcs	33d13774 <do_mem_mtest+0xac>
			*addr = val;
33d13764:	e4845004 	str	r5, [r4], #4
			val  += incr;
33d13768:	e0855009 	add	r5, r5, r9
		printf ("\rPattern %08lX  Writing..."
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
33d1376c:	e1540007 	cmp	r4, r7
33d13770:	eafffffa 	b	33d13760 <do_mem_mtest+0x98>
			*addr = val;
			val  += incr;
		}

		puts ("Reading...");
33d13774:	e59f0068 	ldr	r0, [pc, #104]	; 33d137e4 <do_mem_mtest+0x11c>
33d13778:	eb000e0b 	bl	33d16fac <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
33d1377c:	e1a0400a 	mov	r4, sl
33d13780:	e15a0007 	cmp	sl, r7
33d13784:	e1a05006 	mov	r5, r6
33d13788:	2a000009 	bcs	33d137b4 <do_mem_mtest+0xec>
			readback = *addr;
33d1378c:	e5942000 	ldr	r2, [r4]
			if (readback != val) {
33d13790:	e1520005 	cmp	r2, r5
				printf ("\nMem error @ 0x%08X: "
33d13794:	e1a01004 	mov	r1, r4
33d13798:	e1a03005 	mov	r3, r5
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
33d1379c:	e2844004 	add	r4, r4, #4	; 0x4
				printf ("\nMem error @ 0x%08X: "
					"found %08lX, expected %08lX\n",
					(uint)addr, readback, val);
				rcode = 1;
			}
			val += incr;
33d137a0:	e0855009 	add	r5, r5, r9
		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
			readback = *addr;
			if (readback != val) {
				printf ("\nMem error @ 0x%08X: "
33d137a4:	e59f003c 	ldr	r0, [pc, #60]	; 33d137e8 <do_mem_mtest+0x120>
33d137a8:	1b000e06 	blne	33d16fc8 <printf>
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
33d137ac:	e1540007 	cmp	r4, r7
33d137b0:	eafffff4 	b	33d13788 <do_mem_mtest+0xc0>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
33d137b4:	e3560000 	cmp	r6, #0	; 0x0
			pattern = -pattern;	/* complement & increment */
33d137b8:	b2666000 	rsblt	r6, r6, #0	; 0x0
		}
		else {
			pattern = ~pattern;
33d137bc:	a1e06006 	mvnge	r6, r6
		}
		incr = -incr;
33d137c0:	e2699000 	rsb	r9, r9, #0	; 0x0
		}
	}

#else /* The original, quickie test */
	incr = 1;
	for (;;) {
33d137c4:	eaffffdb 	b	33d13738 <do_mem_mtest+0x70>
		if (ctrlc()) {
			putc ('\n');
33d137c8:	e3a0000a 	mov	r0, #10	; 0xa
33d137cc:	eb000dec 	bl	33d16f84 <putc>
		}
		incr = -incr;
	}
	return rcode;
#endif
}
33d137d0:	e3a00001 	mov	r0, #1	; 0x1
33d137d4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d137d8:	37f00000 	.word	0x37f00000
33d137dc:	33d2a468 	.word	0x33d2a468
33d137e0:	33d2a490 	.word	0x33d2a490
33d137e4:	33d2a494 	.word	0x33d2a494
33d137e8:	33d2a4a0 	.word	0x33d2a4a0

33d137ec <mod_mem>:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char *argv[])
{
33d137ec:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	ulong	addr, i;
	int	nbytes, size;
	extern char console_buffer[];

	if (argc != 2) {
33d137f0:	e3530002 	cmp	r3, #2	; 0x2
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char *argv[])
{
33d137f4:	e24dd004 	sub	sp, sp, #4	; 0x4
33d137f8:	e1a07001 	mov	r7, r1
33d137fc:	e59d4020 	ldr	r4, [sp, #32]
	ulong	addr, i;
	int	nbytes, size;
	extern char console_buffer[];

	if (argc != 2) {
33d13800:	0a000003 	beq	33d13814 <mod_mem+0x28>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d13804:	e5901010 	ldr	r1, [r0, #16]
33d13808:	e59f0124 	ldr	r0, [pc, #292]	; 33d13934 <mod_mem+0x148>
33d1380c:	eb000ded 	bl	33d16fc8 <printf>
33d13810:	ea00000a 	b	33d13840 <mod_mem+0x54>
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
33d13814:	e59fa11c 	ldr	sl, [pc, #284]	; 33d13938 <mod_mem+0x14c>
	size = mm_last_size;
33d13818:	e59f911c 	ldr	r9, [pc, #284]	; 33d1393c <mod_mem+0x150>

	if ((flag & CMD_FLAG_REPEAT) == 0) {
33d1381c:	e3120001 	tst	r2, #1	; 0x1
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
33d13820:	e59a5000 	ldr	r5, [sl]
	size = mm_last_size;
33d13824:	e5996000 	ldr	r6, [r9]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
33d13828:	1a00000d 	bne	33d13864 <mod_mem+0x78>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
33d1382c:	e5940000 	ldr	r0, [r4]
33d13830:	e3a01004 	mov	r1, #4	; 0x4
33d13834:	ebfffdc0 	bl	33d12f3c <cmd_get_data_size>
33d13838:	e2506000 	subs	r6, r0, #0	; 0x0
33d1383c:	aa000001 	bge	33d13848 <mod_mem+0x5c>
			return 1;
33d13840:	e3a00001 	mov	r0, #1	; 0x1
33d13844:	ea000038 	b	33d1392c <mod_mem+0x140>

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
33d13848:	e5940004 	ldr	r0, [r4, #4]
33d1384c:	e3a01000 	mov	r1, #0	; 0x0
33d13850:	e3a02010 	mov	r2, #16	; 0x10
33d13854:	eb001b40 	bl	33d1a55c <simple_strtoul>
		addr += base_address;
33d13858:	e59f30e0 	ldr	r3, [pc, #224]	; 33d13940 <mod_mem+0x154>
33d1385c:	e5933000 	ldr	r3, [r3]
33d13860:	e0805003 	add	r5, r0, r3

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
33d13864:	e59f00d8 	ldr	r0, [pc, #216]	; 33d13944 <mod_mem+0x158>
33d13868:	e1a01005 	mov	r1, r5
33d1386c:	eb000dd5 	bl	33d16fc8 <printf>
		if (size == 4)
33d13870:	e3560004 	cmp	r6, #4	; 0x4
			printf(" %08x", *((uint   *)addr));
33d13874:	059f00cc 	ldreq	r0, [pc, #204]	; 33d13948 <mod_mem+0x15c>
33d13878:	05951000 	ldreq	r1, [r5]
	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
		if (size == 4)
33d1387c:	0a000004 	beq	33d13894 <mod_mem+0xa8>
			printf(" %08x", *((uint   *)addr));
		else if (size == 2)
33d13880:	e3560002 	cmp	r6, #2	; 0x2
			printf(" %04x", *((ushort *)addr));
33d13884:	059f00c0 	ldreq	r0, [pc, #192]	; 33d1394c <mod_mem+0x160>
33d13888:	01d510b0 	ldrheq	r1, [r5]
		else
			printf(" %02x", *((u_char *)addr));
33d1388c:	159f00bc 	ldrne	r0, [pc, #188]	; 33d13950 <mod_mem+0x164>
33d13890:	15d51000 	ldrbne	r1, [r5]
33d13894:	eb000dcb 	bl	33d16fc8 <printf>

		nbytes = readline (" ? ");
33d13898:	e59f00b4 	ldr	r0, [pc, #180]	; 33d13954 <mod_mem+0x168>
33d1389c:	ebffe458 	bl	33d0ca04 <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
33d138a0:	e2502000 	subs	r2, r0, #0	; 0x0
33d138a4:	0a000005 	beq	33d138c0 <mod_mem+0xd4>
33d138a8:	e3520001 	cmp	r2, #1	; 0x1
33d138ac:	1a000009 	bne	33d138d8 <mod_mem+0xec>
33d138b0:	e59f30a0 	ldr	r3, [pc, #160]	; 33d13958 <mod_mem+0x16c>
33d138b4:	e5d33000 	ldrb	r3, [r3]
33d138b8:	e353002d 	cmp	r3, #45	; 0x2d
33d138bc:	1a000005 	bne	33d138d8 <mod_mem+0xec>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
33d138c0:	e3570000 	cmp	r7, #0	; 0x0
33d138c4:	0affffe6 	beq	33d13864 <mod_mem+0x78>
				addr += nbytes ? -size : size;
33d138c8:	e3520000 	cmp	r2, #0	; 0x0
33d138cc:	10665005 	rsbne	r5, r6, r5
33d138d0:	00855006 	addeq	r5, r5, r6
			nbytes = 1;
33d138d4:	eaffffe2 	b	33d13864 <mod_mem+0x78>
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
33d138d8:	e59f4078 	ldr	r4, [pc, #120]	; 33d13958 <mod_mem+0x16c>
33d138dc:	e3a02010 	mov	r2, #16	; 0x10
33d138e0:	e1a0100d 	mov	r1, sp
33d138e4:	e1a00004 	mov	r0, r4
33d138e8:	eb001b1b 	bl	33d1a55c <simple_strtoul>
			nbytes = endp - console_buffer;
33d138ec:	e59d3000 	ldr	r3, [sp]
			if (nbytes) {
33d138f0:	e0532004 	subs	r2, r3, r4
33d138f4:	0a000009 	beq	33d13920 <mod_mem+0x134>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
33d138f8:	e3560004 	cmp	r6, #4	; 0x4
					*((uint   *)addr) = i;
33d138fc:	05850000 	streq	r0, [r5]
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
33d13900:	0a000002 	beq	33d13910 <mod_mem+0x124>
					*((uint   *)addr) = i;
				else if (size == 2)
33d13904:	e3560002 	cmp	r6, #2	; 0x2
					*((ushort *)addr) = i;
33d13908:	01c500b0 	strheq	r0, [r5]
				else
					*((u_char *)addr) = i;
33d1390c:	15c50000 	strbne	r0, [r5]
				if (incrflag)
33d13910:	e3570000 	cmp	r7, #0	; 0x0
					addr += size;
33d13914:	10855006 	addne	r5, r5, r6
			}
		}
	} while (nbytes);
33d13918:	e3520000 	cmp	r2, #0	; 0x0
33d1391c:	1affffd0 	bne	33d13864 <mod_mem+0x78>

	mm_last_addr = addr;
33d13920:	e58a5000 	str	r5, [sl]
	mm_last_size = size;
33d13924:	e5896000 	str	r6, [r9]
	return 0;
33d13928:	e3a00000 	mov	r0, #0	; 0x0
}
33d1392c:	e28dd004 	add	sp, sp, #4	; 0x4
33d13930:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d13934:	33d27008 	.word	0x33d27008
33d13938:	33d60c04 	.word	0x33d60c04
33d1393c:	33d60c08 	.word	0x33d60c08
33d13940:	33d60c0c 	.word	0x33d60c0c
33d13944:	33d2a330 	.word	0x33d2a330
33d13948:	33d2a338 	.word	0x33d2a338
33d1394c:	33d2a340 	.word	0x33d2a340
33d13950:	33d2a348 	.word	0x33d2a348
33d13954:	33d2a4d4 	.word	0x33d2a4d4
33d13958:	33d60688 	.word	0x33d60688

33d1395c <do_mem_nm>:
int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
}
int do_mem_nm ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d1395c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d13960:	e1a0c002 	mov	ip, r2
33d13964:	e24dd004 	sub	sp, sp, #4	; 0x4
	return mod_mem (cmdtp, 0, flag, argc, argv);
33d13968:	e58d3000 	str	r3, [sp]
33d1396c:	e1a02001 	mov	r2, r1
33d13970:	e1a0300c 	mov	r3, ip
33d13974:	e3a01000 	mov	r1, #0	; 0x0
33d13978:	ebffff9b 	bl	33d137ec <mod_mem>
}
33d1397c:	e28dd004 	add	sp, sp, #4	; 0x4
33d13980:	e8bd8000 	pop	{pc}

33d13984 <do_mem_mm>:
	dp_last_size = size;
	return (rc);
}

int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13984:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d13988:	e1a0c002 	mov	ip, r2
33d1398c:	e24dd004 	sub	sp, sp, #4	; 0x4
	return mod_mem (cmdtp, 1, flag, argc, argv);
33d13990:	e58d3000 	str	r3, [sp]
33d13994:	e1a02001 	mov	r2, r1
33d13998:	e1a0300c 	mov	r3, ip
33d1399c:	e3a01001 	mov	r1, #1	; 0x1
33d139a0:	ebffff91 	bl	33d137ec <mod_mem>
}
33d139a4:	e28dd004 	add	sp, sp, #4	; 0x4
33d139a8:	e8bd8000 	pop	{pc}

33d139ac <do_mem_crc>:
}

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d139ac:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d139b0:	e1a0a002 	mov	sl, r2
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3) {
33d139b4:	e35a0002 	cmp	sl, #2	; 0x2
}

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d139b8:	e1a06003 	mov	r6, r3
	if (argc < 3) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	addr = simple_strtoul (argv[1], NULL, 16);
33d139bc:	e3a01000 	mov	r1, #0	; 0x0
}

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d139c0:	e1a03000 	mov	r3, r0
	if (argc < 3) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	addr = simple_strtoul (argv[1], NULL, 16);
33d139c4:	e3a02010 	mov	r2, #16	; 0x10
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3) {
		printf ("Usage:\n%s\n", cmdtp->usage);
33d139c8:	e59f0088 	ldr	r0, [pc, #136]	; 33d13a58 <do_mem_crc+0xac>
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3) {
33d139cc:	ca000003 	bgt	33d139e0 <do_mem_crc+0x34>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d139d0:	e5931010 	ldr	r1, [r3, #16]
33d139d4:	eb000d7b 	bl	33d16fc8 <printf>
		return 1;
33d139d8:	e3a00001 	mov	r0, #1	; 0x1
33d139dc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

	addr = simple_strtoul (argv[1], NULL, 16);
33d139e0:	e5960004 	ldr	r0, [r6, #4]
33d139e4:	eb001adc 	bl	33d1a55c <simple_strtoul>
	addr += base_address;
33d139e8:	e59f306c 	ldr	r3, [pc, #108]	; 33d13a5c <do_mem_crc+0xb0>
33d139ec:	e5933000 	ldr	r3, [r3]

	length = simple_strtoul (argv[2], NULL, 16);
33d139f0:	e3a01000 	mov	r1, #0	; 0x0
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
33d139f4:	e0805003 	add	r5, r0, r3

	length = simple_strtoul (argv[2], NULL, 16);
33d139f8:	e3a02010 	mov	r2, #16	; 0x10
33d139fc:	e5960008 	ldr	r0, [r6, #8]
33d13a00:	eb001ad5 	bl	33d1a55c <simple_strtoul>

	crc = crc32 (0, (const uchar *) addr, length);
33d13a04:	e1a01005 	mov	r1, r5
33d13a08:	e1a02000 	mov	r2, r0
	}

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);
33d13a0c:	e1a04000 	mov	r4, r0

	crc = crc32 (0, (const uchar *) addr, length);
33d13a10:	e3a00000 	mov	r0, #0	; 0x0
33d13a14:	eb0018bf 	bl	33d19d18 <crc32>

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
33d13a18:	e0854004 	add	r4, r5, r4
	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);

	crc = crc32 (0, (const uchar *) addr, length);
33d13a1c:	e1a07000 	mov	r7, r0

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
33d13a20:	e1a01005 	mov	r1, r5
33d13a24:	e2442001 	sub	r2, r4, #1	; 0x1
33d13a28:	e59f0030 	ldr	r0, [pc, #48]	; 33d13a60 <do_mem_crc+0xb4>
33d13a2c:	e1a03007 	mov	r3, r7
33d13a30:	eb000d64 	bl	33d16fc8 <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
33d13a34:	e35a0003 	cmp	sl, #3	; 0x3
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
33d13a38:	e3a01000 	mov	r1, #0	; 0x0
33d13a3c:	e3a02010 	mov	r2, #16	; 0x10
	crc = crc32 (0, (const uchar *) addr, length);

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
			addr, addr + length - 1, crc);

	if (argc > 3) {
33d13a40:	da000002 	ble	33d13a50 <do_mem_crc+0xa4>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
33d13a44:	e596000c 	ldr	r0, [r6, #12]
33d13a48:	eb001ac3 	bl	33d1a55c <simple_strtoul>
		*ptr = crc;
33d13a4c:	e5807000 	str	r7, [r0]
	}

	return 0;
33d13a50:	e3a00000 	mov	r0, #0	; 0x0
}
33d13a54:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d13a58:	33d27008 	.word	0x33d27008
33d13a5c:	33d60c0c 	.word	0x33d60c0c
33d13a60:	33d2a4d8 	.word	0x33d2a4d8

33d13a64 <do_sleep>:
#include <command.h>

#if (CONFIG_COMMANDS & CFG_CMD_MISC)

int do_sleep (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13a64:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d13a68:	e1a06000 	mov	r6, r0
	ulong start = get_timer(0);
33d13a6c:	e3a00000 	mov	r0, #0	; 0x0
#include <command.h>

#if (CONFIG_COMMANDS & CFG_CMD_MISC)

int do_sleep (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d13a70:	e1a04002 	mov	r4, r2
33d13a74:	e1a05003 	mov	r5, r3
	ulong start = get_timer(0);
33d13a78:	ebffb4da 	bl	33d00de8 <get_timer>
	ulong delay;

	if (argc != 2) {
33d13a7c:	e3540002 	cmp	r4, #2	; 0x2

#if (CONFIG_COMMANDS & CFG_CMD_MISC)

int do_sleep (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	ulong start = get_timer(0);
33d13a80:	e1a07000 	mov	r7, r0
	ulong delay;

	if (argc != 2) {
33d13a84:	0a000006 	beq	33d13aa4 <do_sleep+0x40>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d13a88:	e59f006c 	ldr	r0, [pc, #108]	; 33d13afc <do_sleep+0x98>
33d13a8c:	e5961010 	ldr	r1, [r6, #16]
33d13a90:	eb000d4c 	bl	33d16fc8 <printf>
		return 1;
33d13a94:	e3a00001 	mov	r0, #1	; 0x1
33d13a98:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

	delay = simple_strtoul(argv[1], NULL, 10) * CFG_HZ;

	while (get_timer(start) < delay) {
		if (ctrlc ()) {
			return (-1);
33d13a9c:	e3e00000 	mvn	r0, #0	; 0x0
33d13aa0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	if (argc != 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	delay = simple_strtoul(argv[1], NULL, 10) * CFG_HZ;
33d13aa4:	e5950004 	ldr	r0, [r5, #4]
33d13aa8:	e3a01000 	mov	r1, #0	; 0x0
33d13aac:	e3a0200a 	mov	r2, #10	; 0xa
33d13ab0:	eb001aa9 	bl	33d1a55c <simple_strtoul>
33d13ab4:	e0603280 	rsb	r3, r0, r0, lsl #5
33d13ab8:	e0633303 	rsb	r3, r3, r3, lsl #6
33d13abc:	e0800183 	add	r0, r0, r3, lsl #3
33d13ac0:	e0800100 	add	r0, r0, r0, lsl #2
33d13ac4:	e0800100 	add	r0, r0, r0, lsl #2
33d13ac8:	e1a04100 	lsl	r4, r0, #2

	while (get_timer(start) < delay) {
33d13acc:	ea000004 	b	33d13ae4 <do_sleep+0x80>
		if (ctrlc ()) {
33d13ad0:	eb000d55 	bl	33d1702c <ctrlc>
33d13ad4:	e3500000 	cmp	r0, #0	; 0x0
			return (-1);
		}
		udelay (100);
33d13ad8:	e3a00064 	mov	r0, #100	; 0x64
	}

	delay = simple_strtoul(argv[1], NULL, 10) * CFG_HZ;

	while (get_timer(start) < delay) {
		if (ctrlc ()) {
33d13adc:	1affffee 	bne	33d13a9c <do_sleep+0x38>
			return (-1);
		}
		udelay (100);
33d13ae0:	ebffb4c9 	bl	33d00e0c <udelay>
33d13ae4:	e1a00007 	mov	r0, r7
33d13ae8:	ebffb4be 	bl	33d00de8 <get_timer>
33d13aec:	e1500004 	cmp	r0, r4
33d13af0:	3afffff6 	bcc	33d13ad0 <do_sleep+0x6c>
	}

	return 0;
33d13af4:	e3a00000 	mov	r0, #0	; 0x0
}
33d13af8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d13afc:	33d27008 	.word	0x33d27008

33d13b00 <arg_off_size>:
    return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int
arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
{
33d13b00:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d13b04:	e1a0a003 	mov	sl, r3
    int idx = nand_curr_device;
33d13b08:	e59f3210 	ldr	r3, [pc, #528]	; 33d13d20 <arg_off_size+0x220>
    return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int
arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
{
33d13b0c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
    struct mtd_device *dev;
    struct part_info *part;
    u8 pnum;

    if (argc >= 1 && !(str2long(argv[0], off))) {
33d13b10:	e2507000 	subs	r7, r0, #0	; 0x0
    return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int
arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
{
33d13b14:	e1a05001 	mov	r5, r1
33d13b18:	e1a0b002 	mov	fp, r2
    int idx = nand_curr_device;
33d13b1c:	e5936000 	ldr	r6, [r3]
    return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int
arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
{
33d13b20:	e59d903c 	ldr	r9, [sp, #60]
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
    struct mtd_device *dev;
    struct part_info *part;
    u8 pnum;

    if (argc >= 1 && !(str2long(argv[0], off))) {
33d13b24:	da000053 	ble	33d13c78 <arg_off_size+0x178>
}

/* ------------------------------------------------------------------------- */

static inline int str2long(char *p, ulong *num)
{
33d13b28:	e5914000 	ldr	r4, [r1]
    char *endptr;

    *num = simple_strtoul(p, &endptr, 16);
33d13b2c:	e3a02010 	mov	r2, #16	; 0x10
33d13b30:	e28d1014 	add	r1, sp, #20	; 0x14
33d13b34:	e1a00004 	mov	r0, r4
33d13b38:	eb001a87 	bl	33d1a55c <simple_strtoul>
33d13b3c:	e58a0000 	str	r0, [sl]
33d13b40:	e5d43000 	ldrb	r3, [r4]
33d13b44:	e3530000 	cmp	r3, #0	; 0x0
33d13b48:	0a000003 	beq	33d13b5c <arg_off_size+0x5c>
33d13b4c:	e59d3014 	ldr	r3, [sp, #20]
33d13b50:	e5d33000 	ldrb	r3, [r3]
33d13b54:	e3530000 	cmp	r3, #0	; 0x0
33d13b58:	0a000035 	beq	33d13c34 <arg_off_size+0x134>
    struct mtd_device *dev;
    struct part_info *part;
    u8 pnum;

    if (argc >= 1 && !(str2long(argv[0], off))) {
        if ((mtdparts_init() == 0) &&
33d13b5c:	ebfff540 	bl	33d11064 <mtdparts_init>
33d13b60:	e3500000 	cmp	r0, #0	; 0x0
33d13b64:	1a000032 	bne	33d13c34 <arg_off_size+0x134>
33d13b68:	e5950000 	ldr	r0, [r5]
33d13b6c:	e28d1010 	add	r1, sp, #16	; 0x10
33d13b70:	e28d201b 	add	r2, sp, #27	; 0x1b
33d13b74:	e28d300c 	add	r3, sp, #12	; 0xc
33d13b78:	ebfff4d0 	bl	33d10ec0 <find_dev_and_part>
33d13b7c:	e3500000 	cmp	r0, #0	; 0x0
33d13b80:	1a00002b 	bne	33d13c34 <arg_off_size+0x134>
            (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
            if (dev->id->type != MTD_DEV_TYPE_NAND) {
33d13b84:	e59d3010 	ldr	r3, [sp, #16]
33d13b88:	e5933008 	ldr	r3, [r3, #8]
33d13b8c:	e5d33008 	ldrb	r3, [r3, #8]
33d13b90:	e3530002 	cmp	r3, #2	; 0x2
33d13b94:	0a000002 	beq	33d13ba4 <arg_off_size+0xa4>
                puts("not a NAND device\n");
33d13b98:	e59f0184 	ldr	r0, [pc, #388]	; 33d13d24 <arg_off_size+0x224>
33d13b9c:	eb000d02 	bl	33d16fac <puts>
33d13ba0:	ea00004c 	b	33d13cd8 <arg_off_size+0x1d8>
                return -1;
            }
            *off = part->offset;
33d13ba4:	e59d200c 	ldr	r2, [sp, #12]
33d13ba8:	e5923014 	ldr	r3, [r2, #20]
33d13bac:	e58a3000 	str	r3, [sl]
            if (argc >= 2) {
33d13bb0:	e3570001 	cmp	r7, #1	; 0x1
                    return -1;
                }
                if (*size > part->size)
                    *size = part->size;
            } else {
                *size = part->size;
33d13bb4:	d5923010 	ldrle	r3, [r2, #16]
33d13bb8:	d5893000 	strle	r3, [r9]
            if (dev->id->type != MTD_DEV_TYPE_NAND) {
                puts("not a NAND device\n");
                return -1;
            }
            *off = part->offset;
            if (argc >= 2) {
33d13bbc:	da000011 	ble	33d13c08 <arg_off_size+0x108>
}

/* ------------------------------------------------------------------------- */

static inline int str2long(char *p, ulong *num)
{
33d13bc0:	e5954004 	ldr	r4, [r5, #4]
    char *endptr;

    *num = simple_strtoul(p, &endptr, 16);
33d13bc4:	e28d1008 	add	r1, sp, #8	; 0x8
33d13bc8:	e1a00004 	mov	r0, r4
33d13bcc:	e3a02010 	mov	r2, #16	; 0x10
33d13bd0:	eb001a61 	bl	33d1a55c <simple_strtoul>
33d13bd4:	e5890000 	str	r0, [r9]
33d13bd8:	e5d43000 	ldrb	r3, [r4]
33d13bdc:	e3530000 	cmp	r3, #0	; 0x0
33d13be0:	0a000039 	beq	33d13ccc <arg_off_size+0x1cc>
33d13be4:	e59d3008 	ldr	r3, [sp, #8]
33d13be8:	e5d33000 	ldrb	r3, [r3]
33d13bec:	e3530000 	cmp	r3, #0	; 0x0
33d13bf0:	1a000035 	bne	33d13ccc <arg_off_size+0x1cc>
            if (argc >= 2) {
                if (!(str2long(argv[1], size))) {
                    printf("'%s' is not a number\n", argv[1]);
                    return -1;
                }
                if (*size > part->size)
33d13bf4:	e59d300c 	ldr	r3, [sp, #12]
33d13bf8:	e5932010 	ldr	r2, [r3, #16]
33d13bfc:	e5993000 	ldr	r3, [r9]
33d13c00:	e1530002 	cmp	r3, r2
                    *size = part->size;
33d13c04:	85892000 	strhi	r2, [r9]
            } else {
                *size = part->size;
            }
            idx = dev->id->num;
33d13c08:	e59d3010 	ldr	r3, [sp, #16]
33d13c0c:	e5933008 	ldr	r3, [r3, #8]
33d13c10:	e5d36009 	ldrb	r6, [r3, #9]
            *nand = nand_info[idx];
33d13c14:	e59f310c 	ldr	r3, [pc, #268]	; 33d13d28 <arg_off_size+0x228>
33d13c18:	e0861106 	add	r1, r6, r6, lsl #2
33d13c1c:	e0861181 	add	r1, r6, r1, lsl #3
33d13c20:	e0831181 	add	r1, r3, r1, lsl #3
33d13c24:	e1a0000b 	mov	r0, fp
33d13c28:	e3a02f52 	mov	r2, #328	; 0x148
33d13c2c:	eb0019ec 	bl	33d1a3e4 <memcpy>
            goto out;
33d13c30:	ea00002a 	b	33d13ce0 <arg_off_size+0x1e0>
        }
    }
#endif

    if (argc >= 1) {
33d13c34:	e3570000 	cmp	r7, #0	; 0x0
33d13c38:	da00000e 	ble	33d13c78 <arg_off_size+0x178>
}

/* ------------------------------------------------------------------------- */

static inline int str2long(char *p, ulong *num)
{
33d13c3c:	e5954000 	ldr	r4, [r5]
    char *endptr;

    *num = simple_strtoul(p, &endptr, 16);
33d13c40:	e28d1004 	add	r1, sp, #4	; 0x4
33d13c44:	e1a00004 	mov	r0, r4
33d13c48:	e3a02010 	mov	r2, #16	; 0x10
33d13c4c:	eb001a42 	bl	33d1a55c <simple_strtoul>
33d13c50:	e58a0000 	str	r0, [sl]
33d13c54:	e5d43000 	ldrb	r3, [r4]
33d13c58:	e3530000 	cmp	r3, #0	; 0x0
33d13c5c:	0a000003 	beq	33d13c70 <arg_off_size+0x170>
33d13c60:	e59d3004 	ldr	r3, [sp, #4]
33d13c64:	e5d33000 	ldrb	r3, [r3]
33d13c68:	e3530000 	cmp	r3, #0	; 0x0
33d13c6c:	0a000003 	beq	33d13c80 <arg_off_size+0x180>
    }
#endif

    if (argc >= 1) {
        if (!(str2long(argv[0], off))) {
            printf("'%s' is not a number\n", argv[0]);
33d13c70:	e5951000 	ldr	r1, [r5]
33d13c74:	ea000015 	b	33d13cd0 <arg_off_size+0x1d0>
            return -1;
        }
    } else {
        *off = 0;
33d13c78:	e3a03000 	mov	r3, #0	; 0x0
33d13c7c:	e58a3000 	str	r3, [sl]
    }

    if (argc >= 2) {
33d13c80:	e3570001 	cmp	r7, #1	; 0x1
        if (!(str2long(argv[1], size))) {
            printf("'%s' is not a number\n", argv[1]);
            return -1;
        }
    } else {
        *size = nand->size - *off;
33d13c84:	d59b3008 	ldrle	r3, [fp, #8]
33d13c88:	d59a2000 	ldrle	r2, [sl]
33d13c8c:	d0623003 	rsble	r3, r2, r3
33d13c90:	d5893000 	strle	r3, [r9]
        }
    } else {
        *off = 0;
    }

    if (argc >= 2) {
33d13c94:	da000011 	ble	33d13ce0 <arg_off_size+0x1e0>
}

/* ------------------------------------------------------------------------- */

static inline int str2long(char *p, ulong *num)
{
33d13c98:	e5954004 	ldr	r4, [r5, #4]
    char *endptr;

    *num = simple_strtoul(p, &endptr, 16);
33d13c9c:	e1a0100d 	mov	r1, sp
33d13ca0:	e1a00004 	mov	r0, r4
33d13ca4:	e3a02010 	mov	r2, #16	; 0x10
33d13ca8:	eb001a2b 	bl	33d1a55c <simple_strtoul>
33d13cac:	e5890000 	str	r0, [r9]
33d13cb0:	e5d43000 	ldrb	r3, [r4]
33d13cb4:	e3530000 	cmp	r3, #0	; 0x0
33d13cb8:	0a000003 	beq	33d13ccc <arg_off_size+0x1cc>
33d13cbc:	e59d3000 	ldr	r3, [sp]
33d13cc0:	e5d33000 	ldrb	r3, [r3]
33d13cc4:	e3530000 	cmp	r3, #0	; 0x0
33d13cc8:	0a000004 	beq	33d13ce0 <arg_off_size+0x1e0>
        *off = 0;
    }

    if (argc >= 2) {
        if (!(str2long(argv[1], size))) {
            printf("'%s' is not a number\n", argv[1]);
33d13ccc:	e5951004 	ldr	r1, [r5, #4]
33d13cd0:	e59f0054 	ldr	r0, [pc, #84]	; 33d13d2c <arg_off_size+0x22c>
33d13cd4:	eb000cbb 	bl	33d16fc8 <printf>
            return -1;
33d13cd8:	e3e00000 	mvn	r0, #0	; 0x0
33d13cdc:	ea00000d 	b	33d13d18 <arg_off_size+0x218>
    }

#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
out:
#endif
    printf("device %d ", idx);
33d13ce0:	e1a01006 	mov	r1, r6
33d13ce4:	e59f0044 	ldr	r0, [pc, #68]	; 33d13d30 <arg_off_size+0x230>
33d13ce8:	eb000cb6 	bl	33d16fc8 <printf>
    if (*size == nand->size)
33d13cec:	e5992000 	ldr	r2, [r9]
33d13cf0:	e59b3008 	ldr	r3, [fp, #8]
33d13cf4:	e1520003 	cmp	r2, r3
33d13cf8:	1a000002 	bne	33d13d08 <arg_off_size+0x208>
        puts("whole chip\n");
33d13cfc:	e59f0030 	ldr	r0, [pc, #48]	; 33d13d34 <arg_off_size+0x234>
33d13d00:	eb000ca9 	bl	33d16fac <puts>
33d13d04:	ea000002 	b	33d13d14 <arg_off_size+0x214>
    else
        printf("offset 0x%x, size 0x%x\n", *off, *size);
33d13d08:	e59a1000 	ldr	r1, [sl]
33d13d0c:	e59f0024 	ldr	r0, [pc, #36]	; 33d13d38 <arg_off_size+0x238>
33d13d10:	eb000cac 	bl	33d16fc8 <printf>
    return 0;
33d13d14:	e3a00000 	mov	r0, #0	; 0x0
}
33d13d18:	e28dd01c 	add	sp, sp, #28	; 0x1c
33d13d1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d13d20:	33d2ddbc 	.word	0x33d2ddbc
33d13d24:	33d2ac4c 	.word	0x33d2ac4c
33d13d28:	33d39920 	.word	0x33d39920
33d13d2c:	33d2ac60 	.word	0x33d2ac60
33d13d30:	33d2ac78 	.word	0x33d2ac78
33d13d34:	33d2ac84 	.word	0x33d2ac84
33d13d38:	33d2ac90 	.word	0x33d2ac90

33d13d3c <do_nand>:

int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d13d3c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d13d40:	e24dd0a8 	sub	sp, sp, #168	; 0xa8
33d13d44:	e1a09002 	mov	r9, r2
33d13d48:	e58d0038 	str	r0, [sp, #56]
    int i, dev, ret;
    ulong addr, off, size;
    char *cmd, *s;
    nand_info_t *nand;
    int quiet = 0;
    const char *quiet_str = getenv("quiet");
33d13d4c:	e59f0ba4 	ldr	r0, [pc, #2980]	; 33d148f8 <do_nand+0xbbc>
        printf("offset 0x%x, size 0x%x\n", *off, *size);
    return 0;
}

int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d13d50:	e1a06003 	mov	r6, r3
    int i, dev, ret;
    ulong addr, off, size;
    char *cmd, *s;
    nand_info_t *nand;
    int quiet = 0;
    const char *quiet_str = getenv("quiet");
33d13d54:	eb0006bd 	bl	33d15850 <getenv>
{
    int i, dev, ret;
    ulong addr, off, size;
    char *cmd, *s;
    nand_info_t *nand;
    int quiet = 0;
33d13d58:	e3a02000 	mov	r2, #0	; 0x0
    const char *quiet_str = getenv("quiet");

    /* at least two arguments please */
    if (argc < 2)
33d13d5c:	e3590001 	cmp	r9, #1	; 0x1
{
    int i, dev, ret;
    ulong addr, off, size;
    char *cmd, *s;
    nand_info_t *nand;
    int quiet = 0;
33d13d60:	e58d2034 	str	r2, [sp, #52]
    const char *quiet_str = getenv("quiet");

    /* at least two arguments please */
    if (argc < 2)
33d13d64:	da0002dc 	ble	33d148dc <do_nand+0xba0>
        goto usage;

    if (quiet_str)
33d13d68:	e1500002 	cmp	r0, r2
33d13d6c:	0a000004 	beq	33d13d84 <do_nand+0x48>
        quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
33d13d70:	e1a01002 	mov	r1, r2
33d13d74:	eb0019f8 	bl	33d1a55c <simple_strtoul>
33d13d78:	e2500000 	subs	r0, r0, #0	; 0x0
33d13d7c:	13a00001 	movne	r0, #1	; 0x1
33d13d80:	e58d0034 	str	r0, [sp, #52]

    cmd = argv[1];
33d13d84:	e5964004 	ldr	r4, [r6, #4]

    if (strcmp(cmd, "info") == 0) {
33d13d88:	e59f1b6c 	ldr	r1, [pc, #2924]	; 33d148fc <do_nand+0xbc0>
33d13d8c:	e1a00004 	mov	r0, r4
33d13d90:	eb0018b4 	bl	33d1a068 <strcmp>
33d13d94:	e2505000 	subs	r5, r0, #0	; 0x0
33d13d98:	1a00000b 	bne	33d13dcc <do_nand+0x90>

        putc('\n');
33d13d9c:	e280000a 	add	r0, r0, #10	; 0xa
33d13da0:	eb000c77 	bl	33d16f84 <putc>
33d13da4:	e59f3b54 	ldr	r3, [pc, #2900]	; 33d14900 <do_nand+0xbc4>
        for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
            if (nand_info[i].name)
33d13da8:	e5932024 	ldr	r2, [r3, #36]
33d13dac:	e3520000 	cmp	r2, #0	; 0x0
    cmd = argv[1];

    if (strcmp(cmd, "info") == 0) {

        putc('\n');
        for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
33d13db0:	e1a01005 	mov	r1, r5
            if (nand_info[i].name)
                printf("Device %d: %s, sector size %lu KiB\n",
33d13db4:	1593300c 	ldrne	r3, [r3, #12]
33d13db8:	159f0b44 	ldrne	r0, [pc, #2884]	; 33d14904 <do_nand+0xbc8>
33d13dbc:	11a03523 	lsrne	r3, r3, #10
33d13dc0:	1b000c80 	blne	33d16fc8 <printf>
                    i, nand_info[i].name,
                    nand_info[i].erasesize >> 10);
        }
        return 0;
33d13dc4:	e1a00005 	mov	r0, r5
33d13dc8:	ea0002c8 	b	33d148f0 <do_nand+0xbb4>
    }

    if (strcmp(cmd, "device") == 0) {
33d13dcc:	e59f1b34 	ldr	r1, [pc, #2868]	; 33d14908 <do_nand+0xbcc>
33d13dd0:	e1a00004 	mov	r0, r4
33d13dd4:	eb0018a3 	bl	33d1a068 <strcmp>
33d13dd8:	e2501000 	subs	r1, r0, #0	; 0x0
33d13ddc:	1a00001f 	bne	33d13e60 <do_nand+0x124>

        if (argc < 3) {
33d13de0:	e3590002 	cmp	r9, #2	; 0x2
33d13de4:	ca000009 	bgt	33d13e10 <do_nand+0xd4>
            if ((nand_curr_device < 0) ||
33d13de8:	e59f3b1c 	ldr	r3, [pc, #2844]	; 33d1490c <do_nand+0xbd0>
33d13dec:	e5931000 	ldr	r1, [r3]
33d13df0:	e3510000 	cmp	r1, #0	; 0x0
                (nand_curr_device >= CFG_MAX_NAND_DEVICE))
                puts("\nno devices available\n");
33d13df4:	159f0b14 	ldrne	r0, [pc, #2836]	; 33d14910 <do_nand+0xbd4>
    }

    if (strcmp(cmd, "device") == 0) {

        if (argc < 3) {
            if ((nand_curr_device < 0) ||
33d13df8:	1a00029b 	bne	33d1486c <do_nand+0xb30>
                (nand_curr_device >= CFG_MAX_NAND_DEVICE))
                puts("\nno devices available\n");
            else
                printf("\nDevice %d: %s\n", nand_curr_device,
33d13dfc:	e59f3afc 	ldr	r3, [pc, #2812]	; 33d14900 <do_nand+0xbc4>
33d13e00:	e59f0b0c 	ldr	r0, [pc, #2828]	; 33d14914 <do_nand+0xbd8>
33d13e04:	e5932024 	ldr	r2, [r3, #36]
33d13e08:	eb000c6e 	bl	33d16fc8 <printf>
33d13e0c:	ea000297 	b	33d14870 <do_nand+0xb34>
                    nand_info[nand_curr_device].name);
            return 0;
        }
        dev = (int)simple_strtoul(argv[2], NULL, 10);
33d13e10:	e5960008 	ldr	r0, [r6, #8]
33d13e14:	e3a0200a 	mov	r2, #10	; 0xa
33d13e18:	eb0019cf 	bl	33d1a55c <simple_strtoul>
        if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
33d13e1c:	e2504000 	subs	r4, r0, #0	; 0x0
33d13e20:	1a000003 	bne	33d13e34 <do_nand+0xf8>
33d13e24:	e59f3ad4 	ldr	r3, [pc, #2772]	; 33d14900 <do_nand+0xbc4>
33d13e28:	e5932024 	ldr	r2, [r3, #36]
33d13e2c:	e3520000 	cmp	r2, #0	; 0x0
33d13e30:	1a000001 	bne	33d13e3c <do_nand+0x100>
            puts("No such device\n");
33d13e34:	e59f0adc 	ldr	r0, [pc, #2780]	; 33d14918 <do_nand+0xbdc>
33d13e38:	ea000046 	b	33d13f58 <do_nand+0x21c>
            return 1;
        }
        printf("Device %d: %s", dev, nand_info[dev].name);
33d13e3c:	e59f0ad8 	ldr	r0, [pc, #2776]	; 33d1491c <do_nand+0xbe0>
33d13e40:	e1a01004 	mov	r1, r4
33d13e44:	eb000c5f 	bl	33d16fc8 <printf>
        puts("... is now current device\n");
33d13e48:	e59f0ad0 	ldr	r0, [pc, #2768]	; 33d14920 <do_nand+0xbe4>
33d13e4c:	eb000c56 	bl	33d16fac <puts>
        nand_curr_device = dev;
33d13e50:	e59f3ab4 	ldr	r3, [pc, #2740]	; 33d1490c <do_nand+0xbd0>
         * Select the chip in the board/cpu specific driver
         */
        board_nand_select_device(nand_info[dev].priv, dev);
#endif

        return 0;
33d13e54:	e1a00004 	mov	r0, r4
            puts("No such device\n");
            return 1;
        }
        printf("Device %d: %s", dev, nand_info[dev].name);
        puts("... is now current device\n");
        nand_curr_device = dev;
33d13e58:	e5834000 	str	r4, [r3]
         * Select the chip in the board/cpu specific driver
         */
        board_nand_select_device(nand_info[dev].priv, dev);
#endif

        return 0;
33d13e5c:	ea0002a3 	b	33d148f0 <do_nand+0xbb4>
    }

    if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
33d13e60:	e1a00004 	mov	r0, r4
33d13e64:	e59f1ab8 	ldr	r1, [pc, #2744]	; 33d14924 <do_nand+0xbe8>
33d13e68:	eb00187e 	bl	33d1a068 <strcmp>
33d13e6c:	e3500000 	cmp	r0, #0	; 0x0
33d13e70:	0a00002f 	beq	33d13f34 <do_nand+0x1f8>
33d13e74:	e1a00004 	mov	r0, r4
33d13e78:	e59f1aa8 	ldr	r1, [pc, #2728]	; 33d14928 <do_nand+0xbec>
33d13e7c:	eb001879 	bl	33d1a068 <strcmp>
33d13e80:	e3500000 	cmp	r0, #0	; 0x0
33d13e84:	0a00002a 	beq	33d13f34 <do_nand+0x1f8>
33d13e88:	e1a00004 	mov	r0, r4
33d13e8c:	e59f1a98 	ldr	r1, [pc, #2712]	; 33d1492c <do_nand+0xbf0>
33d13e90:	e3a02004 	mov	r2, #4	; 0x4
33d13e94:	eb00187f 	bl	33d1a098 <strncmp>
33d13e98:	e3500000 	cmp	r0, #0	; 0x0
33d13e9c:	0a000024 	beq	33d13f34 <do_nand+0x1f8>
33d13ea0:	e1a00004 	mov	r0, r4
33d13ea4:	e59f1a84 	ldr	r1, [pc, #2692]	; 33d14930 <do_nand+0xbf4>
33d13ea8:	e3a02004 	mov	r2, #4	; 0x4
33d13eac:	eb001879 	bl	33d1a098 <strncmp>
33d13eb0:	e3500000 	cmp	r0, #0	; 0x0
33d13eb4:	0a00001e 	beq	33d13f34 <do_nand+0x1f8>
33d13eb8:	e1a00004 	mov	r0, r4
33d13ebc:	e59f1a70 	ldr	r1, [pc, #2672]	; 33d14934 <do_nand+0xbf8>
33d13ec0:	e3a02005 	mov	r2, #5	; 0x5
33d13ec4:	eb001873 	bl	33d1a098 <strncmp>
33d13ec8:	e3500000 	cmp	r0, #0	; 0x0
33d13ecc:	0a000018 	beq	33d13f34 <do_nand+0x1f8>
33d13ed0:	e1a00004 	mov	r0, r4
33d13ed4:	e59f1a5c 	ldr	r1, [pc, #2652]	; 33d14938 <do_nand+0xbfc>
33d13ed8:	eb001862 	bl	33d1a068 <strcmp>
33d13edc:	e3500000 	cmp	r0, #0	; 0x0
33d13ee0:	0a000013 	beq	33d13f34 <do_nand+0x1f8>
33d13ee4:	e1a00004 	mov	r0, r4
33d13ee8:	e59f1a4c 	ldr	r1, [pc, #2636]	; 33d1493c <do_nand+0xc00>
33d13eec:	eb00185d 	bl	33d1a068 <strcmp>
33d13ef0:	e3500000 	cmp	r0, #0	; 0x0
33d13ef4:	0a00000e 	beq	33d13f34 <do_nand+0x1f8>
33d13ef8:	e1a00004 	mov	r0, r4
33d13efc:	e59f1a3c 	ldr	r1, [pc, #2620]	; 33d14940 <do_nand+0xc04>
33d13f00:	eb001858 	bl	33d1a068 <strcmp>
33d13f04:	e3500000 	cmp	r0, #0	; 0x0
33d13f08:	0a000009 	beq	33d13f34 <do_nand+0x1f8>
33d13f0c:	e1a00004 	mov	r0, r4
33d13f10:	e59f1a2c 	ldr	r1, [pc, #2604]	; 33d14944 <do_nand+0xc08>
33d13f14:	eb001853 	bl	33d1a068 <strcmp>
33d13f18:	e3500000 	cmp	r0, #0	; 0x0
33d13f1c:	0a000004 	beq	33d13f34 <do_nand+0x1f8>
33d13f20:	e1a00004 	mov	r0, r4
33d13f24:	e59f1a1c 	ldr	r1, [pc, #2588]	; 33d14948 <do_nand+0xc0c>
33d13f28:	eb00184e 	bl	33d1a068 <strcmp>
33d13f2c:	e3500000 	cmp	r0, #0	; 0x0
33d13f30:	1a000269 	bne	33d148dc <do_nand+0xba0>
        strcmp(cmd, "biterr") != 0 &&
        strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
        goto usage;

    /* the following commands operate on the current device */
    if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
33d13f34:	e59fb9d0 	ldr	fp, [pc, #2512]	; 33d1490c <do_nand+0xbd0>
33d13f38:	e59ba000 	ldr	sl, [fp]
33d13f3c:	e35a0000 	cmp	sl, #0	; 0x0
33d13f40:	1a000003 	bne	33d13f54 <do_nand+0x218>
33d13f44:	e59f29b4 	ldr	r2, [pc, #2484]	; 33d14900 <do_nand+0xbc4>
33d13f48:	e5923024 	ldr	r3, [r2, #36]
33d13f4c:	e3530000 	cmp	r3, #0	; 0x0
33d13f50:	1a000002 	bne	33d13f60 <do_nand+0x224>
        !nand_info[nand_curr_device].name) {
        puts("\nno devices available\n");
33d13f54:	e59f09b4 	ldr	r0, [pc, #2484]	; 33d14910 <do_nand+0xbd4>
33d13f58:	eb000c13 	bl	33d16fac <puts>
33d13f5c:	ea000262 	b	33d148ec <do_nand+0xbb0>
        return 1;
    }
    nand = &nand_info[nand_curr_device];

    if (strcmp(cmd, "bad") == 0) {
33d13f60:	e1a00004 	mov	r0, r4
33d13f64:	e59f19b8 	ldr	r1, [pc, #2488]	; 33d14924 <do_nand+0xbe8>
33d13f68:	eb00183e 	bl	33d1a068 <strcmp>
33d13f6c:	e2505000 	subs	r5, r0, #0	; 0x0
    if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
        !nand_info[nand_curr_device].name) {
        puts("\nno devices available\n");
        return 1;
    }
    nand = &nand_info[nand_curr_device];
33d13f70:	e59f7988 	ldr	r7, [pc, #2440]	; 33d14900 <do_nand+0xbc4>

    if (strcmp(cmd, "bad") == 0) {
33d13f74:	1a000017 	bne	33d13fd8 <do_nand+0x29c>
        printf("\nDevice %d bad blocks:\n", nand_curr_device);
33d13f78:	e59b1000 	ldr	r1, [fp]
33d13f7c:	e59f09c8 	ldr	r0, [pc, #2504]	; 33d1494c <do_nand+0xc10>
33d13f80:	eb000c10 	bl	33d16fc8 <printf>
        for (off = 0; off < nand->size; off += nand->erasesize)
33d13f84:	e5973008 	ldr	r3, [r7, #8]
33d13f88:	e58d5040 	str	r5, [sp, #64]
33d13f8c:	e1a01005 	mov	r1, r5
33d13f90:	e1550003 	cmp	r5, r3
33d13f94:	2a000235 	bcs	33d14870 <do_nand+0xb34>
	return info->write(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_block_isbad(nand_info_t *info, ulong ofs)
{
	return info->block_isbad(info, ofs);
33d13f98:	e3a02000 	mov	r2, #0	; 0x0
33d13f9c:	e59f095c 	ldr	r0, [pc, #2396]	; 33d14900 <do_nand+0xbc4>
33d13fa0:	e1a0e00f 	mov	lr, pc
33d13fa4:	e597f134 	ldr	pc, [r7, #308]
{
	return info->write(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_block_isbad(nand_info_t *info, ulong ofs)
{
33d13fa8:	e3500000 	cmp	r0, #0	; 0x0
            if (nand_block_isbad(nand, off))
                printf("  %08x\n", off);
33d13fac:	e59f099c 	ldr	r0, [pc, #2460]	; 33d14950 <do_nand+0xc14>
33d13fb0:	159d1040 	ldrne	r1, [sp, #64]
33d13fb4:	1b000c03 	blne	33d16fc8 <printf>
    }
    nand = &nand_info[nand_curr_device];

    if (strcmp(cmd, "bad") == 0) {
        printf("\nDevice %d bad blocks:\n", nand_curr_device);
        for (off = 0; off < nand->size; off += nand->erasesize)
33d13fb8:	e597300c 	ldr	r3, [r7, #12]
33d13fbc:	e59d2040 	ldr	r2, [sp, #64]
33d13fc0:	e0822003 	add	r2, r2, r3
33d13fc4:	e5973008 	ldr	r3, [r7, #8]
33d13fc8:	e1a01002 	mov	r1, r2
33d13fcc:	e1520003 	cmp	r2, r3
33d13fd0:	e58d2040 	str	r2, [sp, #64]
33d13fd4:	eaffffee 	b	33d13f94 <do_nand+0x258>
    /*
     * Syntax is:
     *   0    1     2       3    4
     *   nand erase [clean] [off size]
     */
    if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
33d13fd8:	e1a00004 	mov	r0, r4
33d13fdc:	e59f1944 	ldr	r1, [pc, #2372]	; 33d14928 <do_nand+0xbec>
33d13fe0:	eb001820 	bl	33d1a068 <strcmp>
33d13fe4:	e3500000 	cmp	r0, #0	; 0x0
33d13fe8:	0a000004 	beq	33d14000 <do_nand+0x2c4>
33d13fec:	e1a00004 	mov	r0, r4
33d13ff0:	e59f1940 	ldr	r1, [pc, #2368]	; 33d14938 <do_nand+0xbfc>
33d13ff4:	eb00181b 	bl	33d1a068 <strcmp>
33d13ff8:	e3500000 	cmp	r0, #0	; 0x0
33d13ffc:	1a000048 	bne	33d14124 <do_nand+0x3e8>
        nand_erase_options_t opts;
        /* "clean" at index 2 means request to write cleanmarker */
        int clean = argc > 2 && !strcmp("clean", argv[2]);
33d14000:	e3590002 	cmp	r9, #2	; 0x2
33d14004:	e1a0700a 	mov	r7, sl
33d14008:	da000006 	ble	33d14028 <do_nand+0x2ec>
33d1400c:	e59f0940 	ldr	r0, [pc, #2368]	; 33d14954 <do_nand+0xc18>
33d14010:	e5961008 	ldr	r1, [r6, #8]
33d14014:	eb001813 	bl	33d1a068 <strcmp>
33d14018:	e3500000 	cmp	r0, #0	; 0x0
33d1401c:	03a07001 	moveq	r7, #1	; 0x1
        int o = clean ? 3 : 2;
33d14020:	03a05003 	moveq	r5, #3	; 0x3
     *   nand erase [clean] [off size]
     */
    if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
        nand_erase_options_t opts;
        /* "clean" at index 2 means request to write cleanmarker */
        int clean = argc > 2 && !strcmp("clean", argv[2]);
33d14024:	0a000000 	beq	33d1402c <do_nand+0x2f0>
        int o = clean ? 3 : 2;
33d14028:	e3a05002 	mov	r5, #2	; 0x2
        int scrub = !strcmp(cmd, "scrub");
33d1402c:	e1a00004 	mov	r0, r4
33d14030:	e59f1900 	ldr	r1, [pc, #2304]	; 33d14938 <do_nand+0xbfc>
33d14034:	eb00180b 	bl	33d1a068 <strcmp>

        printf("\nNAND %s: ", scrub ? "scrub" : "erase");
33d14038:	e59f38f8 	ldr	r3, [pc, #2296]	; 33d14938 <do_nand+0xbfc>
33d1403c:	e3500000 	cmp	r0, #0	; 0x0
33d14040:	e59f18e0 	ldr	r1, [pc, #2272]	; 33d14928 <do_nand+0xbec>
33d14044:	01a01003 	moveq	r1, r3
    if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
        nand_erase_options_t opts;
        /* "clean" at index 2 means request to write cleanmarker */
        int clean = argc > 2 && !strcmp("clean", argv[2]);
        int o = clean ? 3 : 2;
        int scrub = !strcmp(cmd, "scrub");
33d14048:	e2704001 	rsbs	r4, r0, #1	; 0x1
33d1404c:	33a04000 	movcc	r4, #0	; 0x0

        printf("\nNAND %s: ", scrub ? "scrub" : "erase");
33d14050:	e59f0900 	ldr	r0, [pc, #2304]	; 33d14958 <do_nand+0xc1c>
33d14054:	eb000bdb 	bl	33d16fc8 <printf>
        /* skip first two or three arguments, look for offset and size */
        if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
33d14058:	e28dc03c 	add	ip, sp, #60	; 0x3c
33d1405c:	e0861105 	add	r1, r6, r5, lsl #2
33d14060:	e0650009 	rsb	r0, r5, r9
33d14064:	e59f2894 	ldr	r2, [pc, #2196]	; 33d14900 <do_nand+0xbc4>
33d14068:	e28d3040 	add	r3, sp, #64	; 0x40
33d1406c:	e58dc000 	str	ip, [sp]
33d14070:	ebfffea2 	bl	33d13b00 <arg_off_size>
33d14074:	e3500000 	cmp	r0, #0	; 0x0
33d14078:	1a00021b 	bne	33d148ec <do_nand+0xbb0>
            return 1;

        memset(&opts, 0, sizeof(opts));
33d1407c:	e28d5094 	add	r5, sp, #148	; 0x94
33d14080:	e1a01000 	mov	r1, r0
33d14084:	e3a02014 	mov	r2, #20	; 0x14
33d14088:	e1a00005 	mov	r0, r5
33d1408c:	eb0018c0 	bl	33d1a394 <memset>
        opts.offset = off;
33d14090:	e59d3040 	ldr	r3, [sp, #64]
33d14094:	e58d3098 	str	r3, [sp, #152]
        opts.length = size;
33d14098:	e59d303c 	ldr	r3, [sp, #60]
33d1409c:	e58d3094 	str	r3, [sp, #148]
        opts.jffs2  = clean;
        opts.quiet  = quiet;
33d140a0:	e59d3034 	ldr	r3, [sp, #52]

        if (scrub) {
33d140a4:	e3540000 	cmp	r4, #0	; 0x0
            return 1;

        memset(&opts, 0, sizeof(opts));
        opts.offset = off;
        opts.length = size;
        opts.jffs2  = clean;
33d140a8:	e58d70a0 	str	r7, [sp, #160]
        opts.quiet  = quiet;
33d140ac:	e58d309c 	str	r3, [sp, #156]

        if (scrub) {
33d140b0:	0a000010 	beq	33d140f8 <do_nand+0x3bc>
            puts("Warning: "
33d140b4:	e59f08a0 	ldr	r0, [pc, #2208]	; 33d1495c <do_nand+0xc20>
33d140b8:	eb000bbb 	bl	33d16fac <puts>
                 "if you\n"
                 "         "
                 "are sure of what you are doing!\n"
                 "\nReally scrub this NAND flash? <y/N> : ");

            if (getc() == 'y' )
33d140bc:	eb000ba4 	bl	33d16f54 <getc>
33d140c0:	e3500079 	cmp	r0, #121	; 0x79
33d140c4:	1a000007 	bne	33d140e8 <do_nand+0x3ac>
            {
            	printf("y");
33d140c8:	e59f0890 	ldr	r0, [pc, #2192]	; 33d14960 <do_nand+0xc24>
33d140cc:	eb000bbd 	bl	33d16fc8 <printf>
            	getc() == '\r';
33d140d0:	eb000b9f 	bl	33d16f54 <getc>
            	printf("\n");
33d140d4:	e59f0888 	ldr	r0, [pc, #2184]	; 33d14964 <do_nand+0xc28>
33d140d8:	eb000bba 	bl	33d16fc8 <printf>
                opts.scrub = 1;
33d140dc:	e3a03001 	mov	r3, #1	; 0x1
33d140e0:	e58d30a4 	str	r3, [sp, #164]
33d140e4:	ea000003 	b	33d140f8 <do_nand+0x3bc>
            } else {
                puts("scrub aborted\n");
33d140e8:	e59f0878 	ldr	r0, [pc, #2168]	; 33d14968 <do_nand+0xc2c>
33d140ec:	eb000bae 	bl	33d16fac <puts>
                return -1;
33d140f0:	e3e00000 	mvn	r0, #0	; 0x0
33d140f4:	ea0001fd 	b	33d148f0 <do_nand+0xbb4>
            }
        }
        ret = nand_erase_opts(nand, &opts);
33d140f8:	e1a01005 	mov	r1, r5
33d140fc:	e59f07fc 	ldr	r0, [pc, #2044]	; 33d14900 <do_nand+0xbc4>
33d14100:	eb003a35 	bl	33d229dc <nand_erase_opts>
        printf("%s\n", ret ? "ERROR" : "OK");
33d14104:	e59f3860 	ldr	r3, [pc, #2144]	; 33d1496c <do_nand+0xc30>
33d14108:	e3500000 	cmp	r0, #0	; 0x0
33d1410c:	e1a04000 	mov	r4, r0
33d14110:	e59f1858 	ldr	r1, [pc, #2136]	; 33d14970 <do_nand+0xc34>
33d14114:	e59f0858 	ldr	r0, [pc, #2136]	; 33d14974 <do_nand+0xc38>
33d14118:	11a01003 	movne	r1, r3
33d1411c:	eb000ba9 	bl	33d16fc8 <printf>
33d14120:	ea00015b 	b	33d14694 <do_nand+0x958>

        return ret == 0 ? 0 : 1;
    }

    if (strncmp(cmd, "dump", 4) == 0) {
33d14124:	e1a00004 	mov	r0, r4
33d14128:	e59f17fc 	ldr	r1, [pc, #2044]	; 33d1492c <do_nand+0xbf0>
33d1412c:	e3a02004 	mov	r2, #4	; 0x4
33d14130:	eb0017d8 	bl	33d1a098 <strncmp>
33d14134:	e2505000 	subs	r5, r0, #0	; 0x0
33d14138:	1a00007d 	bne	33d14334 <do_nand+0x5f8>
        if (argc < 3)
33d1413c:	e3590002 	cmp	r9, #2	; 0x2
33d14140:	da0001e5 	ble	33d148dc <do_nand+0xba0>
            goto usage;

        s = strchr(cmd, '.');
33d14144:	e1a00004 	mov	r0, r4
33d14148:	e3a0102e 	mov	r1, #46	; 0x2e
33d1414c:	eb0017e3 	bl	33d1a0e0 <strchr>
        off = (int)simple_strtoul(argv[2], NULL, 16);
33d14150:	e1a01005 	mov	r1, r5

    if (strncmp(cmd, "dump", 4) == 0) {
        if (argc < 3)
            goto usage;

        s = strchr(cmd, '.');
33d14154:	e1a04000 	mov	r4, r0
        off = (int)simple_strtoul(argv[2], NULL, 16);
33d14158:	e3a02010 	mov	r2, #16	; 0x10
33d1415c:	e5960008 	ldr	r0, [r6, #8]
33d14160:	eb0018fd 	bl	33d1a55c <simple_strtoul>

        if (s != NULL && strcmp(s, ".oob") == 0)
33d14164:	e3540000 	cmp	r4, #0	; 0x0
    if (strncmp(cmd, "dump", 4) == 0) {
        if (argc < 3)
            goto usage;

        s = strchr(cmd, '.');
        off = (int)simple_strtoul(argv[2], NULL, 16);
33d14168:	e58d0040 	str	r0, [sp, #64]

        if (s != NULL && strcmp(s, ".oob") == 0)
33d1416c:	0a000004 	beq	33d14184 <do_nand+0x448>
33d14170:	e1a00004 	mov	r0, r4
33d14174:	e59f17fc 	ldr	r1, [pc, #2044]	; 33d14978 <do_nand+0xc3c>
33d14178:	eb0017ba 	bl	33d1a068 <strcmp>
33d1417c:	e3500000 	cmp	r0, #0	; 0x0
33d14180:	0a000067 	beq	33d14324 <do_nand+0x5e8>
static int nand_dump(nand_info_t *nand, ulong off)
{
    int i;
    u_char *buf, *p;

    buf = malloc(nand->oobblock + nand->oobsize);
33d14184:	e2872010 	add	r2, r7, #16	; 0x10
33d14188:	e8920005 	ldm	r2, {r0, r2}
33d1418c:	e0800002 	add	r0, r0, r2
{
    return 0;
}

static int nand_dump(nand_info_t *nand, ulong off)
{
33d14190:	e59d4040 	ldr	r4, [sp, #64]
    int i;
    u_char *buf, *p;

    buf = malloc(nand->oobblock + nand->oobsize);
33d14194:	eb000d33 	bl	33d17668 <malloc>
    if (!buf) {
33d14198:	e2506000 	subs	r6, r0, #0	; 0x0
{
    return 0;
}

static int nand_dump(nand_info_t *nand, ulong off)
{
33d1419c:	e59fa75c 	ldr	sl, [pc, #1884]	; 33d14900 <do_nand+0xbc4>
    int i;
    u_char *buf, *p;

    buf = malloc(nand->oobblock + nand->oobsize);
    if (!buf) {
33d141a0:	1a000002 	bne	33d141b0 <do_nand+0x474>
        puts("No memory for page buffer\n");
33d141a4:	e59f07d0 	ldr	r0, [pc, #2000]	; 33d1497c <do_nand+0xc40>
33d141a8:	eb000b7f 	bl	33d16fac <puts>
33d141ac:	ea000011 	b	33d141f8 <do_nand+0x4bc>
        return 1;
    }
    off &= ~(nand->oobblock - 1);
33d141b0:	e597c010 	ldr	ip, [r7, #16]
33d141b4:	e26c3000 	rsb	r3, ip, #0	; 0x0
    i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
33d141b8:	e597e014 	ldr	lr, [r7, #20]
    buf = malloc(nand->oobblock + nand->oobsize);
    if (!buf) {
        puts("No memory for page buffer\n");
        return 1;
    }
    off &= ~(nand->oobblock - 1);
33d141bc:	e0044003 	and	r4, r4, r3
    i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
33d141c0:	e1a0000a 	mov	r0, sl
33d141c4:	e1a01006 	mov	r1, r6
33d141c8:	e1a02004 	mov	r2, r4
33d141cc:	e3a03000 	mov	r3, #0	; 0x0
33d141d0:	e88d5000 	stm	sp, {ip, lr}
33d141d4:	ebffc681 	bl	33d05be0 <nand_read_raw>
    if (i < 0) {
33d141d8:	e2505000 	subs	r5, r0, #0	; 0x0
33d141dc:	aa000007 	bge	33d14200 <do_nand+0x4c4>
        printf("Error (%d) reading page %08x\n", i, off);
33d141e0:	e59f0798 	ldr	r0, [pc, #1944]	; 33d14980 <do_nand+0xc44>
33d141e4:	e1a01005 	mov	r1, r5
33d141e8:	e1a02004 	mov	r2, r4
33d141ec:	eb000b75 	bl	33d16fc8 <printf>
        free(buf);
33d141f0:	e1a00006 	mov	r0, r6
33d141f4:	eb000c96 	bl	33d17454 <free>
33d141f8:	e3a00001 	mov	r0, #1	; 0x1
33d141fc:	ea000048 	b	33d14324 <do_nand+0x5e8>
        return 1;
    }
    printf("Page %08x dump:\n", off);
33d14200:	e1a01004 	mov	r1, r4
33d14204:	e59f0778 	ldr	r0, [pc, #1912]	; 33d14984 <do_nand+0xc48>
33d14208:	eb000b6e 	bl	33d16fc8 <printf>
    i = nand->oobblock >> 4; p = buf;
33d1420c:	e5973010 	ldr	r3, [r7, #16]
33d14210:	e1a05223 	lsr	r5, r3, #4
    while (i--) {
        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
            "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
            p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
        p += 16;
33d14214:	e2455001 	sub	r5, r5, #1	; 0x1
33d14218:	e3750001 	cmn	r5, #1	; 0x1
        printf("Error (%d) reading page %08x\n", i, off);
        free(buf);
        return 1;
    }
    printf("Page %08x dump:\n", off);
    i = nand->oobblock >> 4; p = buf;
33d1421c:	e1a04006 	mov	r4, r6
    while (i--) {
        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
            "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
            p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
        p += 16;
33d14220:	0a000022 	beq	33d142b0 <do_nand+0x574>
        return 1;
    }
    printf("Page %08x dump:\n", off);
    i = nand->oobblock >> 4; p = buf;
    while (i--) {
        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
33d14224:	e5d40003 	ldrb	r0, [r4, #3]
33d14228:	e5d41000 	ldrb	r1, [r4]
33d1422c:	e5d42001 	ldrb	r2, [r4, #1]
33d14230:	e5d43002 	ldrb	r3, [r4, #2]
33d14234:	e58d0000 	str	r0, [sp]
33d14238:	e5d40004 	ldrb	r0, [r4, #4]
33d1423c:	e58d0004 	str	r0, [sp, #4]
33d14240:	e5d40005 	ldrb	r0, [r4, #5]
33d14244:	e58d0008 	str	r0, [sp, #8]
33d14248:	e5d40006 	ldrb	r0, [r4, #6]
33d1424c:	e58d000c 	str	r0, [sp, #12]
33d14250:	e5d40007 	ldrb	r0, [r4, #7]
33d14254:	e58d0010 	str	r0, [sp, #16]
33d14258:	e5d40008 	ldrb	r0, [r4, #8]
33d1425c:	e58d0014 	str	r0, [sp, #20]
33d14260:	e5d40009 	ldrb	r0, [r4, #9]
33d14264:	e58d0018 	str	r0, [sp, #24]
33d14268:	e5d4000a 	ldrb	r0, [r4, #10]
33d1426c:	e58d001c 	str	r0, [sp, #28]
33d14270:	e5d4000b 	ldrb	r0, [r4, #11]
33d14274:	e58d0020 	str	r0, [sp, #32]
33d14278:	e5d4000c 	ldrb	r0, [r4, #12]
33d1427c:	e58d0024 	str	r0, [sp, #36]
33d14280:	e5d4000d 	ldrb	r0, [r4, #13]
33d14284:	e58d0028 	str	r0, [sp, #40]
33d14288:	e5d4000e 	ldrb	r0, [r4, #14]
33d1428c:	e58d002c 	str	r0, [sp, #44]
33d14290:	e5d4c00f 	ldrb	ip, [r4, #15]
33d14294:	e59f06ec 	ldr	r0, [pc, #1772]	; 33d14988 <do_nand+0xc4c>
33d14298:	e58dc030 	str	ip, [sp, #48]
33d1429c:	eb000b49 	bl	33d16fc8 <printf>
            "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
            p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
        p += 16;
33d142a0:	e2455001 	sub	r5, r5, #1	; 0x1
33d142a4:	e3750001 	cmn	r5, #1	; 0x1
33d142a8:	e2844010 	add	r4, r4, #16	; 0x10
33d142ac:	eaffffdb 	b	33d14220 <do_nand+0x4e4>
    }
    puts("OOB:\n");
33d142b0:	e59f06d4 	ldr	r0, [pc, #1748]	; 33d1498c <do_nand+0xc50>
33d142b4:	eb000b3c 	bl	33d16fac <puts>
    i = nand->oobsize >> 3;
33d142b8:	e59a3014 	ldr	r3, [sl, #20]
33d142bc:	e1a051a3 	lsr	r5, r3, #3
    while (i--) {
        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
        p += 8;
33d142c0:	e2455001 	sub	r5, r5, #1	; 0x1
33d142c4:	e3750001 	cmn	r5, #1	; 0x1
33d142c8:	0a000012 	beq	33d14318 <do_nand+0x5dc>
        p += 16;
    }
    puts("OOB:\n");
    i = nand->oobsize >> 3;
    while (i--) {
        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
33d142cc:	e5d40003 	ldrb	r0, [r4, #3]
33d142d0:	e5d41000 	ldrb	r1, [r4]
33d142d4:	e5d42001 	ldrb	r2, [r4, #1]
33d142d8:	e5d43002 	ldrb	r3, [r4, #2]
33d142dc:	e58d0000 	str	r0, [sp]
33d142e0:	e5d40004 	ldrb	r0, [r4, #4]
33d142e4:	e58d0004 	str	r0, [sp, #4]
33d142e8:	e5d40005 	ldrb	r0, [r4, #5]
33d142ec:	e58d0008 	str	r0, [sp, #8]
33d142f0:	e5d40006 	ldrb	r0, [r4, #6]
33d142f4:	e58d000c 	str	r0, [sp, #12]
33d142f8:	e5d4c007 	ldrb	ip, [r4, #7]
33d142fc:	e59f068c 	ldr	r0, [pc, #1676]	; 33d14990 <do_nand+0xc54>
33d14300:	e58dc010 	str	ip, [sp, #16]
33d14304:	eb000b2f 	bl	33d16fc8 <printf>
            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
        p += 8;
33d14308:	e2455001 	sub	r5, r5, #1	; 0x1
33d1430c:	e3750001 	cmn	r5, #1	; 0x1
33d14310:	e2844008 	add	r4, r4, #8	; 0x8
33d14314:	eaffffeb 	b	33d142c8 <do_nand+0x58c>
    }
    free(buf);
33d14318:	e1a00006 	mov	r0, r6
33d1431c:	eb000c4c 	bl	33d17454 <free>
33d14320:	e3a00000 	mov	r0, #0	; 0x0
{
    return 0;
}

static int nand_dump(nand_info_t *nand, ulong off)
{
33d14324:	e1a04000 	mov	r4, r0
        if (s != NULL && strcmp(s, ".oob") == 0)
            ret = nand_dump_oob(nand, off);
        else
            ret = nand_dump(nand, off);

        return ret == 0 ? 1 : 0;
33d14328:	e2700001 	rsbs	r0, r0, #1	; 0x1
33d1432c:	33a00000 	movcc	r0, #0	; 0x0
33d14330:	ea00016e 	b	33d148f0 <do_nand+0xbb4>

    }

    /* read write */
    if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
33d14334:	e1a00004 	mov	r0, r4
33d14338:	e59f15f0 	ldr	r1, [pc, #1520]	; 33d14930 <do_nand+0xbf4>
33d1433c:	e3a02004 	mov	r2, #4	; 0x4
33d14340:	eb001754 	bl	33d1a098 <strncmp>
33d14344:	e3500000 	cmp	r0, #0	; 0x0
33d14348:	0a000005 	beq	33d14364 <do_nand+0x628>
33d1434c:	e1a00004 	mov	r0, r4
33d14350:	e59f15dc 	ldr	r1, [pc, #1500]	; 33d14934 <do_nand+0xbf8>
33d14354:	e3a02005 	mov	r2, #5	; 0x5
33d14358:	eb00174e 	bl	33d1a098 <strncmp>
33d1435c:	e3500000 	cmp	r0, #0	; 0x0
33d14360:	1a0000ce 	bne	33d146a0 <do_nand+0x964>
        int read;

        if (argc < 4)
33d14364:	e3590003 	cmp	r9, #3	; 0x3
33d14368:	da00015b 	ble	33d148dc <do_nand+0xba0>
            goto usage;

        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
33d1436c:	e1a0100a 	mov	r1, sl
33d14370:	e3a02010 	mov	r2, #16	; 0x10
33d14374:	e5960008 	ldr	r0, [r6, #8]
33d14378:	eb001877 	bl	33d1a55c <simple_strtoul>

        read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
33d1437c:	e3a02004 	mov	r2, #4	; 0x4
33d14380:	e59f15a8 	ldr	r1, [pc, #1448]	; 33d14930 <do_nand+0xbf4>
        int read;

        if (argc < 4)
            goto usage;

        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
33d14384:	e1a05000 	mov	r5, r0

        read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
33d14388:	e1a00004 	mov	r0, r4
33d1438c:	eb001741 	bl	33d1a098 <strncmp>
        printf("\nNAND %s: ", read ? "read" : "write");
33d14390:	e59f3598 	ldr	r3, [pc, #1432]	; 33d14930 <do_nand+0xbf4>
33d14394:	e3500000 	cmp	r0, #0	; 0x0
33d14398:	e59f1594 	ldr	r1, [pc, #1428]	; 33d14934 <do_nand+0xbf8>
33d1439c:	01a01003 	moveq	r1, r3
        if (argc < 4)
            goto usage;

        addr = (ulong)simple_strtoul(argv[2], NULL, 16);

        read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
33d143a0:	e270a001 	rsbs	sl, r0, #1	; 0x1
33d143a4:	33a0a000 	movcc	sl, #0	; 0x0
        printf("\nNAND %s: ", read ? "read" : "write");
33d143a8:	e59f05a8 	ldr	r0, [pc, #1448]	; 33d14958 <do_nand+0xc1c>
33d143ac:	eb000b05 	bl	33d16fc8 <printf>
        if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
33d143b0:	e2490003 	sub	r0, r9, #3	; 0x3
33d143b4:	e286100c 	add	r1, r6, #12	; 0xc
33d143b8:	e28d903c 	add	r9, sp, #60	; 0x3c
33d143bc:	e1a02007 	mov	r2, r7
33d143c0:	e28d3040 	add	r3, sp, #64	; 0x40
33d143c4:	e58d9000 	str	r9, [sp]
33d143c8:	ebfffdcc 	bl	33d13b00 <arg_off_size>
33d143cc:	e3500000 	cmp	r0, #0	; 0x0
33d143d0:	1a000145 	bne	33d148ec <do_nand+0xbb0>
            return 1;

        s = strchr(cmd, '.');
33d143d4:	e1a00004 	mov	r0, r4
33d143d8:	e3a0102e 	mov	r1, #46	; 0x2e
33d143dc:	eb00173f 	bl	33d1a0e0 <strchr>
        if (s != NULL &&
33d143e0:	e2504000 	subs	r4, r0, #0	; 0x0
33d143e4:	0a00008d 	beq	33d14620 <do_nand+0x8e4>
33d143e8:	e59f15a4 	ldr	r1, [pc, #1444]	; 33d14994 <do_nand+0xc58>
33d143ec:	eb00171d 	bl	33d1a068 <strcmp>
33d143f0:	e3500000 	cmp	r0, #0	; 0x0
33d143f4:	0a000009 	beq	33d14420 <do_nand+0x6e4>
33d143f8:	e1a00004 	mov	r0, r4
33d143fc:	e59f1594 	ldr	r1, [pc, #1428]	; 33d14998 <do_nand+0xc5c>
33d14400:	eb001718 	bl	33d1a068 <strcmp>
33d14404:	e3500000 	cmp	r0, #0	; 0x0
33d14408:	0a000004 	beq	33d14420 <do_nand+0x6e4>
33d1440c:	e1a00004 	mov	r0, r4
33d14410:	e59f1584 	ldr	r1, [pc, #1412]	; 33d1499c <do_nand+0xc60>
33d14414:	eb001713 	bl	33d1a068 <strcmp>
33d14418:	e3500000 	cmp	r0, #0	; 0x0
33d1441c:	1a000022 	bne	33d144ac <do_nand+0x770>
            (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
            if (read) {
33d14420:	e35a0000 	cmp	sl, #0	; 0x0
33d14424:	0a00000e 	beq	33d14464 <do_nand+0x728>
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
33d14428:	e28d4078 	add	r4, sp, #120	; 0x78
33d1442c:	e3a01000 	mov	r1, #0	; 0x0
33d14430:	e3a0201c 	mov	r2, #28	; 0x1c
33d14434:	e1a00004 	mov	r0, r4
33d14438:	eb0017d5 	bl	33d1a394 <memset>
                opts.buffer = (u_char*) addr;
                opts.length = size;
33d1443c:	e59d303c 	ldr	r3, [sp, #60]
33d14440:	e58d307c 	str	r3, [sp, #124]
                opts.offset = off;
33d14444:	e59d3040 	ldr	r3, [sp, #64]
                opts.quiet      = quiet;
                ret = nand_read_opts(nand, &opts);
33d14448:	e59f04b0 	ldr	r0, [pc, #1200]	; 33d14900 <do_nand+0xbc4>
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
33d1444c:	e58d3080 	str	r3, [sp, #128]
                opts.quiet      = quiet;
33d14450:	e59d3034 	ldr	r3, [sp, #52]
                ret = nand_read_opts(nand, &opts);
33d14454:	e1a01004 	mov	r1, r4
            (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
            if (read) {
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
33d14458:	e58d5078 	str	r5, [sp, #120]
                opts.length = size;
                opts.offset = off;
                opts.quiet      = quiet;
33d1445c:	e58d3084 	str	r3, [sp, #132]
33d14460:	ea000028 	b	33d14508 <do_nand+0x7cc>
                ret = nand_read_opts(nand, &opts);
            } else {
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
33d14464:	e28d4044 	add	r4, sp, #68	; 0x44
33d14468:	e1a0100a 	mov	r1, sl
33d1446c:	e3a02034 	mov	r2, #52	; 0x34
33d14470:	e1a00004 	mov	r0, r4
33d14474:	eb0017c6 	bl	33d1a394 <memset>
                opts.buffer = (u_char*) addr;
                opts.length = size;
33d14478:	e59d303c 	ldr	r3, [sp, #60]
33d1447c:	e58d3048 	str	r3, [sp, #72]
                opts.offset = off;
33d14480:	e59d3040 	ldr	r3, [sp, #64]
                /* opts.forcejffs2 = 1; */
                opts.pad    = 1;
                opts.blockalign = 1;
                opts.quiet      = quiet;
                ret = nand_write_opts(nand, &opts);
33d14484:	e59f0474 	ldr	r0, [pc, #1140]	; 33d14900 <do_nand+0xbc4>
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
33d14488:	e58d304c 	str	r3, [sp, #76]
                /* opts.forcejffs2 = 1; */
                opts.pad    = 1;
                opts.blockalign = 1;
                opts.quiet      = quiet;
33d1448c:	e59d3034 	ldr	r3, [sp, #52]
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                /* opts.forcejffs2 = 1; */
                opts.pad    = 1;
33d14490:	e3a02001 	mov	r2, #1	; 0x1
                opts.blockalign = 1;
                opts.quiet      = quiet;
                ret = nand_write_opts(nand, &opts);
33d14494:	e1a01004 	mov	r1, r4
                ret = nand_read_opts(nand, &opts);
            } else {
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
33d14498:	e58d5044 	str	r5, [sp, #68]
                opts.length = size;
                opts.offset = off;
                /* opts.forcejffs2 = 1; */
                opts.pad    = 1;
                opts.blockalign = 1;
33d1449c:	e58d206c 	str	r2, [sp, #108]
                opts.quiet      = quiet;
33d144a0:	e58d3050 	str	r3, [sp, #80]
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                /* opts.forcejffs2 = 1; */
                opts.pad    = 1;
33d144a4:	e58d2068 	str	r2, [sp, #104]
33d144a8:	ea00002b 	b	33d1455c <do_nand+0x820>
                opts.blockalign = 1;
                opts.quiet      = quiet;
                ret = nand_write_opts(nand, &opts);
            }
        }else if (  s != NULL && !strcmp(s, ".yaffs")){
33d144ac:	e1a00004 	mov	r0, r4
33d144b0:	e59f14e8 	ldr	r1, [pc, #1256]	; 33d149a0 <do_nand+0xc64>
33d144b4:	eb0016eb 	bl	33d1a068 <strcmp>
33d144b8:	e3500000 	cmp	r0, #0	; 0x0
33d144bc:	1a000028 	bne	33d14564 <do_nand+0x828>
            if (read) {
33d144c0:	e35a0000 	cmp	sl, #0	; 0x0
33d144c4:	0a000011 	beq	33d14510 <do_nand+0x7d4>
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
33d144c8:	e28d4044 	add	r4, sp, #68	; 0x44
33d144cc:	e1a01000 	mov	r1, r0
33d144d0:	e3a0201c 	mov	r2, #28	; 0x1c
33d144d4:	e1a00004 	mov	r0, r4
33d144d8:	eb0017ad 	bl	33d1a394 <memset>
                opts.buffer = (u_char*) addr;
                opts.length = size;
33d144dc:	e59d303c 	ldr	r3, [sp, #60]
33d144e0:	e58d3048 	str	r3, [sp, #72]
                opts.offset = off;
33d144e4:	e59d3040 	ldr	r3, [sp, #64]
                opts.readoob = 1;
                opts.quiet      = quiet;
33d144e8:	e59d2034 	ldr	r2, [sp, #52]
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
33d144ec:	e58d304c 	str	r3, [sp, #76]
                opts.readoob = 1;
33d144f0:	e3a03001 	mov	r3, #1	; 0x1
        }else if (  s != NULL && !strcmp(s, ".yaffs")){
            if (read) {
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
33d144f4:	e58d5044 	str	r5, [sp, #68]
                opts.length = size;
                opts.offset = off;
                opts.readoob = 1;
33d144f8:	e58d3054 	str	r3, [sp, #84]
                opts.quiet      = quiet;
33d144fc:	e58d2050 	str	r2, [sp, #80]
                ret = nand_read_opts(nand, &opts);
33d14500:	e1a00007 	mov	r0, r7
33d14504:	e1a01004 	mov	r1, r4
33d14508:	eb003b62 	bl	33d23298 <nand_read_opts>
33d1450c:	ea000054 	b	33d14664 <do_nand+0x928>
            } else {
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
33d14510:	e28d4060 	add	r4, sp, #96	; 0x60
33d14514:	e1a0100a 	mov	r1, sl
33d14518:	e3a02034 	mov	r2, #52	; 0x34
33d1451c:	e1a00004 	mov	r0, r4
33d14520:	eb00179b 	bl	33d1a394 <memset>
                opts.buffer = (u_char*) addr;
                opts.length = size;
33d14524:	e59d303c 	ldr	r3, [sp, #60]
33d14528:	e58d3064 	str	r3, [sp, #100]
                opts.offset = off;
33d1452c:	e59d3040 	ldr	r3, [sp, #64]
33d14530:	e58d3068 	str	r3, [sp, #104]
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
                opts.writeoob = 1;
                opts.blockalign = 1;
                opts.quiet      = quiet;
33d14534:	e59d3034 	ldr	r3, [sp, #52]
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
33d14538:	e3a02001 	mov	r2, #1	; 0x1
                ret = nand_read_opts(nand, &opts);
            } else {
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
33d1453c:	e58d5060 	str	r5, [sp, #96]
                opts.offset = off;
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
                opts.writeoob = 1;
                opts.blockalign = 1;
                opts.quiet      = quiet;
33d14540:	e58d306c 	str	r3, [sp, #108]
                opts.skipfirstblk = 1;
33d14544:	e58d208c 	str	r2, [sp, #140]
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
33d14548:	e58d207c 	str	r2, [sp, #124]
                opts.writeoob = 1;
33d1454c:	e58d2080 	str	r2, [sp, #128]
                opts.blockalign = 1;
33d14550:	e58d2088 	str	r2, [sp, #136]
                opts.quiet      = quiet;
                opts.skipfirstblk = 1;
                ret = nand_write_opts(nand, &opts);
33d14554:	e1a00007 	mov	r0, r7
33d14558:	e1a01004 	mov	r1, r4
33d1455c:	eb003a02 	bl	33d22d6c <nand_write_opts>
33d14560:	ea00003f 	b	33d14664 <do_nand+0x928>
            }
        }else if (  s != NULL && !strcmp(s, ".raw")){
33d14564:	e1a00004 	mov	r0, r4
33d14568:	e59f1434 	ldr	r1, [pc, #1076]	; 33d149a4 <do_nand+0xc68>
33d1456c:	eb0016bd 	bl	33d1a068 <strcmp>
33d14570:	e2506000 	subs	r6, r0, #0	; 0x0
33d14574:	1a000029 	bne	33d14620 <do_nand+0x8e4>
            if (read) {
33d14578:	e35a0000 	cmp	sl, #0	; 0x0
33d1457c:	0a000012 	beq	33d145cc <do_nand+0x890>
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
33d14580:	e28d4044 	add	r4, sp, #68	; 0x44
33d14584:	e1a01006 	mov	r1, r6
33d14588:	e3a0201c 	mov	r2, #28	; 0x1c
33d1458c:	e1a00004 	mov	r0, r4
33d14590:	eb00177f 	bl	33d1a394 <memset>
                opts.buffer = (u_char*) addr;
                opts.length = size;
33d14594:	e59d303c 	ldr	r3, [sp, #60]
33d14598:	e58d3048 	str	r3, [sp, #72]
                opts.offset = off;
33d1459c:	e59d3040 	ldr	r3, [sp, #64]
33d145a0:	e58d304c 	str	r3, [sp, #76]
                opts.readoob = 0;
                opts.quiet      = quiet;
33d145a4:	e59d3034 	ldr	r3, [sp, #52]
                opts.noecc  = 1;
33d145a8:	e3a02001 	mov	r2, #1	; 0x1
                opts.nocheckbadblk = 1;
                ret = nand_read_opts(nand, &opts);
33d145ac:	e1a00007 	mov	r0, r7
33d145b0:	e1a01004 	mov	r1, r4
        }else if (  s != NULL && !strcmp(s, ".raw")){
            if (read) {
                /* read */
                nand_read_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
33d145b4:	e58d5044 	str	r5, [sp, #68]
                opts.length = size;
                opts.offset = off;
                opts.readoob = 0;
33d145b8:	e58d6054 	str	r6, [sp, #84]
                opts.quiet      = quiet;
33d145bc:	e58d3050 	str	r3, [sp, #80]
                opts.noecc  = 1;
                opts.nocheckbadblk = 1;
33d145c0:	e58d205c 	str	r2, [sp, #92]
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                opts.readoob = 0;
                opts.quiet      = quiet;
                opts.noecc  = 1;
33d145c4:	e58d2058 	str	r2, [sp, #88]
33d145c8:	eaffffce 	b	33d14508 <do_nand+0x7cc>
                opts.nocheckbadblk = 1;
                ret = nand_read_opts(nand, &opts);
            } else {
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
33d145cc:	e28d4060 	add	r4, sp, #96	; 0x60
33d145d0:	e1a0100a 	mov	r1, sl
33d145d4:	e3a02034 	mov	r2, #52	; 0x34
33d145d8:	e1a00004 	mov	r0, r4
33d145dc:	eb00176c 	bl	33d1a394 <memset>
                opts.buffer = (u_char*) addr;
                opts.length = size;
33d145e0:	e59d303c 	ldr	r3, [sp, #60]
33d145e4:	e58d3064 	str	r3, [sp, #100]
                opts.offset = off;
33d145e8:	e59d3040 	ldr	r3, [sp, #64]
33d145ec:	e58d3068 	str	r3, [sp, #104]
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
                opts.writeoob = 0;
                opts.blockalign = 1;
                opts.quiet      = quiet;
33d145f0:	e59d3034 	ldr	r3, [sp, #52]
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
33d145f4:	e3a02001 	mov	r2, #1	; 0x1
                opts.writeoob = 0;
                opts.blockalign = 1;
                opts.quiet      = quiet;
                opts.skipfirstblk = 0;
                opts.nocheckbadblk = 1;
                ret = nand_write_opts(nand, &opts);
33d145f8:	e1a00007 	mov	r0, r7
33d145fc:	e1a01004 	mov	r1, r4
                ret = nand_read_opts(nand, &opts);
            } else {
                /* write */
                nand_write_options_t opts;
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
33d14600:	e58d5060 	str	r5, [sp, #96]
                opts.offset = off;
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
                opts.writeoob = 0;
                opts.blockalign = 1;
                opts.quiet      = quiet;
33d14604:	e58d306c 	str	r3, [sp, #108]
                opts.skipfirstblk = 0;
                opts.nocheckbadblk = 1;
33d14608:	e58d2090 	str	r2, [sp, #144]
                memset(&opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                /* opts.forceyaffs = 1; */
                opts.noecc = 1;
33d1460c:	e58d207c 	str	r2, [sp, #124]
                opts.writeoob = 0;
33d14610:	e58da080 	str	sl, [sp, #128]
                opts.blockalign = 1;
33d14614:	e58d2088 	str	r2, [sp, #136]
                opts.quiet      = quiet;
                opts.skipfirstblk = 0;
33d14618:	e58da08c 	str	sl, [sp, #140]
33d1461c:	eaffffce 	b	33d1455c <do_nand+0x820>
                opts.nocheckbadblk = 1;
                ret = nand_write_opts(nand, &opts);
            }
        }        else {
            if (read)
33d14620:	e35a0000 	cmp	sl, #0	; 0x0
33d14624:	e59d1040 	ldr	r1, [sp, #64]
33d14628:	e59d303c 	ldr	r3, [sp, #60]
33d1462c:	0a000006 	beq	33d1464c <do_nand+0x910>
extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
	return info->read(info, ofs, *len, (size_t *)len, buf);
33d14630:	e58d9000 	str	r9, [sp]
33d14634:	e58d5004 	str	r5, [sp, #4]
33d14638:	e3a02000 	mov	r2, #0	; 0x0
33d1463c:	e59f02bc 	ldr	r0, [pc, #700]	; 33d14900 <do_nand+0xbc4>
33d14640:	e1a0e00f 	mov	lr, pc
33d14644:	e597f10c 	ldr	pc, [r7, #268]
33d14648:	ea000005 	b	33d14664 <do_nand+0x928>
}

static inline int nand_write(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
	return info->write(info, ofs, *len, (size_t *)len, buf);
33d1464c:	e58d9000 	str	r9, [sp]
33d14650:	e58d5004 	str	r5, [sp, #4]
33d14654:	e3a02000 	mov	r2, #0	; 0x0
33d14658:	e59f02a0 	ldr	r0, [pc, #672]	; 33d14900 <do_nand+0xbc4>
33d1465c:	e1a0e00f 	mov	lr, pc
33d14660:	e597f110 	ldr	pc, [r7, #272]
                ret = nand_read(nand, off, &size, (u_char *)addr);
            else
                ret = nand_write(nand, off, &size, (u_char *)addr);
        }

        printf(" %d bytes %s: %s\n", size,
33d14664:	e59f333c 	ldr	r3, [pc, #828]	; 33d149a8 <do_nand+0xc6c>
33d14668:	e35a0000 	cmp	sl, #0	; 0x0
33d1466c:	e59f12fc 	ldr	r1, [pc, #764]	; 33d14970 <do_nand+0xc34>
33d14670:	e59f22b8 	ldr	r2, [pc, #696]	; 33d14930 <do_nand+0xbf4>
33d14674:	01a02003 	moveq	r2, r3
33d14678:	e3500000 	cmp	r0, #0	; 0x0
33d1467c:	e1a04000 	mov	r4, r0
33d14680:	e59f32e4 	ldr	r3, [pc, #740]	; 33d1496c <do_nand+0xc30>
33d14684:	e59f0320 	ldr	r0, [pc, #800]	; 33d149ac <do_nand+0xc70>
33d14688:	01a03001 	moveq	r3, r1
33d1468c:	e59d103c 	ldr	r1, [sp, #60]
33d14690:	eb000a4c 	bl	33d16fc8 <printf>
               read ? "read" : "written", ret ? "ERROR" : "OK");

        return ret == 0 ? 0 : 1;
33d14694:	e2540000 	subs	r0, r4, #0	; 0x0
33d14698:	13a00001 	movne	r0, #1	; 0x1
33d1469c:	ea000093 	b	33d148f0 <do_nand+0xbb4>
    }

    if (strcmp(cmd, "markbad") == 0) {
33d146a0:	e1a00004 	mov	r0, r4
33d146a4:	e59f1290 	ldr	r1, [pc, #656]	; 33d1493c <do_nand+0xc00>
33d146a8:	eb00166e 	bl	33d1a068 <strcmp>
33d146ac:	e3500000 	cmp	r0, #0	; 0x0
33d146b0:	1a000014 	bne	33d14708 <do_nand+0x9cc>
        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
33d146b4:	e1a01000 	mov	r1, r0
33d146b8:	e3a02010 	mov	r2, #16	; 0x10
33d146bc:	e5960008 	ldr	r0, [r6, #8]
33d146c0:	eb0017a5 	bl	33d1a55c <simple_strtoul>
33d146c4:	e1a05000 	mov	r5, r0

        int ret = nand->block_markbad(nand, addr);
33d146c8:	e1a01005 	mov	r1, r5
33d146cc:	e3a02000 	mov	r2, #0	; 0x0
33d146d0:	e1a00007 	mov	r0, r7
33d146d4:	e1a0e00f 	mov	lr, pc
33d146d8:	e597f138 	ldr	pc, [r7, #312]
        if (ret == 0) {
33d146dc:	e2504000 	subs	r4, r0, #0	; 0x0
33d146e0:	1a000003 	bne	33d146f4 <do_nand+0x9b8>
            printf("block 0x%08lx successfully marked as bad\n",
33d146e4:	e1a01005 	mov	r1, r5
33d146e8:	e59f02c0 	ldr	r0, [pc, #704]	; 33d149b0 <do_nand+0xc74>
33d146ec:	eb000a35 	bl	33d16fc8 <printf>
33d146f0:	ea000077 	b	33d148d4 <do_nand+0xb98>
                   (ulong) addr);
            return 0;
        } else {
            printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
33d146f4:	e1a01005 	mov	r1, r5
33d146f8:	e1a02004 	mov	r2, r4
33d146fc:	e59f02b0 	ldr	r0, [pc, #688]	; 33d149b4 <do_nand+0xc78>
33d14700:	eb000a30 	bl	33d16fc8 <printf>
33d14704:	ea000078 	b	33d148ec <do_nand+0xbb0>
                   (ulong) addr, ret);
        }
        return 1;
    }
    if (strcmp(cmd, "biterr") == 0) {
33d14708:	e1a00004 	mov	r0, r4
33d1470c:	e59f122c 	ldr	r1, [pc, #556]	; 33d14940 <do_nand+0xc04>
33d14710:	eb001654 	bl	33d1a068 <strcmp>
33d14714:	e3500000 	cmp	r0, #0	; 0x0
        /* todo */
        return 1;
33d14718:	02800001 	addeq	r0, r0, #1	; 0x1
            printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
                   (ulong) addr, ret);
        }
        return 1;
    }
    if (strcmp(cmd, "biterr") == 0) {
33d1471c:	0a000073 	beq	33d148f0 <do_nand+0xbb4>
        /* todo */
        return 1;
    }

    if (strcmp(cmd, "lock") == 0) {
33d14720:	e1a00004 	mov	r0, r4
33d14724:	e59f1218 	ldr	r1, [pc, #536]	; 33d14944 <do_nand+0xc08>
33d14728:	eb00164e 	bl	33d1a068 <strcmp>
33d1472c:	e3500000 	cmp	r0, #0	; 0x0
33d14730:	1a000050 	bne	33d14878 <do_nand+0xb3c>
        int tight  = 0;
        int status = 0;
        if (argc == 3) {
33d14734:	e3590003 	cmp	r9, #3	; 0x3
        /* todo */
        return 1;
    }

    if (strcmp(cmd, "lock") == 0) {
        int tight  = 0;
33d14738:	e1a04000 	mov	r4, r0
        int status = 0;
        if (argc == 3) {
33d1473c:	1a000043 	bne	33d14850 <do_nand+0xb14>
            if (!strcmp("tight", argv[2]))
33d14740:	e5961008 	ldr	r1, [r6, #8]
33d14744:	e59f026c 	ldr	r0, [pc, #620]	; 33d149b8 <do_nand+0xc7c>
33d14748:	eb001646 	bl	33d1a068 <strcmp>
                tight = 1;
            if (!strcmp("status", argv[2]))
33d1474c:	e5961008 	ldr	r1, [r6, #8]
    if (strcmp(cmd, "lock") == 0) {
        int tight  = 0;
        int status = 0;
        if (argc == 3) {
            if (!strcmp("tight", argv[2]))
                tight = 1;
33d14750:	e2704001 	rsbs	r4, r0, #1	; 0x1
33d14754:	33a04000 	movcc	r4, #0	; 0x0
            if (!strcmp("status", argv[2]))
33d14758:	e59f025c 	ldr	r0, [pc, #604]	; 33d149bc <do_nand+0xc80>
33d1475c:	eb001641 	bl	33d1a068 <strcmp>
33d14760:	e2505000 	subs	r5, r0, #0	; 0x0
33d14764:	1a000039 	bne	33d14850 <do_nand+0xb14>
        }

        if (status) {
            ulong block_start = 0;
            ulong off;
            int last_status = -1;
33d14768:	e3e06000 	mvn	r6, #0	; 0x0

            struct nand_chip *nand_chip = nand->priv;
            /* check the WP bit */
            nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
33d1476c:	e3a01070 	mov	r1, #112	; 0x70
33d14770:	e1a02006 	mov	r2, r6
33d14774:	e1a03006 	mov	r3, r6
        if (status) {
            ulong block_start = 0;
            ulong off;
            int last_status = -1;

            struct nand_chip *nand_chip = nand->priv;
33d14778:	e597413c 	ldr	r4, [r7, #316]
            /* check the WP bit */
            nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
33d1477c:	e1a00007 	mov	r0, r7
33d14780:	e1a0e00f 	mov	lr, pc
33d14784:	e594f038 	ldr	pc, [r4, #56]
            printf("device is %swrite protected\n",
33d14788:	e1a00007 	mov	r0, r7
33d1478c:	e1a0e00f 	mov	lr, pc
33d14790:	e594f008 	ldr	pc, [r4, #8]
33d14794:	e59f3224 	ldr	r3, [pc, #548]	; 33d149c0 <do_nand+0xc84>
33d14798:	e59f1224 	ldr	r1, [pc, #548]	; 33d149c4 <do_nand+0xc88>
33d1479c:	e3100080 	tst	r0, #128	; 0x80
33d147a0:	01a01003 	moveq	r1, r3
33d147a4:	e59f021c 	ldr	r0, [pc, #540]	; 33d149c8 <do_nand+0xc8c>
33d147a8:	eb000a06 	bl	33d16fc8 <printf>
                   (nand_chip->read_byte(nand) & 0x80 ?
                "NOT " : "" ) );

            for (off = 0; off < nand->size; off += nand->oobblock) {
33d147ac:	e5973008 	ldr	r3, [r7, #8]
33d147b0:	e1550003 	cmp	r5, r3
33d147b4:	2a00002d 	bcs	33d14870 <do_nand+0xb34>
                int s = nand_get_lock_status(nand, off);
33d147b8:	e1a01005 	mov	r1, r5
33d147bc:	e59f013c 	ldr	r0, [pc, #316]	; 33d14900 <do_nand+0xbc4>
33d147c0:	eb003bc8 	bl	33d236e8 <nand_get_lock_status>

                /* print message only if status has changed
                 * or at end of chip
                 */
                if (off == nand->size - nand->oobblock
33d147c4:	e5972010 	ldr	r2, [r7, #16]
33d147c8:	e5973008 	ldr	r3, [r7, #8]
33d147cc:	e0623003 	rsb	r3, r2, r3
33d147d0:	e1550003 	cmp	r5, r3
            printf("device is %swrite protected\n",
                   (nand_chip->read_byte(nand) & 0x80 ?
                "NOT " : "" ) );

            for (off = 0; off < nand->size; off += nand->oobblock) {
                int s = nand_get_lock_status(nand, off);
33d147d4:	e1a09000 	mov	r9, r0
                 * or at end of chip
                 */
                if (off == nand->size - nand->oobblock
                    || (s != last_status && off != 0))  {

                    printf("%08x - %08x: %8d pages %s%s%s\n",
33d147d8:	e1a01002 	mov	r1, r2
33d147dc:	e1a00005 	mov	r0, r5
33d147e0:	e245a001 	sub	sl, r5, #1	; 0x1
                int s = nand_get_lock_status(nand, off);

                /* print message only if status has changed
                 * or at end of chip
                 */
                if (off == nand->size - nand->oobblock
33d147e4:	0a000002 	beq	33d147f4 <do_nand+0xab8>
33d147e8:	e1590006 	cmp	r9, r6
33d147ec:	13550000 	cmpne	r5, #0	; 0x0
33d147f0:	0a000010 	beq	33d14838 <do_nand+0xafc>
                    || (s != last_status && off != 0))  {

                    printf("%08x - %08x: %8d pages %s%s%s\n",
33d147f4:	ebffb2f9 	bl	33d013e0 <__udivsi3>
33d147f8:	e59f41cc 	ldr	r4, [pc, #460]	; 33d149cc <do_nand+0xc90>
33d147fc:	e59fe1bc 	ldr	lr, [pc, #444]	; 33d149c0 <do_nand+0xc84>
33d14800:	e3160001 	tst	r6, #1	; 0x1
33d14804:	e59fc1c4 	ldr	ip, [pc, #452]	; 33d149d0 <do_nand+0xc94>
33d14808:	01a0400e 	moveq	r4, lr
33d1480c:	e59f21c0 	ldr	r2, [pc, #448]	; 33d149d4 <do_nand+0xc98>
33d14810:	e3160002 	tst	r6, #2	; 0x2
33d14814:	01a0c00e 	moveq	ip, lr
33d14818:	e3160004 	tst	r6, #4	; 0x4
33d1481c:	11a0e002 	movne	lr, r2
33d14820:	e1a03000 	mov	r3, r0
33d14824:	e1a0200a 	mov	r2, sl
33d14828:	e59f01a8 	ldr	r0, [pc, #424]	; 33d149d8 <do_nand+0xc9c>
33d1482c:	e3a01000 	mov	r1, #0	; 0x0
33d14830:	e88d5010 	stm	sp, {r4, ip, lr}
33d14834:	eb0009e3 	bl	33d16fc8 <printf>
            nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
            printf("device is %swrite protected\n",
                   (nand_chip->read_byte(nand) & 0x80 ?
                "NOT " : "" ) );

            for (off = 0; off < nand->size; off += nand->oobblock) {
33d14838:	e5973010 	ldr	r3, [r7, #16]
33d1483c:	e5972008 	ldr	r2, [r7, #8]
33d14840:	e0855003 	add	r5, r5, r3
                           ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
                           ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
                           ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
                }

                last_status = s;
33d14844:	e1a06009 	mov	r6, r9
            nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
            printf("device is %swrite protected\n",
                   (nand_chip->read_byte(nand) & 0x80 ?
                "NOT " : "" ) );

            for (off = 0; off < nand->size; off += nand->oobblock) {
33d14848:	e1550002 	cmp	r5, r2
33d1484c:	eaffffd8 	b	33d147b4 <do_nand+0xa78>
                }

                last_status = s;
               }
        } else {
            if (!nand_lock(nand, tight)) {
33d14850:	e1a01004 	mov	r1, r4
33d14854:	e59f00a4 	ldr	r0, [pc, #164]	; 33d14900 <do_nand+0xbc4>
33d14858:	eb003b85 	bl	33d23674 <nand_lock>
33d1485c:	e3500000 	cmp	r0, #0	; 0x0
                puts("NAND flash successfully locked\n");
            } else {
                puts("Error locking NAND flash\n");
33d14860:	159f0174 	ldrne	r0, [pc, #372]	; 33d149dc <do_nand+0xca0>
                }

                last_status = s;
               }
        } else {
            if (!nand_lock(nand, tight)) {
33d14864:	1afffdbb 	bne	33d13f58 <do_nand+0x21c>
                puts("NAND flash successfully locked\n");
33d14868:	e59f0170 	ldr	r0, [pc, #368]	; 33d149e0 <do_nand+0xca4>
33d1486c:	eb0009ce 	bl	33d16fac <puts>
            } else {
                puts("Error locking NAND flash\n");
                return 1;
            }
        }
        return 0;
33d14870:	e3a00000 	mov	r0, #0	; 0x0
33d14874:	ea00001d 	b	33d148f0 <do_nand+0xbb4>
    }

    if (strcmp(cmd, "unlock") == 0) {
33d14878:	e1a00004 	mov	r0, r4
33d1487c:	e59f10c4 	ldr	r1, [pc, #196]	; 33d14948 <do_nand+0xc0c>
33d14880:	eb0015f8 	bl	33d1a068 <strcmp>
33d14884:	e3500000 	cmp	r0, #0	; 0x0
33d14888:	1a000013 	bne	33d148dc <do_nand+0xba0>
        if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
33d1488c:	e28dc03c 	add	ip, sp, #60	; 0x3c
33d14890:	e2490002 	sub	r0, r9, #2	; 0x2
33d14894:	e2861008 	add	r1, r6, #8	; 0x8
33d14898:	e59f2060 	ldr	r2, [pc, #96]	; 33d14900 <do_nand+0xbc4>
33d1489c:	e28d3040 	add	r3, sp, #64	; 0x40
33d148a0:	e58dc000 	str	ip, [sp]
33d148a4:	ebfffc95 	bl	33d13b00 <arg_off_size>
33d148a8:	e3500000 	cmp	r0, #0	; 0x0
33d148ac:	ba00000e 	blt	33d148ec <do_nand+0xbb0>
            return 1;

        if (!nand_unlock(nand, off, size)) {
33d148b0:	e59f0048 	ldr	r0, [pc, #72]	; 33d14900 <do_nand+0xbc4>
33d148b4:	e59d1040 	ldr	r1, [sp, #64]
33d148b8:	e59d203c 	ldr	r2, [sp, #60]
33d148bc:	eb003bac 	bl	33d23774 <nand_unlock>
33d148c0:	e2504000 	subs	r4, r0, #0	; 0x0
            puts("NAND flash successfully unlocked\n");
        } else {
            puts("Error unlocking NAND flash, "
33d148c4:	159f0118 	ldrne	r0, [pc, #280]	; 33d149e4 <do_nand+0xca8>

    if (strcmp(cmd, "unlock") == 0) {
        if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
            return 1;

        if (!nand_unlock(nand, off, size)) {
33d148c8:	1afffda2 	bne	33d13f58 <do_nand+0x21c>
            puts("NAND flash successfully unlocked\n");
33d148cc:	e59f0114 	ldr	r0, [pc, #276]	; 33d149e8 <do_nand+0xcac>
33d148d0:	eb0009b5 	bl	33d16fac <puts>
        } else {
            puts("Error unlocking NAND flash, "
                 "write and erase will probably fail\n");
            return 1;
        }
        return 0;
33d148d4:	e1a00004 	mov	r0, r4
33d148d8:	ea000004 	b	33d148f0 <do_nand+0xbb4>
    }

usage:
    printf("Usage:\n%s\n", cmdtp->usage);
33d148dc:	e59d2038 	ldr	r2, [sp, #56]
33d148e0:	e59f0104 	ldr	r0, [pc, #260]	; 33d149ec <do_nand+0xcb0>
33d148e4:	e5921010 	ldr	r1, [r2, #16]
33d148e8:	eb0009b6 	bl	33d16fc8 <printf>
    return 1;
33d148ec:	e3a00001 	mov	r0, #1	; 0x1
}
33d148f0:	e28dd0a8 	add	sp, sp, #168	; 0xa8
33d148f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d148f8:	33d2aca8 	.word	0x33d2aca8
33d148fc:	33d2acb0 	.word	0x33d2acb0
33d14900:	33d39920 	.word	0x33d39920
33d14904:	33d2acb8 	.word	0x33d2acb8
33d14908:	33d2b0ec 	.word	0x33d2b0ec
33d1490c:	33d2ddbc 	.word	0x33d2ddbc
33d14910:	33d2acdc 	.word	0x33d2acdc
33d14914:	33d2acf4 	.word	0x33d2acf4
33d14918:	33d2ad04 	.word	0x33d2ad04
33d1491c:	33d2ad14 	.word	0x33d2ad14
33d14920:	33d2ad24 	.word	0x33d2ad24
33d14924:	33d2ad64 	.word	0x33d2ad64
33d14928:	33d28500 	.word	0x33d28500
33d1492c:	33d2ad40 	.word	0x33d2ad40
33d14930:	33d2ad48 	.word	0x33d2ad48
33d14934:	33d2ad50 	.word	0x33d2ad50
33d14938:	33d2ad58 	.word	0x33d2ad58
33d1493c:	33d2ad60 	.word	0x33d2ad60
33d14940:	33d2ad68 	.word	0x33d2ad68
33d14944:	33d2ad70 	.word	0x33d2ad70
33d14948:	33d2ad78 	.word	0x33d2ad78
33d1494c:	33d2ad80 	.word	0x33d2ad80
33d14950:	33d2ad98 	.word	0x33d2ad98
33d14954:	33d2ada0 	.word	0x33d2ada0
33d14958:	33d2ada8 	.word	0x33d2ada8
33d1495c:	33d2adb4 	.word	0x33d2adb4
33d14960:	33d27038 	.word	0x33d27038
33d14964:	33d2bd80 	.word	0x33d2bd80
33d14968:	33d2aeb0 	.word	0x33d2aeb0
33d1496c:	33d2aec0 	.word	0x33d2aec0
33d14970:	33d2aec8 	.word	0x33d2aec8
33d14974:	33d2ad00 	.word	0x33d2ad00
33d14978:	33d2aecc 	.word	0x33d2aecc
33d1497c:	33d2aed4 	.word	0x33d2aed4
33d14980:	33d2aef0 	.word	0x33d2aef0
33d14984:	33d2af10 	.word	0x33d2af10
33d14988:	33d2af24 	.word	0x33d2af24
33d1498c:	33d2af78 	.word	0x33d2af78
33d14990:	33d2af80 	.word	0x33d2af80
33d14994:	33d2afac 	.word	0x33d2afac
33d14998:	33d2afb4 	.word	0x33d2afb4
33d1499c:	33d2afb8 	.word	0x33d2afb8
33d149a0:	33d2afbc 	.word	0x33d2afbc
33d149a4:	33d2afc4 	.word	0x33d2afc4
33d149a8:	33d2afcc 	.word	0x33d2afcc
33d149ac:	33d2afd4 	.word	0x33d2afd4
33d149b0:	33d2afe8 	.word	0x33d2afe8
33d149b4:	33d2b014 	.word	0x33d2b014
33d149b8:	33d2b040 	.word	0x33d2b040
33d149bc:	33d2b048 	.word	0x33d2b048
33d149c0:	33d2a490 	.word	0x33d2a490
33d149c4:	33d2a570 	.word	0x33d2a570
33d149c8:	33d2a578 	.word	0x33d2a578
33d149cc:	33d2a598 	.word	0x33d2a598
33d149d0:	33d2a5a0 	.word	0x33d2a5a0
33d149d4:	33d2a5a8 	.word	0x33d2a5a8
33d149d8:	33d2a5b0 	.word	0x33d2a5b0
33d149dc:	33d2a5d0 	.word	0x33d2a5d0
33d149e0:	33d2a5ec 	.word	0x33d2a5ec
33d149e4:	33d2a60c 	.word	0x33d2a60c
33d149e8:	33d2a64c 	.word	0x33d2a64c
33d149ec:	33d27008 	.word	0x33d27008

33d149f0 <nand_load_image>:
    "nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
    "nand unlock [offset] [size] - unlock section\n");

static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
               ulong offset, ulong addr, char *cmd)
{
33d149f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d149f4:	e1a06001 	mov	r6, r1
33d149f8:	e24dd014 	sub	sp, sp, #20	; 0x14
    int r;
    char *ep;
    ulong cnt;
    image_header_t *hdr;

    printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
33d149fc:	e5911024 	ldr	r1, [r1, #36]
    "nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
    "nand unlock [offset] [size] - unlock section\n");

static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
               ulong offset, ulong addr, char *cmd)
{
33d14a00:	e1a09000 	mov	r9, r0
    int r;
    char *ep;
    ulong cnt;
    image_header_t *hdr;

    printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
33d14a04:	e59f0138 	ldr	r0, [pc, #312]	; 33d14b44 <nand_load_image+0x154>
    "nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
    "nand unlock [offset] [size] - unlock section\n");

static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
               ulong offset, ulong addr, char *cmd)
{
33d14a08:	e1a05003 	mov	r5, r3
33d14a0c:	e1a04002 	mov	r4, r2
    int r;
    char *ep;
    ulong cnt;
    image_header_t *hdr;

    printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
33d14a10:	eb00096c 	bl	33d16fc8 <printf>

    cnt = nand->oobblock;
33d14a14:	e5963010 	ldr	r3, [r6, #16]
33d14a18:	e28d7014 	add	r7, sp, #20	; 0x14
33d14a1c:	e5273004 	str	r3, [r7, #-4]!
extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
	return info->read(info, ofs, *len, (size_t *)len, buf);
33d14a20:	e1a0a004 	mov	sl, r4
33d14a24:	e3a0b000 	mov	fp, #0	; 0x0
33d14a28:	e58d7000 	str	r7, [sp]
33d14a2c:	e58d5004 	str	r5, [sp, #4]
33d14a30:	e1a00006 	mov	r0, r6
33d14a34:	e1a0200b 	mov	r2, fp
33d14a38:	e1a0100a 	mov	r1, sl
33d14a3c:	e1a0e00f 	mov	lr, pc
33d14a40:	e596f10c 	ldr	pc, [r6, #268]
    r = nand_read(nand, offset, &cnt, (u_char *) addr);
    if (r) {
33d14a44:	e3500000 	cmp	r0, #0	; 0x0
33d14a48:	1a000020 	bne	33d14ad0 <nand_load_image+0xe0>
33d14a4c:	e5951000 	ldr	r1, [r5]
	return __arch__swab32(x);
33d14a50:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d14a54:	e1a03403 	lsl	r3, r3, #8
33d14a58:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d14a5c:	e1833c01 	orr	r3, r3, r1, lsl #24
33d14a60:	e1833422 	orr	r3, r3, r2, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d14a64:	e59f20dc 	ldr	r2, [pc, #220]	; 33d14b48 <nand_load_image+0x158>
	return __arch__swab32(x);
33d14a68:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d14a6c:	e1530002 	cmp	r3, r2
33d14a70:	0a000002 	beq	33d14a80 <nand_load_image+0x90>
    }

    hdr = (image_header_t *) addr;

    if (ntohl(hdr->ih_magic) != IH_MAGIC) {
        printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
33d14a74:	e59f00d0 	ldr	r0, [pc, #208]	; 33d14b4c <nand_load_image+0x15c>
33d14a78:	eb000952 	bl	33d16fc8 <printf>
33d14a7c:	ea00002b 	b	33d14b30 <nand_load_image+0x140>
        SHOW_BOOT_PROGRESS(-1);
        return 1;
    }

    print_image_hdr(hdr);
33d14a80:	e1a00005 	mov	r0, r5
33d14a84:	ebffe2ee 	bl	33d0d644 <print_image_hdr>
33d14a88:	e595200c 	ldr	r2, [r5, #12]
	return __arch__swab32(x);
33d14a8c:	e2023cff 	and	r3, r2, #65280	; 0xff00
33d14a90:	e1a03403 	lsl	r3, r3, #8
33d14a94:	e1833c02 	orr	r3, r3, r2, lsl #24
33d14a98:	e20218ff 	and	r1, r2, #16711680	; 0xff0000
33d14a9c:	e1833421 	orr	r3, r3, r1, lsr #8
33d14aa0:	e1833c22 	orr	r3, r3, r2, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d14aa4:	e2833040 	add	r3, r3, #64	; 0x40
33d14aa8:	e58d7000 	str	r7, [sp]
33d14aac:	e58d3010 	str	r3, [sp, #16]
33d14ab0:	e58d5004 	str	r5, [sp, #4]
33d14ab4:	e1a0200b 	mov	r2, fp
33d14ab8:	e1a0100a 	mov	r1, sl
33d14abc:	e1a00006 	mov	r0, r6
33d14ac0:	e1a0e00f 	mov	lr, pc
33d14ac4:	e596f10c 	ldr	pc, [r6, #268]

    cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));

    r = nand_read(nand, offset, &cnt, (u_char *) addr);
    if (r) {
33d14ac8:	e3500000 	cmp	r0, #0	; 0x0
33d14acc:	0a000002 	beq	33d14adc <nand_load_image+0xec>
        puts("** Read error\n");
33d14ad0:	e59f0078 	ldr	r0, [pc, #120]	; 33d14b50 <nand_load_image+0x160>
33d14ad4:	eb000934 	bl	33d16fac <puts>
33d14ad8:	ea000014 	b	33d14b30 <nand_load_image+0x140>
        return 1;
    }

    /* Loading ok, update default load address */

    load_addr = addr;
33d14adc:	e59f3070 	ldr	r3, [pc, #112]	; 33d14b54 <nand_load_image+0x164>

    /* Check if we should attempt an auto-start */
    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
33d14ae0:	e59f0070 	ldr	r0, [pc, #112]	; 33d14b58 <nand_load_image+0x168>
        return 1;
    }

    /* Loading ok, update default load address */

    load_addr = addr;
33d14ae4:	e5835000 	str	r5, [r3]

    /* Check if we should attempt an auto-start */
    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
33d14ae8:	eb000358 	bl	33d15850 <getenv>
33d14aec:	e3500000 	cmp	r0, #0	; 0x0
33d14af0:	0a000010 	beq	33d14b38 <nand_load_image+0x148>
33d14af4:	e59f1060 	ldr	r1, [pc, #96]	; 33d14b5c <nand_load_image+0x16c>
33d14af8:	eb00155a 	bl	33d1a068 <strcmp>
33d14afc:	e2504000 	subs	r4, r0, #0	; 0x0
33d14b00:	1a00000c 	bne	33d14b38 <nand_load_image+0x148>
        char *local_args[2];
        extern int do_bootm(cmd_tbl_t *, int, int, char *[]);

        local_args[0] = cmd;
33d14b04:	e59d3034 	ldr	r3, [sp, #52]
        local_args[1] = NULL;

        printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
33d14b08:	e1a01005 	mov	r1, r5
33d14b0c:	e59f004c 	ldr	r0, [pc, #76]	; 33d14b60 <nand_load_image+0x170>
    /* Check if we should attempt an auto-start */
    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
        char *local_args[2];
        extern int do_bootm(cmd_tbl_t *, int, int, char *[]);

        local_args[0] = cmd;
33d14b10:	e58d3008 	str	r3, [sp, #8]
        local_args[1] = NULL;
33d14b14:	e58d400c 	str	r4, [sp, #12]

        printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
33d14b18:	eb00092a 	bl	33d16fc8 <printf>

        do_bootm(cmdtp, 0, 1, local_args);
33d14b1c:	e1a00009 	mov	r0, r9
33d14b20:	e1a01004 	mov	r1, r4
33d14b24:	e28d3008 	add	r3, sp, #8	; 0x8
33d14b28:	e3a02001 	mov	r2, #1	; 0x1
33d14b2c:	ebffe4a0 	bl	33d0ddb4 <do_bootm>
        return 1;
33d14b30:	e3a00001 	mov	r0, #1	; 0x1
33d14b34:	ea000000 	b	33d14b3c <nand_load_image+0x14c>
    }
    return 0;
33d14b38:	e3a00000 	mov	r0, #0	; 0x0
}
33d14b3c:	e28dd014 	add	sp, sp, #20	; 0x14
33d14b40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d14b44:	33d2b050 	.word	0x33d2b050
33d14b48:	27051956 	.word	0x27051956
33d14b4c:	33d2b070 	.word	0x33d2b070
33d14b50:	33d2b090 	.word	0x33d2b090
33d14b54:	33d35fec 	.word	0x33d35fec
33d14b58:	33d27b94 	.word	0x33d27b94
33d14b5c:	33d2b0a0 	.word	0x33d2b0a0
33d14b60:	33d2b0a4 	.word	0x33d2b0a4

33d14b64 <do_nandboot>:

int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d14b64:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
    struct mtd_device *dev;
    struct part_info *part;
    u8 pnum;

    if (argc >= 2) {
33d14b68:	e3520001 	cmp	r2, #1	; 0x1
    }
    return 0;
}

int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d14b6c:	e24dd014 	sub	sp, sp, #20	; 0x14
33d14b70:	e1a05002 	mov	r5, r2
33d14b74:	e1a07000 	mov	r7, r0
33d14b78:	e1a06003 	mov	r6, r3
    char *boot_device = NULL;
33d14b7c:	e3a0a000 	mov	sl, #0	; 0x0
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
    struct mtd_device *dev;
    struct part_info *part;
    u8 pnum;

    if (argc >= 2) {
33d14b80:	da000032 	ble	33d14c50 <do_nandboot+0xec>
        char *p = (argc == 2) ? argv[1] : argv[2];
33d14b84:	e3520002 	cmp	r2, #2	; 0x2
33d14b88:	05934004 	ldreq	r4, [r3, #4]
33d14b8c:	15934008 	ldrne	r4, [r3, #8]

static inline int str2long(char *p, ulong *num)
{
    char *endptr;

    *num = simple_strtoul(p, &endptr, 16);
33d14b90:	e28d100c 	add	r1, sp, #12	; 0xc
33d14b94:	e1a00004 	mov	r0, r4
33d14b98:	e3a02010 	mov	r2, #16	; 0x10
33d14b9c:	eb00166e 	bl	33d1a55c <simple_strtoul>
33d14ba0:	e5d43000 	ldrb	r3, [r4]
33d14ba4:	e3530000 	cmp	r3, #0	; 0x0
33d14ba8:	0a000003 	beq	33d14bbc <do_nandboot+0x58>
33d14bac:	e59d300c 	ldr	r3, [sp, #12]
33d14bb0:	e5d33000 	ldrb	r3, [r3]
33d14bb4:	e3530000 	cmp	r3, #0	; 0x0
33d14bb8:	0a000024 	beq	33d14c50 <do_nandboot+0xec>
}

/* ------------------------------------------------------------------------- */

static inline int str2long(char *p, ulong *num)
{
33d14bbc:	ebfff128 	bl	33d11064 <mtdparts_init>
33d14bc0:	e3500000 	cmp	r0, #0	; 0x0
33d14bc4:	1a000021 	bne	33d14c50 <do_nandboot+0xec>
33d14bc8:	e1a00004 	mov	r0, r4
33d14bcc:	e28d1008 	add	r1, sp, #8	; 0x8
33d14bd0:	e28d2013 	add	r2, sp, #19	; 0x13
33d14bd4:	e28d3004 	add	r3, sp, #4	; 0x4
33d14bd8:	ebfff0b8 	bl	33d10ec0 <find_dev_and_part>
33d14bdc:	e3500000 	cmp	r0, #0	; 0x0
33d14be0:	1a00001a 	bne	33d14c50 <do_nandboot+0xec>

    if (argc >= 2) {
        char *p = (argc == 2) ? argv[1] : argv[2];
        if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
            (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
            if (dev->id->type != MTD_DEV_TYPE_NAND) {
33d14be4:	e59d3008 	ldr	r3, [sp, #8]
33d14be8:	e5933008 	ldr	r3, [r3, #8]
33d14bec:	e5d33008 	ldrb	r3, [r3, #8]
33d14bf0:	e3530002 	cmp	r3, #2	; 0x2
                puts("Not a NAND device\n");
33d14bf4:	159f0174 	ldrne	r0, [pc, #372]	; 33d14d70 <do_nandboot+0x20c>

    if (argc >= 2) {
        char *p = (argc == 2) ? argv[1] : argv[2];
        if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
            (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
            if (dev->id->type != MTD_DEV_TYPE_NAND) {
33d14bf8:	1a000043 	bne	33d14d0c <do_nandboot+0x1a8>
                puts("Not a NAND device\n");
                return 1;
            }
            if (argc > 3)
33d14bfc:	e3550003 	cmp	r5, #3	; 0x3
33d14c00:	ca00003b 	bgt	33d14cf4 <do_nandboot+0x190>
                goto usage;
            if (argc == 3)
                addr = simple_strtoul(argv[1], NULL, 16);
            else
                addr = CFG_LOAD_ADDR;
33d14c04:	13a05437 	movne	r5, #922746880	; 0x37000000
                puts("Not a NAND device\n");
                return 1;
            }
            if (argc > 3)
                goto usage;
            if (argc == 3)
33d14c08:	1a000004 	bne	33d14c20 <do_nandboot+0xbc>
                addr = simple_strtoul(argv[1], NULL, 16);
33d14c0c:	e1a01000 	mov	r1, r0
33d14c10:	e3a02010 	mov	r2, #16	; 0x10
33d14c14:	e5960004 	ldr	r0, [r6, #4]
33d14c18:	eb00164f 	bl	33d1a55c <simple_strtoul>
33d14c1c:	e1a05000 	mov	r5, r0
            else
                addr = CFG_LOAD_ADDR;
            return nand_load_image(cmdtp, &nand_info[dev->id->num],
33d14c20:	e59d3008 	ldr	r3, [sp, #8]
33d14c24:	e5933008 	ldr	r3, [r3, #8]
33d14c28:	e5d30009 	ldrb	r0, [r3, #9]
33d14c2c:	e59d3004 	ldr	r3, [sp, #4]
33d14c30:	e59f113c 	ldr	r1, [pc, #316]	; 33d14d74 <do_nandboot+0x210>
33d14c34:	e5932014 	ldr	r2, [r3, #20]
33d14c38:	e0803100 	add	r3, r0, r0, lsl #2
33d14c3c:	e0800183 	add	r0, r0, r3, lsl #3
33d14c40:	e596c000 	ldr	ip, [r6]
33d14c44:	e0811180 	add	r1, r1, r0, lsl #3
33d14c48:	e1a00007 	mov	r0, r7
33d14c4c:	ea000042 	b	33d14d5c <do_nandboot+0x1f8>
                           part->offset, addr, argv[0]);
        }
    }
#endif

    switch (argc) {
33d14c50:	e2453001 	sub	r3, r5, #1	; 0x1
33d14c54:	e3530003 	cmp	r3, #3	; 0x3
33d14c58:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d14c5c:	ea000024 	b	33d14cf4 <do_nandboot+0x190>
33d14c60:	33d14c70 	.word	0x33d14c70
33d14c64:	33d14c84 	.word	0x33d14c84
33d14c68:	33d14ca8 	.word	0x33d14ca8
33d14c6c:	33d14cc4 	.word	0x33d14cc4
    case 1:
        addr = CFG_LOAD_ADDR;
        boot_device = getenv("bootdevice");
33d14c70:	e59f0100 	ldr	r0, [pc, #256]	; 33d14d78 <do_nandboot+0x214>
33d14c74:	eb0002f5 	bl	33d15850 <getenv>
    }
#endif

    switch (argc) {
    case 1:
        addr = CFG_LOAD_ADDR;
33d14c78:	e3a05437 	mov	r5, #922746880	; 0x37000000
        boot_device = getenv("bootdevice");
33d14c7c:	e1a04000 	mov	r4, r0
        break;
33d14c80:	ea00001e 	b	33d14d00 <do_nandboot+0x19c>
    case 2:
        addr = simple_strtoul(argv[1], NULL, 16);
33d14c84:	e3a01000 	mov	r1, #0	; 0x0
33d14c88:	e3a02010 	mov	r2, #16	; 0x10
33d14c8c:	e5960004 	ldr	r0, [r6, #4]
33d14c90:	eb001631 	bl	33d1a55c <simple_strtoul>
33d14c94:	e1a05000 	mov	r5, r0
        boot_device = getenv("bootdevice");
33d14c98:	e59f00d8 	ldr	r0, [pc, #216]	; 33d14d78 <do_nandboot+0x214>
33d14c9c:	eb0002eb 	bl	33d15850 <getenv>
33d14ca0:	e1a04000 	mov	r4, r0
        break;
33d14ca4:	ea000015 	b	33d14d00 <do_nandboot+0x19c>
    case 3:
        addr = simple_strtoul(argv[1], NULL, 16);
33d14ca8:	e5960004 	ldr	r0, [r6, #4]
33d14cac:	e3a01000 	mov	r1, #0	; 0x0
33d14cb0:	e3a02010 	mov	r2, #16	; 0x10
33d14cb4:	eb001628 	bl	33d1a55c <simple_strtoul>
        boot_device = argv[2];
33d14cb8:	e5964008 	ldr	r4, [r6, #8]
    case 2:
        addr = simple_strtoul(argv[1], NULL, 16);
        boot_device = getenv("bootdevice");
        break;
    case 3:
        addr = simple_strtoul(argv[1], NULL, 16);
33d14cbc:	e1a05000 	mov	r5, r0
        boot_device = argv[2];
        break;
33d14cc0:	ea00000e 	b	33d14d00 <do_nandboot+0x19c>
    case 4:
        addr = simple_strtoul(argv[1], NULL, 16);
33d14cc4:	e3a01000 	mov	r1, #0	; 0x0
33d14cc8:	e3a02010 	mov	r2, #16	; 0x10
33d14ccc:	e5960004 	ldr	r0, [r6, #4]
33d14cd0:	eb001621 	bl	33d1a55c <simple_strtoul>
        boot_device = argv[2];
        offset = simple_strtoul(argv[3], NULL, 16);
33d14cd4:	e3a01000 	mov	r1, #0	; 0x0
    case 3:
        addr = simple_strtoul(argv[1], NULL, 16);
        boot_device = argv[2];
        break;
    case 4:
        addr = simple_strtoul(argv[1], NULL, 16);
33d14cd8:	e1a05000 	mov	r5, r0
        boot_device = argv[2];
        offset = simple_strtoul(argv[3], NULL, 16);
33d14cdc:	e3a02010 	mov	r2, #16	; 0x10
33d14ce0:	e596000c 	ldr	r0, [r6, #12]
        addr = simple_strtoul(argv[1], NULL, 16);
        boot_device = argv[2];
        break;
    case 4:
        addr = simple_strtoul(argv[1], NULL, 16);
        boot_device = argv[2];
33d14ce4:	e5964008 	ldr	r4, [r6, #8]
        offset = simple_strtoul(argv[3], NULL, 16);
33d14ce8:	eb00161b 	bl	33d1a55c <simple_strtoul>
33d14cec:	e1a0a000 	mov	sl, r0
        break;
33d14cf0:	ea000002 	b	33d14d00 <do_nandboot+0x19c>
    default:
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
usage:
#endif
        printf("Usage:\n%s\n", cmdtp->usage);
33d14cf4:	e5971010 	ldr	r1, [r7, #16]
33d14cf8:	e59f007c 	ldr	r0, [pc, #124]	; 33d14d7c <do_nandboot+0x218>
33d14cfc:	ea000010 	b	33d14d44 <do_nandboot+0x1e0>
        SHOW_BOOT_PROGRESS(-1);
        return 1;
    }

    if (!boot_device) {
33d14d00:	e3540000 	cmp	r4, #0	; 0x0
33d14d04:	1a000002 	bne	33d14d14 <do_nandboot+0x1b0>
        puts("\n** No boot device **\n");
33d14d08:	e59f0070 	ldr	r0, [pc, #112]	; 33d14d80 <do_nandboot+0x21c>
33d14d0c:	eb0008a6 	bl	33d16fac <puts>
33d14d10:	ea00000c 	b	33d14d48 <do_nandboot+0x1e4>
        SHOW_BOOT_PROGRESS(-1);
        return 1;
    }

    idx = simple_strtoul(boot_device, NULL, 16);
33d14d14:	e1a00004 	mov	r0, r4
33d14d18:	e3a01000 	mov	r1, #0	; 0x0
33d14d1c:	e3a02010 	mov	r2, #16	; 0x10
33d14d20:	eb00160d 	bl	33d1a55c <simple_strtoul>

    if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
33d14d24:	e3500000 	cmp	r0, #0	; 0x0
33d14d28:	1a000003 	bne	33d14d3c <do_nandboot+0x1d8>
33d14d2c:	e59f1040 	ldr	r1, [pc, #64]	; 33d14d74 <do_nandboot+0x210>
33d14d30:	e5913024 	ldr	r3, [r1, #36]
33d14d34:	e3530000 	cmp	r3, #0	; 0x0
33d14d38:	1a000004 	bne	33d14d50 <do_nandboot+0x1ec>
        printf("\n** Device %d not available\n", idx);
33d14d3c:	e1a01000 	mov	r1, r0
33d14d40:	e59f003c 	ldr	r0, [pc, #60]	; 33d14d84 <do_nandboot+0x220>
33d14d44:	eb00089f 	bl	33d16fc8 <printf>
        SHOW_BOOT_PROGRESS(-1);
        return 1;
33d14d48:	e3a00001 	mov	r0, #1	; 0x1
33d14d4c:	ea000005 	b	33d14d68 <do_nandboot+0x204>
    }

    return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
33d14d50:	e596c000 	ldr	ip, [r6]
33d14d54:	e1a00007 	mov	r0, r7
33d14d58:	e1a0200a 	mov	r2, sl
33d14d5c:	e1a03005 	mov	r3, r5
33d14d60:	e58dc000 	str	ip, [sp]
33d14d64:	ebffff21 	bl	33d149f0 <nand_load_image>
}
33d14d68:	e28dd014 	add	sp, sp, #20	; 0x14
33d14d6c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d14d70:	33d2b0d4 	.word	0x33d2b0d4
33d14d74:	33d39920 	.word	0x33d39920
33d14d78:	33d2b0e8 	.word	0x33d2b0e8
33d14d7c:	33d27008 	.word	0x33d27008
33d14d80:	33d2b0f4 	.word	0x33d2b0f4
33d14d84:	33d2b10c 	.word	0x33d2b10c

33d14d88 <netboot_common>:
#endif
}

static int
netboot_common (proto_t proto, cmd_tbl_t *cmdtp, int argc, char *argv[])
{
33d14d88:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d14d8c:	e1a05000 	mov	r5, r0
33d14d90:	e24dd020 	sub	sp, sp, #32	; 0x20
	char *s;
	int   rcode = 0;
	int   size;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
33d14d94:	e59f0250 	ldr	r0, [pc, #592]	; 33d14fec <netboot_common+0x264>
#endif
}

static int
netboot_common (proto_t proto, cmd_tbl_t *cmdtp, int argc, char *argv[])
{
33d14d98:	e1a09001 	mov	r9, r1
33d14d9c:	e1a04002 	mov	r4, r2
33d14da0:	e1a07003 	mov	r7, r3
	char *s;
	int   rcode = 0;
	int   size;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
33d14da4:	eb0002a9 	bl	33d15850 <getenv>
33d14da8:	e3500000 	cmp	r0, #0	; 0x0

static int
netboot_common (proto_t proto, cmd_tbl_t *cmdtp, int argc, char *argv[])
{
	char *s;
	int   rcode = 0;
33d14dac:	e3a0a000 	mov	sl, #0	; 0x0
	int   size;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
33d14db0:	0a000004 	beq	33d14dc8 <netboot_common+0x40>
		load_addr = simple_strtoul(s, NULL, 16);
33d14db4:	e1a0100a 	mov	r1, sl
33d14db8:	e3a02010 	mov	r2, #16	; 0x10
33d14dbc:	eb0015e6 	bl	33d1a55c <simple_strtoul>
33d14dc0:	e59f3228 	ldr	r3, [pc, #552]	; 33d14ff0 <netboot_common+0x268>
33d14dc4:	e5830000 	str	r0, [r3]
	}

	switch (argc) {
33d14dc8:	e3540002 	cmp	r4, #2	; 0x2
33d14dcc:	0a000006 	beq	33d14dec <netboot_common+0x64>
33d14dd0:	ca000002 	bgt	33d14de0 <netboot_common+0x58>
33d14dd4:	e3540001 	cmp	r4, #1	; 0x1
33d14dd8:	0a00001f 	beq	33d14e5c <netboot_common+0xd4>
33d14ddc:	ea00001a 	b	33d14e4c <netboot_common+0xc4>
33d14de0:	e3540003 	cmp	r4, #3	; 0x3
33d14de4:	0a00000d 	beq	33d14e20 <netboot_common+0x98>
33d14de8:	ea000017 	b	33d14e4c <netboot_common+0xc4>

	case 2:	/* only one arg - accept two forms:
		 * just load address, or just boot file name.
		 * The latter form must be written "filename" here.
		 */
		if (argv[1][0] == '"') {	/* just boot filename */
33d14dec:	e5970004 	ldr	r0, [r7, #4]
33d14df0:	e5d03000 	ldrb	r3, [r0]
33d14df4:	e3530022 	cmp	r3, #34	; 0x22
			copy_filename (BootFile, argv[1], sizeof(BootFile));
33d14df8:	01a01000 	moveq	r1, r0
33d14dfc:	03a02080 	moveq	r2, #128	; 0x80
33d14e00:	059f01ec 	ldreq	r0, [pc, #492]	; 33d14ff4 <netboot_common+0x26c>

	case 2:	/* only one arg - accept two forms:
		 * just load address, or just boot file name.
		 * The latter form must be written "filename" here.
		 */
		if (argv[1][0] == '"') {	/* just boot filename */
33d14e04:	0a00000e 	beq	33d14e44 <netboot_common+0xbc>
			copy_filename (BootFile, argv[1], sizeof(BootFile));
		} else {			/* load address	*/
			load_addr = simple_strtoul(argv[1], NULL, 16);
33d14e08:	e1a0100a 	mov	r1, sl
33d14e0c:	e3a02010 	mov	r2, #16	; 0x10
33d14e10:	eb0015d1 	bl	33d1a55c <simple_strtoul>
33d14e14:	e59f31d4 	ldr	r3, [pc, #468]	; 33d14ff0 <netboot_common+0x268>
33d14e18:	e5830000 	str	r0, [r3]
		}
		break;
33d14e1c:	ea00000e 	b	33d14e5c <netboot_common+0xd4>

	case 3:	load_addr = simple_strtoul(argv[1], NULL, 16);
33d14e20:	e1a0100a 	mov	r1, sl
33d14e24:	e3a02010 	mov	r2, #16	; 0x10
33d14e28:	e5970004 	ldr	r0, [r7, #4]
33d14e2c:	eb0015ca 	bl	33d1a55c <simple_strtoul>
33d14e30:	e59f31b8 	ldr	r3, [pc, #440]	; 33d14ff0 <netboot_common+0x268>
33d14e34:	e5830000 	str	r0, [r3]
		copy_filename (BootFile, argv[2], sizeof(BootFile));
33d14e38:	e59f01b4 	ldr	r0, [pc, #436]	; 33d14ff4 <netboot_common+0x26c>
33d14e3c:	e5971008 	ldr	r1, [r7, #8]
33d14e40:	e3a02080 	mov	r2, #128	; 0x80
33d14e44:	ebffb55d 	bl	33d023c0 <copy_filename>

		break;
33d14e48:	ea000003 	b	33d14e5c <netboot_common+0xd4>

	default: printf ("Usage:\n%s\n", cmdtp->usage);
33d14e4c:	e5991010 	ldr	r1, [r9, #16]
33d14e50:	e59f01a0 	ldr	r0, [pc, #416]	; 33d14ff8 <netboot_common+0x270>
33d14e54:	eb00085b 	bl	33d16fc8 <printf>
33d14e58:	ea000003 	b	33d14e6c <netboot_common+0xe4>
		return 1;
	}

	if ((size = NetLoop(proto)) < 0)
33d14e5c:	e1a00005 	mov	r0, r5
33d14e60:	ebffb776 	bl	33d02c40 <NetLoop>
33d14e64:	e2506000 	subs	r6, r0, #0	; 0x0
33d14e68:	aa000001 	bge	33d14e74 <netboot_common+0xec>
		return 1;
33d14e6c:	e3a00001 	mov	r0, #1	; 0x1
33d14e70:	ea00005b 	b	33d14fe4 <netboot_common+0x25c>

static void netboot_update_env (void)
{
	char tmp[22];

	if (NetOurGatewayIP) {
33d14e74:	e59f3180 	ldr	r3, [pc, #384]	; 33d14ffc <netboot_common+0x274>
33d14e78:	e5930000 	ldr	r0, [r3]
33d14e7c:	e3500000 	cmp	r0, #0	; 0x0
33d14e80:	0a000005 	beq	33d14e9c <netboot_common+0x114>
		ip_to_string (NetOurGatewayIP, tmp);
33d14e84:	e28d4008 	add	r4, sp, #8	; 0x8
33d14e88:	e1a01004 	mov	r1, r4
33d14e8c:	ebffb560 	bl	33d02414 <ip_to_string>
		setenv ("gatewayip", tmp);
33d14e90:	e1a01004 	mov	r1, r4
33d14e94:	e59f0164 	ldr	r0, [pc, #356]	; 33d15000 <netboot_common+0x278>
33d14e98:	eb00024e 	bl	33d157d8 <setenv>
	}

	if (NetOurSubnetMask) {
33d14e9c:	e59f3160 	ldr	r3, [pc, #352]	; 33d15004 <netboot_common+0x27c>
33d14ea0:	e5930000 	ldr	r0, [r3]
33d14ea4:	e3500000 	cmp	r0, #0	; 0x0
33d14ea8:	0a000005 	beq	33d14ec4 <netboot_common+0x13c>
		ip_to_string (NetOurSubnetMask, tmp);
33d14eac:	e28d4008 	add	r4, sp, #8	; 0x8
33d14eb0:	e1a01004 	mov	r1, r4
33d14eb4:	ebffb556 	bl	33d02414 <ip_to_string>
		setenv ("netmask", tmp);
33d14eb8:	e1a01004 	mov	r1, r4
33d14ebc:	e59f0144 	ldr	r0, [pc, #324]	; 33d15008 <netboot_common+0x280>
33d14ec0:	eb000244 	bl	33d157d8 <setenv>
	}

	if (NetOurHostName[0])
33d14ec4:	e59f1140 	ldr	r1, [pc, #320]	; 33d1500c <netboot_common+0x284>
33d14ec8:	e5d13000 	ldrb	r3, [r1]
33d14ecc:	e3530000 	cmp	r3, #0	; 0x0
		setenv ("hostname", NetOurHostName);
33d14ed0:	159f0138 	ldrne	r0, [pc, #312]	; 33d15010 <netboot_common+0x288>
33d14ed4:	1b00023f 	blne	33d157d8 <setenv>

	if (NetOurRootPath[0])
33d14ed8:	e59f1134 	ldr	r1, [pc, #308]	; 33d15014 <netboot_common+0x28c>
33d14edc:	e5d13000 	ldrb	r3, [r1]
33d14ee0:	e3530000 	cmp	r3, #0	; 0x0
		setenv ("rootpath", NetOurRootPath);
33d14ee4:	159f012c 	ldrne	r0, [pc, #300]	; 33d15018 <netboot_common+0x290>
33d14ee8:	1b00023a 	blne	33d157d8 <setenv>

	if (NetOurIP) {
33d14eec:	e59f3128 	ldr	r3, [pc, #296]	; 33d1501c <netboot_common+0x294>
33d14ef0:	e5930000 	ldr	r0, [r3]
33d14ef4:	e3500000 	cmp	r0, #0	; 0x0
33d14ef8:	0a000005 	beq	33d14f14 <netboot_common+0x18c>
		ip_to_string (NetOurIP, tmp);
33d14efc:	e28d4008 	add	r4, sp, #8	; 0x8
33d14f00:	e1a01004 	mov	r1, r4
33d14f04:	ebffb542 	bl	33d02414 <ip_to_string>
		setenv ("ipaddr", tmp);
33d14f08:	e1a01004 	mov	r1, r4
33d14f0c:	e59f010c 	ldr	r0, [pc, #268]	; 33d15020 <netboot_common+0x298>
33d14f10:	eb000230 	bl	33d157d8 <setenv>
	}

	if (NetServerIP) {
33d14f14:	e59f3108 	ldr	r3, [pc, #264]	; 33d15024 <netboot_common+0x29c>
33d14f18:	e5930000 	ldr	r0, [r3]
33d14f1c:	e3500000 	cmp	r0, #0	; 0x0
33d14f20:	0a000005 	beq	33d14f3c <netboot_common+0x1b4>
		ip_to_string (NetServerIP, tmp);
33d14f24:	e28d4008 	add	r4, sp, #8	; 0x8
33d14f28:	e1a01004 	mov	r1, r4
33d14f2c:	ebffb538 	bl	33d02414 <ip_to_string>
		setenv ("serverip", tmp);
33d14f30:	e1a01004 	mov	r1, r4
33d14f34:	e59f00ec 	ldr	r0, [pc, #236]	; 33d15028 <netboot_common+0x2a0>
33d14f38:	eb000226 	bl	33d157d8 <setenv>
	}

	if (NetOurDNSIP) {
33d14f3c:	e59f30e8 	ldr	r3, [pc, #232]	; 33d1502c <netboot_common+0x2a4>
33d14f40:	e5930000 	ldr	r0, [r3]
33d14f44:	e3500000 	cmp	r0, #0	; 0x0
33d14f48:	0a000005 	beq	33d14f64 <netboot_common+0x1dc>
		ip_to_string (NetOurDNSIP, tmp);
33d14f4c:	e28d4008 	add	r4, sp, #8	; 0x8
33d14f50:	e1a01004 	mov	r1, r4
33d14f54:	ebffb52e 	bl	33d02414 <ip_to_string>
		setenv ("dnsip", tmp);
33d14f58:	e1a01004 	mov	r1, r4
33d14f5c:	e59f00cc 	ldr	r0, [pc, #204]	; 33d15030 <netboot_common+0x2a8>
33d14f60:	eb00021c 	bl	33d157d8 <setenv>
	if (NetOurDNS2IP) {
		ip_to_string (NetOurDNS2IP, tmp);
		setenv ("dnsip2", tmp);
	}
#endif
	if (NetOurNISDomain[0])
33d14f64:	e59f10c8 	ldr	r1, [pc, #200]	; 33d15034 <netboot_common+0x2ac>
33d14f68:	e5d13000 	ldrb	r3, [r1]
33d14f6c:	e3530000 	cmp	r3, #0	; 0x0
		setenv ("domain", NetOurNISDomain);
33d14f70:	159f00c0 	ldrne	r0, [pc, #192]	; 33d15038 <netboot_common+0x2b0>
33d14f74:	1b000217 	blne	33d157d8 <setenv>

	/* NetLoop ok, update environment */
	netboot_update_env();

	/* done if no file was loaded (no errors though) */
	if (size == 0)
33d14f78:	e3560000 	cmp	r6, #0	; 0x0
		return 0;
33d14f7c:	01a00006 	moveq	r0, r6

	/* NetLoop ok, update environment */
	netboot_update_env();

	/* done if no file was loaded (no errors though) */
	if (size == 0)
33d14f80:	0a000017 	beq	33d14fe4 <netboot_common+0x25c>
		return 0;

	/* flush cache */
	flush_cache(load_addr, size);
33d14f84:	e59f5064 	ldr	r5, [pc, #100]	; 33d14ff0 <netboot_common+0x268>
33d14f88:	e1a01006 	mov	r1, r6
33d14f8c:	e5950000 	ldr	r0, [r5]
33d14f90:	eb00275d 	bl	33d1ed0c <flush_cache>

	/* Loading ok, check if we should attempt an auto-start */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s,"yes") == 0)) {
33d14f94:	e59f00a0 	ldr	r0, [pc, #160]	; 33d1503c <netboot_common+0x2b4>
33d14f98:	eb00022c 	bl	33d15850 <getenv>
33d14f9c:	e3500000 	cmp	r0, #0	; 0x0
33d14fa0:	0a00000e 	beq	33d14fe0 <netboot_common+0x258>
33d14fa4:	e59f1094 	ldr	r1, [pc, #148]	; 33d15040 <netboot_common+0x2b8>
33d14fa8:	eb00142e 	bl	33d1a068 <strcmp>
33d14fac:	e2504000 	subs	r4, r0, #0	; 0x0
33d14fb0:	1a00000a 	bne	33d14fe0 <netboot_common+0x258>
		char *local_args[2];
		local_args[0] = argv[0];
33d14fb4:	e5973000 	ldr	r3, [r7]
		local_args[1] = NULL;

		printf ("Automatic boot of image at addr 0x%08lX ...\n",
33d14fb8:	e5951000 	ldr	r1, [r5]
33d14fbc:	e59f0080 	ldr	r0, [pc, #128]	; 33d15044 <netboot_common+0x2bc>
	flush_cache(load_addr, size);

	/* Loading ok, check if we should attempt an auto-start */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s,"yes") == 0)) {
		char *local_args[2];
		local_args[0] = argv[0];
33d14fc0:	e88d0018 	stm	sp, {r3, r4}
		local_args[1] = NULL;

		printf ("Automatic boot of image at addr 0x%08lX ...\n",
33d14fc4:	eb0007ff 	bl	33d16fc8 <printf>
			load_addr);
		rcode = do_bootm (cmdtp, 0, 1, local_args);
33d14fc8:	e1a00009 	mov	r0, r9
33d14fcc:	e1a01004 	mov	r1, r4
33d14fd0:	e1a0300d 	mov	r3, sp
33d14fd4:	e3a02001 	mov	r2, #1	; 0x1
33d14fd8:	ebffe375 	bl	33d0ddb4 <do_bootm>
33d14fdc:	e1a0a000 	mov	sl, r0
	if (((s = getenv("autoscript")) != NULL) && (strcmp(s,"yes") == 0)) {
		printf("Running autoscript at addr 0x%08lX ...\n", load_addr);
		rcode = autoscript (load_addr);
	}
#endif
	return rcode;
33d14fe0:	e1a0000a 	mov	r0, sl
}
33d14fe4:	e28dd020 	add	sp, sp, #32	; 0x20
33d14fe8:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d14fec:	33d25514 	.word	0x33d25514
33d14ff0:	33d35fec 	.word	0x33d35fec
33d14ff4:	33d37340 	.word	0x33d37340
33d14ff8:	33d27008 	.word	0x33d27008
33d14ffc:	33d37304 	.word	0x33d37304
33d15000:	33d25870 	.word	0x33d25870
33d15004:	33d37308 	.word	0x33d37308
33d15008:	33d2587c 	.word	0x33d2587c
33d1500c:	33d372be 	.word	0x33d372be
33d15010:	33d2b264 	.word	0x33d2b264
33d15014:	33d3727e 	.word	0x33d3727e
33d15018:	33d2b270 	.word	0x33d2b270
33d1501c:	33d37318 	.word	0x33d37318
33d15020:	33d254e4 	.word	0x33d254e4
33d15024:	33d3731c 	.word	0x33d3731c
33d15028:	33d25894 	.word	0x33d25894
33d1502c:	33d37300 	.word	0x33d37300
33d15030:	33d2b27c 	.word	0x33d2b27c
33d15034:	33d372de 	.word	0x33d372de
33d15038:	33d2b284 	.word	0x33d2b284
33d1503c:	33d27b94 	.word	0x33d27b94
33d15040:	33d2b0a0 	.word	0x33d2b0a0
33d15044:	33d2b28c 	.word	0x33d2b28c

33d15048 <do_rarpb>:
	"tftpboot- boot image via network using TFTP protocol\n",
	"[loadAddress] [bootfilename]\n"
);

int do_rarpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15048:	e1a01000 	mov	r1, r0
	return netboot_common (RARP, cmdtp, argc, argv);
33d1504c:	e3a00001 	mov	r0, #1	; 0x1
33d15050:	eaffff4c 	b	33d14d88 <netboot_common>

33d15054 <do_tftpb>:
	"bootp\t- boot image via network using BootP/TFTP protocol\n",
	"[loadAddress] [bootfilename]\n"
);

int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15054:	e1a01000 	mov	r1, r0
	return netboot_common (TFTP, cmdtp, argc, argv);
33d15058:	e3a00003 	mov	r0, #3	; 0x3
33d1505c:	eaffff49 	b	33d14d88 <netboot_common>

33d15060 <do_bootp>:
extern int do_bootm (cmd_tbl_t *, int, int, char *[]);

static int netboot_common (proto_t, cmd_tbl_t *, int , char *[]);

int do_bootp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15060:	e1a01000 	mov	r1, r0
	return netboot_common (BOOTP, cmdtp, argc, argv);
33d15064:	e3a00000 	mov	r0, #0	; 0x0
33d15068:	eaffff46 	b	33d14d88 <netboot_common>

33d1506c <do_ping>:
}

#if (CONFIG_COMMANDS & CFG_CMD_PING)
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc < 2)
33d1506c:	e3520001 	cmp	r2, #1	; 0x1
	return rcode;
}

#if (CONFIG_COMMANDS & CFG_CMD_PING)
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15070:	e92d4030 	push	{r4, r5, lr}
	if (argc < 2)
		return -1;
33d15074:	e3e02000 	mvn	r2, #0	; 0x0
	return rcode;
}

#if (CONFIG_COMMANDS & CFG_CMD_PING)
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15078:	e1a04003 	mov	r4, r3
33d1507c:	e1a05000 	mov	r5, r0
	if (argc < 2)
33d15080:	da000019 	ble	33d150ec <do_ping+0x80>
		return -1;

	NetPingIP = string_to_ip(argv[1]);
33d15084:	e5930004 	ldr	r0, [r3, #4]
33d15088:	ebffb695 	bl	33d02ae4 <string_to_ip>
33d1508c:	e59f3060 	ldr	r3, [pc, #96]	; 33d150f4 <do_ping+0x88>
33d15090:	e1a02000 	mov	r2, r0
	if (NetPingIP == 0) {
33d15094:	e3520000 	cmp	r2, #0	; 0x0
		printf ("Usage:\n%s\n", cmdtp->usage);
		return -1;
	}

	if (NetLoop(PING) < 0) {
33d15098:	e3a00005 	mov	r0, #5	; 0x5
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc < 2)
		return -1;

	NetPingIP = string_to_ip(argv[1]);
33d1509c:	e5832000 	str	r2, [r3]
	if (NetPingIP == 0) {
33d150a0:	1a000004 	bne	33d150b8 <do_ping+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
33d150a4:	e5951010 	ldr	r1, [r5, #16]
33d150a8:	e59f0048 	ldr	r0, [pc, #72]	; 33d150f8 <do_ping+0x8c>
33d150ac:	eb0007c5 	bl	33d16fc8 <printf>
		return -1;
33d150b0:	e3e02000 	mvn	r2, #0	; 0x0
33d150b4:	ea00000c 	b	33d150ec <do_ping+0x80>
	}

	if (NetLoop(PING) < 0) {
33d150b8:	ebffb6e0 	bl	33d02c40 <NetLoop>
33d150bc:	e5943004 	ldr	r3, [r4, #4]
33d150c0:	e3500000 	cmp	r0, #0	; 0x0
		printf("ping failed; host %s is not alive\n", argv[1]);
33d150c4:	e1a01003 	mov	r1, r3
33d150c8:	e59f002c 	ldr	r0, [pc, #44]	; 33d150fc <do_ping+0x90>
	if (NetPingIP == 0) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return -1;
	}

	if (NetLoop(PING) < 0) {
33d150cc:	aa000002 	bge	33d150dc <do_ping+0x70>
		printf("ping failed; host %s is not alive\n", argv[1]);
33d150d0:	eb0007bc 	bl	33d16fc8 <printf>
		return 1;
33d150d4:	e3a02001 	mov	r2, #1	; 0x1
33d150d8:	ea000003 	b	33d150ec <do_ping+0x80>
	}

	printf("host %s is alive\n", argv[1]);
33d150dc:	e1a01003 	mov	r1, r3
33d150e0:	e59f0018 	ldr	r0, [pc, #24]	; 33d15100 <do_ping+0x94>
33d150e4:	eb0007b7 	bl	33d16fc8 <printf>

	return 0;
33d150e8:	e3a02000 	mov	r2, #0	; 0x0
}
33d150ec:	e1a00002 	mov	r0, r2
33d150f0:	e8bd8030 	pop	{r4, r5, pc}
33d150f4:	33d373c0 	.word	0x33d373c0
33d150f8:	33d27008 	.word	0x33d27008
33d150fc:	33d2b2bc 	.word	0x33d2b2bc
33d15100:	33d2b2e0 	.word	0x33d2b2e0

33d15104 <envmatch>:
 * If the names match, return the index for the value2, else NULL.
 */

static int
envmatch (uchar *s1, int i2)
{
33d15104:	e92d4070 	push	{r4, r5, r6, lr}
33d15108:	e1a05000 	mov	r5, r0
33d1510c:	e1a04001 	mov	r4, r1

	while (*s1 == env_get_char(i2++))
33d15110:	ea000001 	b	33d1511c <envmatch+0x18>
		if (*s1++ == '=')
33d15114:	e353003d 	cmp	r3, #61	; 0x3d
33d15118:	0a000011 	beq	33d15164 <envmatch+0x60>
			return(i2);
33d1511c:	e1a00004 	mov	r0, r4
33d15120:	e59f604c 	ldr	r6, [pc, #76]	; 33d15174 <envmatch+0x70>
33d15124:	e1a0e00f 	mov	lr, pc
33d15128:	e596f000 	ldr	pc, [r6]
33d1512c:	e5d53000 	ldrb	r3, [r5]
33d15130:	e20000ff 	and	r0, r0, #255	; 0xff
33d15134:	e1530000 	cmp	r3, r0
static int
envmatch (uchar *s1, int i2)
{

	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
33d15138:	e2855001 	add	r5, r5, #1	; 0x1
			return(i2);
33d1513c:	e2844001 	add	r4, r4, #1	; 0x1
33d15140:	0afffff3 	beq	33d15114 <envmatch+0x10>
	if (*s1 == '\0' && env_get_char(i2-1) == '=')
33d15144:	e3530000 	cmp	r3, #0	; 0x0
33d15148:	1a000007 	bne	33d1516c <envmatch+0x68>
33d1514c:	e2440001 	sub	r0, r4, #1	; 0x1
33d15150:	e1a0e00f 	mov	lr, pc
33d15154:	e596f000 	ldr	pc, [r6]
33d15158:	e20000ff 	and	r0, r0, #255	; 0xff
33d1515c:	e350003d 	cmp	r0, #61	; 0x3d
33d15160:	1a000001 	bne	33d1516c <envmatch+0x68>
envmatch (uchar *s1, int i2)
{

	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
			return(i2);
33d15164:	e1a00004 	mov	r0, r4
33d15168:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (*s1 == '\0' && env_get_char(i2-1) == '=')
		return(i2);
	return(-1);
33d1516c:	e3e00000 	mvn	r0, #0	; 0x0
}
33d15170:	e8bd8070 	pop	{r4, r5, r6, pc}
33d15174:	33d36574 	.word	0x33d36574

33d15178 <do_printenv>:
/************************************************************************
 * Command interface: print one or all environment variables
 */

int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15178:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d1517c:	e24dd008 	sub	sp, sp, #8	; 0x8
	int i, j, k, nxt;
	int rcode = 0;

	if (argc == 1) {		/* Print all env variables	*/
33d15180:	e3520001 	cmp	r2, #1	; 0x1
/************************************************************************
 * Command interface: print one or all environment variables
 */

int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15184:	e58d3004 	str	r3, [sp, #4]
	int i, j, k, nxt;
	int rcode = 0;
33d15188:	e3a03000 	mov	r3, #0	; 0x0
/************************************************************************
 * Command interface: print one or all environment variables
 */

int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d1518c:	e1a09002 	mov	r9, r2
	int i, j, k, nxt;
	int rcode = 0;
33d15190:	e58d3000 	str	r3, [sp]

	if (argc == 1) {		/* Print all env variables	*/
		for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
33d15194:	01a07003 	moveq	r7, r3
int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int i, j, k, nxt;
	int rcode = 0;

	if (argc == 1) {		/* Print all env variables	*/
33d15198:	0a000018 	beq	33d15200 <do_printenv+0x88>
33d1519c:	ea000027 	b	33d15240 <do_printenv+0xc8>
		for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
			for (nxt=i; env_get_char(nxt) != '\0'; ++nxt)
33d151a0:	e1a05007 	mov	r5, r7
33d151a4:	ea000000 	b	33d151ac <do_printenv+0x34>
33d151a8:	e2855001 	add	r5, r5, #1	; 0x1
33d151ac:	e1a00005 	mov	r0, r5
33d151b0:	e1a0e00f 	mov	lr, pc
33d151b4:	e596f000 	ldr	pc, [r6]
33d151b8:	e31000ff 	tst	r0, #255	; 0xff
33d151bc:	1afffff9 	bne	33d151a8 <do_printenv+0x30>
				;
			for (k=i; k<nxt; ++k)
33d151c0:	e1a04007 	mov	r4, r7
33d151c4:	e1540005 	cmp	r4, r5
33d151c8:	aa000006 	bge	33d151e8 <do_printenv+0x70>
				putc(env_get_char(k));
33d151cc:	e1a00004 	mov	r0, r4
33d151d0:	e1a0e00f 	mov	lr, pc
33d151d4:	e596f000 	ldr	pc, [r6]
33d151d8:	e20000ff 	and	r0, r0, #255	; 0xff

	if (argc == 1) {		/* Print all env variables	*/
		for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
			for (nxt=i; env_get_char(nxt) != '\0'; ++nxt)
				;
			for (k=i; k<nxt; ++k)
33d151dc:	e2844001 	add	r4, r4, #1	; 0x1
				putc(env_get_char(k));
33d151e0:	eb000767 	bl	33d16f84 <putc>
33d151e4:	eafffff6 	b	33d151c4 <do_printenv+0x4c>
			putc  ('\n');
33d151e8:	e3a0000a 	mov	r0, #10	; 0xa
33d151ec:	eb000764 	bl	33d16f84 <putc>

			if (ctrlc()) {
33d151f0:	eb00078d 	bl	33d1702c <ctrlc>
33d151f4:	e3500000 	cmp	r0, #0	; 0x0
33d151f8:	1a00000c 	bne	33d15230 <do_printenv+0xb8>
{
	int i, j, k, nxt;
	int rcode = 0;

	if (argc == 1) {		/* Print all env variables	*/
		for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
33d151fc:	e2857001 	add	r7, r5, #1	; 0x1
33d15200:	e59f6118 	ldr	r6, [pc, #280]	; 33d15320 <do_printenv+0x1a8>
33d15204:	e1a00007 	mov	r0, r7
33d15208:	e1a0e00f 	mov	lr, pc
33d1520c:	e596f000 	ldr	pc, [r6]
33d15210:	e21040ff 	ands	r4, r0, #255	; 0xff
33d15214:	1affffe1 	bne	33d151a0 <do_printenv+0x28>
				puts ("\n ** Abort\n");
				return 1;
			}
		}

		printf("\nEnvironment size: %d/%d bytes\n", i, ENV_SIZE);
33d15218:	e59f0104 	ldr	r0, [pc, #260]	; 33d15324 <do_printenv+0x1ac>
33d1521c:	e1a01007 	mov	r1, r7
33d15220:	e59f2100 	ldr	r2, [pc, #256]	; 33d15328 <do_printenv+0x1b0>
33d15224:	eb000767 	bl	33d16fc8 <printf>

		return 0;
33d15228:	e1a00004 	mov	r0, r4
33d1522c:	ea000039 	b	33d15318 <do_printenv+0x1a0>
			for (k=i; k<nxt; ++k)
				putc(env_get_char(k));
			putc  ('\n');

			if (ctrlc()) {
				puts ("\n ** Abort\n");
33d15230:	e59f00f4 	ldr	r0, [pc, #244]	; 33d1532c <do_printenv+0x1b4>
33d15234:	eb00075c 	bl	33d16fac <puts>
				return 1;
33d15238:	e3a00001 	mov	r0, #1	; 0x1
33d1523c:	ea000035 	b	33d15318 <do_printenv+0x1a0>
		printf("\nEnvironment size: %d/%d bytes\n", i, ENV_SIZE);

		return 0;
	}

	for (i=1; i<argc; ++i) {	/* print single env variables	*/
33d15240:	e3a07001 	mov	r7, #1	; 0x1
33d15244:	e1570009 	cmp	r7, r9
33d15248:	aa000031 	bge	33d15314 <do_printenv+0x19c>
		char *name = argv[i];
33d1524c:	e59d3004 	ldr	r3, [sp, #4]

		k = -1;
33d15250:	e3e04000 	mvn	r4, #0	; 0x0

		return 0;
	}

	for (i=1; i<argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];
33d15254:	e793a107 	ldr	sl, [r3, r7, lsl #2]

		k = -1;

		for (j=0; env_get_char(j) != '\0'; j=nxt+1) {
33d15258:	e3a06000 	mov	r6, #0	; 0x0
33d1525c:	ea00001c 	b	33d152d4 <do_printenv+0x15c>

			for (nxt=j; env_get_char(nxt) != '\0'; ++nxt)
33d15260:	e1a05006 	mov	r5, r6
33d15264:	ea000000 	b	33d1526c <do_printenv+0xf4>
33d15268:	e2855001 	add	r5, r5, #1	; 0x1
33d1526c:	e1a00005 	mov	r0, r5
33d15270:	e1a0e00f 	mov	lr, pc
33d15274:	e59bf000 	ldr	pc, [fp]
33d15278:	e31000ff 	tst	r0, #255	; 0xff
33d1527c:	1afffff9 	bne	33d15268 <do_printenv+0xf0>
				;
			k = envmatch((uchar *)name, j);
33d15280:	e1a01006 	mov	r1, r6
33d15284:	e1a0000a 	mov	r0, sl
33d15288:	ebffff9d 	bl	33d15104 <envmatch>
			if (k < 0) {
33d1528c:	e2504000 	subs	r4, r0, #0	; 0x0
33d15290:	ba00000e 	blt	33d152d0 <do_printenv+0x158>
				continue;
			}
			puts (name);
33d15294:	e1a0000a 	mov	r0, sl
33d15298:	eb000743 	bl	33d16fac <puts>
			putc ('=');
33d1529c:	e3a0003d 	mov	r0, #61	; 0x3d
33d152a0:	eb000737 	bl	33d16f84 <putc>
			while (k < nxt)
				putc(env_get_char(k++));
33d152a4:	e1540005 	cmp	r4, r5
33d152a8:	aa000005 	bge	33d152c4 <do_printenv+0x14c>
33d152ac:	e1a00004 	mov	r0, r4
33d152b0:	e1a0e00f 	mov	lr, pc
33d152b4:	e59bf000 	ldr	pc, [fp]
33d152b8:	e2844001 	add	r4, r4, #1	; 0x1
33d152bc:	e20000ff 	and	r0, r0, #255	; 0xff
33d152c0:	eafffff6 	b	33d152a0 <do_printenv+0x128>
			putc ('\n');
33d152c4:	e3a0000a 	mov	r0, #10	; 0xa
33d152c8:	eb00072d 	bl	33d16f84 <putc>
			break;
33d152cc:	ea000006 	b	33d152ec <do_printenv+0x174>
	for (i=1; i<argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;

		for (j=0; env_get_char(j) != '\0'; j=nxt+1) {
33d152d0:	e2856001 	add	r6, r5, #1	; 0x1
33d152d4:	e59fb044 	ldr	fp, [pc, #68]	; 33d15320 <do_printenv+0x1a8>
33d152d8:	e1a00006 	mov	r0, r6
33d152dc:	e1a0e00f 	mov	lr, pc
33d152e0:	e59bf000 	ldr	pc, [fp]
33d152e4:	e31000ff 	tst	r0, #255	; 0xff
33d152e8:	1affffdc 	bne	33d15260 <do_printenv+0xe8>
			while (k < nxt)
				putc(env_get_char(k++));
			putc ('\n');
			break;
		}
		if (k < 0) {
33d152ec:	e3540000 	cmp	r4, #0	; 0x0
33d152f0:	aa000005 	bge	33d1530c <do_printenv+0x194>
			printf ("## Error: \"%s\" not defined\n", name);
33d152f4:	e1a0100a 	mov	r1, sl
33d152f8:	e59f0030 	ldr	r0, [pc, #48]	; 33d15330 <do_printenv+0x1b8>
33d152fc:	eb000731 	bl	33d16fc8 <printf>
			rcode ++;
33d15300:	e59d3000 	ldr	r3, [sp]
33d15304:	e2833001 	add	r3, r3, #1	; 0x1
33d15308:	e58d3000 	str	r3, [sp]
		printf("\nEnvironment size: %d/%d bytes\n", i, ENV_SIZE);

		return 0;
	}

	for (i=1; i<argc; ++i) {	/* print single env variables	*/
33d1530c:	e2877001 	add	r7, r7, #1	; 0x1
33d15310:	eaffffcb 	b	33d15244 <do_printenv+0xcc>
		if (k < 0) {
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
		}
	}
	return rcode;
33d15314:	e59d0000 	ldr	r0, [sp]
}
33d15318:	e28dd008 	add	sp, sp, #8	; 0x8
33d1531c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d15320:	33d36574 	.word	0x33d36574
33d15324:	33d2b510 	.word	0x33d2b510
33d15328:	0001fffc 	.word	0x0001fffc
33d1532c:	33d2b530 	.word	0x33d2b530
33d15330:	33d270c0 	.word	0x33d270c0

33d15334 <_do_setenv>:
 *
 * This function will ONLY work with a in-RAM copy of the environment
 */

int _do_setenv (int flag, int argc, char *argv[])
{
33d15334:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d15338:	e24dd010 	sub	sp, sp, #16	; 0x10
33d1533c:	e58d1004 	str	r1, [sp, #4]
33d15340:	e1a0a002 	mov	sl, r2
	int   i, len, oldval;
	int   console = -1;
	uchar *env, *nxt = NULL;
	char *name;
	bd_t *bd = gd->bd;
33d15344:	e5982000 	ldr	r2, [r8]

	uchar *env_data = env_get_addr(0);
33d15348:	e3a00000 	mov	r0, #0	; 0x0
{
	int   i, len, oldval;
	int   console = -1;
	uchar *env, *nxt = NULL;
	char *name;
	bd_t *bd = gd->bd;
33d1534c:	e58d2000 	str	r2, [sp]

	uchar *env_data = env_get_addr(0);
33d15350:	eb000c3c 	bl	33d18448 <env_get_addr>

	if (!env_data)	/* need copy in RAM */
33d15354:	e250b000 	subs	fp, r0, #0	; 0x0
33d15358:	0a000094 	beq	33d155b0 <_do_setenv+0x27c>
		return 1;

	name = argv[1];
33d1535c:	e59a9004 	ldr	r9, [sl, #4]

	if (strchr(name, '=')) {
33d15360:	e3a0103d 	mov	r1, #61	; 0x3d
33d15364:	e1a00009 	mov	r0, r9
33d15368:	eb00135c 	bl	33d1a0e0 <strchr>
33d1536c:	e3500000 	cmp	r0, #0	; 0x0
		printf ("## Error: illegal character '=' in variable name \"%s\"\n", name);
33d15370:	11a01009 	movne	r1, r9
33d15374:	159f0418 	ldrne	r0, [pc, #1048]	; 33d15794 <_do_setenv+0x460>
	if (!env_data)	/* need copy in RAM */
		return 1;

	name = argv[1];

	if (strchr(name, '=')) {
33d15378:	1a00008b 	bne	33d155ac <_do_setenv+0x278>

	/*
	 * search if variable with this name already exists
	 */
	oldval = -1;
	for (env=env_data; *env; env=nxt+1) {
33d1537c:	e5db3000 	ldrb	r3, [fp]
33d15380:	e1a0400b 	mov	r4, fp
33d15384:	e3530000 	cmp	r3, #0	; 0x0
33d15388:	0a00005e 	beq	33d15508 <_do_setenv+0x1d4>
		for (nxt=env; *nxt; ++nxt)
33d1538c:	e5d43000 	ldrb	r3, [r4]
33d15390:	e1a07004 	mov	r7, r4
33d15394:	e3530000 	cmp	r3, #0	; 0x0
33d15398:	0a000002 	beq	33d153a8 <_do_setenv+0x74>
33d1539c:	e5f73001 	ldrb	r3, [r7, #1]!
33d153a0:	e3530000 	cmp	r3, #0	; 0x0
33d153a4:	eafffffb 	b	33d15398 <_do_setenv+0x64>
			;
		if ((oldval = envmatch((uchar *)name, env-env_data)) >= 0)
33d153a8:	e1a00009 	mov	r0, r9
33d153ac:	e06b1004 	rsb	r1, fp, r4
33d153b0:	ebffff53 	bl	33d15104 <envmatch>
33d153b4:	e3500000 	cmp	r0, #0	; 0x0
33d153b8:	aa000003 	bge	33d153cc <_do_setenv+0x98>

	/*
	 * search if variable with this name already exists
	 */
	oldval = -1;
	for (env=env_data; *env; env=nxt+1) {
33d153bc:	e5d73001 	ldrb	r3, [r7, #1]
33d153c0:	e2874001 	add	r4, r7, #1	; 0x1
33d153c4:	e3530000 	cmp	r3, #0	; 0x0
33d153c8:	eaffffee 	b	33d15388 <_do_setenv+0x54>
			return 1;
		}
#endif

		/* Check for console redirection */
		if (strcmp(name,"stdin") == 0) {
33d153cc:	e1a00009 	mov	r0, r9
33d153d0:	e59f13c0 	ldr	r1, [pc, #960]	; 33d15798 <_do_setenv+0x464>
33d153d4:	eb001323 	bl	33d1a068 <strcmp>
33d153d8:	e3500000 	cmp	r0, #0	; 0x0
33d153dc:	0a00000b 	beq	33d15410 <_do_setenv+0xdc>
			console = stdin;
		} else if (strcmp(name,"stdout") == 0) {
33d153e0:	e1a00009 	mov	r0, r9
33d153e4:	e59f13b0 	ldr	r1, [pc, #944]	; 33d1579c <_do_setenv+0x468>
33d153e8:	eb00131e 	bl	33d1a068 <strcmp>
33d153ec:	e3500000 	cmp	r0, #0	; 0x0
			console = stdout;
33d153f0:	02800001 	addeq	r0, r0, #1	; 0x1
#endif

		/* Check for console redirection */
		if (strcmp(name,"stdin") == 0) {
			console = stdin;
		} else if (strcmp(name,"stdout") == 0) {
33d153f4:	0a000005 	beq	33d15410 <_do_setenv+0xdc>
			console = stdout;
		} else if (strcmp(name,"stderr") == 0) {
33d153f8:	e1a00009 	mov	r0, r9
33d153fc:	e59f139c 	ldr	r1, [pc, #924]	; 33d157a0 <_do_setenv+0x46c>
33d15400:	eb001318 	bl	33d1a068 <strcmp>
33d15404:	e3500000 	cmp	r0, #0	; 0x0
33d15408:	1a000009 	bne	33d15434 <_do_setenv+0x100>
			console = stderr;
33d1540c:	e2800002 	add	r0, r0, #2	; 0x2
		}

		if (console != -1) {
			if (argc < 3) {		/* Cannot delete it! */
33d15410:	e59d3004 	ldr	r3, [sp, #4]
33d15414:	e3530002 	cmp	r3, #2	; 0x2
				printf("Can't delete \"%s\"\n", name);
33d15418:	d1a01009 	movle	r1, r9
33d1541c:	d59f0380 	ldrle	r0, [pc, #896]	; 33d157a4 <_do_setenv+0x470>
		} else if (strcmp(name,"stderr") == 0) {
			console = stderr;
		}

		if (console != -1) {
			if (argc < 3) {		/* Cannot delete it! */
33d15420:	da000061 	ble	33d155ac <_do_setenv+0x278>
				printf("Can't delete \"%s\"\n", name);
				return 1;
			}

			/* Try assigning specified device */
			if (console_assign (console, argv[2]) < 0)
33d15424:	e59a1008 	ldr	r1, [sl, #8]
33d15428:	eb000727 	bl	33d170cc <console_assign>
33d1542c:	e3500000 	cmp	r0, #0	; 0x0
33d15430:	ba00005e 	blt	33d155b0 <_do_setenv+0x27c>
		}

		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(argv[1],"baudrate") == 0) {
33d15434:	e59a0004 	ldr	r0, [sl, #4]
33d15438:	e59f1368 	ldr	r1, [pc, #872]	; 33d157a8 <_do_setenv+0x474>
33d1543c:	eb001309 	bl	33d1a068 <strcmp>
33d15440:	e2506000 	subs	r6, r0, #0	; 0x0
33d15444:	1a00001c 	bne	33d154bc <_do_setenv+0x188>
			int baudrate = simple_strtoul(argv[2], NULL, 10);
33d15448:	e59a0008 	ldr	r0, [sl, #8]
33d1544c:	e1a01006 	mov	r1, r6
33d15450:	e3a0200a 	mov	r2, #10	; 0xa
33d15454:	eb001440 	bl	33d1a55c <simple_strtoul>
33d15458:	e1a05000 	mov	r5, r0
			int i;
			for (i=0; i<N_BAUDRATES; ++i) {
33d1545c:	e1a00006 	mov	r0, r6
				if (baudrate == baudrate_table[i])
33d15460:	e59f3344 	ldr	r3, [pc, #836]	; 33d157ac <_do_setenv+0x478>
33d15464:	e7933100 	ldr	r3, [r3, r0, lsl #2]
33d15468:	e1550003 	cmp	r5, r3
33d1546c:	0a000002 	beq	33d1547c <_do_setenv+0x148>
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(argv[1],"baudrate") == 0) {
			int baudrate = simple_strtoul(argv[2], NULL, 10);
			int i;
			for (i=0; i<N_BAUDRATES; ++i) {
33d15470:	e2800001 	add	r0, r0, #1	; 0x1
33d15474:	e3500004 	cmp	r0, #4	; 0x4
33d15478:	9afffff8 	bls	33d15460 <_do_setenv+0x12c>
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
33d1547c:	e3500005 	cmp	r0, #5	; 0x5
				printf ("## Baudrate %d bps not supported\n",
33d15480:	01a01005 	moveq	r1, r5
33d15484:	059f0324 	ldreq	r0, [pc, #804]	; 33d157b0 <_do_setenv+0x47c>
			int i;
			for (i=0; i<N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
33d15488:	0a000047 	beq	33d155ac <_do_setenv+0x278>
				printf ("## Baudrate %d bps not supported\n",
					baudrate);
				return 1;
			}
			printf ("## Switch baudrate to %d bps and press ENTER ...\n",
33d1548c:	e1a01005 	mov	r1, r5
33d15490:	e59f031c 	ldr	r0, [pc, #796]	; 33d157b4 <_do_setenv+0x480>
33d15494:	eb0006cb 	bl	33d16fc8 <printf>
				baudrate);
			udelay(50000);
33d15498:	e59f0318 	ldr	r0, [pc, #792]	; 33d157b8 <_do_setenv+0x484>
33d1549c:	ebffae5a 	bl	33d00e0c <udelay>
			gd->baudrate = baudrate;
33d154a0:	e5885008 	str	r5, [r8, #8]
#ifdef CONFIG_PPC
			gd->bd->bi_baudrate = baudrate;
#endif

			serial_setbrg ();
33d154a4:	eb002386 	bl	33d1e2c4 <serial_setbrg>
			udelay(50000);
33d154a8:	e59f0308 	ldr	r0, [pc, #776]	; 33d157b8 <_do_setenv+0x484>
33d154ac:	ebffae56 	bl	33d00e0c <udelay>
			for (;;) {
				if (getc() == '\r')
33d154b0:	eb0006a7 	bl	33d16f54 <getc>
33d154b4:	e350000d 	cmp	r0, #13	; 0xd
33d154b8:	1afffffc 	bne	33d154b0 <_do_setenv+0x17c>
				      break;
			}
		}

		if (*++nxt == '\0') {
33d154bc:	e5f73001 	ldrb	r3, [r7, #1]!
33d154c0:	e3530000 	cmp	r3, #0	; 0x0
33d154c4:	1a000003 	bne	33d154d8 <_do_setenv+0x1a4>
			if (env > env_data) {
33d154c8:	e154000b 	cmp	r4, fp
				env--;
33d154cc:	82444001 	subhi	r4, r4, #1	; 0x1
			} else {
				*env = '\0';
33d154d0:	95c43000 	strbls	r3, [r4]
33d154d4:	ea000009 	b	33d15500 <_do_setenv+0x1cc>
			}
		} else {
			for (;;) {
				*env = *nxt++;
33d154d8:	e4d73001 	ldrb	r3, [r7], #1
33d154dc:	e5c43000 	strb	r3, [r4]
				if ((*env == '\0') && (*nxt == '\0'))
33d154e0:	e5d43000 	ldrb	r3, [r4]
33d154e4:	e3530000 	cmp	r3, #0	; 0x0
33d154e8:	1a000002 	bne	33d154f8 <_do_setenv+0x1c4>
33d154ec:	e5d73000 	ldrb	r3, [r7]
33d154f0:	e3530000 	cmp	r3, #0	; 0x0
33d154f4:	0a000001 	beq	33d15500 <_do_setenv+0x1cc>
					break;
				++env;
33d154f8:	e2844001 	add	r4, r4, #1	; 0x1
				env--;
			} else {
				*env = '\0';
			}
		} else {
			for (;;) {
33d154fc:	eafffff5 	b	33d154d8 <_do_setenv+0x1a4>
				if ((*env == '\0') && (*nxt == '\0'))
					break;
				++env;
			}
		}
		*++env = '\0';
33d15500:	e3a03000 	mov	r3, #0	; 0x0
33d15504:	e5c43001 	strb	r3, [r4, #1]
	}
#endif


	/* Delete only ? */
	if ((argc < 3) || argv[2] == NULL) {
33d15508:	e59d2004 	ldr	r2, [sp, #4]
33d1550c:	e3520002 	cmp	r2, #2	; 0x2
33d15510:	da000004 	ble	33d15528 <_do_setenv+0x1f4>
33d15514:	e59a3008 	ldr	r3, [sl, #8]
33d15518:	e3530000 	cmp	r3, #0	; 0x0
	}

	/*
	 * Append new definition at the end
	 */
	for (env=env_data; *env || *(env+1); ++env)
33d1551c:	11a0400b 	movne	r4, fp
33d15520:	15d43000 	ldrbne	r3, [r4]
	}
#endif


	/* Delete only ? */
	if ((argc < 3) || argv[2] == NULL) {
33d15524:	1a000001 	bne	33d15530 <_do_setenv+0x1fc>
		env_crc_update ();
33d15528:	eb000ba9 	bl	33d183d4 <env_crc_update>
33d1552c:	ea000056 	b	33d1568c <_do_setenv+0x358>
	}

	/*
	 * Append new definition at the end
	 */
	for (env=env_data; *env || *(env+1); ++env)
33d15530:	e3530000 	cmp	r3, #0	; 0x0
33d15534:	1a000002 	bne	33d15544 <_do_setenv+0x210>
33d15538:	e5d43001 	ldrb	r3, [r4, #1]
33d1553c:	e3530000 	cmp	r3, #0	; 0x0
33d15540:	0a000001 	beq	33d1554c <_do_setenv+0x218>
33d15544:	e5f43001 	ldrb	r3, [r4, #1]!
33d15548:	eafffff8 	b	33d15530 <_do_setenv+0x1fc>
		;
	if (env > env_data)
33d1554c:	e154000b 	cmp	r4, fp
		++env;
	/*
	 * Overflow when:
	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
	 */
	len = strlen(name) + 2;
33d15550:	e1a00009 	mov	r0, r9
	 * Append new definition at the end
	 */
	for (env=env_data; *env || *(env+1); ++env)
		;
	if (env > env_data)
		++env;
33d15554:	82844001 	addhi	r4, r4, #1	; 0x1
	/*
	 * Overflow when:
	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
	 */
	len = strlen(name) + 2;
33d15558:	eb0012ec 	bl	33d1a110 <strlen>
	/* add '=' for first arg, ' ' for all others */
	for (i=2; i<argc; ++i) {
33d1555c:	e59d3004 	ldr	r3, [sp, #4]
33d15560:	e3a06002 	mov	r6, #2	; 0x2
33d15564:	e1560003 	cmp	r6, r3
		++env;
	/*
	 * Overflow when:
	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
	 */
	len = strlen(name) + 2;
33d15568:	e0805006 	add	r5, r0, r6
	/* add '=' for first arg, ' ' for all others */
	for (i=2; i<argc; ++i) {
33d1556c:	aa000007 	bge	33d15590 <_do_setenv+0x25c>
		len += strlen(argv[i]) + 1;
33d15570:	e79a0106 	ldr	r0, [sl, r6, lsl #2]
33d15574:	eb0012e5 	bl	33d1a110 <strlen>
	 * Overflow when:
	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
	 */
	len = strlen(name) + 2;
	/* add '=' for first arg, ' ' for all others */
	for (i=2; i<argc; ++i) {
33d15578:	e59d2004 	ldr	r2, [sp, #4]
33d1557c:	e2866001 	add	r6, r6, #1	; 0x1
		len += strlen(argv[i]) + 1;
33d15580:	e0850000 	add	r0, r5, r0
	 * Overflow when:
	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
	 */
	len = strlen(name) + 2;
	/* add '=' for first arg, ' ' for all others */
	for (i=2; i<argc; ++i) {
33d15584:	e1560002 	cmp	r6, r2
		len += strlen(argv[i]) + 1;
33d15588:	e2805001 	add	r5, r0, #1	; 0x1
33d1558c:	eafffff6 	b	33d1556c <_do_setenv+0x238>
	}
	if (len > (&env_data[ENV_SIZE]-env)) {
33d15590:	e064300b 	rsb	r3, r4, fp
33d15594:	e2833b7f 	add	r3, r3, #130048	; 0x1fc00
33d15598:	e2833fff 	add	r3, r3, #1020	; 0x3fc
33d1559c:	e1550003 	cmp	r5, r3
33d155a0:	da000004 	ble	33d155b8 <_do_setenv+0x284>
		printf ("## Error: environment overflow, \"%s\" deleted\n", name);
33d155a4:	e59f0210 	ldr	r0, [pc, #528]	; 33d157bc <_do_setenv+0x488>
33d155a8:	e1a01009 	mov	r1, r9
33d155ac:	eb000685 	bl	33d16fc8 <printf>
		return 1;
33d155b0:	e3a01001 	mov	r1, #1	; 0x1
33d155b4:	ea000073 	b	33d15788 <_do_setenv+0x454>
	}
	while ((*env = *name++) != '\0')
		env++;
33d155b8:	e4d93001 	ldrb	r3, [r9], #1
33d155bc:	e5c43000 	strb	r3, [r4]
33d155c0:	e3530000 	cmp	r3, #0	; 0x0
33d155c4:	0a000003 	beq	33d155d8 <_do_setenv+0x2a4>
33d155c8:	e4d93001 	ldrb	r3, [r9], #1
33d155cc:	e5e43001 	strb	r3, [r4, #1]!
33d155d0:	e3530000 	cmp	r3, #0	; 0x0
33d155d4:	eafffffa 	b	33d155c4 <_do_setenv+0x290>
	for (i=2; i<argc; ++i) {
33d155d8:	e59d3004 	ldr	r3, [sp, #4]
33d155dc:	e3a06002 	mov	r6, #2	; 0x2
33d155e0:	e1560003 	cmp	r6, r3
33d155e4:	aa00000c 	bge	33d1561c <_do_setenv+0x2e8>
		char *val = argv[i];

		*env = (i==2) ? '=' : ' ';
33d155e8:	e3560002 	cmp	r6, #2	; 0x2
33d155ec:	03a0303d 	moveq	r3, #61	; 0x3d
33d155f0:	13a03020 	movne	r3, #32	; 0x20
		return 1;
	}
	while ((*env = *name++) != '\0')
		env++;
	for (i=2; i<argc; ++i) {
		char *val = argv[i];
33d155f4:	e79a2106 	ldr	r2, [sl, r6, lsl #2]

		*env = (i==2) ? '=' : ' ';
33d155f8:	e5c43000 	strb	r3, [r4]
		while ((*++env = *val++) != '\0')
33d155fc:	e4d23001 	ldrb	r3, [r2], #1
33d15600:	e3530000 	cmp	r3, #0	; 0x0
33d15604:	e5e43001 	strb	r3, [r4, #1]!
33d15608:	1afffffb 	bne	33d155fc <_do_setenv+0x2c8>
		printf ("## Error: environment overflow, \"%s\" deleted\n", name);
		return 1;
	}
	while ((*env = *name++) != '\0')
		env++;
	for (i=2; i<argc; ++i) {
33d1560c:	e59d2004 	ldr	r2, [sp, #4]
33d15610:	e2866001 	add	r6, r6, #1	; 0x1
33d15614:	e1560002 	cmp	r6, r2
33d15618:	eafffff1 	b	33d155e4 <_do_setenv+0x2b0>
		while ((*++env = *val++) != '\0')
			;
	}

	/* end is marked with double '\0' */
	*++env = '\0';
33d1561c:	e3a05000 	mov	r5, #0	; 0x0
33d15620:	e5c45001 	strb	r5, [r4, #1]

	/* Update CRC */
	env_crc_update ();
33d15624:	eb000b6a 	bl	33d183d4 <env_crc_update>
	/*
	 * Some variables should be updated when the corresponding
	 * entry in the enviornment is changed
	 */

	if (strcmp(argv[1],"ethaddr") == 0) {
33d15628:	e59a0004 	ldr	r0, [sl, #4]
33d1562c:	e59f118c 	ldr	r1, [pc, #396]	; 33d157c0 <_do_setenv+0x48c>
33d15630:	eb00128c 	bl	33d1a068 <strcmp>
33d15634:	e1500005 	cmp	r0, r5
33d15638:	1a000015 	bne	33d15694 <_do_setenv+0x360>
33d1563c:	e59d3000 	ldr	r3, [sp]
		char *s = argv[2];	/* always use only one arg */
33d15640:	e59a4008 	ldr	r4, [sl, #8]
33d15644:	e2835008 	add	r5, r3, #8	; 0x8
33d15648:	e3a06005 	mov	r6, #5	; 0x5
		char *e;
		for (i=0; i<6; ++i) {
			bd->bi_enetaddr[i] = s ? simple_strtoul(s, &e, 16) : 0;
33d1564c:	e3540000 	cmp	r4, #0	; 0x0
33d15650:	e1a00004 	mov	r0, r4
33d15654:	e28d100c 	add	r1, sp, #12	; 0xc
33d15658:	e3a02010 	mov	r2, #16	; 0x10
33d1565c:	01a00004 	moveq	r0, r4
33d15660:	1b0013bd 	blne	33d1a55c <simple_strtoul>
			if (s) s = (*e) ? e+1 : e;
33d15664:	e3540000 	cmp	r4, #0	; 0x0

	if (strcmp(argv[1],"ethaddr") == 0) {
		char *s = argv[2];	/* always use only one arg */
		char *e;
		for (i=0; i<6; ++i) {
			bd->bi_enetaddr[i] = s ? simple_strtoul(s, &e, 16) : 0;
33d15668:	e4c50001 	strb	r0, [r5], #1
			if (s) s = (*e) ? e+1 : e;
33d1566c:	0a000004 	beq	33d15684 <_do_setenv+0x350>
33d15670:	e59d200c 	ldr	r2, [sp, #12]
33d15674:	e5d23000 	ldrb	r3, [r2]
33d15678:	e3530000 	cmp	r3, #0	; 0x0
33d1567c:	01a04002 	moveq	r4, r2
33d15680:	12824001 	addne	r4, r2, #1	; 0x1
33d15684:	e2566001 	subs	r6, r6, #1	; 0x1
33d15688:	5affffef 	bpl	33d1564c <_do_setenv+0x318>
		}
#ifdef CONFIG_NET_MULTI
		eth_set_enetaddr(0, argv[2]);
#endif
		return 0;
33d1568c:	e3a01000 	mov	r1, #0	; 0x0
33d15690:	ea00003c 	b	33d15788 <_do_setenv+0x454>
	}

	if (strcmp(argv[1],"ipaddr") == 0) {
33d15694:	e59a0004 	ldr	r0, [sl, #4]
33d15698:	e59f1124 	ldr	r1, [pc, #292]	; 33d157c4 <_do_setenv+0x490>
33d1569c:	eb001271 	bl	33d1a068 <strcmp>
33d156a0:	e3500000 	cmp	r0, #0	; 0x0
33d156a4:	1a00001f 	bne	33d15728 <_do_setenv+0x3f4>
		char *s = argv[2];	/* always use only one arg */
		char *e;
		unsigned long addr;
		bd->bi_ip_addr = 0;
33d156a8:	e59d2000 	ldr	r2, [sp]
#endif
		return 0;
	}

	if (strcmp(argv[1],"ipaddr") == 0) {
		char *s = argv[2];	/* always use only one arg */
33d156ac:	e59a4008 	ldr	r4, [sl, #8]
		char *e;
		unsigned long addr;
		bd->bi_ip_addr = 0;
33d156b0:	e5820004 	str	r0, [r2, #4]
		for (addr=0, i=0; i<4; ++i) {
33d156b4:	e1a05000 	mov	r5, r0
33d156b8:	e3a06003 	mov	r6, #3	; 0x3
			ulong val = s ? simple_strtoul(s, &e, 10) : 0;
33d156bc:	e3540000 	cmp	r4, #0	; 0x0
33d156c0:	e1a00004 	mov	r0, r4
33d156c4:	e28d1008 	add	r1, sp, #8	; 0x8
33d156c8:	e3a0200a 	mov	r2, #10	; 0xa
33d156cc:	01a00004 	moveq	r0, r4
33d156d0:	1b0013a1 	blne	33d1a55c <simple_strtoul>
			addr <<= 8;
			addr  |= (val & 0xFF);
33d156d4:	e20030ff 	and	r3, r0, #255	; 0xff
			if (s) s = (*e) ? e+1 : e;
33d156d8:	e3540000 	cmp	r4, #0	; 0x0
		unsigned long addr;
		bd->bi_ip_addr = 0;
		for (addr=0, i=0; i<4; ++i) {
			ulong val = s ? simple_strtoul(s, &e, 10) : 0;
			addr <<= 8;
			addr  |= (val & 0xFF);
33d156dc:	e1835405 	orr	r5, r3, r5, lsl #8
			if (s) s = (*e) ? e+1 : e;
33d156e0:	0a000004 	beq	33d156f8 <_do_setenv+0x3c4>
33d156e4:	e59d2008 	ldr	r2, [sp, #8]
33d156e8:	e5d23000 	ldrb	r3, [r2]
33d156ec:	e3530000 	cmp	r3, #0	; 0x0
33d156f0:	01a04002 	moveq	r4, r2
33d156f4:	12824001 	addne	r4, r2, #1	; 0x1
33d156f8:	e2566001 	subs	r6, r6, #1	; 0x1
33d156fc:	5affffee 	bpl	33d156bc <_do_setenv+0x388>
33d15700:	e2053cff 	and	r3, r5, #65280	; 0xff00
	return __arch__swab32(x);
33d15704:	e1a03403 	lsl	r3, r3, #8
33d15708:	e20528ff 	and	r2, r5, #16711680	; 0xff0000
33d1570c:	e1833c05 	orr	r3, r3, r5, lsl #24
33d15710:	e1833422 	orr	r3, r3, r2, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d15714:	e59d2000 	ldr	r2, [sp]
	return __arch__swab32(x);
33d15718:	e1833c25 	orr	r3, r3, r5, lsr #24
		}
		bd->bi_ip_addr = htonl(addr);
		return 0;
33d1571c:	e3a01000 	mov	r1, #0	; 0x0
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d15720:	e5823004 	str	r3, [r2, #4]
33d15724:	ea000017 	b	33d15788 <_do_setenv+0x454>
	}
	if (strcmp(argv[1],"loadaddr") == 0) {
33d15728:	e59a0004 	ldr	r0, [sl, #4]
33d1572c:	e59f1094 	ldr	r1, [pc, #148]	; 33d157c8 <_do_setenv+0x494>
33d15730:	eb00124c 	bl	33d1a068 <strcmp>
33d15734:	e2504000 	subs	r4, r0, #0	; 0x0
33d15738:	1a000007 	bne	33d1575c <_do_setenv+0x428>
		load_addr = simple_strtoul(argv[2], NULL, 16);
33d1573c:	e1a01004 	mov	r1, r4
33d15740:	e59a0008 	ldr	r0, [sl, #8]
33d15744:	e3a02010 	mov	r2, #16	; 0x10
33d15748:	eb001383 	bl	33d1a55c <simple_strtoul>
33d1574c:	e59f3078 	ldr	r3, [pc, #120]	; 33d157cc <_do_setenv+0x498>
		return 0;
33d15750:	e1a01004 	mov	r1, r4
		}
		bd->bi_ip_addr = htonl(addr);
		return 0;
	}
	if (strcmp(argv[1],"loadaddr") == 0) {
		load_addr = simple_strtoul(argv[2], NULL, 16);
33d15754:	e5830000 	str	r0, [r3]
		return 0;
33d15758:	ea00000a 	b	33d15788 <_do_setenv+0x454>
	}
#if (CONFIG_COMMANDS & CFG_CMD_NET)
	if (strcmp(argv[1],"bootfile") == 0) {
33d1575c:	e59f106c 	ldr	r1, [pc, #108]	; 33d157d0 <_do_setenv+0x49c>
33d15760:	e59a0004 	ldr	r0, [sl, #4]
33d15764:	eb00123f 	bl	33d1a068 <strcmp>
33d15768:	e2504000 	subs	r4, r0, #0	; 0x0
		video_set_color(video_get_attr());
		return 0;
	}
#endif	/* CONFIG_AMIGAONEG3SE */

	return 0;
33d1576c:	11a01005 	movne	r1, r5
	if (strcmp(argv[1],"loadaddr") == 0) {
		load_addr = simple_strtoul(argv[2], NULL, 16);
		return 0;
	}
#if (CONFIG_COMMANDS & CFG_CMD_NET)
	if (strcmp(argv[1],"bootfile") == 0) {
33d15770:	1a000004 	bne	33d15788 <_do_setenv+0x454>
		copy_filename (BootFile, argv[2], sizeof(BootFile));
33d15774:	e59a1008 	ldr	r1, [sl, #8]
33d15778:	e59f0054 	ldr	r0, [pc, #84]	; 33d157d4 <_do_setenv+0x4a0>
33d1577c:	e3a02080 	mov	r2, #128	; 0x80
33d15780:	ebffb30e 	bl	33d023c0 <copy_filename>
		return 0;
33d15784:	e1a01004 	mov	r1, r4
		return 0;
	}
#endif	/* CONFIG_AMIGAONEG3SE */

	return 0;
}
33d15788:	e1a00001 	mov	r0, r1
33d1578c:	e28dd010 	add	sp, sp, #16	; 0x10
33d15790:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d15794:	33d2b53c 	.word	0x33d2b53c
33d15798:	33d2b574 	.word	0x33d2b574
33d1579c:	33d2b57c 	.word	0x33d2b57c
33d157a0:	33d2b584 	.word	0x33d2b584
33d157a4:	33d2b58c 	.word	0x33d2b58c
33d157a8:	33d254ac 	.word	0x33d254ac
33d157ac:	33d249c8 	.word	0x33d249c8
33d157b0:	33d2b5a0 	.word	0x33d2b5a0
33d157b4:	33d29d5c 	.word	0x33d29d5c
33d157b8:	0000c350 	.word	0x0000c350
33d157bc:	33d2b5c4 	.word	0x33d2b5c4
33d157c0:	33d254ec 	.word	0x33d254ec
33d157c4:	33d254e4 	.word	0x33d254e4
33d157c8:	33d25514 	.word	0x33d25514
33d157cc:	33d35fec 	.word	0x33d35fec
33d157d0:	33d25520 	.word	0x33d25520
33d157d4:	33d37340 	.word	0x33d37340

33d157d8 <setenv>:

void setenv (char *varname, char *varvalue)
{
33d157d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	char *argv[4] = { "setenv", varname, varvalue, NULL };
33d157dc:	e3a0c000 	mov	ip, #0	; 0x0

	return 0;
}

void setenv (char *varname, char *varvalue)
{
33d157e0:	e24dd010 	sub	sp, sp, #16	; 0x10
	char *argv[4] = { "setenv", varname, varvalue, NULL };
33d157e4:	e59f3020 	ldr	r3, [pc, #32]	; 33d1580c <setenv+0x34>
33d157e8:	e98d0003 	stmib	sp, {r0, r1}
	_do_setenv (0, 3, argv);
33d157ec:	e1a0000c 	mov	r0, ip
33d157f0:	e3a01003 	mov	r1, #3	; 0x3
33d157f4:	e1a0200d 	mov	r2, sp
	return 0;
}

void setenv (char *varname, char *varvalue)
{
	char *argv[4] = { "setenv", varname, varvalue, NULL };
33d157f8:	e58d3000 	str	r3, [sp]
33d157fc:	e58dc00c 	str	ip, [sp, #12]
	_do_setenv (0, 3, argv);
33d15800:	ebfffecb 	bl	33d15334 <_do_setenv>
33d15804:	e28dd010 	add	sp, sp, #16	; 0x10
33d15808:	e8bd8000 	pop	{pc}
33d1580c:	33d2b3b8 	.word	0x33d2b3b8

33d15810 <do_setenv>:
}

int do_setenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc < 2) {
33d15810:	e3520001 	cmp	r2, #1	; 0x1
	char *argv[4] = { "setenv", varname, varvalue, NULL };
	_do_setenv (0, 3, argv);
}

int do_setenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15814:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d15818:	e1a0c001 	mov	ip, r1
33d1581c:	e1a0e000 	mov	lr, r0
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	return _do_setenv (flag, argc, argv);
33d15820:	e1a01002 	mov	r1, r2
}

int do_setenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
33d15824:	e59f0020 	ldr	r0, [pc, #32]	; 33d1584c <do_setenv+0x3c>
		return 1;
	}

	return _do_setenv (flag, argc, argv);
33d15828:	e1a02003 	mov	r2, r3
	_do_setenv (0, 3, argv);
}

int do_setenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc < 2) {
33d1582c:	da000002 	ble	33d1583c <do_setenv+0x2c>
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	return _do_setenv (flag, argc, argv);
33d15830:	e1a0000c 	mov	r0, ip
}
33d15834:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	return _do_setenv (flag, argc, argv);
33d15838:	eafffebd 	b	33d15334 <_do_setenv>
}

int do_setenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
33d1583c:	e59e1010 	ldr	r1, [lr, #16]
33d15840:	eb0005e0 	bl	33d16fc8 <printf>
		return 1;
	}

	return _do_setenv (flag, argc, argv);
}
33d15844:	e3a00001 	mov	r0, #1	; 0x1
33d15848:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1584c:	33d27008 	.word	0x33d27008

33d15850 <getenv>:
 * return address of storage for that variable,
 * or NULL if not found
 */

char *getenv (char *name)
{
33d15850:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d15854:	e1a07000 	mov	r7, r0
	int i, nxt;

	WATCHDOG_RESET();

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
33d15858:	e3a05000 	mov	r5, #0	; 0x0
33d1585c:	ea000011 	b	33d158a8 <getenv+0x58>
		int val;

		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
33d15860:	e1a04005 	mov	r4, r5
33d15864:	ea000002 	b	33d15874 <getenv+0x24>
			if (nxt >= CFG_ENV_SIZE) {
33d15868:	e3540802 	cmp	r4, #131072	; 0x20000
33d1586c:	aa000013 	bge	33d158c0 <getenv+0x70>
	WATCHDOG_RESET();

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
		int val;

		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
33d15870:	e2844001 	add	r4, r4, #1	; 0x1
33d15874:	e1a00004 	mov	r0, r4
33d15878:	e1a0e00f 	mov	lr, pc
33d1587c:	e596f000 	ldr	pc, [r6]
33d15880:	e31000ff 	tst	r0, #255	; 0xff
33d15884:	1afffff7 	bne	33d15868 <getenv+0x18>
			if (nxt >= CFG_ENV_SIZE) {
				return (NULL);
			}
		}
		if ((val=envmatch((uchar *)name, i)) < 0)
33d15888:	e1a01005 	mov	r1, r5
33d1588c:	e1a00007 	mov	r0, r7
33d15890:	ebfffe1b 	bl	33d15104 <envmatch>
33d15894:	e3500000 	cmp	r0, #0	; 0x0
33d15898:	ba000001 	blt	33d158a4 <getenv+0x54>
			continue;
		return ((char *)env_get_addr(val));
	}

	return (NULL);
}
33d1589c:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
				return (NULL);
			}
		}
		if ((val=envmatch((uchar *)name, i)) < 0)
			continue;
		return ((char *)env_get_addr(val));
33d158a0:	ea000ae8 	b	33d18448 <env_get_addr>
{
	int i, nxt;

	WATCHDOG_RESET();

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
33d158a4:	e2845001 	add	r5, r4, #1	; 0x1
33d158a8:	e59f6018 	ldr	r6, [pc, #24]	; 33d158c8 <getenv+0x78>
33d158ac:	e1a00005 	mov	r0, r5
33d158b0:	e1a0e00f 	mov	lr, pc
33d158b4:	e596f000 	ldr	pc, [r6]
33d158b8:	e31000ff 	tst	r0, #255	; 0xff
33d158bc:	1affffe7 	bne	33d15860 <getenv+0x10>
			continue;
		return ((char *)env_get_addr(val));
	}

	return (NULL);
}
33d158c0:	e3a00000 	mov	r0, #0	; 0x0
33d158c4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d158c8:	33d36574 	.word	0x33d36574

33d158cc <getenv_r>:

int getenv_r (char *name, char *buf, unsigned len)
{
33d158cc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d158d0:	e1a09000 	mov	r9, r0
33d158d4:	e1a0b002 	mov	fp, r2
33d158d8:	e1a07001 	mov	r7, r1
	int i, nxt;

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
33d158dc:	e3a05000 	mov	r5, #0	; 0x0
33d158e0:	ea000021 	b	33d1596c <getenv_r+0xa0>
		int val, n;

		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
33d158e4:	e1a04005 	mov	r4, r5
33d158e8:	ea000004 	b	33d15900 <getenv_r+0x34>
			if (nxt >= CFG_ENV_SIZE) {
33d158ec:	e3540802 	cmp	r4, #131072	; 0x20000
33d158f0:	ba000001 	blt	33d158fc <getenv_r+0x30>
				return (-1);
33d158f4:	e3e00000 	mvn	r0, #0	; 0x0
33d158f8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	int i, nxt;

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
		int val, n;

		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
33d158fc:	e2844001 	add	r4, r4, #1	; 0x1
33d15900:	e1a00004 	mov	r0, r4
33d15904:	e1a0e00f 	mov	lr, pc
33d15908:	e59af000 	ldr	pc, [sl]
33d1590c:	e21060ff 	ands	r6, r0, #255	; 0xff
33d15910:	1afffff5 	bne	33d158ec <getenv_r+0x20>
			if (nxt >= CFG_ENV_SIZE) {
				return (-1);
			}
		}
		if ((val=envmatch((uchar *)name, i)) < 0)
33d15914:	e1a01005 	mov	r1, r5
33d15918:	e1a00009 	mov	r0, r9
33d1591c:	ebfffdf8 	bl	33d15104 <envmatch>
33d15920:	e2505000 	subs	r5, r0, #0	; 0x0
33d15924:	ba00000f 	blt	33d15968 <getenv_r+0x9c>
			continue;
		/* found; copy out */
		n = 0;
33d15928:	e1a04006 	mov	r4, r6
		while ((len > n++) && (*buf++ = env_get_char(val++)) != '\0')
33d1592c:	e154000b 	cmp	r4, fp
33d15930:	e1a00005 	mov	r0, r5
33d15934:	e2844001 	add	r4, r4, #1	; 0x1
33d15938:	e2855001 	add	r5, r5, #1	; 0x1
33d1593c:	2a000004 	bcs	33d15954 <getenv_r+0x88>
33d15940:	e1a0e00f 	mov	lr, pc
33d15944:	e59af000 	ldr	pc, [sl]
33d15948:	e31000ff 	tst	r0, #255	; 0xff
33d1594c:	e4c70001 	strb	r0, [r7], #1
33d15950:	1afffff5 	bne	33d1592c <getenv_r+0x60>
			;
		if (len == n)
33d15954:	e15b0004 	cmp	fp, r4
			*buf = '\0';
33d15958:	03a03000 	moveq	r3, #0	; 0x0
		return (n);
33d1595c:	e1a00004 	mov	r0, r4
		/* found; copy out */
		n = 0;
		while ((len > n++) && (*buf++ = env_get_char(val++)) != '\0')
			;
		if (len == n)
			*buf = '\0';
33d15960:	05c73000 	strbeq	r3, [r7]
		return (n);
33d15964:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

int getenv_r (char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
33d15968:	e2845001 	add	r5, r4, #1	; 0x1
33d1596c:	e59fa018 	ldr	sl, [pc, #24]	; 33d1598c <getenv_r+0xc0>
33d15970:	e1a00005 	mov	r0, r5
33d15974:	e1a0e00f 	mov	lr, pc
33d15978:	e59af000 	ldr	pc, [sl]
33d1597c:	e31000ff 	tst	r0, #255	; 0xff
33d15980:	1affffd7 	bne	33d158e4 <getenv_r+0x18>
			;
		if (len == n)
			*buf = '\0';
		return (n);
	}
	return (-1);
33d15984:	e3e00000 	mvn	r0, #0	; 0x0
}
33d15988:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1598c:	33d36574 	.word	0x33d36574

33d15990 <do_saveenv>:
    ((CONFIG_COMMANDS & (CFG_CMD_ENV|CFG_CMD_FLASH)) == \
      (CFG_CMD_ENV|CFG_CMD_FLASH)) || \
    ((CONFIG_COMMANDS & (CFG_CMD_ENV|CFG_CMD_NAND)) == \
      (CFG_CMD_ENV|CFG_CMD_NAND))
int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d15990:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	extern char * env_name_spec;

	printf ("Saving Environment to %s...\n", env_name_spec);
33d15994:	e59f3018 	ldr	r3, [pc, #24]	; 33d159b4 <do_saveenv+0x24>
33d15998:	e59f0018 	ldr	r0, [pc, #24]	; 33d159b8 <do_saveenv+0x28>
33d1599c:	e5931000 	ldr	r1, [r3]
33d159a0:	eb000588 	bl	33d16fc8 <printf>

	return (saveenv() ? 1 : 0);
33d159a4:	eb000add 	bl	33d18520 <saveenv>
}
33d159a8:	e2500000 	subs	r0, r0, #0	; 0x0
33d159ac:	13a00001 	movne	r0, #1	; 0x1
33d159b0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d159b4:	33d36578 	.word	0x33d36578
33d159b8:	33d2b5f4 	.word	0x33d2b5f4

33d159bc <do_usbslave>:
extern char bLARGEBLOCK;			//HJ_add 20090807
extern char b128MB;				//HJ_add 20090807
extern int NF_ReadID(void);				//HJ_add 20090807

int do_usbslave (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d159bc:	e92d4070 	push	{r4, r5, r6, lr}

    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
     * download_run为0时表示将文件保存在参数argv[2]指定的位置
     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
     */
    download_run = 1;
33d159c0:	e59f5194 	ldr	r5, [pc, #404]	; 33d15b5c <do_usbslave+0x1a0>
extern char bLARGEBLOCK;			//HJ_add 20090807
extern char b128MB;				//HJ_add 20090807
extern int NF_ReadID(void);				//HJ_add 20090807

int do_usbslave (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d159c4:	e1a01002 	mov	r1, r2
    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
     * download_run为0时表示将文件保存在参数argv[2]指定的位置
     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
     */
    download_run = 1;
    switch (argc) {
33d159c8:	e3520002 	cmp	r2, #2	; 0x2

    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
     * download_run为0时表示将文件保存在参数argv[2]指定的位置
     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
     */
    download_run = 1;
33d159cc:	e3a02001 	mov	r2, #1	; 0x1
extern char bLARGEBLOCK;			//HJ_add 20090807
extern char b128MB;				//HJ_add 20090807
extern int NF_ReadID(void);				//HJ_add 20090807

int do_usbslave (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d159d0:	e24dd020 	sub	sp, sp, #32	; 0x20

    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
     * download_run为0时表示将文件保存在参数argv[2]指定的位置
     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
     */
    download_run = 1;
33d159d4:	e5852000 	str	r2, [r5]
extern char bLARGEBLOCK;			//HJ_add 20090807
extern char b128MB;				//HJ_add 20090807
extern int NF_ReadID(void);				//HJ_add 20090807

int do_usbslave (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d159d8:	e1a04003 	mov	r4, r3
    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
     * download_run为0时表示将文件保存在参数argv[2]指定的位置
     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
     */
    download_run = 1;
    switch (argc) {
33d159dc:	0a000006 	beq	33d159fc <do_usbslave+0x40>
33d159e0:	ca000002 	bgt	33d159f0 <do_usbslave+0x34>
33d159e4:	e1510002 	cmp	r1, r2
33d159e8:	0a00001e 	beq	33d15a68 <do_usbslave+0xac>
33d159ec:	ea000018 	b	33d15a54 <do_usbslave+0x98>
33d159f0:	e3510003 	cmp	r1, #3	; 0x3
33d159f4:	0a000007 	beq	33d15a18 <do_usbslave+0x5c>
33d159f8:	ea000015 	b	33d15a54 <do_usbslave+0x98>
        {
            break;
        }
        case 2:
        {
            g_bUSBWait = (int)simple_strtoul(argv[1], NULL, 16);
33d159fc:	e5930004 	ldr	r0, [r3, #4]
33d15a00:	e3a01000 	mov	r1, #0	; 0x0
33d15a04:	e3a02010 	mov	r2, #16	; 0x10
33d15a08:	eb0012d3 	bl	33d1a55c <simple_strtoul>
33d15a0c:	e59f314c 	ldr	r3, [pc, #332]	; 33d15b60 <do_usbslave+0x1a4>
33d15a10:	e5830000 	str	r0, [r3]
            break;
33d15a14:	ea000013 	b	33d15a68 <do_usbslave+0xac>
        }

        case 3:
        {
            g_bUSBWait = (int)simple_strtoul(argv[1], NULL, 16);
33d15a18:	e3a01000 	mov	r1, #0	; 0x0
33d15a1c:	e3a02010 	mov	r2, #16	; 0x10
33d15a20:	e5930004 	ldr	r0, [r3, #4]
33d15a24:	eb0012cc 	bl	33d1a55c <simple_strtoul>
33d15a28:	e59f3130 	ldr	r3, [pc, #304]	; 33d15b60 <do_usbslave+0x1a4>
33d15a2c:	e5830000 	str	r0, [r3]
            load_addr = simple_strtoul(argv[2], NULL, 16);
33d15a30:	e3a01000 	mov	r1, #0	; 0x0
33d15a34:	e5940008 	ldr	r0, [r4, #8]
33d15a38:	e3a02010 	mov	r2, #16	; 0x10
33d15a3c:	eb0012c6 	bl	33d1a55c <simple_strtoul>
33d15a40:	e59f311c 	ldr	r3, [pc, #284]	; 33d15b64 <do_usbslave+0x1a8>
33d15a44:	e5830000 	str	r0, [r3]
            download_run = 0;
33d15a48:	e3a03000 	mov	r3, #0	; 0x0
33d15a4c:	e5853000 	str	r3, [r5]
            break;
33d15a50:	ea000004 	b	33d15a68 <do_usbslave+0xac>
        }
        
        default: 
        {
            printf ("Usage:\n%s\n", cmdtp->usage);
33d15a54:	e5901010 	ldr	r1, [r0, #16]
33d15a58:	e59f0108 	ldr	r0, [pc, #264]	; 33d15b68 <do_usbslave+0x1ac>
33d15a5c:	eb000559 	bl	33d16fc8 <printf>
    		return 1;
33d15a60:	e3a00001 	mov	r0, #1	; 0x1
33d15a64:	ea00003a 	b	33d15b54 <do_usbslave+0x198>
        }
    }

    dwUSBBufBase = load_addr;  
    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
33d15a68:	e59f30fc 	ldr	r3, [pc, #252]	; 33d15b6c <do_usbslave+0x1b0>
            printf ("Usage:\n%s\n", cmdtp->usage);
    		return 1;
        }
    }

    dwUSBBufBase = load_addr;  
33d15a6c:	e59f60f0 	ldr	r6, [pc, #240]	; 33d15b64 <do_usbslave+0x1a8>
    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
33d15a70:	e593c000 	ldr	ip, [r3]
            printf ("Usage:\n%s\n", cmdtp->usage);
    		return 1;
        }
    }

    dwUSBBufBase = load_addr;  
33d15a74:	e59f10f4 	ldr	r1, [pc, #244]	; 33d15b70 <do_usbslave+0x1b4>
33d15a78:	e5962000 	ldr	r2, [r6]
    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
33d15a7c:	e1a039ac 	lsr	r3, ip, #19
            printf ("Usage:\n%s\n", cmdtp->usage);
    		return 1;
        }
    }

    dwUSBBufBase = load_addr;  
33d15a80:	e5812000 	str	r2, [r1]
    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
33d15a84:	e59f20e8 	ldr	r2, [pc, #232]	; 33d15b74 <do_usbslave+0x1b8>
33d15a88:	e1a03983 	lsl	r3, r3, #19
33d15a8c:	e5823000 	str	r3, [r2]
    if (g_bUSBWait)
33d15a90:	e59f30c8 	ldr	r3, [pc, #200]	; 33d15b60 <do_usbslave+0x1a4>
33d15a94:	e5932000 	ldr	r2, [r3]
        len = FREE_RAM_SIZE;

    g_dwDownloadLen = usb_receive(dwUSBBufBase, len, g_bUSBWait);
33d15a98:	e3520000 	cmp	r2, #0	; 0x0
33d15a9c:	e5910000 	ldr	r0, [r1]
33d15aa0:	e3e01000 	mvn	r1, #0	; 0x0
33d15aa4:	11a0100c 	movne	r1, ip
33d15aa8:	ebffd43e 	bl	33d0aba8 <usb_receive>
33d15aac:	e59f40c4 	ldr	r4, [pc, #196]	; 33d15b78 <do_usbslave+0x1bc>
33d15ab0:	e1a03000 	mov	r3, r0
    sprintf(buf, "%lx", g_dwDownloadLen);
33d15ab4:	e1a02000 	mov	r2, r0
    dwUSBBufBase = load_addr;  
    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
    if (g_bUSBWait)
        len = FREE_RAM_SIZE;

    g_dwDownloadLen = usb_receive(dwUSBBufBase, len, g_bUSBWait);
33d15ab8:	e5843000 	str	r3, [r4]
    sprintf(buf, "%lx", g_dwDownloadLen);
33d15abc:	e59f10b8 	ldr	r1, [pc, #184]	; 33d15b7c <do_usbslave+0x1c0>
33d15ac0:	e1a0000d 	mov	r0, sp
33d15ac4:	eb00148a 	bl	33d1acf4 <sprintf>
    setenv("filesize", buf);
33d15ac8:	e59f00b0 	ldr	r0, [pc, #176]	; 33d15b80 <do_usbslave+0x1c4>
33d15acc:	e1a0100d 	mov	r1, sp
33d15ad0:	ebffff40 	bl	33d157d8 <setenv>
if (NF_ReadID() == 0x76)
33d15ad4:	ebffaa9e 	bl	33d00554 <NF_ReadID>
33d15ad8:	e3500076 	cmp	r0, #118	; 0x76
    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
    if (g_bUSBWait)
        len = FREE_RAM_SIZE;

    g_dwDownloadLen = usb_receive(dwUSBBufBase, len, g_bUSBWait);
    sprintf(buf, "%lx", g_dwDownloadLen);
33d15adc:	e1a0500d 	mov	r5, sp
33d15ae0:	e5942000 	ldr	r2, [r4]
    setenv("filesize", buf);
if (NF_ReadID() == 0x76)
33d15ae4:	1a000006 	bne	33d15b04 <do_usbslave+0x148>
{
	sprintf(buf, "%lx", g_dwDownloadLen%(512*32) == 0 ? g_dwDownloadLen : (g_dwDownloadLen/(512*32)+1)*32*512);
33d15ae8:	e1a03902 	lsl	r3, r2, #18
33d15aec:	e1a03923 	lsr	r3, r3, #18
33d15af0:	e3530000 	cmp	r3, #0	; 0x0
33d15af4:	13c23dff 	bicne	r3, r2, #16320	; 0x3fc0
33d15af8:	13c3303f 	bicne	r3, r3, #63	; 0x3f
33d15afc:	12832901 	addne	r2, r3, #16384	; 0x4000
33d15b00:	ea000005 	b	33d15b1c <do_usbslave+0x160>
}
else
{
	sprintf(buf, "%lx", g_dwDownloadLen%(2048*64) == 0 ? g_dwDownloadLen : (g_dwDownloadLen/(2048*64)+1)*64*2048);
33d15b04:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
33d15b08:	e3c338fe 	bic	r3, r3, #16646144	; 0xfe0000
33d15b0c:	e3530000 	cmp	r3, #0	; 0x0
33d15b10:	11a038a2 	lsrne	r3, r2, #17
33d15b14:	11a03883 	lslne	r3, r3, #17
33d15b18:	12832802 	addne	r2, r3, #131072	; 0x20000
33d15b1c:	e59f1058 	ldr	r1, [pc, #88]	; 33d15b7c <do_usbslave+0x1c0>
33d15b20:	e1a00005 	mov	r0, r5
33d15b24:	eb001472 	bl	33d1acf4 <sprintf>
}
    setenv("filesize+1", buf);
33d15b28:	e59f0054 	ldr	r0, [pc, #84]	; 33d15b84 <do_usbslave+0x1c8>
33d15b2c:	e1a01005 	mov	r1, r5
33d15b30:	ebffff28 	bl	33d157d8 <setenv>

    sprintf(buf, "%lX", (unsigned long)load_addr);
33d15b34:	e5962000 	ldr	r2, [r6]
33d15b38:	e59f1048 	ldr	r1, [pc, #72]	; 33d15b88 <do_usbslave+0x1cc>
33d15b3c:	e1a00005 	mov	r0, r5
33d15b40:	eb00146b 	bl	33d1acf4 <sprintf>
    setenv("fileaddr", buf);
33d15b44:	e59f0040 	ldr	r0, [pc, #64]	; 33d15b8c <do_usbslave+0x1d0>
33d15b48:	e1a01005 	mov	r1, r5
33d15b4c:	ebffff21 	bl	33d157d8 <setenv>

	return 0;
33d15b50:	e3a00000 	mov	r0, #0	; 0x0
}
33d15b54:	e28dd020 	add	sp, sp, #32	; 0x20
33d15b58:	e8bd8070 	pop	{r4, r5, r6, pc}
33d15b5c:	33d60404 	.word	0x33d60404
33d15b60:	33d3607c 	.word	0x33d3607c
33d15b64:	33d35fec 	.word	0x33d35fec
33d15b68:	33d27008 	.word	0x33d27008
33d15b6c:	33d00054 	.word	0x33d00054
33d15b70:	33d60450 	.word	0x33d60450
33d15b74:	33d60454 	.word	0x33d60454
33d15b78:	33d60c10 	.word	0x33d60c10
33d15b7c:	33d25950 	.word	0x33d25950
33d15b80:	33d25954 	.word	0x33d25954
33d15b84:	33d25960 	.word	0x33d25960
33d15b88:	33d2596c 	.word	0x33d2596c
33d15b8c:	33d25970 	.word	0x33d25970

33d15b90 <param_menu_usage>:
extern void download_nkbin_to_flash(void);
extern int boot_zImage(ulong from, size_t size);
extern char bLARGEBLOCK;

void param_menu_usage(void)
{
33d15b90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	printf("\r\n##### Parameter Menu #####\r\n");
33d15b94:	e59f0044 	ldr	r0, [pc, #68]	; 33d15be0 <param_menu_usage+0x50>
33d15b98:	eb00050a 	bl	33d16fc8 <printf>
	printf("[1] Set NFS boot parameter \r\n");
33d15b9c:	e59f0040 	ldr	r0, [pc, #64]	; 33d15be4 <param_menu_usage+0x54>
33d15ba0:	eb000508 	bl	33d16fc8 <printf>
	printf("[2] Set Yaffs boot parameter \r\n");
33d15ba4:	e59f003c 	ldr	r0, [pc, #60]	; 33d15be8 <param_menu_usage+0x58>
33d15ba8:	eb000506 	bl	33d16fc8 <printf>
	printf("[3] Set parameter \r\n");
33d15bac:	e59f0038 	ldr	r0, [pc, #56]	; 33d15bec <param_menu_usage+0x5c>
33d15bb0:	eb000504 	bl	33d16fc8 <printf>
	printf("[4] View the parameters\r\n");
33d15bb4:	e59f0034 	ldr	r0, [pc, #52]	; 33d15bf0 <param_menu_usage+0x60>
33d15bb8:	eb000502 	bl	33d16fc8 <printf>
	printf("[d] Delete parameter \r\n");
33d15bbc:	e59f0030 	ldr	r0, [pc, #48]	; 33d15bf4 <param_menu_usage+0x64>
33d15bc0:	eb000500 	bl	33d16fc8 <printf>
	printf("[s] Save the parameters to Nand Flash \r\n");
33d15bc4:	e59f002c 	ldr	r0, [pc, #44]	; 33d15bf8 <param_menu_usage+0x68>
33d15bc8:	eb0004fe 	bl	33d16fc8 <printf>
	printf("[q] Return main Menu \r\n");
33d15bcc:	e59f0028 	ldr	r0, [pc, #40]	; 33d15bfc <param_menu_usage+0x6c>
33d15bd0:	eb0004fc 	bl	33d16fc8 <printf>
	printf("Enter your selection: ");
33d15bd4:	e59f0024 	ldr	r0, [pc, #36]	; 33d15c00 <param_menu_usage+0x70>
33d15bd8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d15bdc:	ea0004f9 	b	33d16fc8 <printf>
33d15be0:	33d2b72c 	.word	0x33d2b72c
33d15be4:	33d2b74c 	.word	0x33d2b74c
33d15be8:	33d2b76c 	.word	0x33d2b76c
33d15bec:	33d2b78c 	.word	0x33d2b78c
33d15bf0:	33d2b7a4 	.word	0x33d2b7a4
33d15bf4:	33d2b7c0 	.word	0x33d2b7c0
33d15bf8:	33d2b7d8 	.word	0x33d2b7d8
33d15bfc:	33d2b804 	.word	0x33d2b804
33d15c00:	33d2b81c 	.word	0x33d2b81c

33d15c04 <param_menu_shell>:
}


void param_menu_shell(void)
{
33d15c04:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d15c08:	e24ddf69 	sub	sp, sp, #420	; 0x1a4
	char param_buf3[25];
	char param_buf4[64];

	while (1)
	{
		param_menu_usage();
33d15c0c:	ebffffdf 	bl	33d15b90 <param_menu_usage>
		c = awaitkey(-1, NULL);
33d15c10:	e3a01000 	mov	r1, #0	; 0x0
33d15c14:	e3e00000 	mvn	r0, #0	; 0x0
33d15c18:	ebffd344 	bl	33d0a930 <awaitkey>
33d15c1c:	e20040ff 	and	r4, r0, #255	; 0xff
		printf("%c\n", c);
33d15c20:	e1a01004 	mov	r1, r4
33d15c24:	e59f0230 	ldr	r0, [pc, #560]	; 33d15e5c <param_menu_shell+0x258>
33d15c28:	eb0004e6 	bl	33d16fc8 <printf>
		switch (c)
33d15c2c:	e3540044 	cmp	r4, #68	; 0x44
33d15c30:	0a000073 	beq	33d15e04 <param_menu_shell+0x200>
33d15c34:	ca00000a 	bgt	33d15c64 <param_menu_shell+0x60>
33d15c38:	e3540032 	cmp	r4, #50	; 0x32
33d15c3c:	0a00004a 	beq	33d15d6c <param_menu_shell+0x168>
33d15c40:	ca000002 	bgt	33d15c50 <param_menu_shell+0x4c>
33d15c44:	e3540031 	cmp	r4, #49	; 0x31
33d15c48:	0a000011 	beq	33d15c94 <param_menu_shell+0x90>
33d15c4c:	eaffffee 	b	33d15c0c <param_menu_shell+0x8>
33d15c50:	e3540033 	cmp	r4, #51	; 0x33
33d15c54:	0a00004b 	beq	33d15d88 <param_menu_shell+0x184>
33d15c58:	e3540034 	cmp	r4, #52	; 0x34
33d15c5c:	0a000062 	beq	33d15dec <param_menu_shell+0x1e8>
33d15c60:	eaffffe9 	b	33d15c0c <param_menu_shell+0x8>
33d15c64:	e3540064 	cmp	r4, #100	; 0x64
33d15c68:	0a000065 	beq	33d15e04 <param_menu_shell+0x200>
33d15c6c:	ca000003 	bgt	33d15c80 <param_menu_shell+0x7c>
33d15c70:	e3540051 	cmp	r4, #81	; 0x51
33d15c74:	0a000076 	beq	33d15e54 <param_menu_shell+0x250>
33d15c78:	e3540053 	cmp	r4, #83	; 0x53
33d15c7c:	ea000002 	b	33d15c8c <param_menu_shell+0x88>
33d15c80:	e3540071 	cmp	r4, #113	; 0x71
33d15c84:	0a000072 	beq	33d15e54 <param_menu_shell+0x250>
33d15c88:	e3540073 	cmp	r4, #115	; 0x73
33d15c8c:	0a000068 	beq	33d15e34 <param_menu_shell+0x230>
33d15c90:	eaffffdd 	b	33d15c0c <param_menu_shell+0x8>
		{
			case '1':
			{
				sprintf(cmd_buf, "setenv bootargs ");
33d15c94:	e28da0a4 	add	sl, sp, #164	; 0xa4
33d15c98:	e59f11c0 	ldr	r1, [pc, #448]	; 33d15e60 <param_menu_shell+0x25c>
33d15c9c:	e1a0000a 	mov	r0, sl
33d15ca0:	eb001413 	bl	33d1acf4 <sprintf>

				printf("Enter the PC IP address:(xxx.xxx.xxx.xxx)\n");
33d15ca4:	e59f01b8 	ldr	r0, [pc, #440]	; 33d15e64 <param_menu_shell+0x260>
33d15ca8:	eb0004c6 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf1,console_buffer);
33d15cac:	e28d7088 	add	r7, sp, #136	; 0x88
			case '1':
			{
				sprintf(cmd_buf, "setenv bootargs ");

				printf("Enter the PC IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d15cb0:	e3a00000 	mov	r0, #0	; 0x0
33d15cb4:	ebffdb52 	bl	33d0ca04 <readline>
				strcpy(param_buf1,console_buffer);
33d15cb8:	e59f11a8 	ldr	r1, [pc, #424]	; 33d15e68 <param_menu_shell+0x264>
33d15cbc:	e1a00007 	mov	r0, r7
33d15cc0:	eb0010bd 	bl	33d19fbc <strcpy>
				printf("Enter the SKY2440/TQ2440 IP address:(xxx.xxx.xxx.xxx)\n");
33d15cc4:	e59f01a0 	ldr	r0, [pc, #416]	; 33d15e6c <param_menu_shell+0x268>
33d15cc8:	eb0004be 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf2,console_buffer);
33d15ccc:	e28d506c 	add	r5, sp, #108	; 0x6c

				printf("Enter the PC IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
				strcpy(param_buf1,console_buffer);
				printf("Enter the SKY2440/TQ2440 IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d15cd0:	e3a00000 	mov	r0, #0	; 0x0
33d15cd4:	ebffdb4a 	bl	33d0ca04 <readline>
				strcpy(param_buf2,console_buffer);
33d15cd8:	e59f1188 	ldr	r1, [pc, #392]	; 33d15e68 <param_menu_shell+0x264>
33d15cdc:	e1a00005 	mov	r0, r5
33d15ce0:	eb0010b5 	bl	33d19fbc <strcpy>
				printf("Enter the Mask IP address:(xxx.xxx.xxx.xxx)\n");
33d15ce4:	e59f0184 	ldr	r0, [pc, #388]	; 33d15e70 <param_menu_shell+0x26c>
33d15ce8:	eb0004b6 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf3,console_buffer);
33d15cec:	e28d6050 	add	r6, sp, #80	; 0x50
				strcpy(param_buf1,console_buffer);
				printf("Enter the SKY2440/TQ2440 IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
				strcpy(param_buf2,console_buffer);
				printf("Enter the Mask IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d15cf0:	e3a00000 	mov	r0, #0	; 0x0
33d15cf4:	ebffdb42 	bl	33d0ca04 <readline>
				strcpy(param_buf3,console_buffer);
33d15cf8:	e59f1168 	ldr	r1, [pc, #360]	; 33d15e68 <param_menu_shell+0x264>
33d15cfc:	e1a00006 	mov	r0, r6
33d15d00:	eb0010ad 	bl	33d19fbc <strcpy>
				printf("Enter NFS directory:(eg: /opt/EmbedSky/root_nfs)\n");
33d15d04:	e59f0168 	ldr	r0, [pc, #360]	; 33d15e74 <param_menu_shell+0x270>
33d15d08:	eb0004ae 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf4,console_buffer);
33d15d0c:	e28d4010 	add	r4, sp, #16	; 0x10
				strcpy(param_buf2,console_buffer);
				printf("Enter the Mask IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
				strcpy(param_buf3,console_buffer);
				printf("Enter NFS directory:(eg: /opt/EmbedSky/root_nfs)\n");
				readline(NULL);
33d15d10:	e3a00000 	mov	r0, #0	; 0x0
33d15d14:	ebffdb3a 	bl	33d0ca04 <readline>
				strcpy(param_buf4,console_buffer);
33d15d18:	e59f1148 	ldr	r1, [pc, #328]	; 33d15e68 <param_menu_shell+0x264>
33d15d1c:	e1a00004 	mov	r0, r4
33d15d20:	eb0010a5 	bl	33d19fbc <strcpy>
				sprintf(cmd_buf, "setenv bootargs console=ttySAC0 root=/dev/nfs nfsroot=%s:%s ip=%s:%s:%s:%s:SKY2440.embedsky.net:eth0:off", param_buf1, param_buf4, param_buf2, param_buf1, param_buf2, param_buf3);
33d15d24:	e1a02007 	mov	r2, r7
33d15d28:	e1a03004 	mov	r3, r4
33d15d2c:	e59f1144 	ldr	r1, [pc, #324]	; 33d15e78 <param_menu_shell+0x274>
33d15d30:	e1a0000a 	mov	r0, sl
33d15d34:	e88d00a0 	stm	sp, {r5, r7}
33d15d38:	e58d5008 	str	r5, [sp, #8]
33d15d3c:	e58d600c 	str	r6, [sp, #12]
33d15d40:	eb0013eb 	bl	33d1acf4 <sprintf>
				printf("bootargs: console=ttySAC0 root=/dev/nfs nfsroot=%s:%s ip=%s:%s:%s:%s:SKY2440.embedsky.net:eth0:off\n",param_buf1, param_buf4, param_buf2, param_buf1, param_buf2, param_buf3);
33d15d44:	e59f0130 	ldr	r0, [pc, #304]	; 33d15e7c <param_menu_shell+0x278>
33d15d48:	e1a01007 	mov	r1, r7
33d15d4c:	e1a02004 	mov	r2, r4
33d15d50:	e1a03005 	mov	r3, r5
33d15d54:	e58d6008 	str	r6, [sp, #8]
33d15d58:	e58d7000 	str	r7, [sp]
33d15d5c:	e58d5004 	str	r5, [sp, #4]
33d15d60:	eb000498 	bl	33d16fc8 <printf>

				run_command(cmd_buf, 0);
33d15d64:	e1a0000a 	mov	r0, sl
33d15d68:	ea000036 	b	33d15e48 <param_menu_shell+0x244>
			{
			#if CONFIG_128MB_SDRAM
				sprintf(cmd_buf, "setenv bootargs noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0 mem=128M");
				printf("bootargs: noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0 mem=128M\n");
			#else
				sprintf(cmd_buf, "setenv bootargs noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0");
33d15d6c:	e28d40a4 	add	r4, sp, #164	; 0xa4
33d15d70:	e59f1108 	ldr	r1, [pc, #264]	; 33d15e80 <param_menu_shell+0x27c>
33d15d74:	e1a00004 	mov	r0, r4
33d15d78:	eb0013dd 	bl	33d1acf4 <sprintf>
				printf("bootargs: noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0\n");
33d15d7c:	e59f0100 	ldr	r0, [pc, #256]	; 33d15e84 <param_menu_shell+0x280>
33d15d80:	eb000490 	bl	33d16fc8 <printf>
33d15d84:	ea00002e 	b	33d15e44 <param_menu_shell+0x240>
				break;
			}

			case '3':
			{
				sprintf(cmd_buf, "setenv ");
33d15d88:	e28d40a4 	add	r4, sp, #164	; 0xa4
33d15d8c:	e59f10f4 	ldr	r1, [pc, #244]	; 33d15e88 <param_menu_shell+0x284>
33d15d90:	e1a00004 	mov	r0, r4
33d15d94:	eb0013d6 	bl	33d1acf4 <sprintf>

				printf("Name: ");
33d15d98:	e59f00ec 	ldr	r0, [pc, #236]	; 33d15e8c <param_menu_shell+0x288>
33d15d9c:	eb000489 	bl	33d16fc8 <printf>
				readline(NULL);
33d15da0:	e3a00000 	mov	r0, #0	; 0x0
33d15da4:	ebffdb16 	bl	33d0ca04 <readline>
				strcat(cmd_buf, console_buffer);
33d15da8:	e59f10b8 	ldr	r1, [pc, #184]	; 33d15e68 <param_menu_shell+0x264>
33d15dac:	e1a00004 	mov	r0, r4
33d15db0:	eb001091 	bl	33d19ffc <strcat>

				printf("Value: ");
33d15db4:	e59f00d4 	ldr	r0, [pc, #212]	; 33d15e90 <param_menu_shell+0x28c>
33d15db8:	eb000482 	bl	33d16fc8 <printf>
				readline(NULL);
33d15dbc:	e3a00000 	mov	r0, #0	; 0x0
33d15dc0:	ebffdb0f 	bl	33d0ca04 <readline>
				strcat(cmd_buf, " ");
33d15dc4:	e1a00004 	mov	r0, r4
33d15dc8:	e59f10c4 	ldr	r1, [pc, #196]	; 33d15e94 <param_menu_shell+0x290>
33d15dcc:	eb00108a 	bl	33d19ffc <strcat>
				strcat(cmd_buf, console_buffer);
33d15dd0:	e1a00004 	mov	r0, r4
33d15dd4:	e59f108c 	ldr	r1, [pc, #140]	; 33d15e68 <param_menu_shell+0x264>
33d15dd8:	eb001087 	bl	33d19ffc <strcat>
				printf("%s\n",cmd_buf);
33d15ddc:	e1a01004 	mov	r1, r4
33d15de0:	e59f00b0 	ldr	r0, [pc, #176]	; 33d15e98 <param_menu_shell+0x294>
33d15de4:	eb000477 	bl	33d16fc8 <printf>
33d15de8:	ea000015 	b	33d15e44 <param_menu_shell+0x240>
				break;
			}

			case '4':
			{
				strcpy(cmd_buf, "printenv ");
33d15dec:	e28d40a4 	add	r4, sp, #164	; 0xa4
33d15df0:	e59f10a4 	ldr	r1, [pc, #164]	; 33d15e9c <param_menu_shell+0x298>
33d15df4:	e1a00004 	mov	r0, r4
33d15df8:	eb00106f 	bl	33d19fbc <strcpy>
				printf("Name(enter to view all paramters): ");
33d15dfc:	e59f009c 	ldr	r0, [pc, #156]	; 33d15ea0 <param_menu_shell+0x29c>
33d15e00:	ea000004 	b	33d15e18 <param_menu_shell+0x214>
			}

			case 'D':
			case 'd':
			{
				sprintf(cmd_buf, "setenv ");
33d15e04:	e28d40a4 	add	r4, sp, #164	; 0xa4
33d15e08:	e59f1078 	ldr	r1, [pc, #120]	; 33d15e88 <param_menu_shell+0x284>
33d15e0c:	e1a00004 	mov	r0, r4
33d15e10:	eb0013b7 	bl	33d1acf4 <sprintf>

				printf("Name: ");
33d15e14:	e59f0070 	ldr	r0, [pc, #112]	; 33d15e8c <param_menu_shell+0x288>
33d15e18:	eb00046a 	bl	33d16fc8 <printf>
				readline(NULL);
33d15e1c:	e3a00000 	mov	r0, #0	; 0x0
33d15e20:	ebffdaf7 	bl	33d0ca04 <readline>
				strcat(cmd_buf, console_buffer);
33d15e24:	e1a00004 	mov	r0, r4
33d15e28:	e59f1038 	ldr	r1, [pc, #56]	; 33d15e68 <param_menu_shell+0x264>
33d15e2c:	eb001072 	bl	33d19ffc <strcat>
33d15e30:	ea000003 	b	33d15e44 <param_menu_shell+0x240>
			}

			case 'S':
			case 's':
			{
				sprintf(cmd_buf, "saveenv");
33d15e34:	e28d40a4 	add	r4, sp, #164	; 0xa4
33d15e38:	e1a00004 	mov	r0, r4
33d15e3c:	e59f1060 	ldr	r1, [pc, #96]	; 33d15ea4 <param_menu_shell+0x2a0>
33d15e40:	eb0013ab 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d15e44:	e1a00004 	mov	r0, r4
33d15e48:	e3a01000 	mov	r1, #0	; 0x0
33d15e4c:	ebffdb63 	bl	33d0cbe0 <run_command>
				break;
33d15e50:	eaffff6d 	b	33d15c0c <param_menu_shell+0x8>
				return;
				break;
			}
		}
	}
}
33d15e54:	e28ddf69 	add	sp, sp, #420	; 0x1a4
33d15e58:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d15e5c:	33d2b834 	.word	0x33d2b834
33d15e60:	33d2b838 	.word	0x33d2b838
33d15e64:	33d2b84c 	.word	0x33d2b84c
33d15e68:	33d60688 	.word	0x33d60688
33d15e6c:	33d2b878 	.word	0x33d2b878
33d15e70:	33d2b8b0 	.word	0x33d2b8b0
33d15e74:	33d2b8e0 	.word	0x33d2b8e0
33d15e78:	33d2b914 	.word	0x33d2b914
33d15e7c:	33d2b980 	.word	0x33d2b980
33d15e80:	33d2b9e4 	.word	0x33d2b9e4
33d15e84:	33d2ba30 	.word	0x33d2ba30
33d15e88:	33d2ba78 	.word	0x33d2ba78
33d15e8c:	33d2ba80 	.word	0x33d2ba80
33d15e90:	33d2bce8 	.word	0x33d2bce8
33d15e94:	33d25a00 	.word	0x33d25a00
33d15e98:	33d2ad00 	.word	0x33d2ad00
33d15e9c:	33d2ba88 	.word	0x33d2ba88
33d15ea0:	33d2ba94 	.word	0x33d2ba94
33d15ea4:	33d2b374 	.word	0x33d2b374

33d15ea8 <lcd_menu_usage>:


void lcd_menu_usage(void)
{
33d15ea8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	printf("\r\n##### LCD Parameters Menu #####\r\n");
33d15eac:	e59f0054 	ldr	r0, [pc, #84]	; 33d15f08 <lcd_menu_usage+0x60>
33d15eb0:	eb000444 	bl	33d16fc8 <printf>
	printf("[1] VBPD       - Set VBPD \r\n");
33d15eb4:	e59f0050 	ldr	r0, [pc, #80]	; 33d15f0c <lcd_menu_usage+0x64>
33d15eb8:	eb000442 	bl	33d16fc8 <printf>
	printf("[2] VFPD       - Set VFPD \r\n");
33d15ebc:	e59f004c 	ldr	r0, [pc, #76]	; 33d15f10 <lcd_menu_usage+0x68>
33d15ec0:	eb000440 	bl	33d16fc8 <printf>
	printf("[3] VSPW       - Set VSPW \r\n");
33d15ec4:	e59f0048 	ldr	r0, [pc, #72]	; 33d15f14 <lcd_menu_usage+0x6c>
33d15ec8:	eb00043e 	bl	33d16fc8 <printf>
	printf("[4] HBPD       - Set HBPD \r\n");
33d15ecc:	e59f0044 	ldr	r0, [pc, #68]	; 33d15f18 <lcd_menu_usage+0x70>
33d15ed0:	eb00043c 	bl	33d16fc8 <printf>
	printf("[5] HFPD       - Set HFPD \r\n");
33d15ed4:	e59f0040 	ldr	r0, [pc, #64]	; 33d15f1c <lcd_menu_usage+0x74>
33d15ed8:	eb00043a 	bl	33d16fc8 <printf>
	printf("[6] HSPW       - Set HSPW \r\n");
33d15edc:	e59f003c 	ldr	r0, [pc, #60]	; 33d15f20 <lcd_menu_usage+0x78>
33d15ee0:	eb000438 	bl	33d16fc8 <printf>
	printf("[7] CLKVAL     - Set CLKVAL \r\n");
33d15ee4:	e59f0038 	ldr	r0, [pc, #56]	; 33d15f24 <lcd_menu_usage+0x7c>
33d15ee8:	eb000436 	bl	33d16fc8 <printf>
	printf("[s] Save the parameters to Nand Flash \r\n");
33d15eec:	e59f0034 	ldr	r0, [pc, #52]	; 33d15f28 <lcd_menu_usage+0x80>
33d15ef0:	eb000434 	bl	33d16fc8 <printf>
	printf("[q] Return main Menu \r\n");
33d15ef4:	e59f0030 	ldr	r0, [pc, #48]	; 33d15f2c <lcd_menu_usage+0x84>
33d15ef8:	eb000432 	bl	33d16fc8 <printf>
	printf("Enter your selection: ");
33d15efc:	e59f002c 	ldr	r0, [pc, #44]	; 33d15f30 <lcd_menu_usage+0x88>
33d15f00:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d15f04:	ea00042f 	b	33d16fc8 <printf>
33d15f08:	33d2bab8 	.word	0x33d2bab8
33d15f0c:	33d2badc 	.word	0x33d2badc
33d15f10:	33d2bafc 	.word	0x33d2bafc
33d15f14:	33d2bb1c 	.word	0x33d2bb1c
33d15f18:	33d2bb3c 	.word	0x33d2bb3c
33d15f1c:	33d2bb5c 	.word	0x33d2bb5c
33d15f20:	33d2bb7c 	.word	0x33d2bb7c
33d15f24:	33d2bb9c 	.word	0x33d2bb9c
33d15f28:	33d2b7d8 	.word	0x33d2b7d8
33d15f2c:	33d2b804 	.word	0x33d2b804
33d15f30:	33d2b81c 	.word	0x33d2b81c

33d15f34 <lcd_menu_shell>:
}


void lcd_menu_shell(void)
{
33d15f34:	e92d4010 	push	{r4, lr}
33d15f38:	e24ddc01 	sub	sp, sp, #256	; 0x100
	char c;
	char cmd_buf[256];

	while (1)
	{
		lcd_menu_usage();
33d15f3c:	ebffffd9 	bl	33d15ea8 <lcd_menu_usage>
		c = awaitkey(-1, NULL);
33d15f40:	e3a01000 	mov	r1, #0	; 0x0
33d15f44:	e3e00000 	mvn	r0, #0	; 0x0
33d15f48:	ebffd278 	bl	33d0a930 <awaitkey>
33d15f4c:	e20040ff 	and	r4, r0, #255	; 0xff
		printf("%c\n", c);
33d15f50:	e1a01004 	mov	r1, r4
33d15f54:	e59f0174 	ldr	r0, [pc, #372]	; 33d160d0 <lcd_menu_shell+0x19c>
33d15f58:	eb00041a 	bl	33d16fc8 <printf>
		switch (c)
33d15f5c:	e3540036 	cmp	r4, #54	; 0x36
33d15f60:	0a000044 	beq	33d16078 <lcd_menu_shell+0x144>
33d15f64:	ca00000c 	bgt	33d15f9c <lcd_menu_shell+0x68>
33d15f68:	e3540033 	cmp	r4, #51	; 0x33
33d15f6c:	0a00002f 	beq	33d16030 <lcd_menu_shell+0xfc>
33d15f70:	ca000004 	bgt	33d15f88 <lcd_menu_shell+0x54>
33d15f74:	e3540031 	cmp	r4, #49	; 0x31
33d15f78:	0a000014 	beq	33d15fd0 <lcd_menu_shell+0x9c>
33d15f7c:	e3540032 	cmp	r4, #50	; 0x32
33d15f80:	0a000018 	beq	33d15fe8 <lcd_menu_shell+0xb4>
33d15f84:	eaffffec 	b	33d15f3c <lcd_menu_shell+0x8>
33d15f88:	e3540034 	cmp	r4, #52	; 0x34
33d15f8c:	0a00002d 	beq	33d16048 <lcd_menu_shell+0x114>
33d15f90:	e3540035 	cmp	r4, #53	; 0x35
33d15f94:	0a000031 	beq	33d16060 <lcd_menu_shell+0x12c>
33d15f98:	eaffffe7 	b	33d15f3c <lcd_menu_shell+0x8>
33d15f9c:	e3540053 	cmp	r4, #83	; 0x53
33d15fa0:	0a000040 	beq	33d160a8 <lcd_menu_shell+0x174>
33d15fa4:	ca000004 	bgt	33d15fbc <lcd_menu_shell+0x88>
33d15fa8:	e3540037 	cmp	r4, #55	; 0x37
33d15fac:	0a000037 	beq	33d16090 <lcd_menu_shell+0x15c>
33d15fb0:	e3540051 	cmp	r4, #81	; 0x51
33d15fb4:	0a000043 	beq	33d160c8 <lcd_menu_shell+0x194>
33d15fb8:	eaffffdf 	b	33d15f3c <lcd_menu_shell+0x8>
33d15fbc:	e3540071 	cmp	r4, #113	; 0x71
33d15fc0:	0a000040 	beq	33d160c8 <lcd_menu_shell+0x194>
33d15fc4:	e3540073 	cmp	r4, #115	; 0x73
33d15fc8:	0a000036 	beq	33d160a8 <lcd_menu_shell+0x174>
33d15fcc:	eaffffda 	b	33d15f3c <lcd_menu_shell+0x8>
		{
			case '1':
			{
				sprintf(cmd_buf, "setenv dwVBPD");
33d15fd0:	e59f10fc 	ldr	r1, [pc, #252]	; 33d160d4 <lcd_menu_shell+0x1a0>
33d15fd4:	e1a0000d 	mov	r0, sp
33d15fd8:	eb001345 	bl	33d1acf4 <sprintf>

				printf("Please enter VBPD Value: ");
33d15fdc:	e59f00f4 	ldr	r0, [pc, #244]	; 33d160d8 <lcd_menu_shell+0x1a4>
		printf("%c\n", c);
		switch (c)
		{
			case '1':
			{
				sprintf(cmd_buf, "setenv dwVBPD");
33d15fe0:	e1a0400d 	mov	r4, sp
33d15fe4:	ea000004 	b	33d15ffc <lcd_menu_shell+0xc8>
				break;
			}

			case '2':
			{
				sprintf(cmd_buf, "setenv dwVFPD");
33d15fe8:	e59f10ec 	ldr	r1, [pc, #236]	; 33d160dc <lcd_menu_shell+0x1a8>
33d15fec:	e1a0000d 	mov	r0, sp
33d15ff0:	eb00133f 	bl	33d1acf4 <sprintf>

				printf("Please enter VFPD Value: ");
33d15ff4:	e59f00e4 	ldr	r0, [pc, #228]	; 33d160e0 <lcd_menu_shell+0x1ac>
				break;
			}

			case '2':
			{
				sprintf(cmd_buf, "setenv dwVFPD");
33d15ff8:	e1a0400d 	mov	r4, sp

				printf("Please enter VFPD Value: ");
33d15ffc:	eb0003f1 	bl	33d16fc8 <printf>
				readline(NULL);
33d16000:	e3a00000 	mov	r0, #0	; 0x0
33d16004:	ebffda7e 	bl	33d0ca04 <readline>
				strcat(cmd_buf, " ");
33d16008:	e1a00004 	mov	r0, r4
33d1600c:	e59f10d0 	ldr	r1, [pc, #208]	; 33d160e4 <lcd_menu_shell+0x1b0>
33d16010:	eb000ff9 	bl	33d19ffc <strcat>
				strcat(cmd_buf, console_buffer);
33d16014:	e1a00004 	mov	r0, r4
33d16018:	e59f10c8 	ldr	r1, [pc, #200]	; 33d160e8 <lcd_menu_shell+0x1b4>
33d1601c:	eb000ff6 	bl	33d19ffc <strcat>
				printf("%s\n",cmd_buf);
33d16020:	e1a01004 	mov	r1, r4
33d16024:	e59f00c0 	ldr	r0, [pc, #192]	; 33d160ec <lcd_menu_shell+0x1b8>
33d16028:	eb0003e6 	bl	33d16fc8 <printf>
33d1602c:	ea000021 	b	33d160b8 <lcd_menu_shell+0x184>
				break;
			}

			case '3':
			{
				sprintf(cmd_buf, "setenv dwVSPW");
33d16030:	e59f10b8 	ldr	r1, [pc, #184]	; 33d160f0 <lcd_menu_shell+0x1bc>
33d16034:	e1a0000d 	mov	r0, sp
33d16038:	eb00132d 	bl	33d1acf4 <sprintf>

				printf("Please enter VSPW Value: ");
33d1603c:	e59f00b0 	ldr	r0, [pc, #176]	; 33d160f4 <lcd_menu_shell+0x1c0>
				break;
			}

			case '3':
			{
				sprintf(cmd_buf, "setenv dwVSPW");
33d16040:	e1a0400d 	mov	r4, sp
33d16044:	eaffffec 	b	33d15ffc <lcd_menu_shell+0xc8>
				break;
			}

			case '4':
			{
				sprintf(cmd_buf, "setenv dwHBPD");
33d16048:	e59f10a8 	ldr	r1, [pc, #168]	; 33d160f8 <lcd_menu_shell+0x1c4>
33d1604c:	e1a0000d 	mov	r0, sp
33d16050:	eb001327 	bl	33d1acf4 <sprintf>

				printf("Please enter HBPD Value: ");
33d16054:	e59f00a0 	ldr	r0, [pc, #160]	; 33d160fc <lcd_menu_shell+0x1c8>
				break;
			}

			case '4':
			{
				sprintf(cmd_buf, "setenv dwHBPD");
33d16058:	e1a0400d 	mov	r4, sp
33d1605c:	eaffffe6 	b	33d15ffc <lcd_menu_shell+0xc8>
				break;
			}

			case '5':
			{
				sprintf(cmd_buf, "setenv dwHFPD");
33d16060:	e59f1098 	ldr	r1, [pc, #152]	; 33d16100 <lcd_menu_shell+0x1cc>
33d16064:	e1a0000d 	mov	r0, sp
33d16068:	eb001321 	bl	33d1acf4 <sprintf>

				printf("Please enter HFPD Value: ");
33d1606c:	e59f0090 	ldr	r0, [pc, #144]	; 33d16104 <lcd_menu_shell+0x1d0>
				break;
			}

			case '5':
			{
				sprintf(cmd_buf, "setenv dwHFPD");
33d16070:	e1a0400d 	mov	r4, sp
33d16074:	eaffffe0 	b	33d15ffc <lcd_menu_shell+0xc8>
				break;
			}

			case '6':
			{
				sprintf(cmd_buf, "setenv dwHSPW");
33d16078:	e59f1088 	ldr	r1, [pc, #136]	; 33d16108 <lcd_menu_shell+0x1d4>
33d1607c:	e1a0000d 	mov	r0, sp
33d16080:	eb00131b 	bl	33d1acf4 <sprintf>

				printf("Please enter HSPW Value: ");
33d16084:	e59f0080 	ldr	r0, [pc, #128]	; 33d1610c <lcd_menu_shell+0x1d8>
				break;
			}

			case '6':
			{
				sprintf(cmd_buf, "setenv dwHSPW");
33d16088:	e1a0400d 	mov	r4, sp
33d1608c:	eaffffda 	b	33d15ffc <lcd_menu_shell+0xc8>
				break;
			}

			case '7':
			{
				sprintf(cmd_buf, "setenv dwCLKVAL");
33d16090:	e59f1078 	ldr	r1, [pc, #120]	; 33d16110 <lcd_menu_shell+0x1dc>
33d16094:	e1a0000d 	mov	r0, sp
33d16098:	eb001315 	bl	33d1acf4 <sprintf>

				printf("Please enter CLKVAL Value: ");
33d1609c:	e59f0070 	ldr	r0, [pc, #112]	; 33d16114 <lcd_menu_shell+0x1e0>
				break;
			}

			case '7':
			{
				sprintf(cmd_buf, "setenv dwCLKVAL");
33d160a0:	e1a0400d 	mov	r4, sp
33d160a4:	eaffffd4 	b	33d15ffc <lcd_menu_shell+0xc8>
			}

			case 'S':
			case 's':
			{
				sprintf(cmd_buf, "saveenv");
33d160a8:	e1a0000d 	mov	r0, sp
33d160ac:	e59f1064 	ldr	r1, [pc, #100]	; 33d16118 <lcd_menu_shell+0x1e4>
33d160b0:	e1a0400d 	mov	r4, sp
33d160b4:	eb00130e 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d160b8:	e1a00004 	mov	r0, r4
33d160bc:	e3a01000 	mov	r1, #0	; 0x0
33d160c0:	ebffdac6 	bl	33d0cbe0 <run_command>
				break;
33d160c4:	eaffff9c 	b	33d15f3c <lcd_menu_shell+0x8>
				return;
				break;
			}
		}
	}
}
33d160c8:	e28ddc01 	add	sp, sp, #256	; 0x100
33d160cc:	e8bd8010 	pop	{r4, pc}
33d160d0:	33d2b834 	.word	0x33d2b834
33d160d4:	33d2bbbc 	.word	0x33d2bbbc
33d160d8:	33d2bbcc 	.word	0x33d2bbcc
33d160dc:	33d2bbe8 	.word	0x33d2bbe8
33d160e0:	33d2bbf8 	.word	0x33d2bbf8
33d160e4:	33d25a00 	.word	0x33d25a00
33d160e8:	33d60688 	.word	0x33d60688
33d160ec:	33d2ad00 	.word	0x33d2ad00
33d160f0:	33d2bc14 	.word	0x33d2bc14
33d160f4:	33d2bc24 	.word	0x33d2bc24
33d160f8:	33d2bc40 	.word	0x33d2bc40
33d160fc:	33d2bc50 	.word	0x33d2bc50
33d16100:	33d2bc6c 	.word	0x33d2bc6c
33d16104:	33d2bc7c 	.word	0x33d2bc7c
33d16108:	33d2bc98 	.word	0x33d2bc98
33d1610c:	33d2bca8 	.word	0x33d2bca8
33d16110:	33d2bcc4 	.word	0x33d2bcc4
33d16114:	33d2bcd4 	.word	0x33d2bcd4
33d16118:	33d2b374 	.word	0x33d2b374

33d1611c <main_menu_usage>:

#define USE_TFTP_DOWN		1
#define USE_USB_DOWN		2

void main_menu_usage(char menu_type)
{
33d1611c:	e92d4010 	push	{r4, lr}
33d16120:	e20040ff 	and	r4, r0, #255	; 0xff

	if (bBootFrmNORFlash())
33d16124:	ebffa9e9 	bl	33d008d0 <bBootFrmNORFlash>
33d16128:	e3500000 	cmp	r0, #0	; 0x0
		printf("\r\n#####	 Boot for Nor Flash Main Menu	#####\r\n");
33d1612c:	159f0120 	ldrne	r0, [pc, #288]	; 33d16254 <main_menu_usage+0x138>
	else
		printf("\r\n#####	 Boot for Nand Flash Main Menu	#####\r\n");
33d16130:	059f0120 	ldreq	r0, [pc, #288]	; 33d16258 <main_menu_usage+0x13c>
33d16134:	eb0003a3 	bl	33d16fc8 <printf>

	if( menu_type == USE_USB_DOWN)
33d16138:	e3540002 	cmp	r4, #2	; 0x2
33d1613c:	1a000002 	bne	33d1614c <main_menu_usage+0x30>
	{
		printf("#####     EmbedSky USB download mode     #####\r\n\n");
33d16140:	e59f0114 	ldr	r0, [pc, #276]	; 33d1625c <main_menu_usage+0x140>
33d16144:	eb00039f 	bl	33d16fc8 <printf>
33d16148:	ea000006 	b	33d16168 <main_menu_usage+0x4c>
	}
	else if( menu_type == USE_TFTP_DOWN)
33d1614c:	e3540001 	cmp	r4, #1	; 0x1
33d16150:	1a000002 	bne	33d16160 <main_menu_usage+0x44>
	{
		printf("#####     EmbedSky TFTP download mode     #####\r\n\n");
33d16154:	e59f0104 	ldr	r0, [pc, #260]	; 33d16260 <main_menu_usage+0x144>
33d16158:	eb00039a 	bl	33d16fc8 <printf>
33d1615c:	ea000005 	b	33d16178 <main_menu_usage+0x5c>
	}
	

	if( menu_type == USE_USB_DOWN)
33d16160:	e3540002 	cmp	r4, #2	; 0x2
33d16164:	1a000001 	bne	33d16170 <main_menu_usage+0x54>
	{
		printf("[1] Download u-boot or STEPLDR.nb1 or other bootloader to Nand Flash\r\n");
33d16168:	e59f00f4 	ldr	r0, [pc, #244]	; 33d16264 <main_menu_usage+0x148>
33d1616c:	ea000002 	b	33d1617c <main_menu_usage+0x60>
	}
	else if( menu_type == USE_TFTP_DOWN)
33d16170:	e3540001 	cmp	r4, #1	; 0x1
33d16174:	1a000001 	bne	33d16180 <main_menu_usage+0x64>
	{
		printf("[1] Download u-boot.bin to Nand Flash\r\n");
33d16178:	e59f00e8 	ldr	r0, [pc, #232]	; 33d16268 <main_menu_usage+0x14c>
33d1617c:	eb000391 	bl	33d16fc8 <printf>
	}
	printf("[2] Download Eboot (eboot.nb0) to Nand Flash\r\n");
33d16180:	e59f00e4 	ldr	r0, [pc, #228]	; 33d1626c <main_menu_usage+0x150>
33d16184:	eb00038f 	bl	33d16fc8 <printf>
	printf("[3] Download Linux Kernel (zImage.bin) to Nand Flash\r\n");
33d16188:	e59f00e0 	ldr	r0, [pc, #224]	; 33d16270 <main_menu_usage+0x154>
33d1618c:	eb00038d 	bl	33d16fc8 <printf>
	if( menu_type == USE_USB_DOWN)
33d16190:	e3540002 	cmp	r4, #2	; 0x2
	{
#ifdef CONFIG_SURPORT_WINCE	
		printf("[4] Download WinCE NK.bin to Nand Flash\r\n");
#endif
		printf("[5] Download CRAMFS image to Nand Flash\r\n");
33d16194:	059f00d8 	ldreq	r0, [pc, #216]	; 33d16274 <main_menu_usage+0x158>
	{
		printf("[1] Download u-boot.bin to Nand Flash\r\n");
	}
	printf("[2] Download Eboot (eboot.nb0) to Nand Flash\r\n");
	printf("[3] Download Linux Kernel (zImage.bin) to Nand Flash\r\n");
	if( menu_type == USE_USB_DOWN)
33d16198:	0a000004 	beq	33d161b0 <main_menu_usage+0x94>
#ifdef CONFIG_SURPORT_WINCE	
		printf("[4] Download WinCE NK.bin to Nand Flash\r\n");
#endif
		printf("[5] Download CRAMFS image to Nand Flash\r\n");
	}
	else if( menu_type == USE_TFTP_DOWN)
33d1619c:	e3540001 	cmp	r4, #1	; 0x1
33d161a0:	1a000003 	bne	33d161b4 <main_menu_usage+0x98>
	{
		printf("[4] Download stepldr.nb1 to Nand Flash\r\n");
33d161a4:	e59f00cc 	ldr	r0, [pc, #204]	; 33d16278 <main_menu_usage+0x15c>
33d161a8:	eb000386 	bl	33d16fc8 <printf>
		printf("[5] Set TFTP parameters(PC IP,TQ2440 IP,Mask IP...)\r\n");
33d161ac:	e59f00c8 	ldr	r0, [pc, #200]	; 33d1627c <main_menu_usage+0x160>
33d161b0:	eb000384 	bl	33d16fc8 <printf>
	}
	printf("[6] Download YAFFS image (root.bin) to Nand Flash\r\n");
33d161b4:	e59f00c4 	ldr	r0, [pc, #196]	; 33d16280 <main_menu_usage+0x164>
33d161b8:	eb000382 	bl	33d16fc8 <printf>
	printf("[7] Download Program (uCOS-II or TQ2440_Test) to SDRAM and Run it\r\n");
33d161bc:	e59f00c0 	ldr	r0, [pc, #192]	; 33d16284 <main_menu_usage+0x168>
33d161c0:	eb000380 	bl	33d16fc8 <printf>

	printf("[8] Boot the system\r\n");
33d161c4:	e59f00bc 	ldr	r0, [pc, #188]	; 33d16288 <main_menu_usage+0x16c>
33d161c8:	eb00037e 	bl	33d16fc8 <printf>
	printf("[9] Format the Nand Flash\r\n");
33d161cc:	e59f00b8 	ldr	r0, [pc, #184]	; 33d1628c <main_menu_usage+0x170>
33d161d0:	eb00037c 	bl	33d16fc8 <printf>
	printf("[0] Set the boot parameters\r\n");
33d161d4:	e59f00b4 	ldr	r0, [pc, #180]	; 33d16290 <main_menu_usage+0x174>
33d161d8:	eb00037a 	bl	33d16fc8 <printf>
	printf("[a] Download User Program (eg: uCOS-II or TQ2440_Test)\r\n");
33d161dc:	e59f00b0 	ldr	r0, [pc, #176]	; 33d16294 <main_menu_usage+0x178>
33d161e0:	eb000378 	bl	33d16fc8 <printf>
	printf("[b] Download LOGO Picture (.bin) to Nand  Flash \r\n");
33d161e4:	e59f00ac 	ldr	r0, [pc, #172]	; 33d16298 <main_menu_usage+0x17c>
33d161e8:	eb000376 	bl	33d16fc8 <printf>
	printf("[l] Set LCD Parameters \r\n");
33d161ec:	e59f00a8 	ldr	r0, [pc, #168]	; 33d1629c <main_menu_usage+0x180>
33d161f0:	eb000374 	bl	33d16fc8 <printf>
	if( menu_type == USE_USB_DOWN)
33d161f4:	e3540002 	cmp	r4, #2	; 0x2
	{
		printf("[n] Enter TFTP download mode menu \r\n");
33d161f8:	059f00a0 	ldreq	r0, [pc, #160]	; 33d162a0 <main_menu_usage+0x184>
33d161fc:	0b000371 	bleq	33d16fc8 <printf>
	}

	if (bBootFrmNORFlash())
33d16200:	ebffa9b2 	bl	33d008d0 <bBootFrmNORFlash>
33d16204:	e3500000 	cmp	r0, #0	; 0x0
		printf("[o] Download u-boot to Nor Flash\r\n");
33d16208:	159f0094 	ldrne	r0, [pc, #148]	; 33d162a4 <main_menu_usage+0x188>
33d1620c:	1b00036d 	blne	33d16fc8 <printf>
	if( menu_type == USE_TFTP_DOWN)
33d16210:	e3540001 	cmp	r4, #1	; 0x1
		printf("[p] Test network (TQ2440 Ping PC's IP) \r\n");
33d16214:	059f008c 	ldreq	r0, [pc, #140]	; 33d162a8 <main_menu_usage+0x18c>
33d16218:	0b00036a 	bleq	33d16fc8 <printf>

	printf("[r] Reboot u-boot\r\n");
33d1621c:	e59f0088 	ldr	r0, [pc, #136]	; 33d162ac <main_menu_usage+0x190>
33d16220:	eb000368 	bl	33d16fc8 <printf>
	printf("[t] Test Linux Image (zImage)\r\n");
33d16224:	e59f0084 	ldr	r0, [pc, #132]	; 33d162b0 <main_menu_usage+0x194>
33d16228:	eb000366 	bl	33d16fc8 <printf>
	if( menu_type == USE_USB_DOWN)
33d1622c:	e3540002 	cmp	r4, #2	; 0x2
	{
		printf("[q] quit from menu\r\n");
33d16230:	059f007c 	ldreq	r0, [pc, #124]	; 33d162b4 <main_menu_usage+0x198>
	if( menu_type == USE_TFTP_DOWN)
		printf("[p] Test network (TQ2440 Ping PC's IP) \r\n");

	printf("[r] Reboot u-boot\r\n");
	printf("[t] Test Linux Image (zImage)\r\n");
	if( menu_type == USE_USB_DOWN)
33d16234:	0a000002 	beq	33d16244 <main_menu_usage+0x128>
	{
		printf("[q] quit from menu\r\n");
	}
	else if( menu_type == USE_TFTP_DOWN)
33d16238:	e3540001 	cmp	r4, #1	; 0x1
33d1623c:	1a000001 	bne	33d16248 <main_menu_usage+0x12c>
	{
		printf("[q] Return main Menu \r\n");
33d16240:	e59f0070 	ldr	r0, [pc, #112]	; 33d162b8 <main_menu_usage+0x19c>
33d16244:	eb00035f 	bl	33d16fc8 <printf>
	}

	printf("Enter your selection: ");
33d16248:	e59f006c 	ldr	r0, [pc, #108]	; 33d162bc <main_menu_usage+0x1a0>
33d1624c:	e8bd4010 	pop	{r4, lr}
33d16250:	ea00035c 	b	33d16fc8 <printf>
33d16254:	33d2bcf0 	.word	0x33d2bcf0
33d16258:	33d2bd20 	.word	0x33d2bd20
33d1625c:	33d2bd50 	.word	0x33d2bd50
33d16260:	33d2bd84 	.word	0x33d2bd84
33d16264:	33d2bdb8 	.word	0x33d2bdb8
33d16268:	33d2be00 	.word	0x33d2be00
33d1626c:	33d2be28 	.word	0x33d2be28
33d16270:	33d2be58 	.word	0x33d2be58
33d16274:	33d2be90 	.word	0x33d2be90
33d16278:	33d2bebc 	.word	0x33d2bebc
33d1627c:	33d2bee8 	.word	0x33d2bee8
33d16280:	33d2bf20 	.word	0x33d2bf20
33d16284:	33d2bf54 	.word	0x33d2bf54
33d16288:	33d2bf98 	.word	0x33d2bf98
33d1628c:	33d2bfb0 	.word	0x33d2bfb0
33d16290:	33d2bfcc 	.word	0x33d2bfcc
33d16294:	33d2bfec 	.word	0x33d2bfec
33d16298:	33d2c028 	.word	0x33d2c028
33d1629c:	33d2c05c 	.word	0x33d2c05c
33d162a0:	33d2c078 	.word	0x33d2c078
33d162a4:	33d2c0a0 	.word	0x33d2c0a0
33d162a8:	33d2c0c4 	.word	0x33d2c0c4
33d162ac:	33d2c0f0 	.word	0x33d2c0f0
33d162b0:	33d2c104 	.word	0x33d2c104
33d162b4:	33d2c124 	.word	0x33d2c124
33d162b8:	33d2b804 	.word	0x33d2b804
33d162bc:	33d2b81c 	.word	0x33d2b81c

33d162c0 <tftp_menu_shell>:
}


void tftp_menu_shell(void)
{
33d162c0:	e92d4070 	push	{r4, r5, r6, lr}
33d162c4:	e24ddf5a 	sub	sp, sp, #360	; 0x168
	char c;
	char cmd_buf[200];

	while (1)
	{
		main_menu_usage(USE_TFTP_DOWN);
33d162c8:	e3a00001 	mov	r0, #1	; 0x1
33d162cc:	ebffff92 	bl	33d1611c <main_menu_usage>
		c = awaitkey(-1, NULL);
33d162d0:	e3a01000 	mov	r1, #0	; 0x0
33d162d4:	e3e00000 	mvn	r0, #0	; 0x0
33d162d8:	ebffd194 	bl	33d0a930 <awaitkey>
33d162dc:	e1a04000 	mov	r4, r0
33d162e0:	e20440ff 	and	r4, r4, #255	; 0xff
		printf("%c\n", c);
33d162e4:	e1a01004 	mov	r1, r4
33d162e8:	e59f0404 	ldr	r0, [pc, #1028]	; 33d166f4 <tftp_menu_shell+0x434>
		switch (c)
33d162ec:	e2444030 	sub	r4, r4, #48	; 0x30

	while (1)
	{
		main_menu_usage(USE_TFTP_DOWN);
		c = awaitkey(-1, NULL);
		printf("%c\n", c);
33d162f0:	eb000334 	bl	33d16fc8 <printf>
		switch (c)
33d162f4:	e3540044 	cmp	r4, #68	; 0x44
33d162f8:	979ff104 	ldrls	pc, [pc, r4, lsl #2]
33d162fc:	eafffff1 	b	33d162c8 <tftp_menu_shell+0x8>
33d16300:	33d1661c 	.word	0x33d1661c
33d16304:	33d16414 	.word	0x33d16414
33d16308:	33d16424 	.word	0x33d16424
33d1630c:	33d16438 	.word	0x33d16438
33d16310:	33d16448 	.word	0x33d16448
33d16314:	33d16458 	.word	0x33d16458
33d16318:	33d16554 	.word	0x33d16554
33d1631c:	33d16564 	.word	0x33d16564
33d16320:	33d165f0 	.word	0x33d165f0
33d16324:	33d1660c 	.word	0x33d1660c
33d16328:	33d162c8 	.word	0x33d162c8
33d1632c:	33d162c8 	.word	0x33d162c8
33d16330:	33d162c8 	.word	0x33d162c8
33d16334:	33d162c8 	.word	0x33d162c8
33d16338:	33d162c8 	.word	0x33d162c8
33d1633c:	33d162c8 	.word	0x33d162c8
33d16340:	33d162c8 	.word	0x33d162c8
33d16344:	33d16624 	.word	0x33d16624
33d16348:	33d1665c 	.word	0x33d1665c
33d1634c:	33d162c8 	.word	0x33d162c8
33d16350:	33d162c8 	.word	0x33d162c8
33d16354:	33d162c8 	.word	0x33d162c8
33d16358:	33d162c8 	.word	0x33d162c8
33d1635c:	33d162c8 	.word	0x33d162c8
33d16360:	33d162c8 	.word	0x33d162c8
33d16364:	33d162c8 	.word	0x33d162c8
33d16368:	33d162c8 	.word	0x33d162c8
33d1636c:	33d162c8 	.word	0x33d162c8
33d16370:	33d1666c 	.word	0x33d1666c
33d16374:	33d162c8 	.word	0x33d162c8
33d16378:	33d162c8 	.word	0x33d162c8
33d1637c:	33d16674 	.word	0x33d16674
33d16380:	33d16690 	.word	0x33d16690
33d16384:	33d166ec 	.word	0x33d166ec
33d16388:	33d166bc 	.word	0x33d166bc
33d1638c:	33d162c8 	.word	0x33d162c8
33d16390:	33d166cc 	.word	0x33d166cc
33d16394:	33d162c8 	.word	0x33d162c8
33d16398:	33d162c8 	.word	0x33d162c8
33d1639c:	33d162c8 	.word	0x33d162c8
33d163a0:	33d162c8 	.word	0x33d162c8
33d163a4:	33d162c8 	.word	0x33d162c8
33d163a8:	33d162c8 	.word	0x33d162c8
33d163ac:	33d162c8 	.word	0x33d162c8
33d163b0:	33d162c8 	.word	0x33d162c8
33d163b4:	33d162c8 	.word	0x33d162c8
33d163b8:	33d162c8 	.word	0x33d162c8
33d163bc:	33d162c8 	.word	0x33d162c8
33d163c0:	33d162c8 	.word	0x33d162c8
33d163c4:	33d16624 	.word	0x33d16624
33d163c8:	33d1665c 	.word	0x33d1665c
33d163cc:	33d162c8 	.word	0x33d162c8
33d163d0:	33d162c8 	.word	0x33d162c8
33d163d4:	33d162c8 	.word	0x33d162c8
33d163d8:	33d162c8 	.word	0x33d162c8
33d163dc:	33d162c8 	.word	0x33d162c8
33d163e0:	33d162c8 	.word	0x33d162c8
33d163e4:	33d162c8 	.word	0x33d162c8
33d163e8:	33d162c8 	.word	0x33d162c8
33d163ec:	33d162c8 	.word	0x33d162c8
33d163f0:	33d1666c 	.word	0x33d1666c
33d163f4:	33d162c8 	.word	0x33d162c8
33d163f8:	33d162c8 	.word	0x33d162c8
33d163fc:	33d16674 	.word	0x33d16674
33d16400:	33d16690 	.word	0x33d16690
33d16404:	33d166ec 	.word	0x33d166ec
33d16408:	33d166bc 	.word	0x33d166bc
33d1640c:	33d162c8 	.word	0x33d162c8
33d16410:	33d166cc 	.word	0x33d166cc
		{
			case '1':
			{
			strcpy(cmd_buf, "tftp 0x30000000 u-boot.bin; nand erase bios; nand write.jffs2 0x30000000 bios $(filesize)");
33d16414:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16418:	e59f12d8 	ldr	r1, [pc, #728]	; 33d166f8 <tftp_menu_shell+0x438>
33d1641c:	e1a00004 	mov	r0, r4
33d16420:	ea0000ac 	b	33d166d8 <tftp_menu_shell+0x418>
			break;
			}

			case '2':
			{
				sprintf(cmd_buf, "tftp 0x30000000 eboot.nb0; nand erase eboot; nand write.jffs2 0x30000000 eboot $(filesize)");
33d16424:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16428:	e1a00004 	mov	r0, r4
33d1642c:	e59f12c8 	ldr	r1, [pc, #712]	; 33d166fc <tftp_menu_shell+0x43c>
33d16430:	eb00122f 	bl	33d1acf4 <sprintf>
33d16434:	ea0000a8 	b	33d166dc <tftp_menu_shell+0x41c>
				break;
			}

			case '3':
			{
				strcpy(cmd_buf, "tftp 0x30000000 zImage.bin; nand erase kernel; nand write.jffs2 0x30000000 kernel $(filesize)");
33d16438:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d1643c:	e59f12bc 	ldr	r1, [pc, #700]	; 33d16700 <tftp_menu_shell+0x440>
33d16440:	e1a00004 	mov	r0, r4
33d16444:	ea0000a3 	b	33d166d8 <tftp_menu_shell+0x418>
				break;
			}

			case '4':
			{
				strcpy(cmd_buf, "tftp 0x30000000 stepldr.nb1; nand erase kernel; nand write.jffs2 0x30000000 kernel $(filesize)");
33d16448:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d1644c:	e59f12b0 	ldr	r1, [pc, #688]	; 33d16704 <tftp_menu_shell+0x444>
33d16450:	e1a00004 	mov	r0, r4
33d16454:	ea00009f 	b	33d166d8 <tftp_menu_shell+0x418>
			{
				char param_buf1[25];
				char param_buf2[25];
				char param_buf3[25];

				printf("Enter the TFTP Server(PC) IP address:(xxx.xxx.xxx.xxx)\n");
33d16458:	e59f02a8 	ldr	r0, [pc, #680]	; 33d16708 <tftp_menu_shell+0x448>
33d1645c:	eb0002d9 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf1,console_buffer);
33d16460:	e28d4084 	add	r4, sp, #132	; 0x84
				char param_buf1[25];
				char param_buf2[25];
				char param_buf3[25];

				printf("Enter the TFTP Server(PC) IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d16464:	e3a00000 	mov	r0, #0	; 0x0
				strcpy(param_buf1,console_buffer);
				sprintf(cmd_buf, "setenv serverip %s",param_buf1);
33d16468:	e28d50a0 	add	r5, sp, #160	; 0xa0
				char param_buf1[25];
				char param_buf2[25];
				char param_buf3[25];

				printf("Enter the TFTP Server(PC) IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d1646c:	ebffd964 	bl	33d0ca04 <readline>
				strcpy(param_buf1,console_buffer);
33d16470:	e59f1294 	ldr	r1, [pc, #660]	; 33d1670c <tftp_menu_shell+0x44c>
33d16474:	e1a00004 	mov	r0, r4
33d16478:	eb000ecf 	bl	33d19fbc <strcpy>
				sprintf(cmd_buf, "setenv serverip %s",param_buf1);
33d1647c:	e1a02004 	mov	r2, r4
33d16480:	e59f1288 	ldr	r1, [pc, #648]	; 33d16710 <tftp_menu_shell+0x450>
33d16484:	e1a00005 	mov	r0, r5
33d16488:	eb001219 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d1648c:	e3a01000 	mov	r1, #0	; 0x0
33d16490:	e1a00005 	mov	r0, r5
33d16494:	ebffd9d1 	bl	33d0cbe0 <run_command>

				printf("Enter the SKY2440/TQ2440 IP address:(xxx.xxx.xxx.xxx)\n");
33d16498:	e59f0274 	ldr	r0, [pc, #628]	; 33d16714 <tftp_menu_shell+0x454>
33d1649c:	eb0002c9 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf2,console_buffer);
33d164a0:	e28d4068 	add	r4, sp, #104	; 0x68
				strcpy(param_buf1,console_buffer);
				sprintf(cmd_buf, "setenv serverip %s",param_buf1);
				run_command(cmd_buf, 0);

				printf("Enter the SKY2440/TQ2440 IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d164a4:	e3a00000 	mov	r0, #0	; 0x0
33d164a8:	ebffd955 	bl	33d0ca04 <readline>
				strcpy(param_buf2,console_buffer);
33d164ac:	e59f1258 	ldr	r1, [pc, #600]	; 33d1670c <tftp_menu_shell+0x44c>
33d164b0:	e1a00004 	mov	r0, r4
33d164b4:	eb000ec0 	bl	33d19fbc <strcpy>
				sprintf(cmd_buf, "setenv ipaddr %s",param_buf2);
33d164b8:	e1a02004 	mov	r2, r4
33d164bc:	e59f1254 	ldr	r1, [pc, #596]	; 33d16718 <tftp_menu_shell+0x458>
33d164c0:	e1a00005 	mov	r0, r5
33d164c4:	eb00120a 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d164c8:	e3a01000 	mov	r1, #0	; 0x0
33d164cc:	e1a00005 	mov	r0, r5
33d164d0:	ebffd9c2 	bl	33d0cbe0 <run_command>

				printf("Enter the Mask IP address:(xxx.xxx.xxx.xxx)\n");
33d164d4:	e59f0240 	ldr	r0, [pc, #576]	; 33d1671c <tftp_menu_shell+0x45c>
33d164d8:	eb0002ba 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(param_buf3,console_buffer);
33d164dc:	e28d404c 	add	r4, sp, #76	; 0x4c
				strcpy(param_buf2,console_buffer);
				sprintf(cmd_buf, "setenv ipaddr %s",param_buf2);
				run_command(cmd_buf, 0);

				printf("Enter the Mask IP address:(xxx.xxx.xxx.xxx)\n");
				readline(NULL);
33d164e0:	e3a00000 	mov	r0, #0	; 0x0
33d164e4:	ebffd946 	bl	33d0ca04 <readline>
				strcpy(param_buf3,console_buffer);
33d164e8:	e59f121c 	ldr	r1, [pc, #540]	; 33d1670c <tftp_menu_shell+0x44c>
33d164ec:	e1a00004 	mov	r0, r4
33d164f0:	eb000eb1 	bl	33d19fbc <strcpy>
				sprintf(cmd_buf, "setenv netmask %s",param_buf3);
33d164f4:	e1a02004 	mov	r2, r4
33d164f8:	e59f1220 	ldr	r1, [pc, #544]	; 33d16720 <tftp_menu_shell+0x460>
33d164fc:	e1a00005 	mov	r0, r5
33d16500:	eb0011fb 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d16504:	e3a01000 	mov	r1, #0	; 0x0
33d16508:	e1a00005 	mov	r0, r5
33d1650c:	ebffd9b3 	bl	33d0cbe0 <run_command>

				printf("Save TFTP IP parameters?(y/n)\n");
33d16510:	e59f020c 	ldr	r0, [pc, #524]	; 33d16724 <tftp_menu_shell+0x464>
33d16514:	eb0002ab 	bl	33d16fc8 <printf>
				if (getc() == 'y' )
33d16518:	eb00028d 	bl	33d16f54 <getc>
33d1651c:	e3500079 	cmp	r0, #121	; 0x79
33d16520:	1a000008 	bne	33d16548 <tftp_menu_shell+0x288>
				{
					printf("y");
33d16524:	e59f01fc 	ldr	r0, [pc, #508]	; 33d16728 <tftp_menu_shell+0x468>
33d16528:	eb0002a6 	bl	33d16fc8 <printf>
					getc() == '\r';
33d1652c:	eb000288 	bl	33d16f54 <getc>
					printf("\n");
33d16530:	e59f01f4 	ldr	r0, [pc, #500]	; 33d1672c <tftp_menu_shell+0x46c>
33d16534:	eb0002a3 	bl	33d16fc8 <printf>
					sprintf(cmd_buf, "saveenv");
33d16538:	e1a00005 	mov	r0, r5
33d1653c:	e59f11ec 	ldr	r1, [pc, #492]	; 33d16730 <tftp_menu_shell+0x470>
33d16540:	eb0011eb 	bl	33d1acf4 <sprintf>
33d16544:	ea000042 	b	33d16654 <tftp_menu_shell+0x394>
					run_command(cmd_buf, 0);
				}
				else
				{
					printf("Not Save it!!!\n");
33d16548:	e59f01e4 	ldr	r0, [pc, #484]	; 33d16734 <tftp_menu_shell+0x474>
33d1654c:	eb00029d 	bl	33d16fc8 <printf>
				}
				break;
33d16550:	eaffff5c 	b	33d162c8 <tftp_menu_shell+0x8>
			}

			case '6':
			{
				strcpy(cmd_buf, "tftp 0x30000000 root.bin; nand erase root; nand write.yaffs 0x30000000 root $(filesize)");
33d16554:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16558:	e59f11d8 	ldr	r1, [pc, #472]	; 33d16738 <tftp_menu_shell+0x478>
33d1655c:	e1a00004 	mov	r0, r4
33d16560:	ea00005c 	b	33d166d8 <tftp_menu_shell+0x418>
			case '7':
			{
				char tftpaddress[12];
				char filename[32];

				printf("Enter downloads to SDRAM address:\n");
33d16564:	e59f01d0 	ldr	r0, [pc, #464]	; 33d1673c <tftp_menu_shell+0x47c>
33d16568:	eb000296 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(tftpaddress, console_buffer);
33d1656c:	e28d4040 	add	r4, sp, #64	; 0x40
			{
				char tftpaddress[12];
				char filename[32];

				printf("Enter downloads to SDRAM address:\n");
				readline(NULL);
33d16570:	e3a00000 	mov	r0, #0	; 0x0
33d16574:	ebffd922 	bl	33d0ca04 <readline>
				strcpy(tftpaddress, console_buffer);
33d16578:	e59f118c 	ldr	r1, [pc, #396]	; 33d1670c <tftp_menu_shell+0x44c>
33d1657c:	e1a00004 	mov	r0, r4
33d16580:	eb000e8d 	bl	33d19fbc <strcpy>

				printf("Enter program name:\n");
33d16584:	e59f01b4 	ldr	r0, [pc, #436]	; 33d16740 <tftp_menu_shell+0x480>
33d16588:	eb00028e 	bl	33d16fc8 <printf>
				readline(NULL);
				strcpy(filename, console_buffer);
33d1658c:	e28d5020 	add	r5, sp, #32	; 0x20
				printf("Enter downloads to SDRAM address:\n");
				readline(NULL);
				strcpy(tftpaddress, console_buffer);

				printf("Enter program name:\n");
				readline(NULL);
33d16590:	e3a00000 	mov	r0, #0	; 0x0
33d16594:	ebffd91a 	bl	33d0ca04 <readline>
				strcpy(filename, console_buffer);

				sprintf(cmd_buf, "tftp %s %s", tftpaddress, filename);
33d16598:	e28d60a0 	add	r6, sp, #160	; 0xa0
				readline(NULL);
				strcpy(tftpaddress, console_buffer);

				printf("Enter program name:\n");
				readline(NULL);
				strcpy(filename, console_buffer);
33d1659c:	e59f1168 	ldr	r1, [pc, #360]	; 33d1670c <tftp_menu_shell+0x44c>
33d165a0:	e1a00005 	mov	r0, r5
33d165a4:	eb000e84 	bl	33d19fbc <strcpy>

				sprintf(cmd_buf, "tftp %s %s", tftpaddress, filename);
33d165a8:	e1a03005 	mov	r3, r5
33d165ac:	e1a02004 	mov	r2, r4
33d165b0:	e59f118c 	ldr	r1, [pc, #396]	; 33d16744 <tftp_menu_shell+0x484>
33d165b4:	e1a00006 	mov	r0, r6
33d165b8:	eb0011cd 	bl	33d1acf4 <sprintf>
				printf("tftp %s %s\n", tftpaddress, filename);
33d165bc:	e1a02005 	mov	r2, r5
33d165c0:	e1a01004 	mov	r1, r4
33d165c4:	e59f017c 	ldr	r0, [pc, #380]	; 33d16748 <tftp_menu_shell+0x488>
33d165c8:	eb00027e 	bl	33d16fc8 <printf>
				run_command(cmd_buf, 0);
33d165cc:	e3a01000 	mov	r1, #0	; 0x0
33d165d0:	e1a00006 	mov	r0, r6
33d165d4:	ebffd981 	bl	33d0cbe0 <run_command>

				sprintf(cmd_buf, "go %s", tftpaddress);
33d165d8:	e1a00006 	mov	r0, r6
33d165dc:	e1a02004 	mov	r2, r4
33d165e0:	e59f1164 	ldr	r1, [pc, #356]	; 33d1674c <tftp_menu_shell+0x48c>
33d165e4:	eb0011c2 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d165e8:	e1a00006 	mov	r0, r6
33d165ec:	ea00003b 	b	33d166e0 <tftp_menu_shell+0x420>
			}

			case '8':
			{
#ifdef CONFIG_EMBEDSKY_LOGO
				embedsky_user_logo();					//user's logo display
33d165f0:	ebffcb6e 	bl	33d093b0 <embedsky_user_logo>
					run_command(cmd_buf, 0);
				}
				else
#endif
				{
					printf("Start Linux ...\n");
33d165f4:	e59f0154 	ldr	r0, [pc, #340]	; 33d16750 <tftp_menu_shell+0x490>
33d165f8:	eb000272 	bl	33d16fc8 <printf>
					strcpy(cmd_buf, "boot_zImage");
33d165fc:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16600:	e59f114c 	ldr	r1, [pc, #332]	; 33d16754 <tftp_menu_shell+0x494>
33d16604:	e1a00004 	mov	r0, r4
33d16608:	ea000032 	b	33d166d8 <tftp_menu_shell+0x418>
				break;
			}

			case '9':
			{
				strcpy(cmd_buf, "nand scrub ");
33d1660c:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16610:	e59f1140 	ldr	r1, [pc, #320]	; 33d16758 <tftp_menu_shell+0x498>
33d16614:	e1a00004 	mov	r0, r4
33d16618:	ea00002e 	b	33d166d8 <tftp_menu_shell+0x418>
				break;
			}

			case '0':
			{
				param_menu_shell();
33d1661c:	ebfffd78 	bl	33d15c04 <param_menu_shell>
				break;
33d16620:	eaffff28 	b	33d162c8 <tftp_menu_shell+0x8>
			case 'A':
			case 'a':
			{
				char filename[32];

				printf("Enter program name:\n");
33d16624:	e59f0114 	ldr	r0, [pc, #276]	; 33d16740 <tftp_menu_shell+0x480>
33d16628:	eb000266 	bl	33d16fc8 <printf>
				readline(NULL);
33d1662c:	e3a00000 	mov	r0, #0	; 0x0
33d16630:	ebffd8f3 	bl	33d0ca04 <readline>
				strcpy(filename, console_buffer);
33d16634:	e59f10d0 	ldr	r1, [pc, #208]	; 33d1670c <tftp_menu_shell+0x44c>
33d16638:	e1a0000d 	mov	r0, sp
33d1663c:	eb000e5e 	bl	33d19fbc <strcpy>

				sprintf(cmd_buf, "tftp 0x30000000 %s; nand erase 0x0 $(filesize+1); nand write.jffs2 0x30000000 0x0 $(filesize+1)", filename);
33d16640:	e28d50a0 	add	r5, sp, #160	; 0xa0
33d16644:	e59f1110 	ldr	r1, [pc, #272]	; 33d1675c <tftp_menu_shell+0x49c>
33d16648:	e1a0200d 	mov	r2, sp
33d1664c:	e1a00005 	mov	r0, r5
33d16650:	eb0011a7 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d16654:	e1a00005 	mov	r0, r5
33d16658:	ea000020 	b	33d166e0 <tftp_menu_shell+0x420>
			}

			case 'B':
			case 'b':
			{
				strcpy(cmd_buf, "tftp 0x30000000 logo.bin; nand erase logo; nand write.jffs2 0x30000000 logo $(filesize)");
33d1665c:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16660:	e59f10f8 	ldr	r1, [pc, #248]	; 33d16760 <tftp_menu_shell+0x4a0>
33d16664:	e1a00004 	mov	r0, r4
33d16668:	ea00001a 	b	33d166d8 <tftp_menu_shell+0x418>
			}

			case 'L':
			case 'l':
			{
				lcd_menu_shell();
33d1666c:	ebfffe30 	bl	33d15f34 <lcd_menu_shell>
				break;
33d16670:	eaffff14 	b	33d162c8 <tftp_menu_shell+0x8>
			}

			case 'O':
			case 'o':
			{
				if (bBootFrmNORFlash())
33d16674:	ebffa895 	bl	33d008d0 <bBootFrmNORFlash>
33d16678:	e3500000 	cmp	r0, #0	; 0x0
33d1667c:	0affff11 	beq	33d162c8 <tftp_menu_shell+0x8>
				{
					strcpy(cmd_buf, "tftp 0x30000000 uboot.bin; protect off all; erase 0 +$(filesize); cp.b 0x30000000 0 $(filesize)");
33d16680:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d16684:	e59f10d8 	ldr	r1, [pc, #216]	; 33d16764 <tftp_menu_shell+0x4a4>
33d16688:	e1a00004 	mov	r0, r4
33d1668c:	ea000011 	b	33d166d8 <tftp_menu_shell+0x418>

			case 'P':
			case 'p':
			{
				char *serverip;
				serverip=getenv("serverip");
33d16690:	e59f00d0 	ldr	r0, [pc, #208]	; 33d16768 <tftp_menu_shell+0x4a8>
33d16694:	ebfffc6d 	bl	33d15850 <getenv>
				printf("TQ2440 ping PC IP:ping %s\n",serverip);
33d16698:	e1a01000 	mov	r1, r0

			case 'P':
			case 'p':
			{
				char *serverip;
				serverip=getenv("serverip");
33d1669c:	e1a04000 	mov	r4, r0
				printf("TQ2440 ping PC IP:ping %s\n",serverip);
33d166a0:	e59f00c4 	ldr	r0, [pc, #196]	; 33d1676c <tftp_menu_shell+0x4ac>
33d166a4:	eb000247 	bl	33d16fc8 <printf>
				sprintf(cmd_buf, "ping %s",serverip);
33d166a8:	e28d50a0 	add	r5, sp, #160	; 0xa0
33d166ac:	e59f10bc 	ldr	r1, [pc, #188]	; 33d16770 <tftp_menu_shell+0x4b0>
33d166b0:	e1a02004 	mov	r2, r4
33d166b4:	e1a00005 	mov	r0, r5
33d166b8:	eaffffe4 	b	33d16650 <tftp_menu_shell+0x390>
			}

			case 'R':
			case 'r':
			{
				strcpy(cmd_buf, "reset");
33d166bc:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d166c0:	e59f10ac 	ldr	r1, [pc, #172]	; 33d16774 <tftp_menu_shell+0x4b4>
33d166c4:	e1a00004 	mov	r0, r4
33d166c8:	ea000002 	b	33d166d8 <tftp_menu_shell+0x418>
			}
			
			case 'T':
			case 't':
			{
				strcpy(cmd_buf, "tftp 0x30008000 zImage.bin; test_zImage");
33d166cc:	e28d40a0 	add	r4, sp, #160	; 0xa0
33d166d0:	e59f10a0 	ldr	r1, [pc, #160]	; 33d16778 <tftp_menu_shell+0x4b8>
33d166d4:	e1a00004 	mov	r0, r4
33d166d8:	eb000e37 	bl	33d19fbc <strcpy>
				run_command(cmd_buf, 0);
33d166dc:	e1a00004 	mov	r0, r4
33d166e0:	e3a01000 	mov	r1, #0	; 0x0
33d166e4:	ebffd93d 	bl	33d0cbe0 <run_command>
				break;
33d166e8:	eafffef6 	b	33d162c8 <tftp_menu_shell+0x8>
				break;
			}
		}
	}

}
33d166ec:	e28ddf5a 	add	sp, sp, #360	; 0x168
33d166f0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d166f4:	33d2b834 	.word	0x33d2b834
33d166f8:	33d2c13c 	.word	0x33d2c13c
33d166fc:	33d2c198 	.word	0x33d2c198
33d16700:	33d2c1f4 	.word	0x33d2c1f4
33d16704:	33d2c254 	.word	0x33d2c254
33d16708:	33d2c2b4 	.word	0x33d2c2b4
33d1670c:	33d60688 	.word	0x33d60688
33d16710:	33d2c2ec 	.word	0x33d2c2ec
33d16714:	33d2b878 	.word	0x33d2b878
33d16718:	33d2c300 	.word	0x33d2c300
33d1671c:	33d2b8b0 	.word	0x33d2b8b0
33d16720:	33d2c314 	.word	0x33d2c314
33d16724:	33d2c328 	.word	0x33d2c328
33d16728:	33d27038 	.word	0x33d27038
33d1672c:	33d2bd80 	.word	0x33d2bd80
33d16730:	33d2b374 	.word	0x33d2b374
33d16734:	33d2c348 	.word	0x33d2c348
33d16738:	33d2c358 	.word	0x33d2c358
33d1673c:	33d2c3b0 	.word	0x33d2c3b0
33d16740:	33d2c3d4 	.word	0x33d2c3d4
33d16744:	33d2c3ec 	.word	0x33d2c3ec
33d16748:	33d2c3f8 	.word	0x33d2c3f8
33d1674c:	33d2c404 	.word	0x33d2c404
33d16750:	33d2c40c 	.word	0x33d2c40c
33d16754:	33d255ac 	.word	0x33d255ac
33d16758:	33d2c420 	.word	0x33d2c420
33d1675c:	33d2c42c 	.word	0x33d2c42c
33d16760:	33d2c48c 	.word	0x33d2c48c
33d16764:	33d2c4e4 	.word	0x33d2c4e4
33d16768:	33d25894 	.word	0x33d25894
33d1676c:	33d2c544 	.word	0x33d2c544
33d16770:	33d2c560 	.word	0x33d2c560
33d16774:	33d27294 	.word	0x33d27294
33d16778:	33d2c568 	.word	0x33d2c568

33d1677c <menu_shell>:

void menu_shell(void)
{
33d1677c:	e92d4070 	push	{r4, r5, r6, lr}
33d16780:	e24dd0c8 	sub	sp, sp, #200	; 0xc8
	char c;
	char cmd_buf[200];

	while (1)
	{
		main_menu_usage(USE_USB_DOWN);
33d16784:	e3a00002 	mov	r0, #2	; 0x2
33d16788:	ebfffe63 	bl	33d1611c <main_menu_usage>
		c = awaitkey(-1, NULL);
33d1678c:	e3a01000 	mov	r1, #0	; 0x0
33d16790:	e3e00000 	mvn	r0, #0	; 0x0
33d16794:	ebffd065 	bl	33d0a930 <awaitkey>
33d16798:	e1a04000 	mov	r4, r0
33d1679c:	e20440ff 	and	r4, r4, #255	; 0xff
		printf("%c\n", c);
33d167a0:	e1a01004 	mov	r1, r4
33d167a4:	e59f027c 	ldr	r0, [pc, #636]	; 33d16a28 <menu_shell+0x2ac>
		switch (c)
33d167a8:	e2444030 	sub	r4, r4, #48	; 0x30

	while (1)
	{
		main_menu_usage(USE_USB_DOWN);
		c = awaitkey(-1, NULL);
		printf("%c\n", c);
33d167ac:	eb000205 	bl	33d16fc8 <printf>
		switch (c)
33d167b0:	e3540044 	cmp	r4, #68	; 0x44
33d167b4:	979ff104 	ldrls	pc, [pc, r4, lsl #2]
33d167b8:	eafffff1 	b	33d16784 <menu_shell+0x8>
33d167bc:	33d1699c 	.word	0x33d1699c
33d167c0:	33d168d0 	.word	0x33d168d0
33d167c4:	33d168e0 	.word	0x33d168e0
33d167c8:	33d168f4 	.word	0x33d168f4
33d167cc:	33d16784 	.word	0x33d16784
33d167d0:	33d16904 	.word	0x33d16904
33d167d4:	33d16914 	.word	0x33d16914
33d167d8:	33d16924 	.word	0x33d16924
33d167dc:	33d16970 	.word	0x33d16970
33d167e0:	33d1698c 	.word	0x33d1698c
33d167e4:	33d16784 	.word	0x33d16784
33d167e8:	33d16784 	.word	0x33d16784
33d167ec:	33d16784 	.word	0x33d16784
33d167f0:	33d16784 	.word	0x33d16784
33d167f4:	33d16784 	.word	0x33d16784
33d167f8:	33d16784 	.word	0x33d16784
33d167fc:	33d16784 	.word	0x33d16784
33d16800:	33d169a4 	.word	0x33d169a4
33d16804:	33d169b4 	.word	0x33d169b4
33d16808:	33d16784 	.word	0x33d16784
33d1680c:	33d16784 	.word	0x33d16784
33d16810:	33d16784 	.word	0x33d16784
33d16814:	33d16784 	.word	0x33d16784
33d16818:	33d16784 	.word	0x33d16784
33d1681c:	33d16784 	.word	0x33d16784
33d16820:	33d16784 	.word	0x33d16784
33d16824:	33d16784 	.word	0x33d16784
33d16828:	33d16784 	.word	0x33d16784
33d1682c:	33d169c4 	.word	0x33d169c4
33d16830:	33d16784 	.word	0x33d16784
33d16834:	33d169cc 	.word	0x33d169cc
33d16838:	33d169d4 	.word	0x33d169d4
33d1683c:	33d16784 	.word	0x33d16784
33d16840:	33d16a20 	.word	0x33d16a20
33d16844:	33d169f0 	.word	0x33d169f0
33d16848:	33d16784 	.word	0x33d16784
33d1684c:	33d16a00 	.word	0x33d16a00
33d16850:	33d16784 	.word	0x33d16784
33d16854:	33d16784 	.word	0x33d16784
33d16858:	33d16784 	.word	0x33d16784
33d1685c:	33d16784 	.word	0x33d16784
33d16860:	33d16784 	.word	0x33d16784
33d16864:	33d16784 	.word	0x33d16784
33d16868:	33d16784 	.word	0x33d16784
33d1686c:	33d16784 	.word	0x33d16784
33d16870:	33d16784 	.word	0x33d16784
33d16874:	33d16784 	.word	0x33d16784
33d16878:	33d16784 	.word	0x33d16784
33d1687c:	33d16784 	.word	0x33d16784
33d16880:	33d169a4 	.word	0x33d169a4
33d16884:	33d169b4 	.word	0x33d169b4
33d16888:	33d16784 	.word	0x33d16784
33d1688c:	33d16784 	.word	0x33d16784
33d16890:	33d16784 	.word	0x33d16784
33d16894:	33d16784 	.word	0x33d16784
33d16898:	33d16784 	.word	0x33d16784
33d1689c:	33d16784 	.word	0x33d16784
33d168a0:	33d16784 	.word	0x33d16784
33d168a4:	33d16784 	.word	0x33d16784
33d168a8:	33d16784 	.word	0x33d16784
33d168ac:	33d169c4 	.word	0x33d169c4
33d168b0:	33d16784 	.word	0x33d16784
33d168b4:	33d169cc 	.word	0x33d169cc
33d168b8:	33d169d4 	.word	0x33d169d4
33d168bc:	33d16784 	.word	0x33d16784
33d168c0:	33d16a20 	.word	0x33d16a20
33d168c4:	33d169f0 	.word	0x33d169f0
33d168c8:	33d16784 	.word	0x33d16784
33d168cc:	33d16a00 	.word	0x33d16a00
		{
			case '1':
			{
				strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase bios; nand write.jffs2 0x30000000 bios $(filesize)");
33d168d0:	e59f1154 	ldr	r1, [pc, #340]	; 33d16a2c <menu_shell+0x2b0>
33d168d4:	e1a0400d 	mov	r4, sp
33d168d8:	e1a0000d 	mov	r0, sp
33d168dc:	ea00004a 	b	33d16a0c <menu_shell+0x290>
				break;
			}
			
			case '2':
			{
				sprintf(cmd_buf, "usbslave 1 0x30000000; nand erase eboot; nand write.jffs2 0x30000000 eboot $(filesize)");
33d168e0:	e1a0000d 	mov	r0, sp
33d168e4:	e59f1144 	ldr	r1, [pc, #324]	; 33d16a30 <menu_shell+0x2b4>
33d168e8:	e1a0400d 	mov	r4, sp
33d168ec:	eb001100 	bl	33d1acf4 <sprintf>
33d168f0:	ea000046 	b	33d16a10 <menu_shell+0x294>
				break;
			}

			case '3':
			{
				strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase kernel; nand write.jffs2 0x30000000 kernel $(filesize)");
33d168f4:	e59f1138 	ldr	r1, [pc, #312]	; 33d16a34 <menu_shell+0x2b8>
33d168f8:	e1a0400d 	mov	r4, sp
33d168fc:	e1a0000d 	mov	r0, sp
33d16900:	ea000041 	b	33d16a0c <menu_shell+0x290>
				break;
			}
#endif
			case '5':
			{
				strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.jffs2 0x30000000 root $(filesize)");
33d16904:	e59f112c 	ldr	r1, [pc, #300]	; 33d16a38 <menu_shell+0x2bc>
33d16908:	e1a0400d 	mov	r4, sp
33d1690c:	e1a0000d 	mov	r0, sp
33d16910:	ea00003d 	b	33d16a0c <menu_shell+0x290>
				break;
			}

			case '6':
			{
				strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.yaffs 0x30000000 root $(filesize)");
33d16914:	e59f1120 	ldr	r1, [pc, #288]	; 33d16a3c <menu_shell+0x2c0>
33d16918:	e1a0400d 	mov	r4, sp
33d1691c:	e1a0000d 	mov	r0, sp
33d16920:	ea000039 	b	33d16a0c <menu_shell+0x290>
			case '7':
			{
				extern volatile U32 downloadAddress;
				extern int download_run;
				
				download_run = 1;
33d16924:	e59f6114 	ldr	r6, [pc, #276]	; 33d16a40 <menu_shell+0x2c4>
33d16928:	e3a03001 	mov	r3, #1	; 0x1
				strcpy(cmd_buf, "usbslave 1");
33d1692c:	e59f1110 	ldr	r1, [pc, #272]	; 33d16a44 <menu_shell+0x2c8>
33d16930:	e1a0000d 	mov	r0, sp
			case '7':
			{
				extern volatile U32 downloadAddress;
				extern int download_run;
				
				download_run = 1;
33d16934:	e5863000 	str	r3, [r6]
				strcpy(cmd_buf, "usbslave 1");
33d16938:	eb000d9f 	bl	33d19fbc <strcpy>
				run_command(cmd_buf, 0);
33d1693c:	e3a01000 	mov	r1, #0	; 0x0
33d16940:	e1a0000d 	mov	r0, sp
33d16944:	ebffd8a5 	bl	33d0cbe0 <run_command>
				download_run = 0;
				sprintf(cmd_buf, "go %x", downloadAddress);
33d16948:	e59f30f8 	ldr	r3, [pc, #248]	; 33d16a48 <menu_shell+0x2cc>
				extern int download_run;
				
				download_run = 1;
				strcpy(cmd_buf, "usbslave 1");
				run_command(cmd_buf, 0);
				download_run = 0;
33d1694c:	e3a05000 	mov	r5, #0	; 0x0
				sprintf(cmd_buf, "go %x", downloadAddress);
33d16950:	e59f10f4 	ldr	r1, [pc, #244]	; 33d16a4c <menu_shell+0x2d0>
33d16954:	e5932000 	ldr	r2, [r3]
33d16958:	e1a0000d 	mov	r0, sp
				extern int download_run;
				
				download_run = 1;
				strcpy(cmd_buf, "usbslave 1");
				run_command(cmd_buf, 0);
				download_run = 0;
33d1695c:	e5865000 	str	r5, [r6]
				sprintf(cmd_buf, "go %x", downloadAddress);
33d16960:	eb0010e3 	bl	33d1acf4 <sprintf>
				run_command(cmd_buf, 0);
33d16964:	e1a0000d 	mov	r0, sp
33d16968:	e1a01005 	mov	r1, r5
33d1696c:	ea000029 	b	33d16a18 <menu_shell+0x29c>
			}

			case '8':
			{
#ifdef CONFIG_EMBEDSKY_LOGO
				embedsky_user_logo();					//user's logo display
33d16970:	ebffca8e 	bl	33d093b0 <embedsky_user_logo>
					run_command(cmd_buf, 0);
				}
				else
#endif
				{
					printf("Start Linux ...\n");
33d16974:	e59f00d4 	ldr	r0, [pc, #212]	; 33d16a50 <menu_shell+0x2d4>
33d16978:	eb000192 	bl	33d16fc8 <printf>
					strcpy(cmd_buf, "boot_zImage");
33d1697c:	e59f10d0 	ldr	r1, [pc, #208]	; 33d16a54 <menu_shell+0x2d8>
33d16980:	e1a0400d 	mov	r4, sp
33d16984:	e1a0000d 	mov	r0, sp
33d16988:	ea00001f 	b	33d16a0c <menu_shell+0x290>
				break;
			}

			case '9':
			{
				strcpy(cmd_buf, "nand scrub ");
33d1698c:	e59f10c4 	ldr	r1, [pc, #196]	; 33d16a58 <menu_shell+0x2dc>
33d16990:	e1a0400d 	mov	r4, sp
33d16994:	e1a0000d 	mov	r0, sp
33d16998:	ea00001b 	b	33d16a0c <menu_shell+0x290>
				break;
			}

			case '0':
			{
				param_menu_shell();
33d1699c:	ebfffc98 	bl	33d15c04 <param_menu_shell>
				break;
33d169a0:	eaffff77 	b	33d16784 <menu_shell+0x8>
			}

			case 'A':
			case 'a':
			{
				strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase 0x0 $(filesize+1); nand write.jffs2 0x30000000 0x0 $(filesize+1)");
33d169a4:	e59f10b0 	ldr	r1, [pc, #176]	; 33d16a5c <menu_shell+0x2e0>
33d169a8:	e1a0400d 	mov	r4, sp
33d169ac:	e1a0000d 	mov	r0, sp
33d169b0:	ea000015 	b	33d16a0c <menu_shell+0x290>
			}

			case 'B':
			case 'b':
			{
				strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase logo; nand write.jffs2 0x30000000 logo $(filesize)");
33d169b4:	e59f10a4 	ldr	r1, [pc, #164]	; 33d16a60 <menu_shell+0x2e4>
33d169b8:	e1a0400d 	mov	r4, sp
33d169bc:	e1a0000d 	mov	r0, sp
33d169c0:	ea000011 	b	33d16a0c <menu_shell+0x290>
			}

			case 'L':
			case 'l':
			{
				lcd_menu_shell();
33d169c4:	ebfffd5a 	bl	33d15f34 <lcd_menu_shell>
				break;
33d169c8:	eaffff6d 	b	33d16784 <menu_shell+0x8>
			}

			case 'N':
			case 'n':
			{
				tftp_menu_shell();
33d169cc:	ebfffe3b 	bl	33d162c0 <tftp_menu_shell>
				break;
33d169d0:	eaffff6b 	b	33d16784 <menu_shell+0x8>
			}

			case 'O':
			case 'o':
			{
				if (bBootFrmNORFlash())
33d169d4:	ebffa7bd 	bl	33d008d0 <bBootFrmNORFlash>
33d169d8:	e3500000 	cmp	r0, #0	; 0x0
33d169dc:	0affff68 	beq	33d16784 <menu_shell+0x8>
				{
					strcpy(cmd_buf, "usbslave 1 0x30000000; protect off all; erase 0 +$(filesize); cp.b 0x30000000 0 $(filesize)");
33d169e0:	e59f107c 	ldr	r1, [pc, #124]	; 33d16a64 <menu_shell+0x2e8>
33d169e4:	e1a0400d 	mov	r4, sp
33d169e8:	e1a0000d 	mov	r0, sp
33d169ec:	ea000006 	b	33d16a0c <menu_shell+0x290>
			}

			case 'R':
			case 'r':
			{
				strcpy(cmd_buf, "reset");
33d169f0:	e59f1070 	ldr	r1, [pc, #112]	; 33d16a68 <menu_shell+0x2ec>
33d169f4:	e1a0400d 	mov	r4, sp
33d169f8:	e1a0000d 	mov	r0, sp
33d169fc:	ea000002 	b	33d16a0c <menu_shell+0x290>
			}
			
			case 'T':
			case 't':
			{
				strcpy(cmd_buf, "usbslave 1 0x30008000; test_zImage");
33d16a00:	e59f1064 	ldr	r1, [pc, #100]	; 33d16a6c <menu_shell+0x2f0>
33d16a04:	e1a0400d 	mov	r4, sp
33d16a08:	e1a0000d 	mov	r0, sp
33d16a0c:	eb000d6a 	bl	33d19fbc <strcpy>
				run_command(cmd_buf, 0);
33d16a10:	e1a00004 	mov	r0, r4
33d16a14:	e3a01000 	mov	r1, #0	; 0x0
33d16a18:	ebffd870 	bl	33d0cbe0 <run_command>
				break;
33d16a1c:	eaffff58 	b	33d16784 <menu_shell+0x8>
			}

		}
				
	}
}
33d16a20:	e28dd0c8 	add	sp, sp, #200	; 0xc8
33d16a24:	e8bd8070 	pop	{r4, r5, r6, pc}
33d16a28:	33d2b834 	.word	0x33d2b834
33d16a2c:	33d2c590 	.word	0x33d2c590
33d16a30:	33d2c5e8 	.word	0x33d2c5e8
33d16a34:	33d2c640 	.word	0x33d2c640
33d16a38:	33d2c69c 	.word	0x33d2c69c
33d16a3c:	33d2c6f4 	.word	0x33d2c6f4
33d16a40:	33d60404 	.word	0x33d60404
33d16a44:	33d2c74c 	.word	0x33d2c74c
33d16a48:	33d60420 	.word	0x33d60420
33d16a4c:	33d2c758 	.word	0x33d2c758
33d16a50:	33d2c40c 	.word	0x33d2c40c
33d16a54:	33d255ac 	.word	0x33d255ac
33d16a58:	33d2c420 	.word	0x33d2c420
33d16a5c:	33d2c760 	.word	0x33d2c760
33d16a60:	33d2c7c4 	.word	0x33d2c7c4
33d16a64:	33d2c81c 	.word	0x33d2c81c
33d16a68:	33d27294 	.word	0x33d27294
33d16a6c:	33d2c878 	.word	0x33d2c878

33d16a70 <do_menu>:

int do_menu (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d16a70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	menu_shell();
33d16a74:	ebffff40 	bl	33d1677c <menu_shell>
	return 0;
}
33d16a78:	e3a00000 	mov	r0, #0	; 0x0
33d16a7c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d16a80 <do_version>:
#include <common.h>
#include <command.h>

int
do_version (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d16a80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	extern char version_string[];
	printf ("\n%s\n", version_string);
33d16a84:	e59f000c 	ldr	r0, [pc, #12]	; 33d16a98 <do_version+0x18>
33d16a88:	e59f100c 	ldr	r1, [pc, #12]	; 33d16a9c <do_version+0x1c>
33d16a8c:	eb00014d 	bl	33d16fc8 <printf>
	return 0;
}
33d16a90:	e3a00000 	mov	r0, #0	; 0x0
33d16a94:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d16a98:	33d2caa4 	.word	0x33d2caa4
33d16a9c:	33d247f0 	.word	0x33d247f0

33d16aa0 <do_echo>:

#if (CONFIG_COMMANDS & CFG_CMD_ECHO)

int
do_echo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d16aa0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i, putnl = 1;
33d16aa4:	e3a06001 	mov	r6, #1	; 0x1

	for (i = 1; i < argc; i++) {
33d16aa8:	e1560002 	cmp	r6, r2

#if (CONFIG_COMMANDS & CFG_CMD_ECHO)

int
do_echo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d16aac:	e1a07002 	mov	r7, r2
33d16ab0:	e1a0a003 	mov	sl, r3
	int i, putnl = 1;

	for (i = 1; i < argc; i++) {
33d16ab4:	e1a05006 	mov	r5, r6
33d16ab8:	aa000014 	bge	33d16b10 <do_echo+0x70>
		char *p = argv[i], c;

		if (i > 1)
33d16abc:	e3550001 	cmp	r5, #1	; 0x1
do_echo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int i, putnl = 1;

	for (i = 1; i < argc; i++) {
		char *p = argv[i], c;
33d16ac0:	e79a4105 	ldr	r4, [sl, r5, lsl #2]

		if (i > 1)
33d16ac4:	da000001 	ble	33d16ad0 <do_echo+0x30>
			putc(' ');
33d16ac8:	e3a00020 	mov	r0, #32	; 0x20
33d16acc:	eb00012c 	bl	33d16f84 <putc>
		while ((c = *p++) != '\0') {
			if (c == '\\' && *p == 'c') {
				putnl = 0;
				p++;
			} else {
				putc(c);
33d16ad0:	e4d40001 	ldrb	r0, [r4], #1
33d16ad4:	e3500000 	cmp	r0, #0	; 0x0
33d16ad8:	0a000007 	beq	33d16afc <do_echo+0x5c>
		char *p = argv[i], c;

		if (i > 1)
			putc(' ');
		while ((c = *p++) != '\0') {
			if (c == '\\' && *p == 'c') {
33d16adc:	e350005c 	cmp	r0, #92	; 0x5c
33d16ae0:	1afffff9 	bne	33d16acc <do_echo+0x2c>
33d16ae4:	e5d43000 	ldrb	r3, [r4]
33d16ae8:	e3530063 	cmp	r3, #99	; 0x63
33d16aec:	1afffff6 	bne	33d16acc <do_echo+0x2c>
				putnl = 0;
				p++;
33d16af0:	e2844001 	add	r4, r4, #1	; 0x1

		if (i > 1)
			putc(' ');
		while ((c = *p++) != '\0') {
			if (c == '\\' && *p == 'c') {
				putnl = 0;
33d16af4:	e3a06000 	mov	r6, #0	; 0x0
				p++;
33d16af8:	eafffff4 	b	33d16ad0 <do_echo+0x30>
int
do_echo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int i, putnl = 1;

	for (i = 1; i < argc; i++) {
33d16afc:	e2855001 	add	r5, r5, #1	; 0x1
33d16b00:	e1550007 	cmp	r5, r7
33d16b04:	baffffec 	blt	33d16abc <do_echo+0x1c>
				putc(c);
			}
		}
	}

	if (putnl)
33d16b08:	e3560000 	cmp	r6, #0	; 0x0
33d16b0c:	0a000001 	beq	33d16b18 <do_echo+0x78>
		putc('\n');
33d16b10:	e3a0000a 	mov	r0, #10	; 0xa
33d16b14:	eb00011a 	bl	33d16f84 <putc>
	return 0;
}
33d16b18:	e3a00000 	mov	r0, #0	; 0x0
33d16b1c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

33d16b20 <find_cmd>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd (const char *cmd)
{
33d16b20:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}

	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
33d16b24:	e3a0102e 	mov	r1, #46	; 0x2e

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd (const char *cmd)
{
33d16b28:	e1a06000 	mov	r6, r0

	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
33d16b2c:	eb000d6b 	bl	33d1a0e0 <strchr>
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd (const char *cmd)
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = &__u_boot_cmd_start;	/*Init value */
33d16b30:	e59f7088 	ldr	r7, [pc, #136]	; 33d16bc0 <find_cmd+0xa0>

	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
33d16b34:	e3500000 	cmp	r0, #0	; 0x0
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd (const char *cmd)
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = &__u_boot_cmd_start;	/*Init value */
33d16b38:	e1a04007 	mov	r4, r7
	const char *p;
	int len;
	int n_found = 0;
33d16b3c:	e3a0a000 	mov	sl, #0	; 0x0

	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
33d16b40:	10665000 	rsbne	r5, r6, r0
33d16b44:	1a000002 	bne	33d16b54 <find_cmd+0x34>
33d16b48:	e1a00006 	mov	r0, r6
33d16b4c:	eb000d6f 	bl	33d1a110 <strlen>
33d16b50:	e1a05000 	mov	r5, r0

	for (cmdtp = &__u_boot_cmd_start;
33d16b54:	e59f9068 	ldr	r9, [pc, #104]	; 33d16bc4 <find_cmd+0xa4>
33d16b58:	e1540009 	cmp	r4, r9
33d16b5c:	e59f405c 	ldr	r4, [pc, #92]	; 33d16bc0 <find_cmd+0xa0>
33d16b60:	0a000014 	beq	33d16bb8 <find_cmd+0x98>
	     cmdtp != &__u_boot_cmd_end;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
33d16b64:	e5941000 	ldr	r1, [r4]
33d16b68:	e1a02005 	mov	r2, r5
33d16b6c:	e1a00006 	mov	r0, r6
33d16b70:	eb000d48 	bl	33d1a098 <strncmp>
33d16b74:	e3500000 	cmp	r0, #0	; 0x0
33d16b78:	1a000005 	bne	33d16b94 <find_cmd+0x74>
			if (len == strlen (cmdtp->name))
33d16b7c:	e5940000 	ldr	r0, [r4]
33d16b80:	eb000d62 	bl	33d1a110 <strlen>
33d16b84:	e1550000 	cmp	r5, r0
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
33d16b88:	e28aa001 	add	sl, sl, #1	; 0x1

	for (cmdtp = &__u_boot_cmd_start;
	     cmdtp != &__u_boot_cmd_end;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
			if (len == strlen (cmdtp->name))
33d16b8c:	0a000007 	beq	33d16bb0 <find_cmd+0x90>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
33d16b90:	e1a07004 	mov	r7, r4
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = &__u_boot_cmd_start;
33d16b94:	e2844018 	add	r4, r4, #24	; 0x18
33d16b98:	e1540009 	cmp	r4, r9
33d16b9c:	1afffff0 	bne	33d16b64 <find_cmd+0x44>

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
		}
	}
	if (n_found == 1) {			/* exactly one match */
33d16ba0:	e35a0001 	cmp	sl, #1	; 0x1
		return cmdtp_temp;
33d16ba4:	01a00007 	moveq	r0, r7

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
		}
	}
	if (n_found == 1) {			/* exactly one match */
33d16ba8:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
33d16bac:	ea000001 	b	33d16bb8 <find_cmd+0x98>
	for (cmdtp = &__u_boot_cmd_start;
	     cmdtp != &__u_boot_cmd_end;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
			if (len == strlen (cmdtp->name))
				return cmdtp;	/* full match */
33d16bb0:	e1a00004 	mov	r0, r4
33d16bb4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
33d16bb8:	e3a00000 	mov	r0, #0	; 0x0
}
33d16bbc:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d16bc0:	33d36bf0 	.word	0x33d36bf0
33d16bc4:	33d37178 	.word	0x33d37178

33d16bc8 <do_help>:
/*
 * Use puts() instead of printf() to avoid printf buffer overflow
 * for long help messages
 */
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d16bc8:	e1a0c00d 	mov	ip, sp
33d16bcc:	e92ddef0 	push	{r4, r5, r6, r7, r9, sl, fp, ip, lr, pc}
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
33d16bd0:	e3520001 	cmp	r2, #1	; 0x1
/*
 * Use puts() instead of printf() to avoid printf buffer overflow
 * for long help messages
 */
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
33d16bd4:	e24cb004 	sub	fp, ip, #4	; 0x4
33d16bd8:	e24dd004 	sub	sp, sp, #4	; 0x4
33d16bdc:	e1a04002 	mov	r4, r2
33d16be0:	e1a0a003 	mov	sl, r3
	int i;
	int rcode = 0;
33d16be4:	e3a07000 	mov	r7, #0	; 0x0
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
33d16be8:	13a06001 	movne	r6, #1	; 0x1
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
33d16bec:	1a000043 	bne	33d16d00 <do_help+0x138>

		int cmd_items = &__u_boot_cmd_end -
33d16bf0:	e59f1180 	ldr	r1, [pc, #384]	; 33d16d78 <do_help+0x1b0>
33d16bf4:	e59f2180 	ldr	r2, [pc, #384]	; 33d16d7c <do_help+0x1b4>
33d16bf8:	e0612002 	rsb	r2, r1, r2
33d16bfc:	e1a021c2 	asr	r2, r2, #3
33d16c00:	e0823102 	add	r3, r2, r2, lsl #2
33d16c04:	e0833203 	add	r3, r3, r3, lsl #4
33d16c08:	e0833403 	add	r3, r3, r3, lsl #8
33d16c0c:	e0833803 	add	r3, r3, r3, lsl #16
33d16c10:	e0829083 	add	r9, r2, r3, lsl #1
				&__u_boot_cmd_start;	/* pointer arith! */
		cmd_tbl_t *cmd_array[cmd_items];
33d16c14:	e1a03109 	lsl	r3, r9, #2
33d16c18:	e2833004 	add	r3, r3, #4	; 0x4
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
33d16c1c:	e50bd028 	str	sp, [fp, #-40]

		int cmd_items = &__u_boot_cmd_end -
				&__u_boot_cmd_start;	/* pointer arith! */
		cmd_tbl_t *cmd_array[cmd_items];
33d16c20:	e063d00d 	rsb	sp, r3, sp
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = &__u_boot_cmd_start;
		for (i = 0; i < cmd_items; i++) {
33d16c24:	e1a04007 	mov	r4, r7
33d16c28:	e1570009 	cmp	r7, r9
				&__u_boot_cmd_start;	/* pointer arith! */
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = &__u_boot_cmd_start;
33d16c2c:	e1a05001 	mov	r5, r1

	if (argc == 1) {	/*show list of commands */

		int cmd_items = &__u_boot_cmd_end -
				&__u_boot_cmd_start;	/* pointer arith! */
		cmd_tbl_t *cmd_array[cmd_items];
33d16c30:	e1a0700d 	mov	r7, sp
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = &__u_boot_cmd_start;
		for (i = 0; i < cmd_items; i++) {
33d16c34:	aa000004 	bge	33d16c4c <do_help+0x84>
			cmd_array[i] = cmdtp++;
33d16c38:	e7875104 	str	r5, [r7, r4, lsl #2]
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = &__u_boot_cmd_start;
		for (i = 0; i < cmd_items; i++) {
33d16c3c:	e2844001 	add	r4, r4, #1	; 0x1
33d16c40:	e1540009 	cmp	r4, r9
			cmd_array[i] = cmdtp++;
33d16c44:	e2855018 	add	r5, r5, #24	; 0x18
33d16c48:	eafffff9 	b	33d16c34 <do_help+0x6c>
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
33d16c4c:	e2494001 	sub	r4, r9, #1	; 0x1
33d16c50:	e3540000 	cmp	r4, #0	; 0x0
33d16c54:	da000015 	ble	33d16cb0 <do_help+0xe8>
			swaps = 0;
33d16c58:	e3a0a000 	mov	sl, #0	; 0x0
			for (j = 0; j < i; ++j) {
33d16c5c:	e15a0004 	cmp	sl, r4
33d16c60:	e1a0500a 	mov	r5, sl
33d16c64:	aa000011 	bge	33d16cb0 <do_help+0xe8>
				if (strcmp (cmd_array[j]->name,
33d16c68:	e0876105 	add	r6, r7, r5, lsl #2
33d16c6c:	e7973105 	ldr	r3, [r7, r5, lsl #2]
33d16c70:	e5962004 	ldr	r2, [r6, #4]
33d16c74:	e5930000 	ldr	r0, [r3]
33d16c78:	e5921000 	ldr	r1, [r2]
33d16c7c:	eb000cf9 	bl	33d1a068 <strcmp>
33d16c80:	e3500000 	cmp	r0, #0	; 0x0
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
33d16c84:	c5963004 	ldrgt	r3, [r6, #4]
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
33d16c88:	c7972105 	ldrgt	r2, [r7, r5, lsl #2]
					cmd_array[j] = cmd_array[j + 1];
33d16c8c:	c7873105 	strgt	r3, [r7, r5, lsl #2]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
33d16c90:	e2855001 	add	r5, r5, #1	; 0x1
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
33d16c94:	c28aa001 	addgt	sl, sl, #1	; 0x1
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
33d16c98:	c5862004 	strgt	r2, [r6, #4]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
33d16c9c:	e1550004 	cmp	r5, r4
33d16ca0:	bafffff0 	blt	33d16c68 <do_help+0xa0>
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
				}
			}
			if (!swaps)
33d16ca4:	e35a0000 	cmp	sl, #0	; 0x0
		for (i = 0; i < cmd_items; i++) {
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
33d16ca8:	12444001 	subne	r4, r4, #1	; 0x1
33d16cac:	1affffe7 	bne	33d16c50 <do_help+0x88>
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
33d16cb0:	e3a04000 	mov	r4, #0	; 0x0
33d16cb4:	e1540009 	cmp	r4, r9
33d16cb8:	aa00000a 	bge	33d16ce8 <do_help+0x120>
			const char *usage = cmd_array[i]->usage;
33d16cbc:	e7973104 	ldr	r3, [r7, r4, lsl #2]
33d16cc0:	e5935010 	ldr	r5, [r3, #16]

			/* allow user abort */
			if (ctrlc ())
33d16cc4:	eb0000d8 	bl	33d1702c <ctrlc>
33d16cc8:	e3500000 	cmp	r0, #0	; 0x0
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
33d16ccc:	e2844001 	add	r4, r4, #1	; 0x1
			/* allow user abort */
			if (ctrlc ())
				return 1;
			if (usage == NULL)
				continue;
			puts (usage);
33d16cd0:	e1a00005 	mov	r0, r5
		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
33d16cd4:	1a000006 	bne	33d16cf4 <do_help+0x12c>
				return 1;
			if (usage == NULL)
33d16cd8:	e3550000 	cmp	r5, #0	; 0x0
33d16cdc:	0afffff4 	beq	33d16cb4 <do_help+0xec>
				continue;
			puts (usage);
33d16ce0:	eb0000b1 	bl	33d16fac <puts>
33d16ce4:	eafffff2 	b	33d16cb4 <do_help+0xec>
		}
		return 0;
33d16ce8:	e51bd028 	ldr	sp, [fp, #-40]
33d16cec:	e3a00000 	mov	r0, #0	; 0x0
33d16cf0:	ea00001e 	b	33d16d70 <do_help+0x1a8>
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
				return 1;
33d16cf4:	e51bd028 	ldr	sp, [fp, #-40]
33d16cf8:	e3a00001 	mov	r0, #1	; 0x1
33d16cfc:	ea00001b 	b	33d16d70 <do_help+0x1a8>
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
33d16d00:	e1560004 	cmp	r6, r4
33d16d04:	aa000018 	bge	33d16d6c <do_help+0x1a4>
		if ((cmdtp = find_cmd (argv[i])) != NULL) {
33d16d08:	e79a0106 	ldr	r0, [sl, r6, lsl #2]
33d16d0c:	ebffff83 	bl	33d16b20 <find_cmd>
33d16d10:	e2505000 	subs	r5, r0, #0	; 0x0
#else	/* no long help available */
			if (cmdtp->usage)
				puts (cmdtp->usage);
#endif	/* CFG_LONGHELP */
		} else {
			printf ("Unknown command '%s' - try 'help'"
33d16d14:	e59f0064 	ldr	r0, [pc, #100]	; 33d16d80 <do_help+0x1b8>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
		if ((cmdtp = find_cmd (argv[i])) != NULL) {
33d16d18:	0a00000e 	beq	33d16d58 <do_help+0x190>
#ifdef	CFG_LONGHELP
			/* found - print (long) help info */
			puts (cmdtp->name);
33d16d1c:	e5950000 	ldr	r0, [r5]
33d16d20:	eb0000a1 	bl	33d16fac <puts>
			putc (' ');
33d16d24:	e3a00020 	mov	r0, #32	; 0x20
33d16d28:	eb000095 	bl	33d16f84 <putc>
			if (cmdtp->help) {
33d16d2c:	e5953014 	ldr	r3, [r5, #20]
33d16d30:	e2530000 	subs	r0, r3, #0	; 0x0
33d16d34:	0a000001 	beq	33d16d40 <do_help+0x178>
				puts (cmdtp->help);
33d16d38:	eb00009b 	bl	33d16fac <puts>
33d16d3c:	ea000002 	b	33d16d4c <do_help+0x184>
			} else {
				puts ("- No help available.\n");
33d16d40:	e59f003c 	ldr	r0, [pc, #60]	; 33d16d84 <do_help+0x1bc>
33d16d44:	eb000098 	bl	33d16fac <puts>
				rcode = 1;
33d16d48:	e3a07001 	mov	r7, #1	; 0x1
			}
			putc ('\n');
33d16d4c:	e3a0000a 	mov	r0, #10	; 0xa
33d16d50:	eb00008b 	bl	33d16f84 <putc>
33d16d54:	ea000002 	b	33d16d64 <do_help+0x19c>
#else	/* no long help available */
			if (cmdtp->usage)
				puts (cmdtp->usage);
#endif	/* CFG_LONGHELP */
		} else {
			printf ("Unknown command '%s' - try 'help'"
33d16d58:	e79a1106 	ldr	r1, [sl, r6, lsl #2]
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
33d16d5c:	e3a07001 	mov	r7, #1	; 0x1
#else	/* no long help available */
			if (cmdtp->usage)
				puts (cmdtp->usage);
#endif	/* CFG_LONGHELP */
		} else {
			printf ("Unknown command '%s' - try 'help'"
33d16d60:	eb000098 	bl	33d16fc8 <printf>
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
33d16d64:	e2866001 	add	r6, r6, #1	; 0x1
33d16d68:	eaffffe4 	b	33d16d00 <do_help+0x138>
				" known commands\n\n", argv[i]
					);
			rcode = 1;
		}
	}
	return rcode;
33d16d6c:	e1a00007 	mov	r0, r7
}
33d16d70:	e24bd024 	sub	sp, fp, #36	; 0x24
33d16d74:	e89daef0 	ldm	sp, {r4, r5, r6, r7, r9, sl, fp, sp, pc}
33d16d78:	33d36bf0 	.word	0x33d36bf0
33d16d7c:	33d37178 	.word	0x33d37178
33d16d80:	33d2caac 	.word	0x33d2caac
33d16d84:	33d2cb04 	.word	0x33d2cb04

33d16d88 <console_setfile>:
#endif /* CFG_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CFG_CONSOLE_IS_IN_ENV */

static int console_setfile (int file, device_t * dev)
{
33d16d88:	e92d4030 	push	{r4, r5, lr}
	int error = 0;

	if (dev == NULL)
33d16d8c:	e2515000 	subs	r5, r1, #0	; 0x0
#endif /* CFG_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CFG_CONSOLE_IS_IN_ENV */

static int console_setfile (int file, device_t * dev)
{
33d16d90:	e1a04000 	mov	r4, r0
	int error = 0;
33d16d94:	e3a00000 	mov	r0, #0	; 0x0

	if (dev == NULL)
		return -1;
33d16d98:	02400001 	subeq	r0, r0, #1	; 0x1

static int console_setfile (int file, device_t * dev)
{
	int error = 0;

	if (dev == NULL)
33d16d9c:	08bd8030 	popeq	{r4, r5, pc}
		return -1;

	switch (file) {
33d16da0:	e3540002 	cmp	r4, #2	; 0x2
			break;
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
33d16da4:	83e00000 	mvnhi	r0, #0	; 0x0
	int error = 0;

	if (dev == NULL)
		return -1;

	switch (file) {
33d16da8:	88bd8030 	pophi	{r4, r5, pc}
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
33d16dac:	e5953018 	ldr	r3, [r5, #24]
33d16db0:	e3530000 	cmp	r3, #0	; 0x0
33d16db4:	0a000003 	beq	33d16dc8 <console_setfile+0x40>
			error = dev->start ();
33d16db8:	e1a0e00f 	mov	lr, pc
33d16dbc:	e1a0f003 	mov	pc, r3
			/* If it's not started dont use it */
			if (error < 0)
33d16dc0:	e3500000 	cmp	r0, #0	; 0x0
33d16dc4:	b8bd8030 	poplt	{r4, r5, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
33d16dc8:	e59f3058 	ldr	r3, [pc, #88]	; 33d16e28 <console_setfile+0xa0>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
33d16dcc:	e3540000 	cmp	r4, #0	; 0x0
			if (error < 0)
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
33d16dd0:	e7835104 	str	r5, [r3, r4, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
33d16dd4:	0a000002 	beq	33d16de4 <console_setfile+0x5c>
33d16dd8:	e3540001 	cmp	r4, #1	; 0x1
33d16ddc:	18bd8030 	popne	{r4, r5, pc}
33d16de0:	ea000006 	b	33d16e00 <console_setfile+0x78>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
33d16de4:	e5982020 	ldr	r2, [r8, #32]
33d16de8:	e595302c 	ldr	r3, [r5, #44]
33d16dec:	e5823004 	str	r3, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
33d16df0:	e5952028 	ldr	r2, [r5, #40]
33d16df4:	e5983020 	ldr	r3, [r8, #32]
33d16df8:	e5832008 	str	r2, [r3, #8]
			break;
33d16dfc:	e8bd8030 	pop	{r4, r5, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
33d16e00:	e5982020 	ldr	r2, [r8, #32]
33d16e04:	e5953020 	ldr	r3, [r5, #32]
33d16e08:	e582300c 	str	r3, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
33d16e0c:	e5983020 	ldr	r3, [r8, #32]
33d16e10:	e5952024 	ldr	r2, [r5, #36]
33d16e14:	e5832010 	str	r2, [r3, #16]
			gd->jt[XF_printf] = printf;
33d16e18:	e59f300c 	ldr	r3, [pc, #12]	; 33d16e2c <console_setfile+0xa4>
33d16e1c:	e5982020 	ldr	r2, [r8, #32]
33d16e20:	e5823014 	str	r3, [r2, #20]
			break;
		}
		break;
33d16e24:	e8bd8030 	pop	{r4, r5, pc}
33d16e28:	33d60c1c 	.word	0x33d60c1c
33d16e2c:	33d16fc8 	.word	0x33d16fc8

33d16e30 <serial_printf>:
}

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

void serial_printf (const char *fmt, ...)
{
33d16e30:	e92d000f 	push	{r0, r1, r2, r3}
33d16e34:	e92d4010 	push	{r4, lr}
33d16e38:	e24ddf47 	sub	sp, sp, #284	; 0x11c
	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d16e3c:	e1a0000d 	mov	r0, sp
33d16e40:	e59d1124 	ldr	r1, [sp, #292]
33d16e44:	e28d2f4a 	add	r2, sp, #296	; 0x128
33d16e48:	eb000e98 	bl	33d1a8b0 <vsprintf>
	va_end (args);

	serial_puts (printbuffer);
33d16e4c:	e1a0000d 	mov	r0, sp
	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d16e50:	e1a0400d 	mov	r4, sp
	va_end (args);

	serial_puts (printbuffer);
33d16e54:	eb001d47 	bl	33d1e378 <serial_puts>
33d16e58:	e28ddf47 	add	sp, sp, #284	; 0x11c
33d16e5c:	e8bd4010 	pop	{r4, lr}
33d16e60:	e28dd010 	add	sp, sp, #16	; 0x10
33d16e64:	e1a0f00e 	mov	pc, lr

33d16e68 <fgetc>:
}

int fgetc (int file)
{
	if (file < MAX_FILES)
33d16e68:	e3500002 	cmp	r0, #2	; 0x2

	serial_puts (printbuffer);
}

int fgetc (int file)
{
33d16e6c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (file < MAX_FILES)
		return stdio_devices[file]->getc ();

	return -1;
33d16e70:	c3e00000 	mvngt	r0, #0	; 0x0
	serial_puts (printbuffer);
}

int fgetc (int file)
{
	if (file < MAX_FILES)
33d16e74:	c49df004 	popgt	{pc}		; (ldrgt pc, [sp], #4)
		return stdio_devices[file]->getc ();
33d16e78:	e59f300c 	ldr	r3, [pc, #12]	; 33d16e8c <fgetc+0x24>
33d16e7c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
33d16e80:	e1a0e00f 	mov	lr, pc
33d16e84:	e593f02c 	ldr	pc, [r3, #44]
33d16e88:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d16e8c:	33d60c1c 	.word	0x33d60c1c

33d16e90 <ftstc>:
	return -1;
}

int ftstc (int file)
{
	if (file < MAX_FILES)
33d16e90:	e3500002 	cmp	r0, #2	; 0x2

	return -1;
}

int ftstc (int file)
{
33d16e94:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (file < MAX_FILES)
		return stdio_devices[file]->tstc ();

	return -1;
33d16e98:	c3e00000 	mvngt	r0, #0	; 0x0
	return -1;
}

int ftstc (int file)
{
	if (file < MAX_FILES)
33d16e9c:	c49df004 	popgt	{pc}		; (ldrgt pc, [sp], #4)
		return stdio_devices[file]->tstc ();
33d16ea0:	e59f300c 	ldr	r3, [pc, #12]	; 33d16eb4 <ftstc+0x24>
33d16ea4:	e7933100 	ldr	r3, [r3, r0, lsl #2]
33d16ea8:	e1a0e00f 	mov	lr, pc
33d16eac:	e593f028 	ldr	pc, [r3, #40]
33d16eb0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d16eb4:	33d60c1c 	.word	0x33d60c1c

33d16eb8 <fputc>:
	return -1;
}

void fputc (int file, const char c)
{
	if (file < MAX_FILES)
33d16eb8:	e3500002 	cmp	r0, #2	; 0x2

	return -1;
}

void fputc (int file, const char c)
{
33d16ebc:	e20110ff 	and	r1, r1, #255	; 0xff
33d16ec0:	e1a02000 	mov	r2, r0
33d16ec4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (file < MAX_FILES)
		stdio_devices[file]->putc (c);
33d16ec8:	e1a00001 	mov	r0, r1
	return -1;
}

void fputc (int file, const char c)
{
	if (file < MAX_FILES)
33d16ecc:	c49df004 	popgt	{pc}		; (ldrgt pc, [sp], #4)
		stdio_devices[file]->putc (c);
33d16ed0:	e59f300c 	ldr	r3, [pc, #12]	; 33d16ee4 <fputc+0x2c>
33d16ed4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
33d16ed8:	e1a0e00f 	mov	lr, pc
33d16edc:	e593f020 	ldr	pc, [r3, #32]
33d16ee0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d16ee4:	33d60c1c 	.word	0x33d60c1c

33d16ee8 <fputs>:
}

void fputs (int file, const char *s)
{
	if (file < MAX_FILES)
33d16ee8:	e3500002 	cmp	r0, #2	; 0x2
	if (file < MAX_FILES)
		stdio_devices[file]->putc (c);
}

void fputs (int file, const char *s)
{
33d16eec:	e1a02000 	mov	r2, r0
33d16ef0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (file < MAX_FILES)
		stdio_devices[file]->puts (s);
33d16ef4:	e1a00001 	mov	r0, r1
		stdio_devices[file]->putc (c);
}

void fputs (int file, const char *s)
{
	if (file < MAX_FILES)
33d16ef8:	c49df004 	popgt	{pc}		; (ldrgt pc, [sp], #4)
		stdio_devices[file]->puts (s);
33d16efc:	e59f300c 	ldr	r3, [pc, #12]	; 33d16f10 <fputs+0x28>
33d16f00:	e7933102 	ldr	r3, [r3, r2, lsl #2]
33d16f04:	e1a0e00f 	mov	lr, pc
33d16f08:	e593f024 	ldr	pc, [r3, #36]
33d16f0c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d16f10:	33d60c1c 	.word	0x33d60c1c

33d16f14 <fprintf>:
}

void fprintf (int file, const char *fmt, ...)
{
33d16f14:	e92d000e 	push	{r1, r2, r3}
33d16f18:	e92d4030 	push	{r4, r5, lr}
33d16f1c:	e24ddf47 	sub	sp, sp, #284	; 0x11c
33d16f20:	e1a05000 	mov	r5, r0
	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d16f24:	e59d1128 	ldr	r1, [sp, #296]
33d16f28:	e1a0000d 	mov	r0, sp
33d16f2c:	e28d2f4b 	add	r2, sp, #300	; 0x12c
33d16f30:	eb000e5e 	bl	33d1a8b0 <vsprintf>
	va_end (args);

	/* Send to desired file */
	fputs (file, printbuffer);
33d16f34:	e1a00005 	mov	r0, r5
33d16f38:	e1a0100d 	mov	r1, sp
	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d16f3c:	e1a0400d 	mov	r4, sp
	va_end (args);

	/* Send to desired file */
	fputs (file, printbuffer);
33d16f40:	ebffffe8 	bl	33d16ee8 <fputs>
33d16f44:	e28ddf47 	add	sp, sp, #284	; 0x11c
33d16f48:	e8bd4030 	pop	{r4, r5, lr}
33d16f4c:	e28dd00c 	add	sp, sp, #12	; 0xc
33d16f50:	e1a0f00e 	mov	pc, lr

33d16f54 <getc>:

/** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/

int getc (void)
{
	if (gd->flags & GD_FLG_DEVINIT) {
33d16f54:	e5983004 	ldr	r3, [r8, #4]
33d16f58:	e3130002 	tst	r3, #2	; 0x2
		/* Get from the standard input */
		return fgetc (stdin);
33d16f5c:	e3a00000 	mov	r0, #0	; 0x0

/** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/

int getc (void)
{
	if (gd->flags & GD_FLG_DEVINIT) {
33d16f60:	0a000000 	beq	33d16f68 <getc+0x14>
		/* Get from the standard input */
		return fgetc (stdin);
33d16f64:	eaffffbf 	b	33d16e68 <fgetc>
	}

	/* Send directly to the handler */
	return serial_getc ();
33d16f68:	ea001cee 	b	33d1e328 <serial_getc>

33d16f6c <tstc>:
}

int tstc (void)
{
	if (gd->flags & GD_FLG_DEVINIT) {
33d16f6c:	e5983004 	ldr	r3, [r8, #4]
33d16f70:	e3130002 	tst	r3, #2	; 0x2
		/* Test the standard input */
		return ftstc (stdin);
33d16f74:	e3a00000 	mov	r0, #0	; 0x0
	return serial_getc ();
}

int tstc (void)
{
	if (gd->flags & GD_FLG_DEVINIT) {
33d16f78:	0a000000 	beq	33d16f80 <tstc+0x14>
		/* Test the standard input */
		return ftstc (stdin);
33d16f7c:	eaffffc3 	b	33d16e90 <ftstc>
	}

	/* Send directly to the handler */
	return serial_tstc ();
33d16f80:	ea001cf8 	b	33d1e368 <serial_tstc>

33d16f84 <putc>:
#ifdef CONFIG_SILENT_CONSOLE
	if (gd->flags & GD_FLG_SILENT)
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
33d16f84:	e5983004 	ldr	r3, [r8, #4]
33d16f88:	e3130002 	tst	r3, #2	; 0x2
	/* Send directly to the handler */
	return serial_tstc ();
}

void putc (const char c)
{
33d16f8c:	e1a03000 	mov	r3, r0
33d16f90:	e20330ff 	and	r3, r3, #255	; 0xff
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
		/* Send to the standard output */
		fputc (stdout, c);
33d16f94:	e3a00001 	mov	r0, #1	; 0x1
33d16f98:	e1a01003 	mov	r1, r3
#ifdef CONFIG_SILENT_CONSOLE
	if (gd->flags & GD_FLG_SILENT)
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
33d16f9c:	0a000000 	beq	33d16fa4 <putc+0x20>
		/* Send to the standard output */
		fputc (stdout, c);
33d16fa0:	eaffffc4 	b	33d16eb8 <fputc>
	} else {
		/* Send directly to the handler */
		serial_putc (c);
33d16fa4:	e1a00003 	mov	r0, r3
33d16fa8:	ea001ce4 	b	33d1e340 <serial_putc>

33d16fac <puts>:
#ifdef CONFIG_SILENT_CONSOLE
	if (gd->flags & GD_FLG_SILENT)
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
33d16fac:	e5983004 	ldr	r3, [r8, #4]
33d16fb0:	e3130002 	tst	r3, #2	; 0x2
		serial_putc (c);
	}
}

void puts (const char *s)
{
33d16fb4:	e1a01000 	mov	r1, r0
#ifdef CONFIG_SILENT_CONSOLE
	if (gd->flags & GD_FLG_SILENT)
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
33d16fb8:	0a000001 	beq	33d16fc4 <puts+0x18>
		/* Send to the standard output */
		fputs (stdout, s);
33d16fbc:	e3a00001 	mov	r0, #1	; 0x1
33d16fc0:	eaffffc8 	b	33d16ee8 <fputs>
	} else {
		/* Send directly to the handler */
		serial_puts (s);
33d16fc4:	ea001ceb 	b	33d1e378 <serial_puts>

33d16fc8 <printf>:
	}
}

void printf (const char *fmt, ...)
{
33d16fc8:	e92d000f 	push	{r0, r1, r2, r3}
33d16fcc:	e92d4010 	push	{r4, lr}
33d16fd0:	e24ddf47 	sub	sp, sp, #284	; 0x11c
	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d16fd4:	e1a0000d 	mov	r0, sp
33d16fd8:	e59d1124 	ldr	r1, [sp, #292]
33d16fdc:	e28d2f4a 	add	r2, sp, #296	; 0x128
33d16fe0:	eb000e32 	bl	33d1a8b0 <vsprintf>
	va_end (args);

	/* Print the string */
	puts (printbuffer);
33d16fe4:	e1a0000d 	mov	r0, sp
	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d16fe8:	e1a0400d 	mov	r4, sp
	va_end (args);

	/* Print the string */
	puts (printbuffer);
33d16fec:	ebffffee 	bl	33d16fac <puts>
33d16ff0:	e28ddf47 	add	sp, sp, #284	; 0x11c
33d16ff4:	e8bd4010 	pop	{r4, lr}
33d16ff8:	e28dd010 	add	sp, sp, #16	; 0x10
33d16ffc:	e1a0f00e 	mov	pc, lr

33d17000 <vprintf>:
}

void vprintf (const char *fmt, va_list args)
{
33d17000:	e92d4010 	push	{r4, lr}
33d17004:	e24ddf47 	sub	sp, sp, #284	; 0x11c
33d17008:	e1a02001 	mov	r2, r1
	char printbuffer[CFG_PBSIZE];

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d1700c:	e1a01000 	mov	r1, r0
33d17010:	e1a0000d 	mov	r0, sp
33d17014:	eb000e25 	bl	33d1a8b0 <vsprintf>

	/* Print the string */
	puts (printbuffer);
33d17018:	e1a0000d 	mov	r0, sp
	char printbuffer[CFG_PBSIZE];

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
33d1701c:	e1a0400d 	mov	r4, sp

	/* Print the string */
	puts (printbuffer);
33d17020:	ebffffe1 	bl	33d16fac <puts>
33d17024:	e28ddf47 	add	sp, sp, #284	; 0x11c
33d17028:	e8bd8010 	pop	{r4, pc}

33d1702c <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc (void)
{
33d1702c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if (!ctrlc_disabled && gd->have_console) {
33d17030:	e59f3044 	ldr	r3, [pc, #68]	; 33d1707c <ctrlc+0x50>
33d17034:	e5933000 	ldr	r3, [r3]
33d17038:	e3530000 	cmp	r3, #0	; 0x0
33d1703c:	1a00000c 	bne	33d17074 <ctrlc+0x48>
33d17040:	e598300c 	ldr	r3, [r8, #12]
33d17044:	e3530000 	cmp	r3, #0	; 0x0
33d17048:	0a000009 	beq	33d17074 <ctrlc+0x48>
		if (tstc ()) {
33d1704c:	ebffffc6 	bl	33d16f6c <tstc>
33d17050:	e3500000 	cmp	r0, #0	; 0x0
33d17054:	0a000006 	beq	33d17074 <ctrlc+0x48>
			switch (getc ()) {
33d17058:	ebffffbd 	bl	33d16f54 <getc>
33d1705c:	e3500003 	cmp	r0, #3	; 0x3
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
33d17060:	059f3018 	ldreq	r3, [pc, #24]	; 33d17080 <ctrlc+0x54>
33d17064:	e3a02001 	mov	r2, #1	; 0x1
				return 1;
33d17068:	e1a00002 	mov	r0, r2
{
	if (!ctrlc_disabled && gd->have_console) {
		if (tstc ()) {
			switch (getc ()) {
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
33d1706c:	05832000 	streq	r2, [r3]
static int ctrlc_was_pressed = 0;
int ctrlc (void)
{
	if (!ctrlc_disabled && gd->have_console) {
		if (tstc ()) {
			switch (getc ()) {
33d17070:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
			default:
				break;
			}
		}
	}
	return 0;
33d17074:	e3a00000 	mov	r0, #0	; 0x0
}
33d17078:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1707c:	33d60c18 	.word	0x33d60c18
33d17080:	33d60c14 	.word	0x33d60c14

33d17084 <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc (int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
33d17084:	e59f300c 	ldr	r3, [pc, #12]	; 33d17098 <disable_ctrlc+0x14>
33d17088:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
33d1708c:	e5830000 	str	r0, [r3]
	return prev;
}
33d17090:	e1a00002 	mov	r0, r2
33d17094:	e1a0f00e 	mov	pc, lr
33d17098:	33d60c18 	.word	0x33d60c18

33d1709c <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
33d1709c:	e59f3004 	ldr	r3, [pc, #4]	; 33d170a8 <had_ctrlc+0xc>
33d170a0:	e5930000 	ldr	r0, [r3]
33d170a4:	e1a0f00e 	mov	pc, lr
33d170a8:	33d60c14 	.word	0x33d60c14

33d170ac <clear_ctrlc>:

void clear_ctrlc (void)
{
	ctrlc_was_pressed = 0;
33d170ac:	e59f3008 	ldr	r3, [pc, #8]	; 33d170bc <clear_ctrlc+0x10>
33d170b0:	e3a02000 	mov	r2, #0	; 0x0
33d170b4:	e5832000 	str	r2, [r3]
33d170b8:	e1a0f00e 	mov	pc, lr
33d170bc:	33d60c14 	.word	0x33d60c14

33d170c0 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
33d170c0:	e92d000f 	push	{r0, r1, r2, r3}
33d170c4:	e28dd010 	add	sp, sp, #16	; 0x10
33d170c8:	e1a0f00e 	mov	pc, lr

33d170cc <console_assign>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

int console_assign (int file, char *devname)
{
33d170cc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int flag, i;

	/* Check for valid file */
	switch (file) {
33d170d0:	e2506000 	subs	r6, r0, #0	; 0x0
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

int console_assign (int file, char *devname)
{
33d170d4:	e1a07001 	mov	r7, r1
	int flag, i;

	/* Check for valid file */
	switch (file) {
	case stdin:
		flag = DEV_FLAGS_INPUT;
33d170d8:	03a0a001 	moveq	sl, #1	; 0x1
int console_assign (int file, char *devname)
{
	int flag, i;

	/* Check for valid file */
	switch (file) {
33d170dc:	0a000003 	beq	33d170f0 <console_assign+0x24>
33d170e0:	ba00001a 	blt	33d17150 <console_assign+0x84>
33d170e4:	e3560002 	cmp	r6, #2	; 0x2
33d170e8:	ca000018 	bgt	33d17150 <console_assign+0x84>
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
33d170ec:	e3a0a002 	mov	sl, #2	; 0x2
		return -1;
	}

	/* Check for valid device name */

	for (i = 1; i <= ListNumItems (devlist); i++) {
33d170f0:	e3a05001 	mov	r5, #1	; 0x1
33d170f4:	ea00000e 	b	33d17134 <console_assign+0x68>
		device_t *dev = ListGetPtrToItem (devlist, i);
33d170f8:	e5940000 	ldr	r0, [r4]
33d170fc:	eb000779 	bl	33d18ee8 <ListGetPtrToItem>
33d17100:	e1a04000 	mov	r4, r0

		if (strcmp (devname, dev->name) == 0) {
33d17104:	e2841008 	add	r1, r4, #8	; 0x8
33d17108:	e1a00007 	mov	r0, r7
33d1710c:	eb000bd5 	bl	33d1a068 <strcmp>
33d17110:	e3500000 	cmp	r0, #0	; 0x0
33d17114:	1a000006 	bne	33d17134 <console_assign+0x68>
			if (dev->flags & flag)
33d17118:	e5943000 	ldr	r3, [r4]
33d1711c:	e113000a 	tst	r3, sl
33d17120:	0a00000a 	beq	33d17150 <console_assign+0x84>
				return console_setfile (file, dev);
33d17124:	e1a00006 	mov	r0, r6
33d17128:	e1a01004 	mov	r1, r4
			return -1;
		}
	}

	return -1;
}
33d1712c:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	for (i = 1; i <= ListNumItems (devlist); i++) {
		device_t *dev = ListGetPtrToItem (devlist, i);

		if (strcmp (devname, dev->name) == 0) {
			if (dev->flags & flag)
				return console_setfile (file, dev);
33d17130:	eaffff14 	b	33d16d88 <console_setfile>
		return -1;
	}

	/* Check for valid device name */

	for (i = 1; i <= ListNumItems (devlist); i++) {
33d17134:	e59f401c 	ldr	r4, [pc, #28]	; 33d17158 <console_assign+0x8c>
33d17138:	e5940000 	ldr	r0, [r4]
33d1713c:	eb00077b 	bl	33d18f30 <ListNumItems>
33d17140:	e1550000 	cmp	r5, r0
		device_t *dev = ListGetPtrToItem (devlist, i);
33d17144:	e1a01005 	mov	r1, r5
		return -1;
	}

	/* Check for valid device name */

	for (i = 1; i <= ListNumItems (devlist); i++) {
33d17148:	e2855001 	add	r5, r5, #1	; 0x1
33d1714c:	daffffe9 	ble	33d170f8 <console_assign+0x2c>
			return -1;
		}
	}

	return -1;
}
33d17150:	e3e00000 	mvn	r0, #0	; 0x0
33d17154:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d17158:	33d60c28 	.word	0x33d60c28

33d1715c <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f (void)
{
	gd->have_console = 1;
33d1715c:	e3a03001 	mov	r3, #1	; 0x1
	if (getenv("silent") != NULL)
		gd->flags |= GD_FLG_SILENT;
#endif

	return (0);
}
33d17160:	e3a00000 	mov	r0, #0	; 0x0
}

/* Called before relocation - use serial functions */
int console_init_f (void)
{
	gd->have_console = 1;
33d17164:	e588300c 	str	r3, [r8, #12]
	if (getenv("silent") != NULL)
		gd->flags |= GD_FLG_SILENT;
#endif

	return (0);
}
33d17168:	e1a0f00e 	mov	pc, lr

33d1716c <console_init_r>:

#else /* CFG_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r (void)
{
33d1716c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	device_t *inputdev = NULL, *outputdev = NULL;
	int i, items = ListNumItems (devlist);
33d17170:	e59fa0d4 	ldr	sl, [pc, #212]	; 33d1724c <console_init_r+0xe0>
33d17174:	e59a0000 	ldr	r0, [sl]
33d17178:	eb00076c 	bl	33d18f30 <ListNumItems>
	if (gd->flags & GD_FLG_SILENT)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

	/* Scan devices looking for input and output devices */
	for (i = 1;
33d1717c:	e3a04001 	mov	r4, #1	; 0x1
#else /* CFG_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r (void)
{
	device_t *inputdev = NULL, *outputdev = NULL;
33d17180:	e3a06000 	mov	r6, #0	; 0x0
	if (gd->flags & GD_FLG_SILENT)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

	/* Scan devices looking for input and output devices */
	for (i = 1;
33d17184:	e1540000 	cmp	r4, r0

/* Called after the relocation - use desired console functions */
int console_init_r (void)
{
	device_t *inputdev = NULL, *outputdev = NULL;
	int i, items = ListNumItems (devlist);
33d17188:	e1a07000 	mov	r7, r0
#else /* CFG_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r (void)
{
	device_t *inputdev = NULL, *outputdev = NULL;
33d1718c:	e1a05006 	mov	r5, r6
	if (gd->flags & GD_FLG_SILENT)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

	/* Scan devices looking for input and output devices */
	for (i = 1;
33d17190:	ca00001e 	bgt	33d17210 <console_init_r+0xa4>
	     (i <= items) && ((inputdev == NULL) || (outputdev == NULL));
	     i++
	    ) {
		device_t *dev = ListGetPtrToItem (devlist, i);
33d17194:	e1a01004 	mov	r1, r4
33d17198:	e59a0000 	ldr	r0, [sl]
33d1719c:	eb000751 	bl	33d18ee8 <ListGetPtrToItem>

		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
33d171a0:	e5902000 	ldr	r2, [r0]
33d171a4:	e3560000 	cmp	r6, #0	; 0x0
33d171a8:	13a03000 	movne	r3, #0	; 0x0
33d171ac:	02023001 	andeq	r3, r2, #1	; 0x1
			inputdev = dev;
		}
		if ((dev->flags & DEV_FLAGS_OUTPUT) && (outputdev == NULL)) {
33d171b0:	e2751001 	rsbs	r1, r5, #1	; 0x1
33d171b4:	33a01000 	movcc	r1, #0	; 0x0
	     i++
	    ) {
		device_t *dev = ListGetPtrToItem (devlist, i);

		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
			inputdev = dev;
33d171b8:	e3530000 	cmp	r3, #0	; 0x0
33d171bc:	11a06000 	movne	r6, r0
	if (gd->flags & GD_FLG_SILENT)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

	/* Scan devices looking for input and output devices */
	for (i = 1;
33d171c0:	e2844001 	add	r4, r4, #1	; 0x1
		device_t *dev = ListGetPtrToItem (devlist, i);

		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
			inputdev = dev;
		}
		if ((dev->flags & DEV_FLAGS_OUTPUT) && (outputdev == NULL)) {
33d171c4:	e01120a2 	ands	r2, r1, r2, lsr #1
			outputdev = dev;
33d171c8:	11a05000 	movne	r5, r0
	if (gd->flags & GD_FLG_SILENT)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

	/* Scan devices looking for input and output devices */
	for (i = 1;
33d171cc:	e1540007 	cmp	r4, r7
33d171d0:	ca000002 	bgt	33d171e0 <console_init_r+0x74>
33d171d4:	e3550000 	cmp	r5, #0	; 0x0
33d171d8:	13560000 	cmpne	r6, #0	; 0x0
33d171dc:	0affffec 	beq	33d17194 <console_init_r+0x28>
			outputdev = dev;
		}
	}

	/* Initializes output console first */
	if (outputdev != NULL) {
33d171e0:	e3550000 	cmp	r5, #0	; 0x0
33d171e4:	0a000005 	beq	33d17200 <console_init_r+0x94>
		console_setfile (stdout, outputdev);
33d171e8:	e1a01005 	mov	r1, r5
33d171ec:	e3a00001 	mov	r0, #1	; 0x1
33d171f0:	ebfffee4 	bl	33d16d88 <console_setfile>
		console_setfile (stderr, outputdev);
33d171f4:	e1a01005 	mov	r1, r5
33d171f8:	e3a00002 	mov	r0, #2	; 0x2
33d171fc:	ebfffee1 	bl	33d16d88 <console_setfile>
	}

	/* Initializes input console */
	if (inputdev != NULL) {
33d17200:	e3560000 	cmp	r6, #0	; 0x0
		console_setfile (stdin, inputdev);
33d17204:	11a01006 	movne	r1, r6
33d17208:	13a00000 	movne	r0, #0	; 0x0
33d1720c:	1bfffedd 	blne	33d16d88 <console_setfile>
	}

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
33d17210:	e5983004 	ldr	r3, [r8, #4]
33d17214:	e3833002 	orr	r3, r3, #2	; 0x2
33d17218:	e5883004 	str	r3, [r8, #4]
	}
#endif /* CFG_CONSOLE_INFO_QUIET */
}							//HJ_end

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
33d1721c:	e3a04000 	mov	r4, #0	; 0x0
		setenv (stdio_names[i], stdio_devices[i]->name);
33d17220:	e59f3028 	ldr	r3, [pc, #40]	; 33d17250 <console_init_r+0xe4>
33d17224:	e7931104 	ldr	r1, [r3, r4, lsl #2]
33d17228:	e59f3024 	ldr	r3, [pc, #36]	; 33d17254 <console_init_r+0xe8>
33d1722c:	e2811008 	add	r1, r1, #8	; 0x8
33d17230:	e7930104 	ldr	r0, [r3, r4, lsl #2]
	}
#endif /* CFG_CONSOLE_INFO_QUIET */
}							//HJ_end

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
33d17234:	e2844001 	add	r4, r4, #1	; 0x1
		setenv (stdio_names[i], stdio_devices[i]->name);
33d17238:	ebfff966 	bl	33d157d8 <setenv>
	}
#endif /* CFG_CONSOLE_INFO_QUIET */
}							//HJ_end

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
33d1723c:	e3540002 	cmp	r4, #2	; 0x2
33d17240:	dafffff6 	ble	33d17220 <console_init_r+0xb4>
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return (0);
#endif

	return (0);
}
33d17244:	e3a00000 	mov	r0, #0	; 0x0
33d17248:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d1724c:	33d60c28 	.word	0x33d60c28
33d17250:	33d60c1c 	.word	0x33d60c1c
33d17254:	33d36080 	.word	0x33d36080

33d17258 <device_register>:
 * DEVICES
 **************************************************************************
 */

int device_register (device_t * dev)
{
33d17258:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	ListInsertItem (devlist, dev, LIST_END);
33d1725c:	e59f3014 	ldr	r3, [pc, #20]	; 33d17278 <device_register+0x20>
 * DEVICES
 **************************************************************************
 */

int device_register (device_t * dev)
{
33d17260:	e1a01000 	mov	r1, r0
	ListInsertItem (devlist, dev, LIST_END);
33d17264:	e3a02000 	mov	r2, #0	; 0x0
33d17268:	e5930000 	ldr	r0, [r3]
33d1726c:	eb000709 	bl	33d18e98 <ListInsertItem>
	return 0;
}
33d17270:	e3a00000 	mov	r0, #0	; 0x0
33d17274:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d17278:	33d60c28 	.word	0x33d60c28

33d1727c <devices_init>:
	return 0;
}
#endif	/* CFG_DEVICE_DEREGISTER */

int devices_init (void)
{
33d1727c:	e92d4010 	push	{r4, lr}
						relocation_offset);
	}
#endif

	/* Initialize the list */
	devlist = ListCreate (sizeof (device_t));
33d17280:	e3a00034 	mov	r0, #52	; 0x34
	return 0;
}
#endif	/* CFG_DEVICE_DEREGISTER */

int devices_init (void)
{
33d17284:	e24dd034 	sub	sp, sp, #52	; 0x34
						relocation_offset);
	}
#endif

	/* Initialize the list */
	devlist = ListCreate (sizeof (device_t));
33d17288:	eb000677 	bl	33d18c6c <ListCreate>
33d1728c:	e59f307c 	ldr	r3, [pc, #124]	; 33d17310 <devices_init+0x94>
33d17290:	e1a0c000 	mov	ip, r0

	if (devlist == NULL) {
33d17294:	e35c0000 	cmp	ip, #0	; 0x0
		eputs ("Cannot initialize the list of devices!\n");
33d17298:	e59f1074 	ldr	r1, [pc, #116]	; 33d17314 <devices_init+0x98>
33d1729c:	e3a00002 	mov	r0, #2	; 0x2

static void drv_system_init (void)
{
	device_t dev;

	memset (&dev, 0, sizeof (dev));
33d172a0:	e1a0400d 	mov	r4, sp
33d172a4:	e3a02034 	mov	r2, #52	; 0x34
						relocation_offset);
	}
#endif

	/* Initialize the list */
	devlist = ListCreate (sizeof (device_t));
33d172a8:	e583c000 	str	ip, [r3]

	if (devlist == NULL) {
33d172ac:	1a000002 	bne	33d172bc <devices_init+0x40>
		eputs ("Cannot initialize the list of devices!\n");
33d172b0:	ebffff0c 	bl	33d16ee8 <fputs>
		return -1;
33d172b4:	e3e00000 	mvn	r0, #0	; 0x0
33d172b8:	ea000012 	b	33d17308 <devices_init+0x8c>

static void drv_system_init (void)
{
	device_t dev;

	memset (&dev, 0, sizeof (dev));
33d172bc:	e3a01000 	mov	r1, #0	; 0x0
33d172c0:	e1a0000d 	mov	r0, sp
33d172c4:	eb000c32 	bl	33d1a394 <memset>

	strcpy (dev.name, "serial");
33d172c8:	e59f1048 	ldr	r1, [pc, #72]	; 33d17318 <devices_init+0x9c>
33d172cc:	e28d0008 	add	r0, sp, #8	; 0x8
33d172d0:	eb000b39 	bl	33d19fbc <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
33d172d4:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
33d172d8:	e58d3000 	str	r3, [sp]
	dev.putc = serial_buffered_putc;
	dev.puts = serial_buffered_puts;
	dev.getc = serial_buffered_getc;
	dev.tstc = serial_buffered_tstc;
#else
	dev.putc = serial_putc;
33d172dc:	e59f3038 	ldr	r3, [pc, #56]	; 33d1731c <devices_init+0xa0>
33d172e0:	e58d3020 	str	r3, [sp, #32]
	dev.puts = serial_puts;
33d172e4:	e59f3034 	ldr	r3, [pc, #52]	; 33d17320 <devices_init+0xa4>
33d172e8:	e58d3024 	str	r3, [sp, #36]
	dev.getc = serial_getc;
33d172ec:	e59f3030 	ldr	r3, [pc, #48]	; 33d17324 <devices_init+0xa8>
33d172f0:	e58d302c 	str	r3, [sp, #44]
	dev.tstc = serial_tstc;
33d172f4:	e59f302c 	ldr	r3, [pc, #44]	; 33d17328 <devices_init+0xac>
#endif

	device_register (&dev);
33d172f8:	e1a0000d 	mov	r0, sp
	dev.tstc = serial_buffered_tstc;
#else
	dev.putc = serial_putc;
	dev.puts = serial_puts;
	dev.getc = serial_getc;
	dev.tstc = serial_tstc;
33d172fc:	e58d3028 	str	r3, [sp, #40]
#endif

	device_register (&dev);
33d17300:	ebffffd4 	bl	33d17258 <device_register>
#endif
#ifdef CONFIG_NETCONSOLE
	drv_nc_init ();
#endif

	return (0);
33d17304:	e3a00000 	mov	r0, #0	; 0x0
}
33d17308:	e28dd034 	add	sp, sp, #52	; 0x34
33d1730c:	e8bd8010 	pop	{r4, pc}
33d17310:	33d60c28 	.word	0x33d60c28
33d17314:	33d2cb1c 	.word	0x33d2cb1c
33d17318:	33d2cb44 	.word	0x33d2cb44
33d1731c:	33d1e340 	.word	0x33d1e340
33d17320:	33d1e378 	.word	0x33d1e378
33d17324:	33d1e328 	.word	0x33d1e328
33d17328:	33d1e368 	.word	0x33d1e368

33d1732c <devices_done>:

int devices_done (void)
{
33d1732c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	ListDispose (devlist);
33d17330:	e59f300c 	ldr	r3, [pc, #12]	; 33d17344 <devices_done+0x18>
33d17334:	e5930000 	ldr	r0, [r3]
33d17338:	eb000668 	bl	33d18ce0 <ListDispose>

	return 0;
}
33d1733c:	e3a00000 	mov	r0, #0	; 0x0
33d17340:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d17344:	33d60c28 	.word	0x33d60c28

33d17348 <malloc_bin_reloc>:

void malloc_bin_reloc (void)
{
	unsigned long *p = (unsigned long *)(&av_[2]);
	int i;
	for (i=2; i<(sizeof(av_)/sizeof(mbinptr)); ++i) {
33d17348:	e59fc024 	ldr	ip, [pc, #36]	; 33d17374 <malloc_bin_reloc+0x2c>
33d1734c:	e59f0024 	ldr	r0, [pc, #36]	; 33d17378 <malloc_bin_reloc+0x30>
33d17350:	e3a01002 	mov	r1, #2	; 0x2
		*p++ += gd->reloc_off;
33d17354:	e4903004 	ldr	r3, [r0], #4
33d17358:	e5982010 	ldr	r2, [r8, #16]

void malloc_bin_reloc (void)
{
	unsigned long *p = (unsigned long *)(&av_[2]);
	int i;
	for (i=2; i<(sizeof(av_)/sizeof(mbinptr)); ++i) {
33d1735c:	e2811001 	add	r1, r1, #1	; 0x1
		*p++ += gd->reloc_off;
33d17360:	e0833002 	add	r3, r3, r2

void malloc_bin_reloc (void)
{
	unsigned long *p = (unsigned long *)(&av_[2]);
	int i;
	for (i=2; i<(sizeof(av_)/sizeof(mbinptr)); ++i) {
33d17364:	e151000c 	cmp	r1, ip
		*p++ += gd->reloc_off;
33d17368:	e5003004 	str	r3, [r0, #-4]

void malloc_bin_reloc (void)
{
	unsigned long *p = (unsigned long *)(&av_[2]);
	int i;
	for (i=2; i<(sizeof(av_)/sizeof(mbinptr)); ++i) {
33d1736c:	9afffff8 	bls	33d17354 <malloc_bin_reloc+0xc>
33d17370:	e1a0f00e 	mov	pc, lr
33d17374:	00000101 	.word	0x00000101
33d17378:	33d360a0 	.word	0x33d360a0

33d1737c <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
33d1737c:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
33d17380:	e59f60c0 	ldr	r6, [pc, #192]	; 33d17448 <malloc_trim+0xcc>
33d17384:	e5963008 	ldr	r3, [r6, #8]
33d17388:	e5933004 	ldr	r3, [r3, #4]
33d1738c:	e3c34003 	bic	r4, r3, #3	; 0x3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
33d17390:	e0603004 	rsb	r3, r0, r4
33d17394:	e2833efe 	add	r3, r3, #4064	; 0xfe0
33d17398:	e283300f 	add	r3, r3, #15	; 0xf
33d1739c:	e3c33eff 	bic	r3, r3, #4080	; 0xff0
33d173a0:	e3c3300f 	bic	r3, r3, #15	; 0xf
33d173a4:	e2435a01 	sub	r5, r3, #4096	; 0x1000
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
33d173a8:	e3a00000 	mov	r0, #0	; 0x0
  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
33d173ac:	e3550a01 	cmp	r5, #4096	; 0x1000
    return 0;
33d173b0:	e1a0e000 	mov	lr, r0
  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
33d173b4:	ba000021 	blt	33d17440 <malloc_trim+0xc4>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
33d173b8:	ebffa82e 	bl	33d01478 <sbrk>
    if (current_brk != (char*)(top) + top_size)
33d173bc:	e5963008 	ldr	r3, [r6, #8]
33d173c0:	e0833004 	add	r3, r3, r4
33d173c4:	e1500003 	cmp	r0, r3
      return 0;     /* Apparently we don't own memory; must fail */
33d173c8:	e3a0e000 	mov	lr, #0	; 0x0

    else
    {
      new_brk = (char*)(MORECORE (-extra));
33d173cc:	e2650000 	rsb	r0, r5, #0	; 0x0

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
    if (current_brk != (char*)(top) + top_size)
33d173d0:	1a00001a 	bne	33d17440 <malloc_trim+0xc4>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
33d173d4:	ebffa827 	bl	33d01478 <sbrk>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
33d173d8:	e0653004 	rsb	r3, r5, r4

    else
    {
      new_brk = (char*)(MORECORE (-extra));

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
33d173dc:	e3700001 	cmn	r0, #1	; 0x1
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
33d173e0:	e3832001 	orr	r2, r3, #1	; 0x1
	sbrked_mem -= extra;
33d173e4:	e59f1060 	ldr	r1, [pc, #96]	; 33d1744c <malloc_trim+0xd0>
      new_brk = (char*)(MORECORE (-extra));

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
33d173e8:	e3a00000 	mov	r0, #0	; 0x0

    else
    {
      new_brk = (char*)(MORECORE (-extra));

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
33d173ec:	1a00000d 	bne	33d17428 <malloc_trim+0xac>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
33d173f0:	ebffa820 	bl	33d01478 <sbrk>
	top_size = current_brk - (char*)top;
33d173f4:	e596c008 	ldr	ip, [r6, #8]
33d173f8:	e06c4000 	rsb	r4, ip, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
33d173fc:	e354000f 	cmp	r4, #15	; 0xf
	{
	  sbrked_mem = current_brk - sbrk_base;
	  set_head(top, top_size | PREV_INUSE);
33d17400:	e3841001 	orr	r1, r4, #1	; 0x1
	}
	check_chunk(top);
	return 0;
33d17404:	e3a0e000 	mov	lr, #0	; 0x0
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
33d17408:	da00000c 	ble	33d17440 <malloc_trim+0xc4>
	{
	  sbrked_mem = current_brk - sbrk_base;
33d1740c:	e59f303c 	ldr	r3, [pc, #60]	; 33d17450 <malloc_trim+0xd4>
33d17410:	e5933000 	ldr	r3, [r3]
33d17414:	e59f2030 	ldr	r2, [pc, #48]	; 33d1744c <malloc_trim+0xd0>
33d17418:	e0633000 	rsb	r3, r3, r0
33d1741c:	e5823000 	str	r3, [r2]
	  set_head(top, top_size | PREV_INUSE);
33d17420:	e58c1004 	str	r1, [ip, #4]
	}
	check_chunk(top);
	return 0;
33d17424:	ea000005 	b	33d17440 <malloc_trim+0xc4>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
33d17428:	e5963008 	ldr	r3, [r6, #8]
33d1742c:	e5832004 	str	r2, [r3, #4]
	sbrked_mem -= extra;
33d17430:	e5913000 	ldr	r3, [r1]
33d17434:	e0653003 	rsb	r3, r5, r3
33d17438:	e5813000 	str	r3, [r1]
	check_chunk(top);
	return 1;
33d1743c:	e3a0e001 	mov	lr, #1	; 0x1
      }
    }
  }
}
33d17440:	e1a0000e 	mov	r0, lr
33d17444:	e8bd8070 	pop	{r4, r5, r6, pc}
33d17448:	33d36098 	.word	0x33d36098
33d1744c:	33d60c34 	.word	0x33d60c34
33d17450:	33d36094 	.word	0x33d36094

33d17454 <free>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
33d17454:	e3500000 	cmp	r0, #0	; 0x0
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
33d17458:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
33d1745c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
    return;

  p = mem2chunk(mem);
33d17460:	e2405008 	sub	r5, r0, #8	; 0x8
  hd = p->size;
33d17464:	e5953004 	ldr	r3, [r5, #4]

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
33d17468:	e59fa1e4 	ldr	sl, [pc, #484]	; 33d17654 <free+0x200>
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
33d1746c:	e3c34001 	bic	r4, r3, #1	; 0x1
  next = chunk_at_offset(p, sz);
33d17470:	e0856004 	add	r6, r5, r4
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
33d17474:	e59a2008 	ldr	r2, [sl, #8]

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
33d17478:	e5961004 	ldr	r1, [r6, #4]

  if (next == top)                            /* merge with top */
33d1747c:	e1560002 	cmp	r6, r2

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
33d17480:	e3c11003 	bic	r1, r1, #3	; 0x3
33d17484:	e2033001 	and	r3, r3, #1	; 0x1

  if (next == top)                            /* merge with top */
33d17488:	1a000014 	bne	33d174e0 <free+0x8c>
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
33d1748c:	e3530000 	cmp	r3, #0	; 0x0
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
33d17490:	e0844001 	add	r4, r4, r1

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
33d17494:	1a000006 	bne	33d174b4 <free+0x60>
    {
      prevsz = p->prev_size;
33d17498:	e5100008 	ldr	r0, [r0, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
33d1749c:	e0605005 	rsb	r5, r0, r5
      sz += prevsz;
      unlink(p, bck, fwd);
33d174a0:	e285c008 	add	ip, r5, #8	; 0x8
33d174a4:	e89c5000 	ldm	ip, {ip, lr}
33d174a8:	e58ec008 	str	ip, [lr, #8]
33d174ac:	e58ce00c 	str	lr, [ip, #12]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
33d174b0:	e0844000 	add	r4, r4, r0
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
33d174b4:	e3843001 	orr	r3, r4, #1	; 0x1
33d174b8:	e5853004 	str	r3, [r5, #4]
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
33d174bc:	e59f3194 	ldr	r3, [pc, #404]	; 33d17658 <free+0x204>
33d174c0:	e5933000 	ldr	r3, [r3]
33d174c4:	e1540003 	cmp	r4, r3
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
33d174c8:	e58a5008 	str	r5, [sl, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
33d174cc:	38bd84f0 	popcc	{r4, r5, r6, r7, sl, pc}
      malloc_trim(top_pad);
33d174d0:	e59f3184 	ldr	r3, [pc, #388]	; 33d1765c <free+0x208>
33d174d4:	e5930000 	ldr	r0, [r3]

  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);
}
33d174d8:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
33d174dc:	eaffffa6 	b	33d1737c <malloc_trim>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
33d174e0:	e3530000 	cmp	r3, #0	; 0x0
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
33d174e4:	e5861004 	str	r1, [r6, #4]

  islr = 0;
33d174e8:	e3a07000 	mov	r7, #0	; 0x0

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
33d174ec:	1a00000a 	bne	33d1751c <free+0xc8>
  {
    prevsz = p->prev_size;
33d174f0:	e5100008 	ldr	r0, [r0, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
33d174f4:	e0605005 	rsb	r5, r0, r5
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
33d174f8:	e5952008 	ldr	r2, [r5, #8]
33d174fc:	e28a3008 	add	r3, sl, #8	; 0x8
33d17500:	e1520003 	cmp	r2, r3
      islr = 1;
    else
      unlink(p, bck, fwd);
33d17504:	1595e00c 	ldrne	lr, [r5, #12]
33d17508:	11a0c002 	movne	ip, r2
33d1750c:	158ec008 	strne	ip, [lr, #8]
33d17510:	158ce00c 	strne	lr, [ip, #12]

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;
33d17514:	e0844000 	add	r4, r4, r0

    if (p->fd == last_remainder)             /* keep as last_remainder */
      islr = 1;
33d17518:	02877001 	addeq	r7, r7, #1	; 0x1
    else
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
33d1751c:	e0863001 	add	r3, r6, r1
33d17520:	e5933004 	ldr	r3, [r3, #4]
33d17524:	e3130001 	tst	r3, #1	; 0x1
33d17528:	1a000010 	bne	33d17570 <free+0x11c>
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
33d1752c:	e3570000 	cmp	r7, #0	; 0x0
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
33d17530:	e0844001 	add	r4, r4, r1

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
33d17534:	1a000009 	bne	33d17560 <free+0x10c>
33d17538:	e5962008 	ldr	r2, [r6, #8]
33d1753c:	e59f311c 	ldr	r3, [pc, #284]	; 33d17660 <free+0x20c>
33d17540:	e1520003 	cmp	r2, r3
33d17544:	1a000005 	bne	33d17560 <free+0x10c>
    {
      islr = 1;
33d17548:	e2877001 	add	r7, r7, #1	; 0x1
      link_last_remainder(p);
33d1754c:	e582500c 	str	r5, [r2, #12]
33d17550:	e5825008 	str	r5, [r2, #8]
33d17554:	e585200c 	str	r2, [r5, #12]
33d17558:	e5852008 	str	r2, [r5, #8]
33d1755c:	ea000003 	b	33d17570 <free+0x11c>
    }
    else
      unlink(next, bck, fwd);
33d17560:	e286c008 	add	ip, r6, #8	; 0x8
33d17564:	e89c5000 	ldm	ip, {ip, lr}
33d17568:	e58ec008 	str	ip, [lr, #8]
33d1756c:	e58ce00c 	str	lr, [ip, #12]
  }


  set_head(p, sz | PREV_INUSE);
33d17570:	e3843001 	orr	r3, r4, #1	; 0x1
  set_foot(p, sz);
  if (!islr)
33d17574:	e3570000 	cmp	r7, #0	; 0x0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
33d17578:	e5853004 	str	r3, [r5, #4]
  set_foot(p, sz);
33d1757c:	e7854004 	str	r4, [r5, r4]
  if (!islr)
33d17580:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
    frontlink(p, sz, idx, bck, fwd);
33d17584:	e3540c02 	cmp	r4, #512	; 0x200
33d17588:	31a011a4 	lsrcc	r1, r4, #3
33d1758c:	308ae181 	addcc	lr, sl, r1, lsl #3
33d17590:	359a3004 	ldrcc	r3, [sl, #4]
33d17594:	359ec008 	ldrcc	ip, [lr, #8]
33d17598:	3a00001b 	bcc	33d1760c <free+0x1b8>
33d1759c:	e1b014a4 	lsrs	r1, r4, #9
33d175a0:	01a011a4 	lsreq	r1, r4, #3
33d175a4:	0a000013 	beq	33d175f8 <free+0x1a4>
33d175a8:	e3510004 	cmp	r1, #4	; 0x4
33d175ac:	91a03324 	lsrls	r3, r4, #6
33d175b0:	92831038 	addls	r1, r3, #56	; 0x38
33d175b4:	9a00000f 	bls	33d175f8 <free+0x1a4>
33d175b8:	e3510014 	cmp	r1, #20	; 0x14
33d175bc:	9281105b 	addls	r1, r1, #91	; 0x5b
33d175c0:	9a00000c 	bls	33d175f8 <free+0x1a4>
33d175c4:	e3510054 	cmp	r1, #84	; 0x54
33d175c8:	91a03624 	lsrls	r3, r4, #12
33d175cc:	9283106e 	addls	r1, r3, #110	; 0x6e
33d175d0:	9a000008 	bls	33d175f8 <free+0x1a4>
33d175d4:	e3510f55 	cmp	r1, #340	; 0x154
33d175d8:	91a037a4 	lsrls	r3, r4, #15
33d175dc:	92831077 	addls	r1, r3, #119	; 0x77
33d175e0:	9a000004 	bls	33d175f8 <free+0x1a4>
33d175e4:	e59f3078 	ldr	r3, [pc, #120]	; 33d17664 <free+0x210>
33d175e8:	e1510003 	cmp	r1, r3
33d175ec:	91a03924 	lsrls	r3, r4, #18
33d175f0:	9283107c 	addls	r1, r3, #124	; 0x7c
33d175f4:	83a0107e 	movhi	r1, #126	; 0x7e
33d175f8:	e08ae181 	add	lr, sl, r1, lsl #3
33d175fc:	e59ec008 	ldr	ip, [lr, #8]
33d17600:	e15c000e 	cmp	ip, lr
33d17604:	1a000005 	bne	33d17620 <free+0x1cc>
33d17608:	e59a3004 	ldr	r3, [sl, #4]
33d1760c:	e1a01121 	lsr	r1, r1, #2
33d17610:	e3a02001 	mov	r2, #1	; 0x1
33d17614:	e1833112 	orr	r3, r3, r2, lsl r1
33d17618:	e58a3004 	str	r3, [sl, #4]
33d1761c:	ea000007 	b	33d17640 <free+0x1ec>
33d17620:	e59c3004 	ldr	r3, [ip, #4]
33d17624:	e3c33003 	bic	r3, r3, #3	; 0x3
33d17628:	e1540003 	cmp	r4, r3
33d1762c:	2a000002 	bcs	33d1763c <free+0x1e8>
33d17630:	e59cc008 	ldr	ip, [ip, #8]
33d17634:	e15c000e 	cmp	ip, lr
33d17638:	1afffff8 	bne	33d17620 <free+0x1cc>
33d1763c:	e59ce00c 	ldr	lr, [ip, #12]
33d17640:	e585e00c 	str	lr, [r5, #12]
33d17644:	e585c008 	str	ip, [r5, #8]
33d17648:	e58c500c 	str	r5, [ip, #12]
33d1764c:	e58e5008 	str	r5, [lr, #8]
33d17650:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d17654:	33d36098 	.word	0x33d36098
33d17658:	33d36090 	.word	0x33d36090
33d1765c:	33d60c30 	.word	0x33d60c30
33d17660:	33d360a0 	.word	0x33d360a0
33d17664:	00000554 	.word	0x00000554

33d17668 <malloc>:
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
33d17668:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  if ((long)bytes < 0) return 0;
33d1766c:	e3500000 	cmp	r0, #0	; 0x0
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
33d17670:	e24dd004 	sub	sp, sp, #4	; 0x4
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  if ((long)bytes < 0) return 0;
33d17674:	ba000155 	blt	33d17bd0 <malloc+0x568>

  nb = request2size(bytes);  /* padded request size; */
33d17678:	e280000b 	add	r0, r0, #11	; 0xb
33d1767c:	e3500016 	cmp	r0, #22	; 0x16
33d17680:	c3c09007 	bicgt	r9, r0, #7	; 0x7
33d17684:	d3a09010 	movle	r9, #16	; 0x10

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
33d17688:	e3590f7e 	cmp	r9, #504	; 0x1f8
33d1768c:	2a000017 	bcs	33d176f0 <malloc+0x88>
  {
    idx = smallbin_index(nb);

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
33d17690:	e59f35f0 	ldr	r3, [pc, #1520]	; 33d17c88 <malloc+0x620>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
  {
    idx = smallbin_index(nb);
33d17694:	e1a051a9 	lsr	r5, r9, #3

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
33d17698:	e083e185 	add	lr, r3, r5, lsl #3
    victim = last(q);
33d1769c:	e59ec00c 	ldr	ip, [lr, #12]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
33d176a0:	e15c000e 	cmp	ip, lr
33d176a4:	1a000003 	bne	33d176b8 <malloc+0x50>
    {
      q = next_bin(q);
33d176a8:	e28ce008 	add	lr, ip, #8	; 0x8
      victim = last(q);
33d176ac:	e59ec00c 	ldr	ip, [lr, #12]
    }
    if (victim != q)
33d176b0:	e15c000e 	cmp	ip, lr
33d176b4:	0a00000b 	beq	33d176e8 <malloc+0x80>
    {
      victim_size = chunksize(victim);
33d176b8:	e59c3004 	ldr	r3, [ip, #4]
33d176bc:	e3c32003 	bic	r2, r3, #3	; 0x3
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
33d176c0:	e08c2002 	add	r2, ip, r2
33d176c4:	e5923004 	ldr	r3, [r2, #4]
      victim = last(q);
    }
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
33d176c8:	e59c400c 	ldr	r4, [ip, #12]
33d176cc:	e59ce008 	ldr	lr, [ip, #8]
      set_inuse_bit_at_offset(victim, victim_size);
33d176d0:	e3833001 	orr	r3, r3, #1	; 0x1
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
33d176d4:	e28c5008 	add	r5, ip, #8	; 0x8
      victim = last(q);
    }
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
33d176d8:	e584e008 	str	lr, [r4, #8]
      set_inuse_bit_at_offset(victim, victim_size);
33d176dc:	e5823004 	str	r3, [r2, #4]
      victim = last(q);
    }
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
33d176e0:	e58e400c 	str	r4, [lr, #12]
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
33d176e4:	ea000164 	b	33d17c7c <malloc+0x614>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
33d176e8:	e2855002 	add	r5, r5, #2	; 0x2
33d176ec:	ea00002a 	b	33d1779c <malloc+0x134>

  }
  else
  {
    idx = bin_index(nb);
33d176f0:	e1b024a9 	lsrs	r2, r9, #9
33d176f4:	01a051a9 	lsreq	r5, r9, #3
33d176f8:	0a000017 	beq	33d1775c <malloc+0xf4>
33d176fc:	e3520004 	cmp	r2, #4	; 0x4
33d17700:	91a03329 	lsrls	r3, r9, #6
33d17704:	92835038 	addls	r5, r3, #56	; 0x38
33d17708:	9a000013 	bls	33d1775c <malloc+0xf4>
33d1770c:	e3520014 	cmp	r2, #20	; 0x14
33d17710:	9282505b 	addls	r5, r2, #91	; 0x5b
33d17714:	9a000010 	bls	33d1775c <malloc+0xf4>
33d17718:	e3520054 	cmp	r2, #84	; 0x54
33d1771c:	91a03629 	lsrls	r3, r9, #12
33d17720:	9283506e 	addls	r5, r3, #110	; 0x6e
33d17724:	9a00000c 	bls	33d1775c <malloc+0xf4>
33d17728:	e3520f55 	cmp	r2, #340	; 0x154
33d1772c:	91a037a9 	lsrls	r3, r9, #15
33d17730:	92835077 	addls	r5, r3, #119	; 0x77
33d17734:	9a000008 	bls	33d1775c <malloc+0xf4>
33d17738:	e59f354c 	ldr	r3, [pc, #1356]	; 33d17c8c <malloc+0x624>
33d1773c:	e1520003 	cmp	r2, r3
33d17740:	91a03929 	lsrls	r3, r9, #18
33d17744:	9283507c 	addls	r5, r3, #124	; 0x7c
33d17748:	9a000003 	bls	33d1775c <malloc+0xf4>
33d1774c:	ea000001 	b	33d17758 <malloc+0xf0>
      victim_size = chunksize(victim);
      remainder_size = victim_size - nb;

      if (remainder_size >= (long)MINSIZE) /* too big */
      {
	--idx; /* adjust to rescan below after checking last remainder */
33d17750:	e2455001 	sub	r5, r5, #1	; 0x1
	break;
33d17754:	ea00000f 	b	33d17798 <malloc+0x130>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
33d17758:	e3a0507e 	mov	r5, #126	; 0x7e
    bin = bin_at(idx);
33d1775c:	e59f3524 	ldr	r3, [pc, #1316]	; 33d17c88 <malloc+0x620>
33d17760:	e0834185 	add	r4, r3, r5, lsl #3

    for (victim = last(bin); victim != bin; victim = victim->bk)
33d17764:	e594c00c 	ldr	ip, [r4, #12]
33d17768:	e15c0004 	cmp	ip, r4
33d1776c:	0a000009 	beq	33d17798 <malloc+0x130>
    {
      victim_size = chunksize(victim);
33d17770:	e59c3004 	ldr	r3, [ip, #4]
33d17774:	e3c32003 	bic	r2, r3, #3	; 0x3
      remainder_size = victim_size - nb;
33d17778:	e0691002 	rsb	r1, r9, r2

      if (remainder_size >= (long)MINSIZE) /* too big */
33d1777c:	e351000f 	cmp	r1, #15	; 0xf
33d17780:	cafffff2 	bgt	33d17750 <malloc+0xe8>
      {
	--idx; /* adjust to rescan below after checking last remainder */
	break;
      }

      else if (remainder_size >= 0) /* exact fit */
33d17784:	e3510000 	cmp	r1, #0	; 0x0
33d17788:	e59c100c 	ldr	r1, [ip, #12]
33d1778c:	aa000111 	bge	33d17bd8 <malloc+0x570>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
33d17790:	e1a0c001 	mov	ip, r1
33d17794:	eafffff3 	b	33d17768 <malloc+0x100>
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }

    ++idx;
33d17798:	e2855001 	add	r5, r5, #1	; 0x1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
33d1779c:	e59f74ec 	ldr	r7, [pc, #1260]	; 33d17c90 <malloc+0x628>
33d177a0:	e597c008 	ldr	ip, [r7, #8]
33d177a4:	e15c0007 	cmp	ip, r7
33d177a8:	0a000053 	beq	33d178fc <malloc+0x294>
  {
    victim_size = chunksize(victim);
33d177ac:	e59c3004 	ldr	r3, [ip, #4]
33d177b0:	e3c32003 	bic	r2, r3, #3	; 0x3
    remainder_size = victim_size - nb;
33d177b4:	e0691002 	rsb	r1, r9, r2

    if (remainder_size >= (long)MINSIZE) /* re-split */
33d177b8:	e351000f 	cmp	r1, #15	; 0xf
33d177bc:	da00000a 	ble	33d177ec <malloc+0x184>
    {
      remainder = chunk_at_offset(victim, nb);
33d177c0:	e08c0009 	add	r0, ip, r9
      set_head(victim, nb | PREV_INUSE);
33d177c4:	e3892001 	orr	r2, r9, #1	; 0x1
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
33d177c8:	e3813001 	orr	r3, r1, #1	; 0x1
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
33d177cc:	e28c5008 	add	r5, ip, #8	; 0x8
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
33d177d0:	e58c2004 	str	r2, [ip, #4]
      link_last_remainder(remainder);
33d177d4:	e5870008 	str	r0, [r7, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
33d177d8:	e7801001 	str	r1, [r0, r1]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
33d177dc:	e5803004 	str	r3, [r0, #4]

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
33d177e0:	e587000c 	str	r0, [r7, #12]
33d177e4:	e5807008 	str	r7, [r0, #8]
33d177e8:	ea00010f 	b	33d17c2c <malloc+0x5c4>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
33d177ec:	e3510000 	cmp	r1, #0	; 0x0
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    clear_last_remainder;
33d177f0:	e587700c 	str	r7, [r7, #12]
33d177f4:	e5877008 	str	r7, [r7, #8]

    if (remainder_size >= 0)  /* exhaust */
33d177f8:	ba000005 	blt	33d17814 <malloc+0x1ac>
    {
      set_inuse_bit_at_offset(victim, victim_size);
33d177fc:	e08c2002 	add	r2, ip, r2
33d17800:	e5923004 	ldr	r3, [r2, #4]
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
33d17804:	e28c5008 	add	r5, ip, #8	; 0x8

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
33d17808:	e3833001 	orr	r3, r3, #1	; 0x1
33d1780c:	e5823004 	str	r3, [r2, #4]
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
33d17810:	ea000119 	b	33d17c7c <malloc+0x614>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
33d17814:	e3520c02 	cmp	r2, #512	; 0x200
33d17818:	2a000009 	bcs	33d17844 <malloc+0x1dc>
33d1781c:	e1a001a2 	lsr	r0, r2, #3
33d17820:	e2471008 	sub	r1, r7, #8	; 0x8
33d17824:	e0814180 	add	r4, r1, r0, lsl #3
33d17828:	e5912004 	ldr	r2, [r1, #4]
33d1782c:	e1a00120 	lsr	r0, r0, #2
33d17830:	e3a03001 	mov	r3, #1	; 0x1
33d17834:	e594e008 	ldr	lr, [r4, #8]
33d17838:	e1822013 	orr	r2, r2, r3, lsl r0
33d1783c:	e5812004 	str	r2, [r1, #4]
33d17840:	ea000029 	b	33d178ec <malloc+0x284>
33d17844:	e1b004a2 	lsrs	r0, r2, #9
33d17848:	01a001a2 	lsreq	r0, r2, #3
33d1784c:	0a000013 	beq	33d178a0 <malloc+0x238>
33d17850:	e3500004 	cmp	r0, #4	; 0x4
33d17854:	91a03322 	lsrls	r3, r2, #6
33d17858:	92830038 	addls	r0, r3, #56	; 0x38
33d1785c:	9a00000f 	bls	33d178a0 <malloc+0x238>
33d17860:	e3500014 	cmp	r0, #20	; 0x14
33d17864:	9280005b 	addls	r0, r0, #91	; 0x5b
33d17868:	9a00000c 	bls	33d178a0 <malloc+0x238>
33d1786c:	e3500054 	cmp	r0, #84	; 0x54
33d17870:	91a03622 	lsrls	r3, r2, #12
33d17874:	9283006e 	addls	r0, r3, #110	; 0x6e
33d17878:	9a000008 	bls	33d178a0 <malloc+0x238>
33d1787c:	e3500f55 	cmp	r0, #340	; 0x154
33d17880:	91a037a2 	lsrls	r3, r2, #15
33d17884:	92830077 	addls	r0, r3, #119	; 0x77
33d17888:	9a000004 	bls	33d178a0 <malloc+0x238>
33d1788c:	e59f33f8 	ldr	r3, [pc, #1016]	; 33d17c8c <malloc+0x624>
33d17890:	e1500003 	cmp	r0, r3
33d17894:	91a03922 	lsrls	r3, r2, #18
33d17898:	9283007c 	addls	r0, r3, #124	; 0x7c
33d1789c:	83a0007e 	movhi	r0, #126	; 0x7e
33d178a0:	e59f63e0 	ldr	r6, [pc, #992]	; 33d17c88 <malloc+0x620>
33d178a4:	e0864180 	add	r4, r6, r0, lsl #3
33d178a8:	e594e008 	ldr	lr, [r4, #8]
33d178ac:	e15e0004 	cmp	lr, r4
33d178b0:	1a000005 	bne	33d178cc <malloc+0x264>
33d178b4:	e5963004 	ldr	r3, [r6, #4]
33d178b8:	e1a01120 	lsr	r1, r0, #2
33d178bc:	e3a02001 	mov	r2, #1	; 0x1
33d178c0:	e1833112 	orr	r3, r3, r2, lsl r1
33d178c4:	e5863004 	str	r3, [r6, #4]
33d178c8:	ea000007 	b	33d178ec <malloc+0x284>
33d178cc:	e59e3004 	ldr	r3, [lr, #4]
33d178d0:	e3c33003 	bic	r3, r3, #3	; 0x3
33d178d4:	e1520003 	cmp	r2, r3
33d178d8:	2a000002 	bcs	33d178e8 <malloc+0x280>
33d178dc:	e59ee008 	ldr	lr, [lr, #8]
33d178e0:	e15e0004 	cmp	lr, r4
33d178e4:	1afffff8 	bne	33d178cc <malloc+0x264>
33d178e8:	e59e400c 	ldr	r4, [lr, #12]
33d178ec:	e58c400c 	str	r4, [ip, #12]
33d178f0:	e58ce008 	str	lr, [ip, #8]
33d178f4:	e58ec00c 	str	ip, [lr, #12]
33d178f8:	e584c008 	str	ip, [r4, #8]
  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)
33d178fc:	e59f2384 	ldr	r2, [pc, #900]	; 33d17c88 <malloc+0x620>
33d17900:	e1a03fc5 	asr	r3, r5, #31
33d17904:	e0853f23 	add	r3, r5, r3, lsr #30
33d17908:	e5921004 	ldr	r1, [r2, #4]
33d1790c:	e1a03143 	asr	r3, r3, #2
33d17910:	e3a02001 	mov	r2, #1	; 0x1
33d17914:	e1a00312 	lsl	r0, r2, r3
33d17918:	e1500001 	cmp	r0, r1
33d1791c:	8a000037 	bhi	33d17a00 <malloc+0x398>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0)
33d17920:	e1100001 	tst	r0, r1
33d17924:	1a000008 	bne	33d1794c <malloc+0x2e4>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
33d17928:	e1a00210 	lsl	r0, r0, r2
    /* Get to the first marked block */

    if ( (block & binblocks) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
33d1792c:	e3c53003 	bic	r3, r5, #3	; 0x3
      block <<= 1;
      while ((block & binblocks) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
33d17930:	e1100001 	tst	r0, r1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
33d17934:	e2835004 	add	r5, r3, #4	; 0x4
      block <<= 1;
      while ((block & binblocks) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
33d17938:	1a000003 	bne	33d1794c <malloc+0x2e4>
33d1793c:	e1a00080 	lsl	r0, r0, #1
33d17940:	e1100001 	tst	r0, r1
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
      {
	idx += BINBLOCKWIDTH;
33d17944:	e2855004 	add	r5, r5, #4	; 0x4
33d17948:	eafffffa 	b	33d17938 <malloc+0x2d0>

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
33d1794c:	e59fa334 	ldr	sl, [pc, #820]	; 33d17c88 <malloc+0x620>
33d17950:	e08ae185 	add	lr, sl, r5, lsl #3
    }

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
33d17954:	e1a06005 	mov	r6, r5
      q = bin = bin_at(idx);
33d17958:	e1a0400e 	mov	r4, lr
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
33d1795c:	e594c00c 	ldr	ip, [r4, #12]
33d17960:	e15c0004 	cmp	ip, r4
33d17964:	0a000009 	beq	33d17990 <malloc+0x328>
	{
	  victim_size = chunksize(victim);
33d17968:	e59c3004 	ldr	r3, [ip, #4]
33d1796c:	e3c32003 	bic	r2, r3, #3	; 0x3
	  remainder_size = victim_size - nb;
33d17970:	e0691002 	rsb	r1, r9, r2

	  if (remainder_size >= (long)MINSIZE) /* split */
33d17974:	e351000f 	cmp	r1, #15	; 0xf
33d17978:	ca00009e 	bgt	33d17bf8 <malloc+0x590>
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
	  }

	  else if (remainder_size >= 0)  /* take */
33d1797c:	e3510000 	cmp	r1, #0	; 0x0
33d17980:	e59c100c 	ldr	r1, [ip, #12]
33d17984:	aa0000aa 	bge	33d17c34 <malloc+0x5cc>
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
33d17988:	e1a0c001 	mov	ip, r1
33d1798c:	eafffff3 	b	33d17960 <malloc+0x2f8>

	}

       bin = next_bin(bin);

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
33d17990:	e2855001 	add	r5, r5, #1	; 0x1
33d17994:	e3150003 	tst	r5, #3	; 0x3
	    return chunk2mem(victim);
	  }

	}

       bin = next_bin(bin);
33d17998:	e2844008 	add	r4, r4, #8	; 0x8

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
33d1799c:	1affffee 	bne	33d1795c <malloc+0x2f4>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
33d179a0:	e3160003 	tst	r6, #3	; 0x3
	{
	  binblocks &= ~block;
	  break;
	}
	--startidx;
       q = prev_bin(q);
33d179a4:	e24ee008 	sub	lr, lr, #8	; 0x8
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  binblocks &= ~block;
	  break;
	}
	--startidx;
33d179a8:	e2466001 	sub	r6, r6, #1	; 0x1

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
33d179ac:	0a00000f 	beq	33d179f0 <malloc+0x388>
	  binblocks &= ~block;
	  break;
	}
	--startidx;
       q = prev_bin(q);
      } while (first(q) == q);
33d179b0:	e59e3008 	ldr	r3, [lr, #8]
33d179b4:	e153000e 	cmp	r3, lr
33d179b8:	0afffff8 	beq	33d179a0 <malloc+0x338>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) )
33d179bc:	e59f32c4 	ldr	r3, [pc, #708]	; 33d17c88 <malloc+0x620>
33d179c0:	e5933004 	ldr	r3, [r3, #4]
33d179c4:	e1a00080 	lsl	r0, r0, #1
33d179c8:	e1500003 	cmp	r0, r3
33d179cc:	8a00000b 	bhi	33d17a00 <malloc+0x398>
33d179d0:	e3500000 	cmp	r0, #0	; 0x0
33d179d4:	0a000009 	beq	33d17a00 <malloc+0x398>
      {
	while ((block & binblocks) == 0)
	{
	  idx += BINBLOCKWIDTH;
	  block <<= 1;
33d179d8:	e1100003 	tst	r0, r3
33d179dc:	1affffda 	bne	33d1794c <malloc+0x2e4>
33d179e0:	e1a00080 	lsl	r0, r0, #1
33d179e4:	e1100003 	tst	r0, r3

      if ( (block <<= 1) <= binblocks && (block != 0) )
      {
	while ((block & binblocks) == 0)
	{
	  idx += BINBLOCKWIDTH;
33d179e8:	e2855004 	add	r5, r5, #4	; 0x4
33d179ec:	eafffffa 	b	33d179dc <malloc+0x374>

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  binblocks &= ~block;
33d179f0:	e59a3004 	ldr	r3, [sl, #4]
33d179f4:	e1c33000 	bic	r3, r3, r0
33d179f8:	e58a3004 	str	r3, [sl, #4]
	  break;
33d179fc:	eaffffee 	b	33d179bc <malloc+0x354>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
33d17a00:	e59f1280 	ldr	r1, [pc, #640]	; 33d17c88 <malloc+0x620>
33d17a04:	e591a008 	ldr	sl, [r1, #8]
33d17a08:	e59a3004 	ldr	r3, [sl, #4]
33d17a0c:	e3c33003 	bic	r3, r3, #3	; 0x3
33d17a10:	e0691003 	rsb	r1, r9, r3
33d17a14:	e351000f 	cmp	r1, #15	; 0xf
33d17a18:	e58d3000 	str	r3, [sp]
33d17a1c:	ca00008d 	bgt	33d17c58 <malloc+0x5f0>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
33d17a20:	e59f326c 	ldr	r3, [pc, #620]	; 33d17c94 <malloc+0x62c>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
33d17a24:	e59f126c 	ldr	r1, [pc, #620]	; 33d17c98 <malloc+0x630>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
33d17a28:	e5932000 	ldr	r2, [r3]

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
33d17a2c:	e5913000 	ldr	r3, [r1]
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
33d17a30:	e0892002 	add	r2, r9, r2

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
33d17a34:	e3730001 	cmn	r3, #1	; 0x1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
33d17a38:	e2826010 	add	r6, r2, #16	; 0x10
  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
33d17a3c:	12863eff 	addne	r3, r6, #4080	; 0xff0
33d17a40:	1283300f 	addne	r3, r3, #15	; 0xf
33d17a44:	13c36eff 	bicne	r6, r3, #4080	; 0xff0
33d17a48:	13c6600f 	bicne	r6, r6, #15	; 0xf

  brk = (char*)(MORECORE (sbrk_size));
33d17a4c:	e1a00006 	mov	r0, r6
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
33d17a50:	e59d4000 	ldr	r4, [sp]
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
33d17a54:	ebffa687 	bl	33d01478 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
33d17a58:	e3700001 	cmn	r0, #1	; 0x1
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
33d17a5c:	e08a7004 	add	r7, sl, r4
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
33d17a60:	e1a05000 	mov	r5, r0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
33d17a64:	0a000052 	beq	33d17bb4 <malloc+0x54c>
33d17a68:	e1500007 	cmp	r0, r7
33d17a6c:	2a000002 	bcs	33d17a7c <malloc+0x414>
33d17a70:	e59f3210 	ldr	r3, [pc, #528]	; 33d17c88 <malloc+0x620>
33d17a74:	e15a0003 	cmp	sl, r3
33d17a78:	1a00004d 	bne	33d17bb4 <malloc+0x54c>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
33d17a7c:	e59fb218 	ldr	fp, [pc, #536]	; 33d17c9c <malloc+0x634>
33d17a80:	e59b3000 	ldr	r3, [fp]

  if (brk == old_end) /* can just add bytes to current top */
33d17a84:	e1550007 	cmp	r5, r7
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
33d17a88:	e0832006 	add	r2, r3, r6
33d17a8c:	e58b2000 	str	r2, [fp]

  if (brk == old_end) /* can just add bytes to current top */
33d17a90:	1a000005 	bne	33d17aac <malloc+0x444>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
33d17a94:	e59f11ec 	ldr	r1, [pc, #492]	; 33d17c88 <malloc+0x620>

  sbrked_mem += sbrk_size;

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
33d17a98:	e0860004 	add	r0, r6, r4
    set_head(top, top_size | PREV_INUSE);
33d17a9c:	e5912008 	ldr	r2, [r1, #8]
33d17aa0:	e3803001 	orr	r3, r0, #1	; 0x1
33d17aa4:	e5823004 	str	r3, [r2, #4]
33d17aa8:	ea000034 	b	33d17b80 <malloc+0x518>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
33d17aac:	e59f11e4 	ldr	r1, [pc, #484]	; 33d17c98 <malloc+0x630>
33d17ab0:	e5913000 	ldr	r3, [r1]
33d17ab4:	e3730001 	cmn	r3, #1	; 0x1
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
33d17ab8:	10673005 	rsbne	r3, r7, r5
33d17abc:	10823003 	addne	r3, r2, r3
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
33d17ac0:	05815000 	streq	r5, [r1]
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
33d17ac4:	158b3000 	strne	r3, [fp]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0)
33d17ac8:	e2150007 	ands	r0, r5, #7	; 0x7
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
33d17acc:	12604008 	rsbne	r4, r0, #8	; 0x8
      brk += correction;
33d17ad0:	10855004 	addne	r5, r5, r4
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
33d17ad4:	e0852006 	add	r2, r5, r6
33d17ad8:	e2823eff 	add	r3, r2, #4080	; 0xff0
33d17adc:	e283300f 	add	r3, r3, #15	; 0xf
33d17ae0:	e3c33eff 	bic	r3, r3, #4080	; 0xff0
33d17ae4:	e3c3300f 	bic	r3, r3, #15	; 0xf
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
    }
    else
      correction = 0;
33d17ae8:	01a04000 	moveq	r4, r0

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
33d17aec:	e0623003 	rsb	r3, r2, r3
33d17af0:	e0844003 	add	r4, r4, r3
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
33d17af4:	e1a00004 	mov	r0, r4
33d17af8:	ebffa65e 	bl	33d01478 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
33d17afc:	e3700001 	cmn	r0, #1	; 0x1
33d17b00:	0a00002b 	beq	33d17bb4 <malloc+0x54c>

    sbrked_mem += correction;

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
33d17b04:	e0653000 	rsb	r3, r5, r0

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
33d17b08:	e59b2000 	ldr	r2, [fp]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
33d17b0c:	e0830004 	add	r0, r3, r4
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
33d17b10:	e59f3170 	ldr	r3, [pc, #368]	; 33d17c88 <malloc+0x620>
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
33d17b14:	e59f116c 	ldr	r1, [pc, #364]	; 33d17c88 <malloc+0x620>
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
33d17b18:	e15a0003 	cmp	sl, r3

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
33d17b1c:	e0822004 	add	r2, r2, r4

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
33d17b20:	e3803001 	orr	r3, r0, #1	; 0x1

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
33d17b24:	e58b2000 	str	r2, [fp]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
33d17b28:	e5853004 	str	r3, [r5, #4]
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
33d17b2c:	e5815008 	str	r5, [r1, #8]
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
33d17b30:	0a000012 	beq	33d17b80 <malloc+0x518>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
33d17b34:	e59d3000 	ldr	r3, [sp]
33d17b38:	e353000f 	cmp	r3, #15	; 0xf
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
33d17b3c:	93a03001 	movls	r3, #1	; 0x1
33d17b40:	95853004 	strls	r3, [r5, #4]

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
33d17b44:	9a00001a 	bls	33d17bb4 <malloc+0x54c>
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
33d17b48:	e59d1000 	ldr	r1, [sp]
      set_head_size(old_top, old_top_size);
33d17b4c:	e59a2004 	ldr	r2, [sl, #4]
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
33d17b50:	e241300c 	sub	r3, r1, #12	; 0xc
33d17b54:	e3c34007 	bic	r4, r3, #7	; 0x7
      set_head_size(old_top, old_top_size);
33d17b58:	e2022001 	and	r2, r2, #1	; 0x1
      chunk_at_offset(old_top, old_top_size          )->size =
33d17b5c:	e08a1004 	add	r1, sl, r4
33d17b60:	e3a03005 	mov	r3, #5	; 0x5
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
33d17b64:	e1822004 	orr	r2, r2, r4
      chunk_at_offset(old_top, old_top_size          )->size =
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
33d17b68:	e354000f 	cmp	r4, #15	; 0xf
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
33d17b6c:	e58a2004 	str	r2, [sl, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
33d17b70:	e5813008 	str	r3, [r1, #8]
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
      chunk_at_offset(old_top, old_top_size          )->size =
33d17b74:	e5813004 	str	r3, [r1, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
	fREe(chunk2mem(old_top));
33d17b78:	828a0008 	addhi	r0, sl, #8	; 0x8
33d17b7c:	8bfffe34 	blhi	33d17454 <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
33d17b80:	e59f2118 	ldr	r2, [pc, #280]	; 33d17ca0 <malloc+0x638>
33d17b84:	e59f3110 	ldr	r3, [pc, #272]	; 33d17c9c <malloc+0x634>
33d17b88:	e5931000 	ldr	r1, [r3]
33d17b8c:	e5923000 	ldr	r3, [r2]
33d17b90:	e1510003 	cmp	r1, r3
    max_sbrked_mem = sbrked_mem;
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
33d17b94:	e59f3108 	ldr	r3, [pc, #264]	; 33d17ca4 <malloc+0x63c>
33d17b98:	e59f0108 	ldr	r0, [pc, #264]	; 33d17ca8 <malloc+0x640>
33d17b9c:	e5933000 	ldr	r3, [r3]
	fREe(chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
    max_sbrked_mem = sbrked_mem;
33d17ba0:	85821000 	strhi	r1, [r2]
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
33d17ba4:	e5902000 	ldr	r2, [r0]
33d17ba8:	e0833001 	add	r3, r3, r1
33d17bac:	e1530002 	cmp	r3, r2
    max_total_mem = mmapped_mem + sbrked_mem;
33d17bb0:	85803000 	strhi	r3, [r0]
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
33d17bb4:	e59f30cc 	ldr	r3, [pc, #204]	; 33d17c88 <malloc+0x620>
33d17bb8:	e5933008 	ldr	r3, [r3, #8]
33d17bbc:	e5933004 	ldr	r3, [r3, #4]
33d17bc0:	e3c33003 	bic	r3, r3, #3	; 0x3
33d17bc4:	e0691003 	rsb	r1, r9, r3
33d17bc8:	e351000f 	cmp	r1, #15	; 0xf
33d17bcc:	ca000021 	bgt	33d17c58 <malloc+0x5f0>
      return 0; /* propagate failure */
33d17bd0:	e3a05000 	mov	r5, #0	; 0x0
33d17bd4:	ea000028 	b	33d17c7c <malloc+0x614>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
	unlink(victim, bck, fwd);
	set_inuse_bit_at_offset(victim, victim_size);
33d17bd8:	e08c2002 	add	r2, ip, r2
33d17bdc:	e5923004 	ldr	r3, [r2, #4]
	break;
      }

      else if (remainder_size >= 0) /* exact fit */
      {
	unlink(victim, bck, fwd);
33d17be0:	e59ce008 	ldr	lr, [ip, #8]
	set_inuse_bit_at_offset(victim, victim_size);
33d17be4:	e3833001 	orr	r3, r3, #1	; 0x1
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
33d17be8:	e28c5008 	add	r5, ip, #8	; 0x8
	break;
      }

      else if (remainder_size >= 0) /* exact fit */
      {
	unlink(victim, bck, fwd);
33d17bec:	e581e008 	str	lr, [r1, #8]
	set_inuse_bit_at_offset(victim, victim_size);
33d17bf0:	e5823004 	str	r3, [r2, #4]
33d17bf4:	ea000015 	b	33d17c50 <malloc+0x5e8>
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
33d17bf8:	e3893001 	orr	r3, r9, #1	; 0x1
	  victim_size = chunksize(victim);
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
33d17bfc:	e08c0009 	add	r0, ip, r9
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
33d17c00:	e59c400c 	ldr	r4, [ip, #12]
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
33d17c04:	e58c3004 	str	r3, [ip, #4]
	    unlink(victim, bck, fwd);
33d17c08:	e5bce008 	ldr	lr, [ip, #8]!
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
33d17c0c:	e3813001 	orr	r3, r1, #1	; 0x1

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
33d17c10:	e584e008 	str	lr, [r4, #8]
33d17c14:	e58e400c 	str	r4, [lr, #12]
	    link_last_remainder(remainder);
33d17c18:	e5870008 	str	r0, [r7, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
33d17c1c:	e7801001 	str	r1, [r0, r1]
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
33d17c20:	e9800088 	stmib	r0, {r3, r7}
	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
	    link_last_remainder(remainder);
33d17c24:	e587000c 	str	r0, [r7, #12]
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
33d17c28:	e1a0500c 	mov	r5, ip
	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
	    link_last_remainder(remainder);
33d17c2c:	e580700c 	str	r7, [r0, #12]
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
33d17c30:	ea000011 	b	33d17c7c <malloc+0x614>
	  }

	  else if (remainder_size >= 0)  /* take */
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
33d17c34:	e08c2002 	add	r2, ip, r2
33d17c38:	e5923004 	ldr	r3, [r2, #4]
	    unlink(victim, bck, fwd);
33d17c3c:	e5bce008 	ldr	lr, [ip, #8]!
	    return chunk2mem(victim);
	  }

	  else if (remainder_size >= 0)  /* take */
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
33d17c40:	e3833001 	orr	r3, r3, #1	; 0x1
33d17c44:	e5823004 	str	r3, [r2, #4]
	    unlink(victim, bck, fwd);
33d17c48:	e581e008 	str	lr, [r1, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
33d17c4c:	e1a0500c 	mov	r5, ip
	  }

	  else if (remainder_size >= 0)  /* take */
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
	    unlink(victim, bck, fwd);
33d17c50:	e58e100c 	str	r1, [lr, #12]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
33d17c54:	ea000008 	b	33d17c7c <malloc+0x614>
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
33d17c58:	e59f0028 	ldr	r0, [pc, #40]	; 33d17c88 <malloc+0x620>
33d17c5c:	e590c008 	ldr	ip, [r0, #8]
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
33d17c60:	e3811001 	orr	r1, r1, #1	; 0x1
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
33d17c64:	e08c2009 	add	r2, ip, r9
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
33d17c68:	e3893001 	orr	r3, r9, #1	; 0x1
33d17c6c:	e58c3004 	str	r3, [ip, #4]
  top = chunk_at_offset(victim, nb);
33d17c70:	e5802008 	str	r2, [r0, #8]
  set_head(top, remainder_size | PREV_INUSE);
33d17c74:	e5821004 	str	r1, [r2, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
33d17c78:	e28c5008 	add	r5, ip, #8	; 0x8

}
33d17c7c:	e1a00005 	mov	r0, r5
33d17c80:	e28dd004 	add	sp, sp, #4	; 0x4
33d17c84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d17c88:	33d36098 	.word	0x33d36098
33d17c8c:	00000554 	.word	0x00000554
33d17c90:	33d360a0 	.word	0x33d360a0
33d17c94:	33d60c30 	.word	0x33d60c30
33d17c98:	33d36094 	.word	0x33d36094
33d17c9c:	33d60c34 	.word	0x33d60c34
33d17ca0:	33d60c64 	.word	0x33d60c64
33d17ca4:	33d60c60 	.word	0x33d60c60
33d17ca8:	33d60c5c 	.word	0x33d60c5c

33d17cac <realloc>:
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
33d17cac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
33d17cb0:	e3510000 	cmp	r1, #0	; 0x0
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
33d17cb4:	e1a07000 	mov	r7, r0
33d17cb8:	e24dd004 	sub	sp, sp, #4	; 0x4

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
33d17cbc:	b3a00000 	movlt	r0, #0	; 0x0
33d17cc0:	ba000110 	blt	33d18108 <realloc+0x45c>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
33d17cc4:	e3570000 	cmp	r7, #0	; 0x0
33d17cc8:	1a000003 	bne	33d17cdc <realloc+0x30>
33d17ccc:	e1a00001 	mov	r0, r1
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
33d17cd0:	e28dd004 	add	sp, sp, #4	; 0x4
33d17cd4:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
#endif

  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
33d17cd8:	eafffe62 	b	33d17668 <malloc>

  newp    = oldp    = mem2chunk(oldmem);
33d17cdc:	e2474008 	sub	r4, r7, #8	; 0x8
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
33d17ce0:	e281300b 	add	r3, r1, #11	; 0xb

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
33d17ce4:	e5945004 	ldr	r5, [r4, #4]


  nb = request2size(bytes);
33d17ce8:	e3530016 	cmp	r3, #22	; 0x16

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
33d17cec:	e3c5a003 	bic	sl, r5, #3	; 0x3


  nb = request2size(bytes);
33d17cf0:	c3c39007 	bicgt	r9, r3, #7	; 0x7
33d17cf4:	d3a09010 	movle	r9, #16	; 0x10
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
33d17cf8:	e15a0009 	cmp	sl, r9
  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
33d17cfc:	e1a0b004 	mov	fp, r4
  newsize = oldsize = chunksize(oldp);
33d17d00:	e1a0200a 	mov	r2, sl
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
33d17d04:	aa0000e6 	bge	33d180a4 <realloc+0x3f8>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
33d17d08:	e59f0400 	ldr	r0, [pc, #1024]	; 33d18110 <realloc+0x464>
33d17d0c:	e590c008 	ldr	ip, [r0, #8]
  if ((long)(oldsize) < (long)(nb))
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
33d17d10:	e084000a 	add	r0, r4, sl
    if (next == top || !inuse(next))
33d17d14:	e150000c 	cmp	r0, ip
33d17d18:	0a000007 	beq	33d17d3c <realloc+0x90>
33d17d1c:	e5903004 	ldr	r3, [r0, #4]
33d17d20:	e3c33001 	bic	r3, r3, #1	; 0x1
33d17d24:	e0803003 	add	r3, r0, r3
33d17d28:	e5933004 	ldr	r3, [r3, #4]
33d17d2c:	e3130001 	tst	r3, #1	; 0x1
	goto split;
      }
    }
    else
    {
      next = 0;
33d17d30:	13a00000 	movne	r0, #0	; 0x0
      nextsize = 0;
33d17d34:	11a0e000 	movne	lr, r0
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
33d17d38:	1a00001b 	bne	33d17dac <realloc+0x100>
    {
      nextsize = chunksize(next);
33d17d3c:	e5903004 	ldr	r3, [r0, #4]

      /* Forward into top only if a remainder */
      if (next == top)
33d17d40:	e150000c 	cmp	r0, ip
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
    {
      nextsize = chunksize(next);
33d17d44:	e3c3e003 	bic	lr, r3, #3	; 0x3
33d17d48:	e08ec00a 	add	ip, lr, sl

      /* Forward into top only if a remainder */
      if (next == top)
33d17d4c:	1a00000e 	bne	33d17d8c <realloc+0xe0>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
33d17d50:	e2893010 	add	r3, r9, #16	; 0x10
33d17d54:	e15c0003 	cmp	ip, r3
33d17d58:	ba000013 	blt	33d17dac <realloc+0x100>
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
	  set_head(top, (newsize - nb) | PREV_INUSE);
33d17d5c:	e069300c 	rsb	r3, r9, ip
33d17d60:	e3833001 	orr	r3, r3, #1	; 0x1
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
33d17d64:	e0842009 	add	r2, r4, r9
	  set_head(top, (newsize - nb) | PREV_INUSE);
33d17d68:	e5823004 	str	r3, [r2, #4]
	  set_head_size(oldp, nb);
33d17d6c:	e5943004 	ldr	r3, [r4, #4]
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
33d17d70:	e59f1398 	ldr	r1, [pc, #920]	; 33d18110 <realloc+0x464>
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
33d17d74:	e2033001 	and	r3, r3, #1	; 0x1
33d17d78:	e1833009 	orr	r3, r3, r9
	  return chunk2mem(oldp);
33d17d7c:	e2840008 	add	r0, r4, #8	; 0x8
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
33d17d80:	e5812008 	str	r2, [r1, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
33d17d84:	e5843004 	str	r3, [r4, #4]
	  return chunk2mem(oldp);
33d17d88:	ea0000de 	b	33d18108 <realloc+0x45c>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
33d17d8c:	e15c0009 	cmp	ip, r9
33d17d90:	ba000005 	blt	33d17dac <realloc+0x100>
      {
	unlink(next, bck, fwd);
33d17d94:	e2801008 	add	r1, r0, #8	; 0x8
33d17d98:	e891000a 	ldm	r1, {r1, r3}
	newsize  += nextsize;
33d17d9c:	e1a0a00c 	mov	sl, ip
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      {
	unlink(next, bck, fwd);
33d17da0:	e5831008 	str	r1, [r3, #8]
33d17da4:	e581300c 	str	r3, [r1, #12]
	newsize  += nextsize;
	goto split;
33d17da8:	ea0000bd 	b	33d180a4 <realloc+0x3f8>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
33d17dac:	e3150001 	tst	r5, #1	; 0x1
33d17db0:	1a000088 	bne	33d17fd8 <realloc+0x32c>
    {
      prev = prev_chunk(oldp);
33d17db4:	e5943000 	ldr	r3, [r4]
33d17db8:	e0636004 	rsb	r6, r3, r4
      prevsize = chunksize(prev);
33d17dbc:	e5963004 	ldr	r3, [r6, #4]

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
33d17dc0:	e3500000 	cmp	r0, #0	; 0x0
    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
      prevsize = chunksize(prev);
33d17dc4:	e3c34003 	bic	r4, r3, #3	; 0x3

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
33d17dc8:	0a000051 	beq	33d17f14 <realloc+0x268>
      {
	/* into top */
	if (next == top)
33d17dcc:	e59fc33c 	ldr	ip, [pc, #828]	; 33d18110 <realloc+0x464>
33d17dd0:	e59c3008 	ldr	r3, [ip, #8]
33d17dd4:	e1500003 	cmp	r0, r3
33d17dd8:	e08e3004 	add	r3, lr, r4
33d17ddc:	1a00003c 	bne	33d17ed4 <realloc+0x228>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
33d17de0:	e083300a 	add	r3, r3, sl
33d17de4:	e58d3000 	str	r3, [sp]
33d17de8:	e59d0000 	ldr	r0, [sp]
33d17dec:	e2893010 	add	r3, r9, #16	; 0x10
33d17df0:	e1500003 	cmp	r0, r3
33d17df4:	ba000046 	blt	33d17f14 <realloc+0x268>
	  {
	    unlink(prev, bck, fwd);
33d17df8:	e2861008 	add	r1, r6, #8	; 0x8
33d17dfc:	e891000a 	ldm	r1, {r1, r3}
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17e00:	e2422004 	sub	r2, r2, #4	; 0x4
33d17e04:	e3520024 	cmp	r2, #36	; 0x24
	if (next == top)
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
	  {
	    unlink(prev, bck, fwd);
	    newp = prev;
33d17e08:	e1a04006 	mov	r4, r6
	/* into top */
	if (next == top)
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
	  {
	    unlink(prev, bck, fwd);
33d17e0c:	e5831008 	str	r1, [r3, #8]
33d17e10:	e581300c 	str	r3, [r1, #12]
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
33d17e14:	e2865008 	add	r5, r6, #8	; 0x8
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17e18:	8a00001d 	bhi	33d17e94 <realloc+0x1e8>
33d17e1c:	e3520013 	cmp	r2, #19	; 0x13
33d17e20:	e1a0c007 	mov	ip, r7
33d17e24:	e1a01005 	mov	r1, r5
33d17e28:	9a000012 	bls	33d17e78 <realloc+0x1cc>
33d17e2c:	e49c3004 	ldr	r3, [ip], #4
33d17e30:	e5863008 	str	r3, [r6, #8]
33d17e34:	e5973004 	ldr	r3, [r7, #4]
33d17e38:	e352001b 	cmp	r2, #27	; 0x1b
33d17e3c:	e586300c 	str	r3, [r6, #12]
33d17e40:	e28cc004 	add	ip, ip, #4	; 0x4
33d17e44:	e2861010 	add	r1, r6, #16	; 0x10
33d17e48:	9a00000a 	bls	33d17e78 <realloc+0x1cc>
33d17e4c:	e49c3004 	ldr	r3, [ip], #4
33d17e50:	e5863010 	str	r3, [r6, #16]
33d17e54:	e49c3004 	ldr	r3, [ip], #4
33d17e58:	e5863014 	str	r3, [r6, #20]
33d17e5c:	e3520023 	cmp	r2, #35	; 0x23
33d17e60:	849c3004 	ldrhi	r3, [ip], #4
33d17e64:	85863018 	strhi	r3, [r6, #24]
33d17e68:	849c3004 	ldrhi	r3, [ip], #4
33d17e6c:	8586301c 	strhi	r3, [r6, #28]
33d17e70:	e2861018 	add	r1, r6, #24	; 0x18
33d17e74:	82861020 	addhi	r1, r6, #32	; 0x20
33d17e78:	e49c3004 	ldr	r3, [ip], #4
33d17e7c:	e4813004 	str	r3, [r1], #4
33d17e80:	e49c3004 	ldr	r3, [ip], #4
33d17e84:	e4813004 	str	r3, [r1], #4
33d17e88:	e59c3000 	ldr	r3, [ip]
33d17e8c:	e5813000 	str	r3, [r1]
33d17e90:	ea000002 	b	33d17ea0 <realloc+0x1f4>
33d17e94:	e1a01007 	mov	r1, r7
33d17e98:	e1a00005 	mov	r0, r5
33d17e9c:	eb000950 	bl	33d1a3e4 <memcpy>
	    top = chunk_at_offset(newp, nb);
	    set_head(top, (newsize - nb) | PREV_INUSE);
33d17ea0:	e59d1000 	ldr	r1, [sp]
33d17ea4:	e0693001 	rsb	r3, r9, r1
33d17ea8:	e3833001 	orr	r3, r3, #1	; 0x1
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
33d17eac:	e0862009 	add	r2, r6, r9
	    set_head(top, (newsize - nb) | PREV_INUSE);
33d17eb0:	e5823004 	str	r3, [r2, #4]
	    set_head_size(newp, nb);
33d17eb4:	e5963004 	ldr	r3, [r6, #4]
33d17eb8:	e2033001 	and	r3, r3, #1	; 0x1
33d17ebc:	e1833009 	orr	r3, r3, r9
33d17ec0:	e5863004 	str	r3, [r6, #4]
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
33d17ec4:	e59f3244 	ldr	r3, [pc, #580]	; 33d18110 <realloc+0x464>
	    set_head(top, (newsize - nb) | PREV_INUSE);
	    set_head_size(newp, nb);
	    return newmem;
33d17ec8:	e1a00005 	mov	r0, r5
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
33d17ecc:	e5832008 	str	r2, [r3, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
	    set_head_size(newp, nb);
	    return newmem;
33d17ed0:	ea00008c 	b	33d18108 <realloc+0x45c>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
33d17ed4:	e083c00a 	add	ip, r3, sl
33d17ed8:	e15c0009 	cmp	ip, r9
33d17edc:	ba00000c 	blt	33d17f14 <realloc+0x268>
	{
	  unlink(next, bck, fwd);
33d17ee0:	e2801008 	add	r1, r0, #8	; 0x8
33d17ee4:	e891000a 	ldm	r1, {r1, r3}
33d17ee8:	e5831008 	str	r1, [r3, #8]
33d17eec:	e581300c 	str	r3, [r1, #12]
	  unlink(prev, bck, fwd);
	  newp = prev;
	  newsize += nextsize + prevsize;
	  newmem = chunk2mem(newp);
	  MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17ef0:	e2422004 	sub	r2, r2, #4	; 0x4

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
	{
	  unlink(next, bck, fwd);
	  unlink(prev, bck, fwd);
33d17ef4:	e2861008 	add	r1, r6, #8	; 0x8
33d17ef8:	e891000a 	ldm	r1, {r1, r3}
	  newp = prev;
33d17efc:	e1a04006 	mov	r4, r6
	  newsize += nextsize + prevsize;
	  newmem = chunk2mem(newp);
	  MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17f00:	e3520024 	cmp	r2, #36	; 0x24
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
	{
	  unlink(next, bck, fwd);
	  unlink(prev, bck, fwd);
	  newp = prev;
	  newsize += nextsize + prevsize;
33d17f04:	e1a0a00c 	mov	sl, ip

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
	{
	  unlink(next, bck, fwd);
	  unlink(prev, bck, fwd);
33d17f08:	e5831008 	str	r1, [r3, #8]
33d17f0c:	e581300c 	str	r3, [r1, #12]
33d17f10:	ea00000c 	b	33d17f48 <realloc+0x29c>
	  goto split;
	}
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
33d17f14:	e3560000 	cmp	r6, #0	; 0x0
33d17f18:	0a00002e 	beq	33d17fd8 <realloc+0x32c>
33d17f1c:	e084000a 	add	r0, r4, sl
33d17f20:	e1500009 	cmp	r0, r9
33d17f24:	ba00002b 	blt	33d17fd8 <realloc+0x32c>
      {
	unlink(prev, bck, fwd);
33d17f28:	e2861008 	add	r1, r6, #8	; 0x8
33d17f2c:	e891000a 	ldm	r1, {r1, r3}
	newp = prev;
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17f30:	e2422004 	sub	r2, r2, #4	; 0x4
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
      {
	unlink(prev, bck, fwd);
33d17f34:	e5831008 	str	r1, [r3, #8]
33d17f38:	e581300c 	str	r3, [r1, #12]
	newp = prev;
33d17f3c:	e1a04006 	mov	r4, r6
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17f40:	e3520024 	cmp	r2, #36	; 0x24
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
      {
	unlink(prev, bck, fwd);
	newp = prev;
	newsize += prevsize;
33d17f44:	e1a0a000 	mov	sl, r0
	newmem = chunk2mem(newp);
33d17f48:	e2845008 	add	r5, r4, #8	; 0x8
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d17f4c:	8a00001d 	bhi	33d17fc8 <realloc+0x31c>
33d17f50:	e3520013 	cmp	r2, #19	; 0x13
33d17f54:	e1a00005 	mov	r0, r5
33d17f58:	e1a0c007 	mov	ip, r7
33d17f5c:	9a000012 	bls	33d17fac <realloc+0x300>
33d17f60:	e49c3004 	ldr	r3, [ip], #4
33d17f64:	e5843008 	str	r3, [r4, #8]
33d17f68:	e5973004 	ldr	r3, [r7, #4]
33d17f6c:	e352001b 	cmp	r2, #27	; 0x1b
33d17f70:	e584300c 	str	r3, [r4, #12]
33d17f74:	e28cc004 	add	ip, ip, #4	; 0x4
33d17f78:	e2840010 	add	r0, r4, #16	; 0x10
33d17f7c:	9a00000a 	bls	33d17fac <realloc+0x300>
33d17f80:	e49c3004 	ldr	r3, [ip], #4
33d17f84:	e5843010 	str	r3, [r4, #16]
33d17f88:	e49c3004 	ldr	r3, [ip], #4
33d17f8c:	e5843014 	str	r3, [r4, #20]
33d17f90:	e3520023 	cmp	r2, #35	; 0x23
33d17f94:	849c3004 	ldrhi	r3, [ip], #4
33d17f98:	85843018 	strhi	r3, [r4, #24]
33d17f9c:	849c3004 	ldrhi	r3, [ip], #4
33d17fa0:	8584301c 	strhi	r3, [r4, #28]
33d17fa4:	e2840018 	add	r0, r4, #24	; 0x18
33d17fa8:	82840020 	addhi	r0, r4, #32	; 0x20
33d17fac:	e49c3004 	ldr	r3, [ip], #4
33d17fb0:	e4803004 	str	r3, [r0], #4
33d17fb4:	e49c3004 	ldr	r3, [ip], #4
33d17fb8:	e4803004 	str	r3, [r0], #4
33d17fbc:	e59c3000 	ldr	r3, [ip]
33d17fc0:	e5803000 	str	r3, [r0]
33d17fc4:	ea000036 	b	33d180a4 <realloc+0x3f8>
33d17fc8:	e1a00005 	mov	r0, r5
33d17fcc:	e1a01007 	mov	r1, r7
33d17fd0:	eb000903 	bl	33d1a3e4 <memcpy>
	goto split;
33d17fd4:	ea000032 	b	33d180a4 <realloc+0x3f8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
33d17fd8:	e1a00001 	mov	r0, r1
33d17fdc:	ebfffda1 	bl	33d17668 <malloc>

    if (newmem == 0)  /* propagate failure */
33d17fe0:	e2505000 	subs	r5, r0, #0	; 0x0
33d17fe4:	0a00002c 	beq	33d1809c <realloc+0x3f0>
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
33d17fe8:	e59b3004 	ldr	r3, [fp, #4]
33d17fec:	e3c33001 	bic	r3, r3, #1	; 0x1
33d17ff0:	e08b3003 	add	r3, fp, r3
33d17ff4:	e2454008 	sub	r4, r5, #8	; 0x8
33d17ff8:	e1540003 	cmp	r4, r3
    {
      newsize += chunksize(newp);
33d17ffc:	05943004 	ldreq	r3, [r4, #4]
33d18000:	03c33003 	biceq	r3, r3, #3	; 0x3
33d18004:	008aa003 	addeq	sl, sl, r3
      newp = oldp;
33d18008:	01a0400b 	moveq	r4, fp
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
33d1800c:	0a000024 	beq	33d180a4 <realloc+0x3f8>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
33d18010:	e24a2004 	sub	r2, sl, #4	; 0x4
33d18014:	e3520024 	cmp	r2, #36	; 0x24
33d18018:	8a00001b 	bhi	33d1808c <realloc+0x3e0>
33d1801c:	e3520013 	cmp	r2, #19	; 0x13
33d18020:	e1a00007 	mov	r0, r7
33d18024:	e1a01005 	mov	r1, r5
33d18028:	9a000010 	bls	33d18070 <realloc+0x3c4>
33d1802c:	e4903004 	ldr	r3, [r0], #4
33d18030:	e4813004 	str	r3, [r1], #4
33d18034:	e5973004 	ldr	r3, [r7, #4]
33d18038:	e352001b 	cmp	r2, #27	; 0x1b
33d1803c:	e5853004 	str	r3, [r5, #4]
33d18040:	e2800004 	add	r0, r0, #4	; 0x4
33d18044:	e2811004 	add	r1, r1, #4	; 0x4
33d18048:	9a000008 	bls	33d18070 <realloc+0x3c4>
33d1804c:	e4903004 	ldr	r3, [r0], #4
33d18050:	e4813004 	str	r3, [r1], #4
33d18054:	e4903004 	ldr	r3, [r0], #4
33d18058:	e4813004 	str	r3, [r1], #4
33d1805c:	e3520023 	cmp	r2, #35	; 0x23
33d18060:	84903004 	ldrhi	r3, [r0], #4
33d18064:	84813004 	strhi	r3, [r1], #4
33d18068:	84903004 	ldrhi	r3, [r0], #4
33d1806c:	84813004 	strhi	r3, [r1], #4
33d18070:	e4903004 	ldr	r3, [r0], #4
33d18074:	e4813004 	str	r3, [r1], #4
33d18078:	e4903004 	ldr	r3, [r0], #4
33d1807c:	e4813004 	str	r3, [r1], #4
33d18080:	e5903000 	ldr	r3, [r0]
33d18084:	e5813000 	str	r3, [r1]
33d18088:	ea000001 	b	33d18094 <realloc+0x3e8>
33d1808c:	e1a01007 	mov	r1, r7
33d18090:	eb0008d3 	bl	33d1a3e4 <memcpy>
    fREe(oldmem);
33d18094:	e1a00007 	mov	r0, r7
33d18098:	ebfffced 	bl	33d17454 <free>
    return newmem;
33d1809c:	e1a00005 	mov	r0, r5
33d180a0:	ea000018 	b	33d18108 <realloc+0x45c>
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
33d180a4:	e069100a 	rsb	r1, r9, sl
33d180a8:	e351000f 	cmp	r1, #15	; 0xf
33d180ac:	e5943004 	ldr	r3, [r4, #4]
33d180b0:	9a00000c 	bls	33d180e8 <realloc+0x43c>
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
33d180b4:	e2033001 	and	r3, r3, #1	; 0x1

 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
33d180b8:	e0840009 	add	r0, r4, r9
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
33d180bc:	e1833009 	orr	r3, r3, r9
    set_head(remainder, remainder_size | PREV_INUSE);
33d180c0:	e3812001 	orr	r2, r1, #1	; 0x1

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
33d180c4:	e5843004 	str	r3, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
33d180c8:	e5802004 	str	r2, [r0, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
33d180cc:	e0802001 	add	r2, r0, r1
33d180d0:	e5923004 	ldr	r3, [r2, #4]
33d180d4:	e3833001 	orr	r3, r3, #1	; 0x1
33d180d8:	e5823004 	str	r3, [r2, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
33d180dc:	e2800008 	add	r0, r0, #8	; 0x8
33d180e0:	ebfffcdb 	bl	33d17454 <free>
33d180e4:	ea000006 	b	33d18104 <realloc+0x458>
  }
  else
  {
    set_head_size(newp, newsize);
33d180e8:	e2033001 	and	r3, r3, #1	; 0x1
33d180ec:	e183300a 	orr	r3, r3, sl
33d180f0:	e5843004 	str	r3, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
33d180f4:	e084200a 	add	r2, r4, sl
33d180f8:	e5923004 	ldr	r3, [r2, #4]
33d180fc:	e3833001 	orr	r3, r3, #1	; 0x1
33d18100:	e5823004 	str	r3, [r2, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
33d18104:	e2840008 	add	r0, r4, #8	; 0x8
}
33d18108:	e28dd004 	add	sp, sp, #4	; 0x4
33d1810c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d18110:	33d36098 	.word	0x33d36098

33d18114 <memalign>:
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
33d18114:	e3510000 	cmp	r1, #0	; 0x0
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
33d18118:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d1811c:	e1a05000 	mov	r5, r0
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
33d18120:	b3a00000 	movlt	r0, #0	; 0x0
33d18124:	b8bd84f0 	poplt	{r4, r5, r6, r7, sl, pc}

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
33d18128:	e3550008 	cmp	r5, #8	; 0x8
33d1812c:	8a000002 	bhi	33d1813c <memalign+0x28>
33d18130:	e1a00001 	mov	r0, r1
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
33d18134:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}

  if ((long)bytes < 0) return 0;

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
33d18138:	eafffd4a 	b	33d17668 <malloc>

  if (alignment <  MINSIZE) alignment = MINSIZE;

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
33d1813c:	e281000b 	add	r0, r1, #11	; 0xb

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
33d18140:	e355000f 	cmp	r5, #15	; 0xf
33d18144:	93a05010 	movls	r5, #16	; 0x10

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
33d18148:	e3500016 	cmp	r0, #22	; 0x16
33d1814c:	c3c0a007 	bicgt	sl, r0, #7	; 0x7
33d18150:	d3a0a010 	movle	sl, #16	; 0x10
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
33d18154:	e08a0005 	add	r0, sl, r5
33d18158:	e2800010 	add	r0, r0, #16	; 0x10
33d1815c:	ebfffd41 	bl	33d17668 <malloc>

  if (m == 0) return 0; /* propagate failure */
33d18160:	e2507000 	subs	r7, r0, #0	; 0x0
33d18164:	01a00007 	moveq	r0, r7
33d18168:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}

  p = mem2chunk(m);

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
33d1816c:	e1a01005 	mov	r1, r5
33d18170:	eb0019ca 	bl	33d1e8a0 <__umodsi3>
33d18174:	e3500000 	cmp	r0, #0	; 0x0
  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */

  p = mem2chunk(m);
33d18178:	e2476008 	sub	r6, r7, #8	; 0x8

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
33d1817c:	0a000018 	beq	33d181e4 <memalign+0xd0>
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
33d18180:	e0873005 	add	r3, r7, r5
33d18184:	e2652000 	rsb	r2, r5, #0	; 0x0
33d18188:	e2433001 	sub	r3, r3, #1	; 0x1
33d1818c:	e0033002 	and	r3, r3, r2
33d18190:	e2434008 	sub	r4, r3, #8	; 0x8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
33d18194:	e0663004 	rsb	r3, r6, r4

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;
33d18198:	e5962004 	ldr	r2, [r6, #4]
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
33d1819c:	e353000f 	cmp	r3, #15	; 0xf
33d181a0:	90844005 	addls	r4, r4, r5

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
33d181a4:	e0661004 	rsb	r1, r6, r4
    newsize = chunksize(p) - leadsize;
33d181a8:	e3c22003 	bic	r2, r2, #3	; 0x3
33d181ac:	e0612002 	rsb	r2, r1, r2
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
33d181b0:	e3823001 	orr	r3, r2, #1	; 0x1
33d181b4:	e5843004 	str	r3, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
33d181b8:	e0842002 	add	r2, r4, r2
33d181bc:	e5923004 	ldr	r3, [r2, #4]
33d181c0:	e3833001 	orr	r3, r3, #1	; 0x1
33d181c4:	e5823004 	str	r3, [r2, #4]
    set_head_size(p, leadsize);
33d181c8:	e5963004 	ldr	r3, [r6, #4]
33d181cc:	e2033001 	and	r3, r3, #1	; 0x1
33d181d0:	e1833001 	orr	r3, r3, r1
33d181d4:	e5863004 	str	r3, [r6, #4]
    fREe(chunk2mem(p));
33d181d8:	e1a00007 	mov	r0, r7
33d181dc:	ebfffc9c 	bl	33d17454 <free>
    p = newp;
33d181e0:	e1a06004 	mov	r6, r4
    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
33d181e4:	e5963004 	ldr	r3, [r6, #4]
33d181e8:	e3c33003 	bic	r3, r3, #3	; 0x3
33d181ec:	e06a3003 	rsb	r3, sl, r3

  if (remainder_size >= (long)MINSIZE)
33d181f0:	e353000f 	cmp	r3, #15	; 0xf
33d181f4:	da000008 	ble	33d1821c <memalign+0x108>
  {
    remainder = chunk_at_offset(p, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
33d181f8:	e3833001 	orr	r3, r3, #1	; 0x1

  remainder_size = chunksize(p) - nb;

  if (remainder_size >= (long)MINSIZE)
  {
    remainder = chunk_at_offset(p, nb);
33d181fc:	e086000a 	add	r0, r6, sl
    set_head(remainder, remainder_size | PREV_INUSE);
33d18200:	e5803004 	str	r3, [r0, #4]
    set_head_size(p, nb);
33d18204:	e5963004 	ldr	r3, [r6, #4]
33d18208:	e2033001 	and	r3, r3, #1	; 0x1
33d1820c:	e183300a 	orr	r3, r3, sl
33d18210:	e5863004 	str	r3, [r6, #4]
    fREe(chunk2mem(remainder));
33d18214:	e2800008 	add	r0, r0, #8	; 0x8
33d18218:	ebfffc8d 	bl	33d17454 <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
33d1821c:	e2860008 	add	r0, r6, #8	; 0x8

}
33d18220:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

33d18224 <valloc>:
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
33d18224:	e1a01000 	mov	r1, r0
  return mEMALIGn (malloc_getpagesize, bytes);
33d18228:	e3a00a01 	mov	r0, #4096	; 0x1000
33d1822c:	eaffffb8 	b	33d18114 <memalign>

33d18230 <pvalloc>:
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
  size_t pagesize = malloc_getpagesize;
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
33d18230:	e2801eff 	add	r1, r0, #4080	; 0xff0
33d18234:	e281100f 	add	r1, r1, #15	; 0xf
33d18238:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
33d1823c:	e3c1100f 	bic	r1, r1, #15	; 0xf
33d18240:	e3a00a01 	mov	r0, #4096	; 0x1000
33d18244:	eaffffb2 	b	33d18114 <memalign>

33d18248 <calloc>:
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
33d18248:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
33d1824c:	e59f30c0 	ldr	r3, [pc, #192]	; 33d18314 <calloc+0xcc>
33d18250:	e5937008 	ldr	r7, [r3, #8]
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
33d18254:	e1a04000 	mov	r4, r0


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
33d18258:	e5973004 	ldr	r3, [r7, #4]
#endif
  Void_t* mem = mALLOc (sz);
33d1825c:	e0000491 	mul	r0, r1, r4


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
33d18260:	e3c36003 	bic	r6, r3, #3	; 0x3
#endif
  Void_t* mem = mALLOc (sz);
33d18264:	ebfffcff 	bl	33d17668 <malloc>

  if ((long)n < 0) return 0;
33d18268:	e3540000 	cmp	r4, #0	; 0x0
  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
33d1826c:	e1a05000 	mov	r5, r0

  if ((long)n < 0) return 0;
33d18270:	b3a00000 	movlt	r0, #0	; 0x0
33d18274:	b8bd80f0 	poplt	{r4, r5, r6, r7, pc}

  if (mem == 0)
33d18278:	e3550000 	cmp	r5, #0	; 0x0
    return 0;
33d1827c:	01a00005 	moveq	r0, r5
#endif
  Void_t* mem = mALLOc (sz);

  if ((long)n < 0) return 0;

  if (mem == 0)
33d18280:	08bd80f0 	popeq	{r4, r5, r6, r7, pc}
    return 0;
  else
  {
    p = mem2chunk(mem);
33d18284:	e2453008 	sub	r3, r5, #8	; 0x8

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
33d18288:	e5932004 	ldr	r2, [r3, #4]
33d1828c:	e3c22003 	bic	r2, r2, #3	; 0x3

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
33d18290:	e1530007 	cmp	r3, r7
33d18294:	13a03000 	movne	r3, #0	; 0x0
33d18298:	03a03001 	moveq	r3, #1	; 0x1
33d1829c:	e1520006 	cmp	r2, r6
33d182a0:	93a03000 	movls	r3, #0	; 0x0
    {
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
33d182a4:	e3530000 	cmp	r3, #0	; 0x0
33d182a8:	11a02006 	movne	r2, r6
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
33d182ac:	e2422004 	sub	r2, r2, #4	; 0x4
33d182b0:	e3520024 	cmp	r2, #36	; 0x24
33d182b4:	8a000012 	bhi	33d18304 <calloc+0xbc>
33d182b8:	e3520013 	cmp	r2, #19	; 0x13
33d182bc:	e1a01005 	mov	r1, r5
33d182c0:	9a00000a 	bls	33d182f0 <calloc+0xa8>
33d182c4:	e3a03000 	mov	r3, #0	; 0x0
33d182c8:	e4813004 	str	r3, [r1], #4
33d182cc:	e352001b 	cmp	r2, #27	; 0x1b
33d182d0:	e5853004 	str	r3, [r5, #4]
33d182d4:	e2811004 	add	r1, r1, #4	; 0x4
33d182d8:	9a000004 	bls	33d182f0 <calloc+0xa8>
33d182dc:	e4813004 	str	r3, [r1], #4
33d182e0:	e4813004 	str	r3, [r1], #4
33d182e4:	e3520023 	cmp	r2, #35	; 0x23
33d182e8:	84813004 	strhi	r3, [r1], #4
33d182ec:	84813004 	strhi	r3, [r1], #4
33d182f0:	e3a03000 	mov	r3, #0	; 0x0
33d182f4:	e4813004 	str	r3, [r1], #4
33d182f8:	e4813004 	str	r3, [r1], #4
33d182fc:	e5813000 	str	r3, [r1]
33d18300:	ea000001 	b	33d1830c <calloc+0xc4>
33d18304:	e3a01000 	mov	r1, #0	; 0x0
33d18308:	eb000821 	bl	33d1a394 <memset>
    return mem;
33d1830c:	e1a00005 	mov	r0, r5
  }
}
33d18310:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d18314:	33d36098 	.word	0x33d36098

33d18318 <cfree>:
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
  fREe(mem);
33d18318:	eafffc4d 	b	33d17454 <free>

33d1831c <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
33d1831c:	e3500000 	cmp	r0, #0	; 0x0
    return 0;
  else
  {
    p = mem2chunk(mem);
33d18320:	e2401008 	sub	r1, r0, #8	; 0x8
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
33d18324:	01a0f00e 	moveq	pc, lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
33d18328:	e5912004 	ldr	r2, [r1, #4]
    {
      if (!inuse(p)) return 0;
33d1832c:	e3c23001 	bic	r3, r2, #1	; 0x1
  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
33d18330:	e3120002 	tst	r2, #2	; 0x2
    {
      if (!inuse(p)) return 0;
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
    }
    return chunksize(p) - 2*SIZE_SZ;
33d18334:	e3c20003 	bic	r0, r2, #3	; 0x3
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
    {
      if (!inuse(p)) return 0;
33d18338:	e0813003 	add	r3, r1, r3
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
    }
    return chunksize(p) - 2*SIZE_SZ;
33d1833c:	12400008 	subne	r0, r0, #8	; 0x8
  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
33d18340:	11a0f00e 	movne	pc, lr
    {
      if (!inuse(p)) return 0;
33d18344:	e5933004 	ldr	r3, [r3, #4]
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
33d18348:	e3c22003 	bic	r2, r2, #3	; 0x3
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
    {
      if (!inuse(p)) return 0;
33d1834c:	e2133001 	ands	r3, r3, #1	; 0x1
33d18350:	e1a00003 	mov	r0, r3
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
33d18354:	12420004 	subne	r0, r2, #4	; 0x4
33d18358:	e1a0f00e 	mov	pc, lr

33d1835c <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
33d1835c:	e2800004 	add	r0, r0, #4	; 0x4
33d18360:	e3500003 	cmp	r0, #3	; 0x3
33d18364:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
33d18368:	ea000013 	b	33d183bc <mallopt+0x60>
33d1836c:	33d183a4 	.word	0x33d183a4
33d18370:	33d18398 	.word	0x33d18398
33d18374:	33d18388 	.word	0x33d18388
33d18378:	33d1837c 	.word	0x33d1837c
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
33d1837c:	e59f3040 	ldr	r3, [pc, #64]	; 33d183c4 <mallopt+0x68>
33d18380:	e3a00001 	mov	r0, #1	; 0x1
33d18384:	ea000001 	b	33d18390 <mallopt+0x34>
    case M_TOP_PAD:
      top_pad = value; return 1;
33d18388:	e59f3038 	ldr	r3, [pc, #56]	; 33d183c8 <mallopt+0x6c>
33d1838c:	e3a00001 	mov	r0, #1	; 0x1
33d18390:	e5831000 	str	r1, [r3]
33d18394:	e1a0f00e 	mov	pc, lr
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
33d18398:	e59f302c 	ldr	r3, [pc, #44]	; 33d183cc <mallopt+0x70>
33d1839c:	e3a00001 	mov	r0, #1	; 0x1
33d183a0:	eafffffa 	b	33d18390 <mallopt+0x34>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
33d183a4:	e3510000 	cmp	r1, #0	; 0x0
33d183a8:	e3a00000 	mov	r0, #0	; 0x0
33d183ac:	059f301c 	ldreq	r3, [pc, #28]	; 33d183d0 <mallopt+0x74>
33d183b0:	03a00001 	moveq	r0, #1	; 0x1
33d183b4:	11a0f00e 	movne	pc, lr
33d183b8:	eafffff4 	b	33d18390 <mallopt+0x34>
#endif

    default:
      return 0;
33d183bc:	e3a00000 	mov	r0, #0	; 0x0
  }
}
33d183c0:	e1a0f00e 	mov	pc, lr
33d183c4:	33d36090 	.word	0x33d36090
33d183c8:	33d60c30 	.word	0x33d60c30
33d183cc:	33d3608c 	.word	0x33d3608c
33d183d0:	33d60c2c 	.word	0x33d60c2c

33d183d4 <env_crc_update>:
#if defined(CFG_ENV_IS_IN_NAND)		/* Environment is in Nand Flash */
int default_environment_size = sizeof(default_environment);
#endif

void env_crc_update (void)
{
33d183d4:	e92d4010 	push	{r4, lr}
	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
33d183d8:	e59f3018 	ldr	r3, [pc, #24]	; 33d183f8 <env_crc_update+0x24>
33d183dc:	e5934000 	ldr	r4, [r3]
33d183e0:	e3a00000 	mov	r0, #0	; 0x0
33d183e4:	e2841004 	add	r1, r4, #4	; 0x4
33d183e8:	e59f200c 	ldr	r2, [pc, #12]	; 33d183fc <env_crc_update+0x28>
33d183ec:	eb000649 	bl	33d19d18 <crc32>
33d183f0:	e5840000 	str	r0, [r4]
33d183f4:	e8bd8010 	pop	{r4, pc}
33d183f8:	33d60c68 	.word	0x33d60c68
33d183fc:	0001fffc 	.word	0x0001fffc

33d18400 <env_get_char_init>:
}

static uchar env_get_char_init (int index)
{
33d18400:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	uchar c;

	/* if crc was bad, use the default environment */
	if (gd->env_valid)
33d18404:	e5983018 	ldr	r3, [r8, #24]
33d18408:	e3530000 	cmp	r3, #0	; 0x0
	{
		c = env_get_char_spec(index);
	} else {
		c = default_environment[index];
33d1840c:	059f3010 	ldreq	r3, [pc, #16]	; 33d18424 <env_get_char_init+0x24>
33d18410:	07d30000 	ldrbeq	r0, [r3, r0]
static uchar env_get_char_init (int index)
{
	uchar c;

	/* if crc was bad, use the default environment */
	if (gd->env_valid)
33d18414:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
	{
		c = env_get_char_spec(index);
33d18418:	eb000036 	bl	33d184f8 <env_get_char_spec>
33d1841c:	e20000ff 	and	r0, r0, #255	; 0xff
33d18420:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d18424:	33d364a4 	.word	0x33d364a4

33d18428 <env_get_char_memory>:
	return retval;
}
#else
uchar env_get_char_memory (int index)
{
	if (gd->env_valid) {
33d18428:	e5983018 	ldr	r3, [r8, #24]
33d1842c:	e3530000 	cmp	r3, #0	; 0x0
		return ( *((uchar *)(gd->env_addr + index)) );
33d18430:	15983014 	ldrne	r3, [r8, #20]
	} else {
		return ( default_environment[index] );
33d18434:	059f3008 	ldreq	r3, [pc, #8]	; 33d18444 <env_get_char_memory+0x1c>
}
#else
uchar env_get_char_memory (int index)
{
	if (gd->env_valid) {
		return ( *((uchar *)(gd->env_addr + index)) );
33d18438:	17d30000 	ldrbne	r0, [r3, r0]
	} else {
		return ( default_environment[index] );
33d1843c:	07d30000 	ldrbeq	r0, [r3, r0]
	}
}
33d18440:	e1a0f00e 	mov	pc, lr
33d18444:	33d364a4 	.word	0x33d364a4

33d18448 <env_get_addr>:
#endif

uchar *env_get_addr (int index)
{
	if (gd->env_valid) {
33d18448:	e5983018 	ldr	r3, [r8, #24]
33d1844c:	e3530000 	cmp	r3, #0	; 0x0
		return ( ((uchar *)(gd->env_addr + index)) );
33d18450:	15983014 	ldrne	r3, [r8, #20]
	} else {
		return (&default_environment[index]);
33d18454:	059f3008 	ldreq	r3, [pc, #8]	; 33d18464 <env_get_addr+0x1c>
#endif

uchar *env_get_addr (int index)
{
	if (gd->env_valid) {
		return ( ((uchar *)(gd->env_addr + index)) );
33d18458:	10830000 	addne	r0, r3, r0
	} else {
		return (&default_environment[index]);
33d1845c:	00800003 	addeq	r0, r0, r3
	}
}
33d18460:	e1a0f00e 	mov	pc, lr
33d18464:	33d364a4 	.word	0x33d364a4

33d18468 <env_relocate>:

void env_relocate (void)
{
33d18468:	e92d4030 	push	{r4, r5, lr}
	DEBUGF ("%s[%d] embedded ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
#else
	/*
	 * We must allocate a buffer for the environment
	 */
	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
33d1846c:	e3a00802 	mov	r0, #131072	; 0x20000
33d18470:	ebfffc7c 	bl	33d17668 <malloc>
33d18474:	e59f5068 	ldr	r5, [pc, #104]	; 33d184e4 <env_relocate+0x7c>
#endif

	/*
	 * After relocation to RAM, we can always use the "memory" functions
	 */
	env_get_char = env_get_char_memory;
33d18478:	e59f2068 	ldr	r2, [pc, #104]	; 33d184e8 <env_relocate+0x80>
33d1847c:	e59f3068 	ldr	r3, [pc, #104]	; 33d184ec <env_relocate+0x84>
	DEBUGF ("%s[%d] embedded ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
#else
	/*
	 * We must allocate a buffer for the environment
	 */
	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
33d18480:	e5850000 	str	r0, [r5]
#endif

	/*
	 * After relocation to RAM, we can always use the "memory" functions
	 */
	env_get_char = env_get_char_memory;
33d18484:	e5832000 	str	r2, [r3]

	if (gd->env_valid == 0) {
33d18488:	e5984018 	ldr	r4, [r8, #24]
33d1848c:	e3540000 	cmp	r4, #0	; 0x0
#if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
		puts ("Using default environment\n\n");
#else
		puts ("*** Warning - bad CRC, using default environment\n\n");
33d18490:	e59f0058 	ldr	r0, [pc, #88]	; 33d184f0 <env_relocate+0x88>
	/*
	 * After relocation to RAM, we can always use the "memory" functions
	 */
	env_get_char = env_get_char_memory;

	if (gd->env_valid == 0) {
33d18494:	1a00000d 	bne	33d184d0 <env_relocate+0x68>
#if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
		puts ("Using default environment\n\n");
#else
		puts ("*** Warning - bad CRC, using default environment\n\n");
33d18498:	ebfffac3 	bl	33d16fac <puts>
		{
			puts ("*** Error - default environment is too large\n\n");
			return;
		}

		memset (env_ptr, 0, sizeof(env_t));
33d1849c:	e1a01004 	mov	r1, r4
33d184a0:	e3a02802 	mov	r2, #131072	; 0x20000
33d184a4:	e5950000 	ldr	r0, [r5]
33d184a8:	eb0007b9 	bl	33d1a394 <memset>
		memcpy (env_ptr->data,
33d184ac:	e5950000 	ldr	r0, [r5]
33d184b0:	e59f103c 	ldr	r1, [pc, #60]	; 33d184f4 <env_relocate+0x8c>
33d184b4:	e3a020ce 	mov	r2, #206	; 0xce
33d184b8:	e2800004 	add	r0, r0, #4	; 0x4
33d184bc:	eb0007c8 	bl	33d1a3e4 <memcpy>
			default_environment,
			sizeof(default_environment));
#ifdef CFG_REDUNDAND_ENVIRONMENT
		env_ptr->flags = 0xFF;
#endif
		env_crc_update ();
33d184c0:	ebffffc3 	bl	33d183d4 <env_crc_update>
		gd->env_valid = 1;
33d184c4:	e3a03001 	mov	r3, #1	; 0x1
33d184c8:	e5883018 	str	r3, [r8, #24]
33d184cc:	ea000000 	b	33d184d4 <env_relocate+0x6c>
	}
	else {
		env_relocate_spec ();
33d184d0:	eb000067 	bl	33d18674 <env_relocate_spec>
	}
	gd->env_addr = (ulong)&(env_ptr->data);
33d184d4:	e5953000 	ldr	r3, [r5]
33d184d8:	e2833004 	add	r3, r3, #4	; 0x4
33d184dc:	e5883014 	str	r3, [r8, #20]
33d184e0:	e8bd8030 	pop	{r4, r5, pc}
33d184e4:	33d60c68 	.word	0x33d60c68
33d184e8:	33d18428 	.word	0x33d18428
33d184ec:	33d36574 	.word	0x33d36574
33d184f0:	33d2cb4c 	.word	0x33d2cb4c
33d184f4:	33d364a4 	.word	0x33d364a4

33d184f8 <env_get_char_spec>:

DECLARE_GLOBAL_DATA_PTR;

uchar env_get_char_spec (int index)
{
	return ( *((uchar *)(gd->env_addr + index)) );
33d184f8:	e5983014 	ldr	r3, [r8, #20]
}
33d184fc:	e7d30000 	ldrb	r0, [r3, r0]
33d18500:	e1a0f00e 	mov	pc, lr

33d18504 <env_init>:
	if (gd->env_valid == 1)
		env_ptr = tmp_env1;
	else if (gd->env_valid == 2)
		env_ptr = tmp_env2;
#else /* ENV_IS_EMBEDDED */
	gd->env_addr  = (ulong)&default_environment[0];
33d18504:	e59f3010 	ldr	r3, [pc, #16]	; 33d1851c <env_init+0x18>
	gd->env_valid = 1;
#endif /* ENV_IS_EMBEDDED */

	return (0);
}
33d18508:	e3a00000 	mov	r0, #0	; 0x0
	if (gd->env_valid == 1)
		env_ptr = tmp_env1;
	else if (gd->env_valid == 2)
		env_ptr = tmp_env2;
#else /* ENV_IS_EMBEDDED */
	gd->env_addr  = (ulong)&default_environment[0];
33d1850c:	e5883014 	str	r3, [r8, #20]
	gd->env_valid = 1;
33d18510:	e3a03001 	mov	r3, #1	; 0x1
33d18514:	e5883018 	str	r3, [r8, #24]
#endif /* ENV_IS_EMBEDDED */

	return (0);
}
33d18518:	e1a0f00e 	mov	pc, lr
33d1851c:	33d364a4 	.word	0x33d364a4

33d18520 <saveenv>:
	gd->env_valid = (gd->env_valid == 2 ? 1 : 2);
	return ret;
}
#else /* ! CFG_ENV_OFFSET_REDUND */
int saveenv(void)
{
33d18520:	e92d4070 	push	{r4, r5, r6, lr}
	ulong total;
	int ret = 0;

	puts ("Erasing Nand...");
33d18524:	e59f00a8 	ldr	r0, [pc, #168]	; 33d185d4 <saveenv+0xb4>
	gd->env_valid = (gd->env_valid == 2 ? 1 : 2);
	return ret;
}
#else /* ! CFG_ENV_OFFSET_REDUND */
int saveenv(void)
{
33d18528:	e24dd03c 	sub	sp, sp, #60	; 0x3c
{
	return info->block_isbad(info, ofs);
}

static inline int nand_erase(nand_info_t *info, ulong off, ulong size)
{
33d1852c:	e59f50a4 	ldr	r5, [pc, #164]	; 33d185d8 <saveenv+0xb8>
	ulong total;
	int ret = 0;

	puts ("Erasing Nand...");
33d18530:	ebfffa9d 	bl	33d16fac <puts>
}
#else /* ! CFG_ENV_OFFSET_REDUND */
int saveenv(void)
{
	ulong total;
	int ret = 0;
33d18534:	e3a04000 	mov	r4, #0	; 0x0
	struct erase_info instr;

	instr.mtd = info;
	instr.addr = off;
33d18538:	e3a03701 	mov	r3, #262144	; 0x40000
{
	return info->block_isbad(info, ofs);
}

static inline int nand_erase(nand_info_t *info, ulong off, ulong size)
{
33d1853c:	e3a06802 	mov	r6, #131072	; 0x20000
	struct erase_info instr;

	instr.mtd = info;
	instr.addr = off;
	instr.len = size;
	instr.callback = 0;
33d18540:	e58d402c 	str	r4, [sp, #44]
static inline int nand_erase(nand_info_t *info, ulong off, ulong size)
{
	struct erase_info instr;

	instr.mtd = info;
	instr.addr = off;
33d18544:	e58d3010 	str	r3, [sp, #16]

static inline int nand_erase(nand_info_t *info, ulong off, ulong size)
{
	struct erase_info instr;

	instr.mtd = info;
33d18548:	e58d500c 	str	r5, [sp, #12]
	instr.addr = off;
	instr.len = size;
33d1854c:	e58d6014 	str	r6, [sp, #20]
	instr.callback = 0;
33d18550:	e28d100c 	add	r1, sp, #12	; 0xc
33d18554:	e1a00005 	mov	r0, r5
33d18558:	e1a0e00f 	mov	lr, pc
33d1855c:	e595f100 	ldr	pc, [r5, #256]
{
	return info->block_isbad(info, ofs);
}

static inline int nand_erase(nand_info_t *info, ulong off, ulong size)
{
33d18560:	e1500004 	cmp	r0, r4

	puts ("Erasing Nand...");
	if (nand_erase(&nand_info[0], CFG_ENV_OFFSET, CFG_ENV_SIZE))
		return 1;
33d18564:	e3a02001 	mov	r2, #1	; 0x1

	puts ("Writing to Nand... ");
33d18568:	e59f006c 	ldr	r0, [pc, #108]	; 33d185dc <saveenv+0xbc>
33d1856c:	1a000015 	bne	33d185c8 <saveenv+0xa8>
33d18570:	ebfffa8d 	bl	33d16fac <puts>
{
	return info->read(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_write(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
33d18574:	e59f3064 	ldr	r3, [pc, #100]	; 33d185e0 <saveenv+0xc0>
33d18578:	e5932000 	ldr	r2, [r3]
	return info->write(info, ofs, *len, (size_t *)len, buf);
33d1857c:	e28d3008 	add	r3, sp, #8	; 0x8
33d18580:	e58d3000 	str	r3, [sp]
33d18584:	e58d2004 	str	r2, [sp, #4]
33d18588:	e1a03006 	mov	r3, r6
33d1858c:	e3a02000 	mov	r2, #0	; 0x0
33d18590:	e3a01701 	mov	r1, #262144	; 0x40000
	total = CFG_ENV_SIZE;
33d18594:	e58d6008 	str	r6, [sp, #8]
33d18598:	e1a00005 	mov	r0, r5
33d1859c:	e1a0e00f 	mov	lr, pc
33d185a0:	e595f110 	ldr	pc, [r5, #272]
	ret = nand_write(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
	if (ret || total != CFG_ENV_SIZE)
33d185a4:	e2504000 	subs	r4, r0, #0	; 0x0
		return 1;
33d185a8:	e3a02001 	mov	r2, #1	; 0x1
		return 1;

	puts ("Writing to Nand... ");
	total = CFG_ENV_SIZE;
	ret = nand_write(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
	if (ret || total != CFG_ENV_SIZE)
33d185ac:	1a000005 	bne	33d185c8 <saveenv+0xa8>
33d185b0:	e59d3008 	ldr	r3, [sp, #8]
33d185b4:	e3530802 	cmp	r3, #131072	; 0x20000
		return 1;

	puts ("done\n");
33d185b8:	e59f0024 	ldr	r0, [pc, #36]	; 33d185e4 <saveenv+0xc4>
		return 1;

	puts ("Writing to Nand... ");
	total = CFG_ENV_SIZE;
	ret = nand_write(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
	if (ret || total != CFG_ENV_SIZE)
33d185bc:	1a000001 	bne	33d185c8 <saveenv+0xa8>
		return 1;

	puts ("done\n");
33d185c0:	ebfffa79 	bl	33d16fac <puts>
	return ret;
33d185c4:	e1a02004 	mov	r2, r4
}
33d185c8:	e1a00002 	mov	r0, r2
33d185cc:	e28dd03c 	add	sp, sp, #60	; 0x3c
33d185d0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d185d4:	33d2cb88 	.word	0x33d2cb88
33d185d8:	33d39920 	.word	0x33d39920
33d185dc:	33d2cb98 	.word	0x33d2cb98
33d185e0:	33d60c68 	.word	0x33d60c68
33d185e4:	33d2a448 	.word	0x33d2a448

33d185e8 <use_default>:
}
#endif /* CFG_ENV_OFFSET_REDUND */

#if !defined(ENV_IS_EMBEDDED)
static void use_default()
{
33d185e8:	e92d4030 	push	{r4, r5, lr}
	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");

	if (default_environment_size > CFG_ENV_SIZE){
33d185ec:	e59f5068 	ldr	r5, [pc, #104]	; 33d1865c <use_default+0x74>
#endif /* CFG_ENV_OFFSET_REDUND */

#if !defined(ENV_IS_EMBEDDED)
static void use_default()
{
	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");
33d185f0:	e59f0068 	ldr	r0, [pc, #104]	; 33d18660 <use_default+0x78>
33d185f4:	ebfffa6c 	bl	33d16fac <puts>

	if (default_environment_size > CFG_ENV_SIZE){
33d185f8:	e5953000 	ldr	r3, [r5]
		puts ("*** Error - default environment is too large\n\n");
		return;
	}

	memset (env_ptr, 0, sizeof(env_t));
33d185fc:	e3a02802 	mov	r2, #131072	; 0x20000
#if !defined(ENV_IS_EMBEDDED)
static void use_default()
{
	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");

	if (default_environment_size > CFG_ENV_SIZE){
33d18600:	e1530002 	cmp	r3, r2
		puts ("*** Error - default environment is too large\n\n");
		return;
	}

	memset (env_ptr, 0, sizeof(env_t));
33d18604:	e59f4058 	ldr	r4, [pc, #88]	; 33d18664 <use_default+0x7c>
33d18608:	e3a01000 	mov	r1, #0	; 0x0
static void use_default()
{
	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");

	if (default_environment_size > CFG_ENV_SIZE){
		puts ("*** Error - default environment is too large\n\n");
33d1860c:	e59f0054 	ldr	r0, [pc, #84]	; 33d18668 <use_default+0x80>
#if !defined(ENV_IS_EMBEDDED)
static void use_default()
{
	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");

	if (default_environment_size > CFG_ENV_SIZE){
33d18610:	da000001 	ble	33d1861c <use_default+0x34>
			default_environment,
			default_environment_size);
	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
	gd->env_valid = 1;

}
33d18614:	e8bd4030 	pop	{r4, r5, lr}
static void use_default()
{
	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");

	if (default_environment_size > CFG_ENV_SIZE){
		puts ("*** Error - default environment is too large\n\n");
33d18618:	eafffa63 	b	33d16fac <puts>
		return;
	}

	memset (env_ptr, 0, sizeof(env_t));
33d1861c:	e5940000 	ldr	r0, [r4]
33d18620:	eb00075b 	bl	33d1a394 <memset>
	memcpy (env_ptr->data,
33d18624:	e5940000 	ldr	r0, [r4]
33d18628:	e5952000 	ldr	r2, [r5]
33d1862c:	e59f1038 	ldr	r1, [pc, #56]	; 33d1866c <use_default+0x84>
33d18630:	e2800004 	add	r0, r0, #4	; 0x4
33d18634:	eb00076a 	bl	33d1a3e4 <memcpy>
			default_environment,
			default_environment_size);
	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
33d18638:	e5944000 	ldr	r4, [r4]
33d1863c:	e3a00000 	mov	r0, #0	; 0x0
33d18640:	e2841004 	add	r1, r4, #4	; 0x4
33d18644:	e59f2024 	ldr	r2, [pc, #36]	; 33d18670 <use_default+0x88>
33d18648:	eb0005b2 	bl	33d19d18 <crc32>
	gd->env_valid = 1;
33d1864c:	e3a03001 	mov	r3, #1	; 0x1

	memset (env_ptr, 0, sizeof(env_t));
	memcpy (env_ptr->data,
			default_environment,
			default_environment_size);
	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
33d18650:	e5840000 	str	r0, [r4]
	gd->env_valid = 1;
33d18654:	e5883018 	str	r3, [r8, #24]

}
33d18658:	e8bd8030 	pop	{r4, r5, pc}
33d1865c:	33d364a0 	.word	0x33d364a0
33d18660:	33d2cbac 	.word	0x33d2cbac
33d18664:	33d60c68 	.word	0x33d60c68
33d18668:	33d2cbe8 	.word	0x33d2cbe8
33d1866c:	33d364a4 	.word	0x33d364a4
33d18670:	0001fffc 	.word	0x0001fffc

33d18674 <env_relocate_spec>:
/*
 * The legacy NAND code saved the environment in the first NAND device i.e.,
 * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
 */
void env_relocate_spec (void)
{
33d18674:	e92d4010 	push	{r4, lr}
33d18678:	e24dd00c 	sub	sp, sp, #12	; 0xc
#if !defined(ENV_IS_EMBEDDED)
	ulong total = CFG_ENV_SIZE;
33d1867c:	e28d200c 	add	r2, sp, #12	; 0xc
33d18680:	e3a03802 	mov	r3, #131072	; 0x20000
33d18684:	e5223004 	str	r3, [r2, #-4]!

extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
33d18688:	e59f4060 	ldr	r4, [pc, #96]	; 33d186f0 <env_relocate_spec+0x7c>
33d1868c:	e59fc060 	ldr	ip, [pc, #96]	; 33d186f4 <env_relocate_spec+0x80>
33d18690:	e5941000 	ldr	r1, [r4]
	return info->read(info, ofs, *len, (size_t *)len, buf);
33d18694:	e58d2000 	str	r2, [sp]
33d18698:	e58d1004 	str	r1, [sp, #4]
33d1869c:	e1a0000c 	mov	r0, ip
33d186a0:	e3a02000 	mov	r2, #0	; 0x0
33d186a4:	e3a01701 	mov	r1, #262144	; 0x40000
33d186a8:	e1a0e00f 	mov	lr, pc
33d186ac:	e59cf10c 	ldr	pc, [ip, #268]
    ret = nand_read_opts(&nand_info[0], &opts);

#else
	ret = nand_read(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
#endif
  	if (ret || total != CFG_ENV_SIZE)
33d186b0:	e3500000 	cmp	r0, #0	; 0x0
33d186b4:	1a00000a 	bne	33d186e4 <env_relocate_spec+0x70>
33d186b8:	e59d3008 	ldr	r3, [sp, #8]
33d186bc:	e3530802 	cmp	r3, #131072	; 0x20000
		return use_default();

	if (crc32(0, env_ptr->data, ENV_SIZE) != env_ptr->crc)
33d186c0:	e59f2030 	ldr	r2, [pc, #48]	; 33d186f8 <env_relocate_spec+0x84>
    ret = nand_read_opts(&nand_info[0], &opts);

#else
	ret = nand_read(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
#endif
  	if (ret || total != CFG_ENV_SIZE)
33d186c4:	1a000006 	bne	33d186e4 <env_relocate_spec+0x70>
		return use_default();

	if (crc32(0, env_ptr->data, ENV_SIZE) != env_ptr->crc)
33d186c8:	e5941000 	ldr	r1, [r4]
33d186cc:	e2811004 	add	r1, r1, #4	; 0x4
33d186d0:	eb000590 	bl	33d19d18 <crc32>
33d186d4:	e5943000 	ldr	r3, [r4]
33d186d8:	e5933000 	ldr	r3, [r3]
33d186dc:	e1500003 	cmp	r0, r3
33d186e0:	0a000000 	beq	33d186e8 <env_relocate_spec+0x74>
		return use_default();
33d186e4:	ebffffbf 	bl	33d185e8 <use_default>
#endif /* ! ENV_IS_EMBEDDED */
}
33d186e8:	e28dd00c 	add	sp, sp, #12	; 0xc
33d186ec:	e8bd8010 	pop	{r4, pc}
33d186f0:	33d60c68 	.word	0x33d60c68
33d186f4:	33d39920 	.word	0x33d39920
33d186f8:	0001fffc 	.word	0x0001fffc

33d186fc <dummy>:
#include <exports.h>

DECLARE_GLOBAL_DATA_PTR;

static void dummy(void)
{
33d186fc:	e1a0f00e 	mov	pc, lr

33d18700 <get_version>:
}

unsigned long get_version(void)
{
	return XF_VERSION;
}
33d18700:	e3a00003 	mov	r0, #3	; 0x3
33d18704:	e1a0f00e 	mov	pc, lr

33d18708 <jumptable_init>:

void jumptable_init (void)
{
33d18708:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i;

	gd->jt = (void **) malloc (XF_MAX * sizeof (void *));
33d1870c:	e3a00044 	mov	r0, #68	; 0x44
33d18710:	ebfffbd4 	bl	33d17668 <malloc>
33d18714:	e5880020 	str	r0, [r8, #32]
	for (i = 0; i < XF_MAX; i++)
33d18718:	e3a01000 	mov	r1, #0	; 0x0
		gd->jt[i] = (void *) dummy;
33d1871c:	e5982020 	ldr	r2, [r8, #32]
33d18720:	e59f3070 	ldr	r3, [pc, #112]	; 33d18798 <jumptable_init+0x90>
33d18724:	e7823101 	str	r3, [r2, r1, lsl #2]
void jumptable_init (void)
{
	int i;

	gd->jt = (void **) malloc (XF_MAX * sizeof (void *));
	for (i = 0; i < XF_MAX; i++)
33d18728:	e2811001 	add	r1, r1, #1	; 0x1
33d1872c:	e3510010 	cmp	r1, #16	; 0x10
33d18730:	dafffff9 	ble	33d1871c <jumptable_init+0x14>
		gd->jt[i] = (void *) dummy;

	gd->jt[XF_get_version] = (void *) get_version;
33d18734:	e5982020 	ldr	r2, [r8, #32]
33d18738:	e59f305c 	ldr	r3, [pc, #92]	; 33d1879c <jumptable_init+0x94>
33d1873c:	e5823000 	str	r3, [r2]
	gd->jt[XF_malloc] = (void *) malloc;
33d18740:	e59f3058 	ldr	r3, [pc, #88]	; 33d187a0 <jumptable_init+0x98>
33d18744:	e5982020 	ldr	r2, [r8, #32]
33d18748:	e5823020 	str	r3, [r2, #32]
	gd->jt[XF_free] = (void *) free;
33d1874c:	e59f3050 	ldr	r3, [pc, #80]	; 33d187a4 <jumptable_init+0x9c>
33d18750:	e5982020 	ldr	r2, [r8, #32]
33d18754:	e5823024 	str	r3, [r2, #36]
	gd->jt[XF_getenv] = (void *) getenv;
33d18758:	e59f3048 	ldr	r3, [pc, #72]	; 33d187a8 <jumptable_init+0xa0>
33d1875c:	e5982020 	ldr	r2, [r8, #32]
33d18760:	e5823038 	str	r3, [r2, #56]
	gd->jt[XF_setenv] = (void *) setenv;
33d18764:	e59f3040 	ldr	r3, [pc, #64]	; 33d187ac <jumptable_init+0xa4>
33d18768:	e5982020 	ldr	r2, [r8, #32]
33d1876c:	e582303c 	str	r3, [r2, #60]
	gd->jt[XF_get_timer] = (void *) get_timer;
33d18770:	e59f3038 	ldr	r3, [pc, #56]	; 33d187b0 <jumptable_init+0xa8>
33d18774:	e5982020 	ldr	r2, [r8, #32]
33d18778:	e582302c 	str	r3, [r2, #44]
	gd->jt[XF_simple_strtoul] = (void *) simple_strtoul;
33d1877c:	e59f3030 	ldr	r3, [pc, #48]	; 33d187b4 <jumptable_init+0xac>
33d18780:	e5982020 	ldr	r2, [r8, #32]
33d18784:	e5823040 	str	r3, [r2, #64]
	gd->jt[XF_udelay] = (void *) udelay;
33d18788:	e59f3028 	ldr	r3, [pc, #40]	; 33d187b8 <jumptable_init+0xb0>
33d1878c:	e5982020 	ldr	r2, [r8, #32]
33d18790:	e5823028 	str	r3, [r2, #40]
33d18794:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d18798:	33d186fc 	.word	0x33d186fc
33d1879c:	33d18700 	.word	0x33d18700
33d187a0:	33d17668 	.word	0x33d17668
33d187a4:	33d17454 	.word	0x33d17454
33d187a8:	33d15850 	.word	0x33d15850
33d187ac:	33d157d8 	.word	0x33d157d8
33d187b0:	33d00de8 	.word	0x33d00de8
33d187b4:	33d1a55c 	.word	0x33d1a55c
33d187b8:	33d00e0c 	.word	0x33d00e0c

33d187bc <flash_protect>:
 * The monitor is always located in the _first_ Flash bank.
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
33d187bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong b_end = info->start[0] + info->size - 1;	/* bank end address */
	short s_end = info->sector_count - 1;	/* index of last sector */
33d187c0:	e1d350b4 	ldrh	r5, [r3, #4]
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
	ulong b_end = info->start[0] + info->size - 1;	/* bank end address */
33d187c4:	e593700c 	ldr	r7, [r3, #12]
33d187c8:	e5934000 	ldr	r4, [r3]
 * The monitor is always located in the _first_ Flash bank.
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
33d187cc:	e1a0e003 	mov	lr, r3
	ulong b_end = info->start[0] + info->size - 1;	/* bank end address */
	short s_end = info->sector_count - 1;	/* index of last sector */
33d187d0:	e2453001 	sub	r3, r5, #1	; 0x1
33d187d4:	e1a03803 	lsl	r3, r3, #16
 * The monitor is always located in the _first_ Flash bank.
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
33d187d8:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong b_end = info->start[0] + info->size - 1;	/* bank end address */
33d187dc:	e087c004 	add	ip, r7, r4
	short s_end = info->sector_count - 1;	/* index of last sector */
33d187e0:	e1a03823 	lsr	r3, r3, #16
		(flag & FLAG_PROTECT_SET) ? "ON" :
			(flag & FLAG_PROTECT_CLEAR) ? "OFF" : "???",
		from, to);

	/* Do nothing if input data is bad. */
	if (info->sector_count == 0 || info->size == 0 || to < from) {
33d187e4:	e255a000 	subs	sl, r5, #0	; 0x0
 * The monitor is always located in the _first_ Flash bank.
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
33d187e8:	e1a0b000 	mov	fp, r0
33d187ec:	e1a06001 	mov	r6, r1
33d187f0:	e1a00002 	mov	r0, r2
	ulong b_end = info->start[0] + info->size - 1;	/* bank end address */
33d187f4:	e24c9001 	sub	r9, ip, #1	; 0x1
	short s_end = info->sector_count - 1;	/* index of last sector */
33d187f8:	e58d3000 	str	r3, [sp]
		(flag & FLAG_PROTECT_SET) ? "ON" :
			(flag & FLAG_PROTECT_CLEAR) ? "OFF" : "???",
		from, to);

	/* Do nothing if input data is bad. */
	if (info->sector_count == 0 || info->size == 0 || to < from) {
33d187fc:	0a00002d 	beq	33d188b8 <flash_protect+0xfc>
33d18800:	e1520001 	cmp	r2, r1
33d18804:	23a03000 	movcs	r3, #0	; 0x0
33d18808:	33a03001 	movcc	r3, #1	; 0x1
33d1880c:	e3540000 	cmp	r4, #0	; 0x0
33d18810:	03833001 	orreq	r3, r3, #1	; 0x1
33d18814:	e3530000 	cmp	r3, #0	; 0x0
33d18818:	1a000026 	bne	33d188b8 <flash_protect+0xfc>
	}

	/* There is nothing to do if we have no data about the flash
	 * or the protect range and flash range don't overlap.
	 */
	if (info->flash_id == FLASH_UNKNOWN ||
33d1881c:	e59e2008 	ldr	r2, [lr, #8]
33d18820:	e59f3098 	ldr	r3, [pc, #152]	; 33d188c0 <flash_protect+0x104>
33d18824:	e1520003 	cmp	r2, r3
33d18828:	0a000022 	beq	33d188b8 <flash_protect+0xfc>
33d1882c:	e1510009 	cmp	r1, r9
33d18830:	93a03000 	movls	r3, #0	; 0x0
33d18834:	83a03001 	movhi	r3, #1	; 0x1
33d18838:	e1500007 	cmp	r0, r7
33d1883c:	21a0c003 	movcs	ip, r3
33d18840:	3383c001 	orrcc	ip, r3, #1	; 0x1
33d18844:	e35c0000 	cmp	ip, #0	; 0x0
33d18848:	1a00001a 	bne	33d188b8 <flash_protect+0xfc>
	    to < info->start[0] || from > b_end) {
		return;
	}

	for (i=0; i<info->sector_count; ++i) {
33d1884c:	e15c000a 	cmp	ip, sl
33d18850:	aa000018 	bge	33d188b8 <flash_protect+0xfc>
33d18854:	e28e100c 	add	r1, lr, #12	; 0xc
		ulong end;		/* last address in current sect	*/

		end = (i == s_end) ? b_end : info->start[i + 1] - 1;
33d18858:	e59d2000 	ldr	r2, [sp]
33d1885c:	e1a03802 	lsl	r3, r2, #16
33d18860:	e15c0843 	cmp	ip, r3, asr #16
33d18864:	e1a03009 	mov	r3, r9
33d18868:	15913004 	ldrne	r3, [r1, #4]
33d1886c:	12433001 	subne	r3, r3, #1	; 0x1

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
33d18870:	e1560003 	cmp	r6, r3
33d18874:	8a00000b 	bhi	33d188a8 <flash_protect+0xec>
33d18878:	e5913000 	ldr	r3, [r1]
33d1887c:	e1500003 	cmp	r0, r3
33d18880:	3a000008 	bcc	33d188a8 <flash_protect+0xec>
			if (flag & FLAG_PROTECT_CLEAR) {
33d18884:	e31b0002 	tst	fp, #2	; 0x2
#if defined(CFG_FLASH_PROTECTION)
				flash_real_protect(info, i, 0);
#else
				info->protect[i] = 0;
33d18888:	e08c200e 	add	r2, ip, lr
33d1888c:	13a03000 	movne	r3, #0	; 0x0

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
			if (flag & FLAG_PROTECT_CLEAR) {
33d18890:	1a000003 	bne	33d188a4 <flash_protect+0xe8>
#else
				info->protect[i] = 0;
#endif	/* CFG_FLASH_PROTECTION */
				debug ("protect off %d\n", i);
			}
			else if (flag & FLAG_PROTECT_SET) {
33d18894:	e31b0001 	tst	fp, #1	; 0x1
#if defined(CFG_FLASH_PROTECTION)
				flash_real_protect(info, i, 1);
#else
				info->protect[i] = 1;
33d18898:	e08c200e 	add	r2, ip, lr
#else
				info->protect[i] = 0;
#endif	/* CFG_FLASH_PROTECTION */
				debug ("protect off %d\n", i);
			}
			else if (flag & FLAG_PROTECT_SET) {
33d1889c:	0a000001 	beq	33d188a8 <flash_protect+0xec>
#if defined(CFG_FLASH_PROTECTION)
				flash_real_protect(info, i, 1);
#else
				info->protect[i] = 1;
33d188a0:	e3a03001 	mov	r3, #1	; 0x1
33d188a4:	e5c23058 	strb	r3, [r2, #88]
	if (info->flash_id == FLASH_UNKNOWN ||
	    to < info->start[0] || from > b_end) {
		return;
	}

	for (i=0; i<info->sector_count; ++i) {
33d188a8:	e28cc001 	add	ip, ip, #1	; 0x1
33d188ac:	e15c0005 	cmp	ip, r5
33d188b0:	e2811004 	add	r1, r1, #4	; 0x4
33d188b4:	baffffe7 	blt	33d18858 <flash_protect+0x9c>
#endif	/* CFG_FLASH_PROTECTION */
				debug ("protect on %d\n", i);
			}
		}
	}
}
33d188b8:	e28dd004 	add	sp, sp, #4	; 0x4
33d188bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d188c0:	0000ffff 	.word	0x0000ffff

33d188c4 <addr2info>:
{
#ifndef CONFIG_SPD823TS
	flash_info_t *info;
	int i;

	for (i=0, info=&flash_info[0]; i<CFG_MAX_FLASH_BANKS; ++i, ++info) {
33d188c4:	e59f1038 	ldr	r1, [pc, #56]	; 33d18904 <addr2info+0x40>
		if (info->flash_id != FLASH_UNKNOWN &&
33d188c8:	e59f3038 	ldr	r3, [pc, #56]	; 33d18908 <addr2info+0x44>
33d188cc:	e5912008 	ldr	r2, [r1, #8]
33d188d0:	e1520003 	cmp	r2, r3
33d188d4:	0a000008 	beq	33d188fc <addr2info+0x38>
33d188d8:	e591200c 	ldr	r2, [r1, #12]
33d188dc:	e1500002 	cmp	r0, r2
33d188e0:	3a000005 	bcc	33d188fc <addr2info+0x38>
33d188e4:	e5913000 	ldr	r3, [r1]
33d188e8:	e0823003 	add	r3, r2, r3
33d188ec:	e2433001 	sub	r3, r3, #1	; 0x1
33d188f0:	e1500003 	cmp	r0, r3
		     * is at the end of the address space, since
		     * info->start[0] + info->size wraps back to 0.
		     * Please don't change this unless you understand this.
		     */
		    addr <= info->start[0] + info->size - 1) {
			return (info);
33d188f4:	e1a00001 	mov	r0, r1
#ifndef CONFIG_SPD823TS
	flash_info_t *info;
	int i;

	for (i=0, info=&flash_info[0]; i<CFG_MAX_FLASH_BANKS; ++i, ++info) {
		if (info->flash_id != FLASH_UNKNOWN &&
33d188f8:	91a0f00e 	movls	pc, lr
			return (info);
		}
	}
#endif /* CONFIG_SPD823TS */

	return (NULL);
33d188fc:	e3a00000 	mov	r0, #0	; 0x0
}
33d18900:	e1a0f00e 	mov	pc, lr
33d18904:	33d62554 	.word	0x33d62554
33d18908:	0000ffff 	.word	0x0000ffff

33d1890c <flash_write>:
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
33d1890c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
33d18910:	e0813002 	add	r3, r1, r2
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
33d18914:	e24dd00c 	sub	sp, sp, #12	; 0xc
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
33d18918:	e2433001 	sub	r3, r3, #1	; 0x1
33d1891c:	e58d3008 	str	r3, [sp, #8]
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
33d18920:	e1a0b000 	mov	fp, r0
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
33d18924:	e1a00001 	mov	r0, r1
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
33d18928:	e1a06002 	mov	r6, r2
33d1892c:	e1a07001 	mov	r7, r1
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
33d18930:	ebffffe3 	bl	33d188c4 <addr2info>
33d18934:	e1a09000 	mov	r9, r0
	flash_info_t *info_last  = addr2info (end );
33d18938:	e59d0008 	ldr	r0, [sp, #8]
33d1893c:	ebffffe0 	bl	33d188c4 <addr2info>
	flash_info_t *info;

	if (cnt == 0) {
33d18940:	e3560000 	cmp	r6, #0	; 0x0
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
	flash_info_t *info_last  = addr2info (end );
33d18944:	e1a0a000 	mov	sl, r0
	flash_info_t *info;

	if (cnt == 0) {
		return (ERR_OK);
33d18948:	01a00006 	moveq	r0, r6
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
	flash_info_t *info_last  = addr2info (end );
	flash_info_t *info;

	if (cnt == 0) {
33d1894c:	0a00004e 	beq	33d18a8c <flash_write+0x180>
		return (ERR_OK);
	}

	if (!info_first || !info_last) {
33d18950:	e35a0000 	cmp	sl, #0	; 0x0
33d18954:	13590000 	cmpne	r9, #0	; 0x0
		return (ERR_INVAL);
33d18958:	03a00008 	moveq	r0, #8	; 0x8

	if (cnt == 0) {
		return (ERR_OK);
	}

	if (!info_first || !info_last) {
33d1895c:	0a00004a 	beq	33d18a8c <flash_write+0x180>
33d18960:	ea000001 	b	33d1896c <flash_write+0x60>
		for (i=0; i<info->sector_count; ++i) {
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];

			if ((end >= info->start[i]) && (addr < e_addr) &&
			    (info->protect[i] != 0) ) {
				return (ERR_PROTECTED);
33d18964:	e3a00004 	mov	r0, #4	; 0x4
33d18968:	ea000047 	b	33d18a8c <flash_write+0x180>

	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
33d1896c:	e1a05009 	mov	r5, r9
33d18970:	e155000a 	cmp	r5, sl
33d18974:	8a000024 	bhi	33d18a0c <flash_write+0x100>
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
33d18978:	e1d540b4 	ldrh	r4, [r5, #4]
	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
33d1897c:	e595100c 	ldr	r1, [r5, #12]
33d18980:	e5952000 	ldr	r2, [r5]
		short s_end = info->sector_count - 1;
33d18984:	e2443001 	sub	r3, r4, #1	; 0x1
		for (i=0; i<info->sector_count; ++i) {
33d18988:	e3a00000 	mov	r0, #0	; 0x0
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
33d1898c:	e1a03803 	lsl	r3, r3, #16
	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
33d18990:	e0811002 	add	r1, r1, r2
		short s_end = info->sector_count - 1;
33d18994:	e1a03823 	lsr	r3, r3, #16
		for (i=0; i<info->sector_count; ++i) {
33d18998:	e1500004 	cmp	r0, r4
	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
33d1899c:	e58d1004 	str	r1, [sp, #4]
		short s_end = info->sector_count - 1;
33d189a0:	e58d3000 	str	r3, [sp]
		for (i=0; i<info->sector_count; ++i) {
33d189a4:	aa000016 	bge	33d18a04 <flash_write+0xf8>
33d189a8:	e285200c 	add	r2, r5, #12	; 0xc
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
33d189ac:	e59d1000 	ldr	r1, [sp]
33d189b0:	e1a03801 	lsl	r3, r1, #16
33d189b4:	e1500843 	cmp	r0, r3, asr #16
33d189b8:	e59dc004 	ldr	ip, [sp, #4]

			if ((end >= info->start[i]) && (addr < e_addr) &&
33d189bc:	e5923000 	ldr	r3, [r2]

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
		for (i=0; i<info->sector_count; ++i) {
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
33d189c0:	1592c004 	ldrne	ip, [r2, #4]

			if ((end >= info->start[i]) && (addr < e_addr) &&
33d189c4:	e59d1008 	ldr	r1, [sp, #8]
33d189c8:	e1510003 	cmp	r1, r3
33d189cc:	33a03000 	movcc	r3, #0	; 0x0
33d189d0:	23a03001 	movcs	r3, #1	; 0x1
33d189d4:	e157000c 	cmp	r7, ip
33d189d8:	23a03000 	movcs	r3, #0	; 0x0
33d189dc:	e3530000 	cmp	r3, #0	; 0x0
33d189e0:	e080e005 	add	lr, r0, r5
33d189e4:	e2822004 	add	r2, r2, #4	; 0x4
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
		for (i=0; i<info->sector_count; ++i) {
33d189e8:	e2800001 	add	r0, r0, #1	; 0x1
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];

			if ((end >= info->start[i]) && (addr < e_addr) &&
33d189ec:	0a000002 	beq	33d189fc <flash_write+0xf0>
33d189f0:	e5de3058 	ldrb	r3, [lr, #88]
33d189f4:	e3530000 	cmp	r3, #0	; 0x0
33d189f8:	1affffd9 	bne	33d18964 <flash_write+0x58>
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
		for (i=0; i<info->sector_count; ++i) {
33d189fc:	e1500004 	cmp	r0, r4
33d18a00:	baffffe9 	blt	33d189ac <flash_write+0xa0>

	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
33d18a04:	e285506c 	add	r5, r5, #108	; 0x6c
33d18a08:	eaffffd8 	b	33d18970 <flash_write+0x64>
			}
		}
	}

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
33d18a0c:	e159000a 	cmp	r9, sl
33d18a10:	83a03000 	movhi	r3, #0	; 0x0
33d18a14:	93a03001 	movls	r3, #1	; 0x1
33d18a18:	e3560000 	cmp	r6, #0	; 0x0
33d18a1c:	e1a05009 	mov	r5, r9
33d18a20:	03a03000 	moveq	r3, #0	; 0x0
33d18a24:	e3530000 	cmp	r3, #0	; 0x0
33d18a28:	0a000016 	beq	33d18a88 <flash_write+0x17c>
		ulong len;

		len = info->start[0] + info->size - addr;
33d18a2c:	e5952000 	ldr	r2, [r5]
33d18a30:	e595300c 	ldr	r3, [r5, #12]
33d18a34:	e0833002 	add	r3, r3, r2
33d18a38:	e0674003 	rsb	r4, r7, r3
		if (len > cnt)
			len = cnt;
33d18a3c:	e1540006 	cmp	r4, r6
33d18a40:	21a04006 	movcs	r4, r6
		if ((i = write_buff(info, (uchar *)src, addr, len)) != 0) {
33d18a44:	e1a00005 	mov	r0, r5
33d18a48:	e1a0100b 	mov	r1, fp
33d18a4c:	e1a02007 	mov	r2, r7
33d18a50:	e1a03004 	mov	r3, r4
33d18a54:	eb00155d 	bl	33d1dfd0 <write_buff>
33d18a58:	e3500000 	cmp	r0, #0	; 0x0
			}
		}
	}

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
33d18a5c:	e285506c 	add	r5, r5, #108	; 0x6c
			len = cnt;
		if ((i = write_buff(info, (uchar *)src, addr, len)) != 0) {
			return (i);
		}
		cnt  -= len;
		addr += len;
33d18a60:	e0877004 	add	r7, r7, r4
		src  += len;
33d18a64:	e08bb004 	add	fp, fp, r4
		ulong len;

		len = info->start[0] + info->size - addr;
		if (len > cnt)
			len = cnt;
		if ((i = write_buff(info, (uchar *)src, addr, len)) != 0) {
33d18a68:	1a000007 	bne	33d18a8c <flash_write+0x180>
			}
		}
	}

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
33d18a6c:	e0566004 	subs	r6, r6, r4
33d18a70:	03a03000 	moveq	r3, #0	; 0x0
33d18a74:	13a03001 	movne	r3, #1	; 0x1
33d18a78:	e155000a 	cmp	r5, sl
33d18a7c:	83a03000 	movhi	r3, #0	; 0x0
33d18a80:	92033001 	andls	r3, r3, #1	; 0x1
33d18a84:	eaffffe6 	b	33d18a24 <flash_write+0x118>
		}
		cnt  -= len;
		addr += len;
		src  += len;
	}
	return (ERR_OK);
33d18a88:	e3a00000 	mov	r0, #0	; 0x0
#endif /* CONFIG_SPD823TS */
}
33d18a8c:	e28dd00c 	add	sp, sp, #12	; 0xc
33d18a90:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d18a94 <flash_perror>:
/*-----------------------------------------------------------------------
 */

void flash_perror (int err)
{
	switch (err) {
33d18a94:	e3500008 	cmp	r0, #8	; 0x8
33d18a98:	0a00001c 	beq	33d18b10 <flash_perror+0x7c>
33d18a9c:	ca00000a 	bgt	33d18acc <flash_perror+0x38>
33d18aa0:	e3500001 	cmp	r0, #1	; 0x1
33d18aa4:	0a000013 	beq	33d18af8 <flash_perror+0x64>
33d18aa8:	ca000002 	bgt	33d18ab8 <flash_perror+0x24>
33d18aac:	e3500000 	cmp	r0, #0	; 0x0
33d18ab0:	01a0f00e 	moveq	pc, lr
33d18ab4:	ea00001f 	b	33d18b38 <flash_perror+0xa4>
33d18ab8:	e3500002 	cmp	r0, #2	; 0x2
33d18abc:	0a00000f 	beq	33d18b00 <flash_perror+0x6c>
33d18ac0:	e3500004 	cmp	r0, #4	; 0x4
33d18ac4:	0a00000f 	beq	33d18b08 <flash_perror+0x74>
33d18ac8:	ea00001a 	b	33d18b38 <flash_perror+0xa4>
33d18acc:	e3500020 	cmp	r0, #32	; 0x20
33d18ad0:	0a000012 	beq	33d18b20 <flash_perror+0x8c>
33d18ad4:	ca000002 	bgt	33d18ae4 <flash_perror+0x50>
33d18ad8:	e3500010 	cmp	r0, #16	; 0x10
33d18adc:	0a00000d 	beq	33d18b18 <flash_perror+0x84>
33d18ae0:	ea000014 	b	33d18b38 <flash_perror+0xa4>
33d18ae4:	e3500040 	cmp	r0, #64	; 0x40
33d18ae8:	0a00000e 	beq	33d18b28 <flash_perror+0x94>
33d18aec:	e3500080 	cmp	r0, #128	; 0x80
33d18af0:	0a00000e 	beq	33d18b30 <flash_perror+0x9c>
33d18af4:	ea00000f 	b	33d18b38 <flash_perror+0xa4>
	case ERR_OK:
		break;
	case ERR_TIMOUT:
		puts ("Timeout writing to Flash\n");
33d18af8:	e59f004c 	ldr	r0, [pc, #76]	; 33d18b4c <flash_perror+0xb8>
33d18afc:	ea00000c 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_NOT_ERASED:
		puts ("Flash not Erased\n");
33d18b00:	e59f0048 	ldr	r0, [pc, #72]	; 33d18b50 <flash_perror+0xbc>
33d18b04:	ea00000a 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_PROTECTED:
		puts ("Can't write to protected Flash sectors\n");
33d18b08:	e59f0044 	ldr	r0, [pc, #68]	; 33d18b54 <flash_perror+0xc0>
33d18b0c:	ea000008 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_INVAL:
		puts ("Outside available Flash\n");
33d18b10:	e59f0040 	ldr	r0, [pc, #64]	; 33d18b58 <flash_perror+0xc4>
33d18b14:	ea000006 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_ALIGN:
		puts ("Start and/or end address not on sector boundary\n");
33d18b18:	e59f003c 	ldr	r0, [pc, #60]	; 33d18b5c <flash_perror+0xc8>
33d18b1c:	ea000004 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_UNKNOWN_FLASH_VENDOR:
		puts ("Unknown Vendor of Flash\n");
33d18b20:	e59f0038 	ldr	r0, [pc, #56]	; 33d18b60 <flash_perror+0xcc>
33d18b24:	ea000002 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_UNKNOWN_FLASH_TYPE:
		puts ("Unknown Type of Flash\n");
33d18b28:	e59f0034 	ldr	r0, [pc, #52]	; 33d18b64 <flash_perror+0xd0>
33d18b2c:	ea000000 	b	33d18b34 <flash_perror+0xa0>
		break;
	case ERR_PROG_ERROR:
		puts ("General Flash Programming Error\n");
33d18b30:	e59f0030 	ldr	r0, [pc, #48]	; 33d18b68 <flash_perror+0xd4>
33d18b34:	eafff91c 	b	33d16fac <puts>
		break;
	default:
		printf ("%s[%d] FIXME: rc=%d\n", __FILE__, __LINE__, err);
33d18b38:	e1a03000 	mov	r3, r0
33d18b3c:	e59f1028 	ldr	r1, [pc, #40]	; 33d18b6c <flash_perror+0xd8>
33d18b40:	e59f0028 	ldr	r0, [pc, #40]	; 33d18b70 <flash_perror+0xdc>
33d18b44:	e3a020dd 	mov	r2, #221	; 0xdd
33d18b48:	eafff91e 	b	33d16fc8 <printf>
33d18b4c:	33d2cc18 	.word	0x33d2cc18
33d18b50:	33d2cc34 	.word	0x33d2cc34
33d18b54:	33d2cc48 	.word	0x33d2cc48
33d18b58:	33d2cc70 	.word	0x33d2cc70
33d18b5c:	33d2cc8c 	.word	0x33d2cc8c
33d18b60:	33d2ccc0 	.word	0x33d2ccc0
33d18b64:	33d2ccdc 	.word	0x33d2ccdc
33d18b68:	33d2ccf4 	.word	0x33d2ccf4
33d18b6c:	33d2cd18 	.word	0x33d2cd18
33d18b70:	33d2cd20 	.word	0x33d2cd20

33d18b74 <NewHandle>:
#define calloc(size,num)	malloc(size*num)

/********************************************************************/

Handle NewHandle (unsigned int numBytes)
{
33d18b74:	e92d4070 	push	{r4, r5, r6, lr}
33d18b78:	e1a06000 	mov	r6, r0
	void *memPtr;
	HandleRecord *hanPtr;

	memPtr = calloc (numBytes, 1);
33d18b7c:	ebfffab9 	bl	33d17668 <malloc>
33d18b80:	e1a05000 	mov	r5, r0
	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
33d18b84:	e3a00008 	mov	r0, #8	; 0x8
33d18b88:	ebfffab6 	bl	33d17668 <malloc>
	if (hanPtr && (memPtr || numBytes == 0)) {
33d18b8c:	e2504000 	subs	r4, r0, #0	; 0x0
		hanPtr->ptr = memPtr;
		hanPtr->size = numBytes;
		return (Handle) hanPtr;
	} else {
		free (memPtr);
33d18b90:	e1a00005 	mov	r0, r5
	void *memPtr;
	HandleRecord *hanPtr;

	memPtr = calloc (numBytes, 1);
	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
	if (hanPtr && (memPtr || numBytes == 0)) {
33d18b94:	0a000008 	beq	33d18bbc <NewHandle+0x48>
33d18b98:	e2763001 	rsbs	r3, r6, #1	; 0x1
33d18b9c:	33a03000 	movcc	r3, #0	; 0x0
33d18ba0:	e3550000 	cmp	r5, #0	; 0x0
33d18ba4:	13833001 	orrne	r3, r3, #1	; 0x1
33d18ba8:	e3530000 	cmp	r3, #0	; 0x0
		hanPtr->ptr = memPtr;
33d18bac:	15845000 	strne	r5, [r4]
		hanPtr->size = numBytes;
		return (Handle) hanPtr;
33d18bb0:	e1a03004 	mov	r3, r4

	memPtr = calloc (numBytes, 1);
	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
	if (hanPtr && (memPtr || numBytes == 0)) {
		hanPtr->ptr = memPtr;
		hanPtr->size = numBytes;
33d18bb4:	15846004 	strne	r6, [r4, #4]
	void *memPtr;
	HandleRecord *hanPtr;

	memPtr = calloc (numBytes, 1);
	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
	if (hanPtr && (memPtr || numBytes == 0)) {
33d18bb8:	1a000003 	bne	33d18bcc <NewHandle+0x58>
		hanPtr->ptr = memPtr;
		hanPtr->size = numBytes;
		return (Handle) hanPtr;
	} else {
		free (memPtr);
33d18bbc:	ebfffa24 	bl	33d17454 <free>
		free (hanPtr);
33d18bc0:	e1a00004 	mov	r0, r4
33d18bc4:	ebfffa22 	bl	33d17454 <free>
		return NULL;
33d18bc8:	e3a03000 	mov	r3, #0	; 0x0
	}
}
33d18bcc:	e1a00003 	mov	r0, r3
33d18bd0:	e8bd8070 	pop	{r4, r5, r6, pc}

33d18bd4 <DisposeHandle>:
/********************************************************************/

void DisposeHandle (Handle handle)
{
33d18bd4:	e92d4010 	push	{r4, lr}
	if (handle) {
33d18bd8:	e2504000 	subs	r4, r0, #0	; 0x0
33d18bdc:	08bd8010 	popeq	{r4, pc}
		free (*handle);
33d18be0:	e5940000 	ldr	r0, [r4]
33d18be4:	ebfffa1a 	bl	33d17454 <free>
		free ((void *) handle);
33d18be8:	e1a00004 	mov	r0, r4
	}
}
33d18bec:	e8bd4010 	pop	{r4, lr}

void DisposeHandle (Handle handle)
{
	if (handle) {
		free (*handle);
		free ((void *) handle);
33d18bf0:	eafffa17 	b	33d17454 <free>

33d18bf4 <GetHandleSize>:
/********************************************************************/

unsigned int GetHandleSize (Handle handle)
{
	return ((HandleRecord *) handle)->size;
}
33d18bf4:	e5900004 	ldr	r0, [r0, #4]
33d18bf8:	e1a0f00e 	mov	pc, lr

33d18bfc <SetHandleSize>:
/********************************************************************/

int SetHandleSize (Handle handle, unsigned int newSize)
{
33d18bfc:	e92d4070 	push	{r4, r5, r6, lr}
	void *newPtr, *oldPtr;
	unsigned int oldSize;


	oldPtr = hanRecPtr->ptr;
	oldSize = hanRecPtr->size;
33d18c00:	e5906004 	ldr	r6, [r0, #4]

	if (oldSize == newSize)
33d18c04:	e1560001 	cmp	r6, r1
	return ((HandleRecord *) handle)->size;
}
/********************************************************************/

int SetHandleSize (Handle handle, unsigned int newSize)
{
33d18c08:	e1a05000 	mov	r5, r0
33d18c0c:	e1a04001 	mov	r4, r1
	HandleRecord *hanRecPtr = (HandleRecord *) handle;
	void *newPtr, *oldPtr;
	unsigned int oldSize;


	oldPtr = hanRecPtr->ptr;
33d18c10:	e5900000 	ldr	r0, [r0]
	oldSize = hanRecPtr->size;

	if (oldSize == newSize)
33d18c14:	0a000012 	beq	33d18c64 <SetHandleSize+0x68>
		return 1;

	if (oldPtr == NULL) {
33d18c18:	e3500000 	cmp	r0, #0	; 0x0
33d18c1c:	1a000002 	bne	33d18c2c <SetHandleSize+0x30>
		newPtr = malloc (newSize);
33d18c20:	e1a00001 	mov	r0, r1
33d18c24:	ebfffa8f 	bl	33d17668 <malloc>
33d18c28:	ea000000 	b	33d18c30 <SetHandleSize+0x34>
	} else {
		newPtr = realloc (oldPtr, newSize);
33d18c2c:	ebfffc1e 	bl	33d17cac <realloc>
	}
	if (newPtr || (newSize == 0)) {
33d18c30:	e2743001 	rsbs	r3, r4, #1	; 0x1
33d18c34:	33a03000 	movcc	r3, #0	; 0x0
33d18c38:	e3500000 	cmp	r0, #0	; 0x0
33d18c3c:	13833001 	orrne	r3, r3, #1	; 0x1
33d18c40:	e3530000 	cmp	r3, #0	; 0x0
		hanRecPtr->size = newSize;
		if (newSize > oldSize)
			memset ((char *) newPtr + oldSize, 0, newSize - oldSize);
		return 1;
	} else
		return 0;
33d18c44:	01a00003 	moveq	r0, r3
	if (oldPtr == NULL) {
		newPtr = malloc (newSize);
	} else {
		newPtr = realloc (oldPtr, newSize);
	}
	if (newPtr || (newSize == 0)) {
33d18c48:	08bd8070 	popeq	{r4, r5, r6, pc}
		hanRecPtr->ptr = newPtr;
		hanRecPtr->size = newSize;
		if (newSize > oldSize)
33d18c4c:	e1540006 	cmp	r4, r6
	} else {
		newPtr = realloc (oldPtr, newSize);
	}
	if (newPtr || (newSize == 0)) {
		hanRecPtr->ptr = newPtr;
		hanRecPtr->size = newSize;
33d18c50:	e8850011 	stm	r5, {r0, r4}
		if (newSize > oldSize)
			memset ((char *) newPtr + oldSize, 0, newSize - oldSize);
33d18c54:	80662004 	rsbhi	r2, r6, r4
33d18c58:	80800006 	addhi	r0, r0, r6
33d18c5c:	83a01000 	movhi	r1, #0	; 0x0
33d18c60:	8b0005cb 	blhi	33d1a394 <memset>
		return 1;
33d18c64:	e3a00001 	mov	r0, #1	; 0x1
33d18c68:	e8bd8070 	pop	{r4, r5, r6, pc}

33d18c6c <ListCreate>:
#endif	/* CFG_ALL_LIST_FUNCTIONS */

/*******************************/

list_t ListCreate (int elementSize)
{
33d18c6c:	e92d4010 	push	{r4, lr}
33d18c70:	e1a04000 	mov	r4, r0
	list_t list;

	list = (list_t) (NewHandle (sizeof (ListStruct)));  /* create empty list */
33d18c74:	e3a0001c 	mov	r0, #28	; 0x1c
33d18c78:	ebffffbd 	bl	33d18b74 <NewHandle>
	if (list) {
33d18c7c:	e2501000 	subs	r1, r0, #0	; 0x0
		(*list)->signature = LIST_SIGNATURE;
		(*list)->numItems = 0;
33d18c80:	e3a0c000 	mov	ip, #0	; 0x0
list_t ListCreate (int elementSize)
{
	list_t list;

	list = (list_t) (NewHandle (sizeof (ListStruct)));  /* create empty list */
	if (list) {
33d18c84:	08bd8010 	popeq	{r4, pc}
		(*list)->signature = LIST_SIGNATURE;
33d18c88:	e5912000 	ldr	r2, [r1]
33d18c8c:	e59f3034 	ldr	r3, [pc, #52]	; 33d18cc8 <ListCreate+0x5c>
33d18c90:	e5823000 	str	r3, [r2]
		(*list)->numItems = 0;
33d18c94:	e5913000 	ldr	r3, [r1]
33d18c98:	e583c014 	str	ip, [r3, #20]
		(*list)->listSize = 0;
33d18c9c:	e5913000 	ldr	r3, [r1]
33d18ca0:	e583c00c 	str	ip, [r3, #12]
		(*list)->itemSize = elementSize;
33d18ca4:	e5913000 	ldr	r3, [r1]
33d18ca8:	e5834010 	str	r4, [r3, #16]
		(*list)->percentIncrease = kDefaultAllocationPercentIncrease;
33d18cac:	e5912000 	ldr	r2, [r1]
33d18cb0:	e3a0300a 	mov	r3, #10	; 0xa
33d18cb4:	e5823004 	str	r3, [r2, #4]
		(*list)->minNumItemsIncrease =
33d18cb8:	e5912000 	ldr	r2, [r1]
33d18cbc:	e2433006 	sub	r3, r3, #6	; 0x6
33d18cc0:	e5823008 	str	r3, [r2, #8]
				kDefaultAllocationminNumItemsIncrease;
	}

	return list;
}
33d18cc4:	e8bd8010 	pop	{r4, pc}
33d18cc8:	4c495354 	.word	0x4c495354

33d18ccc <ListSetAllocationPolicy>:
/*******************************/

void ListSetAllocationPolicy (list_t list, int minItemsPerAlloc,
			      int percentIncreasePerAlloc)
{
	(*list)->percentIncrease = percentIncreasePerAlloc;
33d18ccc:	e5903000 	ldr	r3, [r0]
33d18cd0:	e5832004 	str	r2, [r3, #4]
	(*list)->minNumItemsIncrease = minItemsPerAlloc;
33d18cd4:	e5903000 	ldr	r3, [r0]
33d18cd8:	e5831008 	str	r1, [r3, #8]
33d18cdc:	e1a0f00e 	mov	pc, lr

33d18ce0 <ListDispose>:

/*******************************/

void ListDispose (list_t list)
{
	DisposeHandle ((Handle) list);
33d18ce0:	eaffffbb 	b	33d18bd4 <DisposeHandle>

33d18ce4 <ListInsertItems>:

/*******************************/

int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
		     int numItemsToInsert)
{
33d18ce4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int numItems = (*list)->numItems;
33d18ce8:	e5904000 	ldr	r4, [r0]
33d18cec:	e5949014 	ldr	r9, [r4, #20]

/*******************************/

int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
		     int numItemsToInsert)
{
33d18cf0:	e1a06002 	mov	r6, r2
	int numItems = (*list)->numItems;

	if (firstItemPosition == numItems + 1)
33d18cf4:	e2892001 	add	r2, r9, #1	; 0x1
33d18cf8:	e1560002 	cmp	r6, r2

/*******************************/

int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
		     int numItemsToInsert)
{
33d18cfc:	e1a0a000 	mov	sl, r0
33d18d00:	e1a0b001 	mov	fp, r1
33d18d04:	e1a07003 	mov	r7, r3
	int numItems = (*list)->numItems;

	if (firstItemPosition == numItems + 1)
		firstItemPosition = LIST_END;
33d18d08:	03a06000 	moveq	r6, #0	; 0x0
int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
		     int numItemsToInsert)
{
	int numItems = (*list)->numItems;

	if (firstItemPosition == numItems + 1)
33d18d0c:	0a000002 	beq	33d18d1c <ListInsertItems+0x38>
		firstItemPosition = LIST_END;
	else if (firstItemPosition > numItems)
33d18d10:	e1560009 	cmp	r6, r9
		return 0;
33d18d14:	c3a00000 	movgt	r0, #0	; 0x0
{
	int numItems = (*list)->numItems;

	if (firstItemPosition == numItems + 1)
		firstItemPosition = LIST_END;
	else if (firstItemPosition > numItems)
33d18d18:	c8bd8ef0 	popgt	{r4, r5, r6, r7, r9, sl, fp, pc}
		return 0;

	if ((*list)->numItems >= (*list)->listSize) {
33d18d1c:	e5943014 	ldr	r3, [r4, #20]
33d18d20:	e594200c 	ldr	r2, [r4, #12]
33d18d24:	e1530002 	cmp	r3, r2
33d18d28:	ba000023 	blt	33d18dbc <ListInsertItems+0xd8>
 * numNewItems plus the number of items indicated by its allocation
 * policy.
 * Returns 1 for success, 0 if out of memory
*/
static int ExpandListSpace (list_t list, int numNewItems)
{
33d18d2c:	e2675000 	rsb	r5, r7, #0	; 0x0
	if (numNewItems == 0) {
33d18d30:	e3550000 	cmp	r5, #0	; 0x0
33d18d34:	1a000009 	bne	33d18d60 <ListInsertItems+0x7c>
		numNewItems = NUMITEMSPERALLOC (list);
33d18d38:	e5943004 	ldr	r3, [r4, #4]
33d18d3c:	e2833064 	add	r3, r3, #100	; 0x64
33d18d40:	e0000293 	mul	r0, r3, r2
33d18d44:	e3a01064 	mov	r1, #100	; 0x64
33d18d48:	eb001644 	bl	33d1e660 <__divsi3>
33d18d4c:	e5943008 	ldr	r3, [r4, #8]
33d18d50:	e1530000 	cmp	r3, r0
33d18d54:	a1a05003 	movge	r5, r3
33d18d58:	b1a05000 	movlt	r5, r0
33d18d5c:	ea000009 	b	33d18d88 <ListInsertItems+0xa4>
	} else if (numNewItems < 0) {
33d18d60:	aa000008 	bge	33d18d88 <ListInsertItems+0xa4>
		numNewItems = (-numNewItems) + NUMITEMSPERALLOC (list);
33d18d64:	e5943004 	ldr	r3, [r4, #4]
33d18d68:	e2833064 	add	r3, r3, #100	; 0x64
33d18d6c:	e0000293 	mul	r0, r3, r2
33d18d70:	e3a01064 	mov	r1, #100	; 0x64
33d18d74:	eb001639 	bl	33d1e660 <__divsi3>
33d18d78:	e5943008 	ldr	r3, [r4, #8]
33d18d7c:	e1530000 	cmp	r3, r0
33d18d80:	a0655003 	rsbge	r5, r5, r3
33d18d84:	b0655000 	rsblt	r5, r5, r0
	}

	if (SetHandleSize ((Handle) list,
33d18d88:	e594300c 	ldr	r3, [r4, #12]
33d18d8c:	e5942010 	ldr	r2, [r4, #16]
33d18d90:	e0833005 	add	r3, r3, r5
33d18d94:	e0010392 	mul	r1, r2, r3
33d18d98:	e1a0000a 	mov	r0, sl
33d18d9c:	e281101c 	add	r1, r1, #28	; 0x1c
33d18da0:	ebffff95 	bl	33d18bfc <SetHandleSize>
33d18da4:	e3500000 	cmp	r0, #0	; 0x0
33d18da8:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
			   sizeof (ListStruct) +
			   ((*list)->listSize +
			   numNewItems) * (*list)->itemSize)) {
		(*list)->listSize += numNewItems;
33d18dac:	e59a2000 	ldr	r2, [sl]
33d18db0:	e592300c 	ldr	r3, [r2, #12]
33d18db4:	e0833005 	add	r3, r3, r5
33d18db8:	e582300c 	str	r3, [r2, #12]
	if ((*list)->numItems >= (*list)->listSize) {
		if (!ExpandListSpace (list, -numItemsToInsert))
			return 0;
	}

	if (firstItemPosition == LIST_START) {
33d18dbc:	e3760001 	cmn	r6, #1	; 0x1
33d18dc0:	1a000003 	bne	33d18dd4 <ListInsertItems+0xf0>
		if (numItems == 0) {
33d18dc4:	e3590000 	cmp	r9, #0	; 0x0
			/* special case for empty list */
			firstItemPosition = LIST_END;
		} else {
			firstItemPosition = 1;
33d18dc8:	12866002 	addne	r6, r6, #2	; 0x2
		if (!ExpandListSpace (list, -numItemsToInsert))
			return 0;
	}

	if (firstItemPosition == LIST_START) {
		if (numItems == 0) {
33d18dcc:	1a00000f 	bne	33d18e10 <ListInsertItems+0x12c>
33d18dd0:	ea000001 	b	33d18ddc <ListInsertItems+0xf8>
		} else {
			firstItemPosition = 1;
		}
	}

	if (firstItemPosition == LIST_END) {	/* add at the end of the list */
33d18dd4:	e3560000 	cmp	r6, #0	; 0x0
33d18dd8:	1a00000c 	bne	33d18e10 <ListInsertItems+0x12c>
		if (ptrToItems)
33d18ddc:	e35b0000 	cmp	fp, #0	; 0x0
33d18de0:	e59a2000 	ldr	r2, [sl]
33d18de4:	0a000006 	beq	33d18e04 <ListInsertItems+0x120>
			memcpy (ITEMPTR (list, numItems), ptrToItems,
33d18de8:	e5923010 	ldr	r3, [r2, #16]
33d18dec:	e0202399 	mla	r0, r9, r3, r2
33d18df0:	e1a0100b 	mov	r1, fp
33d18df4:	e0020397 	mul	r2, r7, r3
33d18df8:	e2800018 	add	r0, r0, #24	; 0x18
33d18dfc:	eb000578 	bl	33d1a3e4 <memcpy>
33d18e00:	ea00001e 	b	33d18e80 <ListInsertItems+0x19c>
					(*list)->itemSize * numItemsToInsert);
		else
			memset (ITEMPTR (list, numItems), 0,
33d18e04:	e5923010 	ldr	r3, [r2, #16]
33d18e08:	e0202399 	mla	r0, r9, r3, r2
33d18e0c:	ea000017 	b	33d18e70 <ListInsertItems+0x18c>
					(*list)->itemSize * numItemsToInsert);

		(*list)->numItems += numItemsToInsert;
	} else {					/* move part of list up to make room for new item */
		memmove (ITEMPTR (list, firstItemPosition - 1 + numItemsToInsert),
33d18e10:	e59a1000 	ldr	r1, [sl]
33d18e14:	e0863007 	add	r3, r6, r7
33d18e18:	e5912010 	ldr	r2, [r1, #16]
33d18e1c:	e2433001 	sub	r3, r3, #1	; 0x1
33d18e20:	e2464001 	sub	r4, r6, #1	; 0x1
33d18e24:	e0201293 	mla	r0, r3, r2, r1
33d18e28:	e0211294 	mla	r1, r4, r2, r1
33d18e2c:	e0663009 	rsb	r3, r6, r9
33d18e30:	e0222293 	mla	r2, r3, r2, r2
33d18e34:	e2800018 	add	r0, r0, #24	; 0x18
33d18e38:	e2811018 	add	r1, r1, #24	; 0x18
33d18e3c:	eb000572 	bl	33d1a40c <memmove>
			 ITEMPTR (list, firstItemPosition - 1),
			 (numItems + 1 - firstItemPosition) * (*list)->itemSize);

		if (ptrToItems)
33d18e40:	e35b0000 	cmp	fp, #0	; 0x0
33d18e44:	e59a2000 	ldr	r2, [sl]
33d18e48:	0a000006 	beq	33d18e68 <ListInsertItems+0x184>
			memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
33d18e4c:	e5923010 	ldr	r3, [r2, #16]
33d18e50:	e0202394 	mla	r0, r4, r3, r2
33d18e54:	e1a0100b 	mov	r1, fp
33d18e58:	e0020397 	mul	r2, r7, r3
33d18e5c:	e2800018 	add	r0, r0, #24	; 0x18
33d18e60:	eb000569 	bl	33d1a40c <memmove>
33d18e64:	ea000005 	b	33d18e80 <ListInsertItems+0x19c>
					 (*list)->itemSize * numItemsToInsert);
		else
			memset (ITEMPTR (list, firstItemPosition - 1), 0,
33d18e68:	e5923010 	ldr	r3, [r2, #16]
33d18e6c:	e0202394 	mla	r0, r4, r3, r2
33d18e70:	e1a0100b 	mov	r1, fp
33d18e74:	e2800018 	add	r0, r0, #24	; 0x18
33d18e78:	e0020397 	mul	r2, r7, r3
33d18e7c:	eb000544 	bl	33d1a394 <memset>
					(*list)->itemSize * numItemsToInsert);

		(*list)->numItems += numItemsToInsert;
33d18e80:	e59a2000 	ldr	r2, [sl]
33d18e84:	e5923014 	ldr	r3, [r2, #20]
	}

	return 1;
33d18e88:	e3a00001 	mov	r0, #1	; 0x1
					 (*list)->itemSize * numItemsToInsert);
		else
			memset (ITEMPTR (list, firstItemPosition - 1), 0,
					(*list)->itemSize * numItemsToInsert);

		(*list)->numItems += numItemsToInsert;
33d18e8c:	e0833007 	add	r3, r3, r7
33d18e90:	e5823014 	str	r3, [r2, #20]
	}

	return 1;
}
33d18e94:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d18e98 <ListInsertItem>:
 * returns 1 if the item is inserted, returns 0 if out of memory or
 * bad arguments were passed.
 */
int ListInsertItem (list_t list, void *ptrToItem, int itemPosition)
{
	return ListInsertItems (list, ptrToItem, itemPosition, 1);
33d18e98:	e3a03001 	mov	r3, #1	; 0x1
33d18e9c:	eaffff90 	b	33d18ce4 <ListInsertItems>

33d18ea0 <ListGetItems>:

void ListGetItems (list_t list, void *itemsDestination,
		   int firstItemPosition, int numItemsToGet)
{

	if (firstItemPosition == LIST_START)
33d18ea0:	e3720001 	cmn	r2, #1	; 0x1

/*******************************/

void ListGetItems (list_t list, void *itemsDestination,
		   int firstItemPosition, int numItemsToGet)
{
33d18ea4:	e92d4010 	push	{r4, lr}

	if (firstItemPosition == LIST_START)
		firstItemPosition = 1;
33d18ea8:	02822002 	addeq	r2, r2, #2	; 0x2

/*******************************/

void ListGetItems (list_t list, void *itemsDestination,
		   int firstItemPosition, int numItemsToGet)
{
33d18eac:	e1a0e001 	mov	lr, r1
33d18eb0:	e1a04003 	mov	r4, r3

	if (firstItemPosition == LIST_START)
33d18eb4:	0a000002 	beq	33d18ec4 <ListGetItems+0x24>
		firstItemPosition = 1;
	else if (firstItemPosition == LIST_END)
33d18eb8:	e3520000 	cmp	r2, #0	; 0x0
		firstItemPosition = (*list)->numItems;
33d18ebc:	05903000 	ldreq	r3, [r0]
33d18ec0:	05932014 	ldreq	r2, [r3, #20]

	memcpy (itemsDestination,
33d18ec4:	e5901000 	ldr	r1, [r0]
33d18ec8:	e5913010 	ldr	r3, [r1, #16]
33d18ecc:	e242c001 	sub	ip, r2, #1	; 0x1
33d18ed0:	e021139c 	mla	r1, ip, r3, r1
33d18ed4:	e0020394 	mul	r2, r4, r3
33d18ed8:	e1a0000e 	mov	r0, lr
33d18edc:	e2811018 	add	r1, r1, #24	; 0x18
33d18ee0:	e8bd4010 	pop	{r4, lr}
33d18ee4:	ea00053e 	b	33d1a3e4 <memcpy>

33d18ee8 <ListGetPtrToItem>:
 * Returns a pointer to the item at itemPosition. returns null if an
 * errors occurred.
 */
void *ListGetPtrToItem (list_t list, int itemPosition)
{
	if (itemPosition == LIST_START)
33d18ee8:	e3710001 	cmn	r1, #1	; 0x1
		itemPosition = 1;
33d18eec:	02811002 	addeq	r1, r1, #2	; 0x2
 * Returns a pointer to the item at itemPosition. returns null if an
 * errors occurred.
 */
void *ListGetPtrToItem (list_t list, int itemPosition)
{
	if (itemPosition == LIST_START)
33d18ef0:	0a000002 	beq	33d18f00 <ListGetPtrToItem+0x18>
		itemPosition = 1;
	else if (itemPosition == LIST_END)
33d18ef4:	e3510000 	cmp	r1, #0	; 0x0
		itemPosition = (*list)->numItems;
33d18ef8:	05903000 	ldreq	r3, [r0]
33d18efc:	05931014 	ldreq	r1, [r3, #20]

	return ITEMPTR (list, itemPosition - 1);
33d18f00:	e5902000 	ldr	r2, [r0]
33d18f04:	e5923010 	ldr	r3, [r2, #16]
33d18f08:	e2411001 	sub	r1, r1, #1	; 0x1
33d18f0c:	e0202391 	mla	r0, r1, r3, r2
}
33d18f10:	e2800018 	add	r0, r0, #24	; 0x18
33d18f14:	e1a0f00e 	mov	pc, lr

33d18f18 <ListGetDataPtr>:
 * returns a pointer the lists data (abstraction violation for
 * optimization)
 */
void *ListGetDataPtr (list_t list)
{
	return &((*list)->itemList[0]);
33d18f18:	e5900000 	ldr	r0, [r0]
}
33d18f1c:	e2800018 	add	r0, r0, #24	; 0x18
33d18f20:	e1a0f00e 	mov	pc, lr

33d18f24 <ListGetItemSize>:

/********************************/

int ListGetItemSize (list_t list)
{
	return (*list)->itemSize;
33d18f24:	e5903000 	ldr	r3, [r0]
}
33d18f28:	e5930010 	ldr	r0, [r3, #16]
33d18f2c:	e1a0f00e 	mov	pc, lr

33d18f30 <ListNumItems>:

/********************************/

int ListNumItems (list_t list)
{
	return (*list)->numItems;
33d18f30:	e5903000 	ldr	r3, [r0]
}
33d18f34:	e5930014 	ldr	r0, [r3, #20]
33d18f38:	e1a0f00e 	mov	pc, lr

33d18f3c <hex1_bin>:

	return (srec_type);
}

static int hex1_bin (char c)
{
33d18f3c:	e20000ff 	and	r0, r0, #255	; 0xff
	if (c >= '0' && c <= '9')
33d18f40:	e2402030 	sub	r2, r0, #48	; 0x30
33d18f44:	e20230ff 	and	r3, r2, #255	; 0xff
33d18f48:	e3530009 	cmp	r3, #9	; 0x9
		return (c - '0');
	if (c >= 'a' && c <= 'f')
33d18f4c:	e2401061 	sub	r1, r0, #97	; 0x61
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
33d18f50:	9a000006 	bls	33d18f70 <hex1_bin+0x34>
		return (c - '0');
	if (c >= 'a' && c <= 'f')
33d18f54:	e3510005 	cmp	r1, #5	; 0x5
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
33d18f58:	e2403041 	sub	r3, r0, #65	; 0x41
static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
		return (c + 10 - 'a');
33d18f5c:	e2402057 	sub	r2, r0, #87	; 0x57

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
33d18f60:	9a000002 	bls	33d18f70 <hex1_bin+0x34>
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
33d18f64:	e3530005 	cmp	r3, #5	; 0x5
		return (c + 10 - 'A');
33d18f68:	e2402037 	sub	r2, r0, #55	; 0x37
	return (-1);
33d18f6c:	83e02000 	mvnhi	r2, #0	; 0x0
}
33d18f70:	e1a00002 	mov	r0, r2
33d18f74:	e1a0f00e 	mov	pc, lr

33d18f78 <hex2_bin>:

static int hex2_bin (char *s)
{
33d18f78:	e92d4030 	push	{r4, r5, lr}
33d18f7c:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
33d18f80:	e4d40001 	ldrb	r0, [r4], #1
33d18f84:	ebffffec 	bl	33d18f3c <hex1_bin>
33d18f88:	e2505000 	subs	r5, r0, #0	; 0x0
		return (-1);
33d18f8c:	e3e03000 	mvn	r3, #0	; 0x0

static int hex2_bin (char *s)
{
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
33d18f90:	ba000004 	blt	33d18fa8 <hex2_bin+0x30>
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
33d18f94:	e5d40000 	ldrb	r0, [r4]
33d18f98:	ebffffe7 	bl	33d18f3c <hex1_bin>
33d18f9c:	e3500000 	cmp	r0, #0	; 0x0
		return (-1);
33d18fa0:	e3e03000 	mvn	r3, #0	; 0x0
	}

	return ((i<<4) + j);
33d18fa4:	a0803205 	addge	r3, r0, r5, lsl #4
}
33d18fa8:	e1a00003 	mov	r0, r3
33d18fac:	e8bd8030 	pop	{r4, r5, pc}

33d18fb0 <srec_decode>:

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
33d18fb0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d18fb4:	e1a05000 	mov	r5, r0
33d18fb8:	e24dd004 	sub	sp, sp, #4	; 0x4

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
33d18fbc:	e5d00000 	ldrb	r0, [r0]

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
33d18fc0:	e58d3000 	str	r3, [sp]

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
33d18fc4:	e3500000 	cmp	r0, #0	; 0x0

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
33d18fc8:	e1a06001 	mov	r6, r1
33d18fcc:	e1a09002 	mov	r9, r2

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
33d18fd0:	0a000006 	beq	33d18ff0 <srec_decode+0x40>
33d18fd4:	e2853001 	add	r3, r5, #1	; 0x1
		if (*input == 'S') {		/* skip 'S' */
33d18fd8:	e3500053 	cmp	r0, #83	; 0x53

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
33d18fdc:	e1a05003 	mov	r5, r3
		if (*input == 'S') {		/* skip 'S' */
33d18fe0:	0a000007 	beq	33d19004 <srec_decode+0x54>

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
33d18fe4:	e5d30000 	ldrb	r0, [r3]
33d18fe8:	e3500000 	cmp	r0, #0	; 0x0
33d18fec:	eafffff7 	b	33d18fd0 <srec_decode+0x20>
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
33d18ff0:	e5d52000 	ldrb	r2, [r5]
33d18ff4:	e3520000 	cmp	r2, #0	; 0x0
		return (SREC_EMPTY);
33d18ff8:	03a0000a 	moveq	r0, #10	; 0xa
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
33d18ffc:	0a000089 	beq	33d19228 <srec_decode+0x278>
33d19000:	ea000001 	b	33d1900c <srec_decode+0x5c>
	 * Return error if not found
	 */

	for (; *input; ++input) {
		if (*input == 'S') {		/* skip 'S' */
			++input;
33d19004:	e1a05003 	mov	r5, r3
			break;
33d19008:	eafffff8 	b	33d18ff0 <srec_decode+0x40>
	}
	if (*input == '\0') {			/* no more data?	*/
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
33d1900c:	e2855001 	add	r5, r5, #1	; 0x1

	if ((*count = hex2_bin(input)) < 0) {
33d19010:	e1a00005 	mov	r0, r5
	}
	if (*input == '\0') {			/* no more data?	*/
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
33d19014:	e1a04002 	mov	r4, r2

	if ((*count = hex2_bin(input)) < 0) {
33d19018:	ebffffd6 	bl	33d18f78 <hex2_bin>
33d1901c:	e3500000 	cmp	r0, #0	; 0x0
33d19020:	e5860000 	str	r0, [r6]
33d19024:	ba00007c 	blt	33d1921c <srec_decode+0x26c>
	}

	chksum += *count;
	input  += 2;

	switch (v) {				/* record type		*/
33d19028:	e2441030 	sub	r1, r4, #48	; 0x30

	if ((*count = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	chksum += *count;
33d1902c:	e20070ff 	and	r7, r0, #255	; 0xff
	input  += 2;
33d19030:	e2855002 	add	r5, r5, #2	; 0x2

	switch (v) {				/* record type		*/
33d19034:	e3510009 	cmp	r1, #9	; 0x9
33d19038:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
33d1903c:	ea00005d 	b	33d191b8 <srec_decode+0x208>
33d19040:	33d19068 	.word	0x33d19068
33d19044:	33d19078 	.word	0x33d19078
33d19048:	33d19088 	.word	0x33d19088
33d1904c:	33d19098 	.word	0x33d19098
33d19050:	33d191b8 	.word	0x33d191b8
33d19054:	33d190a8 	.word	0x33d190a8
33d19058:	33d191b8 	.word	0x33d191b8
33d1905c:	33d190b4 	.word	0x33d190b4
33d19060:	33d190c4 	.word	0x33d190c4
33d19064:	33d190d4 	.word	0x33d190d4

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
33d19068:	e5963000 	ldr	r3, [r6]
	input  += 2;

	switch (v) {				/* record type		*/

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
33d1906c:	e3a0b000 	mov	fp, #0	; 0x0
		*count   -= 3;			/* - checksum and addr	*/
33d19070:	e2433003 	sub	r3, r3, #3	; 0x3
33d19074:	ea000019 	b	33d190e0 <srec_decode+0x130>
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
33d19078:	e5963000 	ldr	r3, [r6]
	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
33d1907c:	e3a0b001 	mov	fp, #1	; 0x1
		*count   -= 3;			/* - checksum and addr	*/
33d19080:	e2433003 	sub	r3, r3, #3	; 0x3
33d19084:	ea000015 	b	33d190e0 <srec_decode+0x130>
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
33d19088:	e5963000 	ldr	r3, [r6]
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
33d1908c:	e3a0b002 	mov	fp, #2	; 0x2
		*count   -= 4;			/* - checksum and addr	*/
33d19090:	e2433004 	sub	r3, r3, #4	; 0x4
33d19094:	ea000011 	b	33d190e0 <srec_decode+0x130>
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
33d19098:	e5963000 	ldr	r3, [r6]
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
33d1909c:	e3a0b003 	mov	fp, #3	; 0x3
		*count   -= 5;			/* - checksum and addr	*/
33d190a0:	e2433005 	sub	r3, r3, #5	; 0x5
33d190a4:	ea00000d 	b	33d190e0 <srec_decode+0x130>
		break;
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
33d190a8:	e3a0b005 	mov	fp, #5	; 0x5
		*count    = 0;			/* no data		*/
33d190ac:	e3a03000 	mov	r3, #0	; 0x0
33d190b0:	ea00000a 	b	33d190e0 <srec_decode+0x130>
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
33d190b4:	e5963000 	ldr	r3, [r6]
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
33d190b8:	e3a0b007 	mov	fp, #7	; 0x7
		*count   -= 5;			/* - checksum and addr	*/
33d190bc:	e2433005 	sub	r3, r3, #5	; 0x5
33d190c0:	ea000006 	b	33d190e0 <srec_decode+0x130>
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
33d190c4:	e5963000 	ldr	r3, [r6]
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
33d190c8:	e3a0b008 	mov	fp, #8	; 0x8
		*count   -= 4;			/* - checksum and addr	*/
33d190cc:	e2433004 	sub	r3, r3, #4	; 0x4
33d190d0:	ea000002 	b	33d190e0 <srec_decode+0x130>
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
33d190d4:	e5963000 	ldr	r3, [r6]
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
33d190d8:	e3a0b009 	mov	fp, #9	; 0x9
		*count   -= 3;			/* - checksum and addr	*/
33d190dc:	e2433003 	sub	r3, r3, #3	; 0x3
33d190e0:	e5863000 	str	r3, [r6]
	}

	/* read address field */
	*addr = 0;

	switch (v) {
33d190e4:	e3510009 	cmp	r1, #9	; 0x9
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
33d190e8:	e3a03000 	mov	r3, #0	; 0x0
33d190ec:	e5893000 	str	r3, [r9]

	switch (v) {
33d190f0:	8a000030 	bhi	33d191b8 <srec_decode+0x208>
33d190f4:	e59f3134 	ldr	r3, [pc, #308]	; 33d19230 <srec_decode+0x280>
33d190f8:	e3a02001 	mov	r2, #1	; 0x1
33d190fc:	e1a00112 	lsl	r0, r2, r1
33d19100:	e0003003 	and	r3, r0, r3
33d19104:	e3530000 	cmp	r3, #0	; 0x0
33d19108:	1a000015 	bne	33d19164 <srec_decode+0x1b4>
33d1910c:	e3100f41 	tst	r0, #260	; 0x104
33d19110:	1a000009 	bne	33d1913c <srec_decode+0x18c>
33d19114:	e3100088 	tst	r0, #136	; 0x88
33d19118:	0a000026 	beq	33d191b8 <srec_decode+0x208>
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
33d1911c:	e1a00005 	mov	r0, r5
33d19120:	ebffff94 	bl	33d18f78 <hex2_bin>
33d19124:	e2504000 	subs	r4, r0, #0	; 0x0
33d19128:	ba00003b 	blt	33d1921c <srec_decode+0x26c>
			return (SREC_E_NOSREC);
		}
		*addr  += v;
		chksum += v;
33d1912c:	e0873004 	add	r3, r7, r4
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr  += v;
33d19130:	e5894000 	str	r4, [r9]
		chksum += v;
33d19134:	e20370ff 	and	r7, r3, #255	; 0xff
		input  += 2;
33d19138:	e2855002 	add	r5, r5, #2	; 0x2
		/* FALL THRU */
	case '2':				/* 3 byte addr field	*/
	case '8':
		if ((v = hex2_bin(input)) < 0) {
33d1913c:	e1a00005 	mov	r0, r5
33d19140:	ebffff8c 	bl	33d18f78 <hex2_bin>
33d19144:	e2504000 	subs	r4, r0, #0	; 0x0
33d19148:	ba000033 	blt	33d1921c <srec_decode+0x26c>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
33d1914c:	e5993000 	ldr	r3, [r9]
		*addr  += v;
33d19150:	e0843403 	add	r3, r4, r3, lsl #8
		chksum += v;
33d19154:	e0872004 	add	r2, r7, r4
	case '8':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
33d19158:	e5893000 	str	r3, [r9]
		chksum += v;
33d1915c:	e20270ff 	and	r7, r2, #255	; 0xff
		input  += 2;
33d19160:	e2855002 	add	r5, r5, #2	; 0x2
		/* FALL THRU */
	case '0':				/* 2 byte addr field	*/
	case '1':
	case '5':
	case '9':
		if ((v = hex2_bin(input)) < 0) {
33d19164:	e1a00005 	mov	r0, r5
33d19168:	ebffff82 	bl	33d18f78 <hex2_bin>
33d1916c:	e2504000 	subs	r4, r0, #0	; 0x0
33d19170:	ba000029 	blt	33d1921c <srec_decode+0x26c>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
33d19174:	e5993000 	ldr	r3, [r9]
		*addr  += v;
		chksum += v;
		input  += 2;
33d19178:	e2855002 	add	r5, r5, #2	; 0x2
	case '9':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
33d1917c:	e084a403 	add	sl, r4, r3, lsl #8
33d19180:	e589a000 	str	sl, [r9]
		chksum += v;
33d19184:	e0873004 	add	r3, r7, r4
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
33d19188:	e1a00005 	mov	r0, r5
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
33d1918c:	e20370ff 	and	r7, r3, #255	; 0xff
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
33d19190:	ebffff78 	bl	33d18f78 <hex2_bin>
33d19194:	e2504000 	subs	r4, r0, #0	; 0x0
33d19198:	ba00001f 	blt	33d1921c <srec_decode+0x26c>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
33d1919c:	e0873004 	add	r3, r7, r4

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
33d191a0:	e084240a 	add	r2, r4, sl, lsl #8
		chksum += v;
33d191a4:	e20370ff 	and	r7, r3, #255	; 0xff
		input  += 2;
33d191a8:	e2855002 	add	r5, r5, #2	; 0x2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
33d191ac:	e3a0a000 	mov	sl, #0	; 0x0

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
33d191b0:	e5892000 	str	r2, [r9]
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
33d191b4:	ea00000a 	b	33d191e4 <srec_decode+0x234>
		chksum += v;
		input  += 2;

		break;
	default:
		return (SREC_E_BADTYPE);
33d191b8:	e3e00000 	mvn	r0, #0	; 0x0
33d191bc:	ea000019 	b	33d19228 <srec_decode+0x278>
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
33d191c0:	ebffff6c 	bl	33d18f78 <hex2_bin>
33d191c4:	e2504000 	subs	r4, r0, #0	; 0x0
			return (SREC_E_NOSREC);
		}
		data[i] = v;
		chksum += v;
33d191c8:	e0873004 	add	r3, r7, r4
33d191cc:	e20370ff 	and	r7, r3, #255	; 0xff
		input  += 2;
33d191d0:	e2855002 	add	r5, r5, #2	; 0x2
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
33d191d4:	ba000010 	blt	33d1921c <srec_decode+0x26c>
			return (SREC_E_NOSREC);
		}
		data[i] = v;
33d191d8:	e59d3000 	ldr	r3, [sp]
33d191dc:	e7c3400a 	strb	r4, [r3, sl]
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
33d191e0:	e28aa001 	add	sl, sl, #1	; 0x1
33d191e4:	e5963000 	ldr	r3, [r6]
33d191e8:	e15a0003 	cmp	sl, r3
		if ((v = hex2_bin(input)) < 0) {
33d191ec:	e1a00005 	mov	r0, r5
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
33d191f0:	bafffff2 	blt	33d191c0 <srec_decode+0x210>
		chksum += v;
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
33d191f4:	ebffff5f 	bl	33d18f78 <hex2_bin>
33d191f8:	e2504000 	subs	r4, r0, #0	; 0x0
33d191fc:	ba000006 	blt	33d1921c <srec_decode+0x26c>
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
33d19200:	e1e03007 	mvn	r3, r7
33d19204:	e20420ff 	and	r2, r4, #255	; 0xff
33d19208:	e20330ff 	and	r3, r3, #255	; 0xff
33d1920c:	e1520003 	cmp	r2, r3
		return (SREC_E_BADCHKS);
33d19210:	13e00002 	mvnne	r0, #2	; 0x2
	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
33d19214:	1a000003 	bne	33d19228 <srec_decode+0x278>
33d19218:	ea000001 	b	33d19224 <srec_decode+0x274>
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
33d1921c:	e3e00001 	mvn	r0, #1	; 0x1
33d19220:	ea000000 	b	33d19228 <srec_decode+0x278>

	if ((unsigned char)v != (unsigned char)~chksum) {
		return (SREC_E_BADCHKS);
	}

	return (srec_type);
33d19224:	e1a0000b 	mov	r0, fp
}
33d19228:	e28dd004 	add	sp, sp, #4	; 0x4
33d1922c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d19230:	00000223 	.word	0x00000223

33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>:

#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
33d19234:	e92d4030 	push	{r4, r5, lr}
33d19238:	e1a05001 	mov	r5, r1
#define DELAY 20
  unsigned long counter = 0;
33d1923c:	e3a04000 	mov	r4, #0	; 0x0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
33d19240:	ea000000 	b	33d19248 <CYGACC_COMM_IF_GETC_TIMEOUT+0x14>
    {
      udelay (DELAY);
33d19244:	ebff9ef0 	bl	33d00e0c <udelay>
      counter++;
33d19248:	ebfff747 	bl	33d16f6c <tstc>
33d1924c:	e3500000 	cmp	r0, #0	; 0x0
{
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
    {
      udelay (DELAY);
33d19250:	e3a00014 	mov	r0, #20	; 0x14
      counter++;
33d19254:	1a000003 	bne	33d19268 <CYGACC_COMM_IF_GETC_TIMEOUT+0x34>
33d19258:	e59f302c 	ldr	r3, [pc, #44]	; 33d1928c <CYGACC_COMM_IF_GETC_TIMEOUT+0x58>
33d1925c:	e1540003 	cmp	r4, r3
33d19260:	e2844001 	add	r4, r4, #1	; 0x1
33d19264:	9afffff6 	bls	33d19244 <CYGACC_COMM_IF_GETC_TIMEOUT+0x10>
    }
  if (tstc ())
33d19268:	ebfff73f 	bl	33d16f6c <tstc>
33d1926c:	e3500000 	cmp	r0, #0	; 0x0
    {
      *c = getc ();
      return 1;
    }
  return 0;
33d19270:	01a03000 	moveq	r3, r0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
    {
      udelay (DELAY);
      counter++;
    }
  if (tstc ())
33d19274:	0a000002 	beq	33d19284 <CYGACC_COMM_IF_GETC_TIMEOUT+0x50>
    {
      *c = getc ();
33d19278:	ebfff735 	bl	33d16f54 <getc>
33d1927c:	e5c50000 	strb	r0, [r5]
      return 1;
33d19280:	e3a03001 	mov	r3, #1	; 0x1
    }
  return 0;
}
33d19284:	e1a00003 	mov	r0, r3
33d19288:	e8bd8030 	pop	{r4, r5, pc}
33d1928c:	0001869f 	.word	0x0001869f

33d19290 <CYGACC_COMM_IF_PUTC>:

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
33d19290:	e20110ff 	and	r1, r1, #255	; 0xff
  putc (y);
33d19294:	e1a00001 	mov	r0, r1
33d19298:	eafff739 	b	33d16f84 <putc>

33d1929c <parse_num>:
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
33d1929c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d192a0:	e1a0e000 	mov	lr, r0
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
33d192a4:	e5d00000 	ldrb	r0, [r0]
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
33d192a8:	e1a09002 	mov	r9, r2
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
33d192ac:	e3500020 	cmp	r0, #32	; 0x20
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
33d192b0:	e1a0b001 	mov	fp, r1
33d192b4:	e1a0a003 	mov	sl, r3
  bool first = true;
33d192b8:	e3a02001 	mov	r2, #1	; 0x1
  int radix = 10;
33d192bc:	e3a0600a 	mov	r6, #10	; 0xa
  char c;
  unsigned long result = 0;
33d192c0:	e3a07000 	mov	r7, #0	; 0x0
  int digit;

  while (*s == ' ')
    s++;
33d192c4:	1a000002 	bne	33d192d4 <parse_num+0x38>
33d192c8:	e5fe3001 	ldrb	r3, [lr, #1]!
33d192cc:	e3530020 	cmp	r3, #32	; 0x20
33d192d0:	eafffffb 	b	33d192c4 <parse_num+0x28>
	      while (*dp && (c != *dp))
		dp++;
	      if (*dp)
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
33d192d4:	e5de3000 	ldrb	r3, [lr]
33d192d8:	e3530000 	cmp	r3, #0	; 0x0
33d192dc:	0a000037 	beq	33d193c0 <parse_num+0x124>

  while (*s == ' ')
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
33d192e0:	e3520000 	cmp	r2, #0	; 0x0
33d192e4:	0a000009 	beq	33d19310 <parse_num+0x74>
33d192e8:	e3530030 	cmp	r3, #48	; 0x30
33d192ec:	1a000007 	bne	33d19310 <parse_num+0x74>
}

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
33d192f0:	e5de0001 	ldrb	r0, [lr, #1]
  if ((c >= 'A') && (c <= 'Z'))
33d192f4:	e2403041 	sub	r3, r0, #65	; 0x41
33d192f8:	e3530019 	cmp	r3, #25	; 0x19
    {
      c = (c - 'A') + 'a';
33d192fc:	92803020 	addls	r3, r0, #32	; 0x20
33d19300:	920300ff 	andls	r0, r3, #255	; 0xff
}

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
33d19304:	e3500078 	cmp	r0, #120	; 0x78
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
33d19308:	028ee002 	addeq	lr, lr, #2	; 0x2
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
33d1930c:	03a06010 	moveq	r6, #16	; 0x10
	  s += 2;
	}
      first = false;
      c = *s++;
33d19310:	e4dec001 	ldrb	ip, [lr], #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
33d19314:	e24c3041 	sub	r3, ip, #65	; 0x41
33d19318:	e24c1030 	sub	r1, ip, #48	; 0x30
33d1931c:	e20340ff 	and	r4, r3, #255	; 0xff
33d19320:	e20100ff 	and	r0, r1, #255	; 0xff
33d19324:	e3540005 	cmp	r4, #5	; 0x5
33d19328:	83500009 	cmphi	r0, #9	; 0x9
33d1932c:	e24c3061 	sub	r3, ip, #97	; 0x61

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
33d19330:	e24c5061 	sub	r5, ip, #97	; 0x61
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
33d19334:	e3a02000 	mov	r2, #0	; 0x0

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
33d19338:	9a000001 	bls	33d19344 <parse_num+0xa8>
33d1933c:	e3530005 	cmp	r3, #5	; 0x5
33d19340:	8a00000a 	bhi	33d19370 <parse_num+0xd4>
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
33d19344:	e3500009 	cmp	r0, #9	; 0x9

/* Convert a single hex nibble */
__inline__ static int
_from_hex (char c)
{
  int ret = 0;
33d19348:	e1a00002 	mov	r0, r2

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
33d1934c:	91a00001 	movls	r0, r1
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
33d19350:	9a000004 	bls	33d19368 <parse_num+0xcc>
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
33d19354:	e3550005 	cmp	r5, #5	; 0x5
    {
      ret = (c - 'a' + 0x0a);
33d19358:	924c0057 	subls	r0, ip, #87	; 0x57

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
33d1935c:	9a000001 	bls	33d19368 <parse_num+0xcc>
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
33d19360:	e3540005 	cmp	r4, #5	; 0x5
    {
      ret = (c - 'A' + 0x0A);
33d19364:	924c0037 	subls	r0, ip, #55	; 0x37
}

/* Convert a single hex nibble */
__inline__ static int
_from_hex (char c)
{
33d19368:	e1500006 	cmp	r0, r6
33d1936c:	ba00000f 	blt	33d193b0 <parse_num+0x114>
	  result = (result * radix) + digit;
#endif
	}
      else
	{
	  if (delim != (char *) 0)
33d19370:	e35a0000 	cmp	sl, #0	; 0x0
33d19374:	0a00000b 	beq	33d193a8 <parse_num+0x10c>
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
	      while (*dp && (c != *dp))
		dp++;
33d19378:	e5da0000 	ldrb	r0, [sl]
33d1937c:	e3500000 	cmp	r0, #0	; 0x0
      else
	{
	  if (delim != (char *) 0)
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
33d19380:	e1a0300a 	mov	r3, sl
	      while (*dp && (c != *dp))
		dp++;
33d19384:	0a000007 	beq	33d193a8 <parse_num+0x10c>
33d19388:	e150000c 	cmp	r0, ip
33d1938c:	0a000002 	beq	33d1939c <parse_num+0x100>
33d19390:	e5f30001 	ldrb	r0, [r3, #1]!
33d19394:	e3500000 	cmp	r0, #0	; 0x0
33d19398:	1afffffa 	bne	33d19388 <parse_num+0xec>
	      if (*dp)
33d1939c:	e5d33000 	ldrb	r3, [r3]
33d193a0:	e3530000 	cmp	r3, #0	; 0x0
33d193a4:	1a000005 	bne	33d193c0 <parse_num+0x124>
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
33d193a8:	e3a00000 	mov	r0, #0	; 0x0
33d193ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d193b0:	e5de3000 	ldrb	r3, [lr]
33d193b4:	e3530000 	cmp	r3, #0	; 0x0
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
33d193b8:	e0270796 	mla	r7, r6, r7, r0
	      while (*dp && (c != *dp))
		dp++;
	      if (*dp)
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
33d193bc:	1affffd3 	bne	33d19310 <parse_num+0x74>
	}
    }
  *val = result;
  if (es != (char **) 0)
33d193c0:	e3590000 	cmp	r9, #0	; 0x0
    {
      *es = s;
    }
  return true;
33d193c4:	e3a00001 	mov	r0, #1	; 0x1
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
33d193c8:	e58b7000 	str	r7, [fp]
  if (es != (char **) 0)
    {
      *es = s;
33d193cc:	1589e000 	strne	lr, [r9]
    }
  return true;
}
33d193d0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d193d4 <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
33d193d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d193d8:	e24dd004 	sub	sp, sp, #4	; 0x4
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
33d193dc:	e59f301c 	ldr	r3, [pc, #28]	; 33d19400 <xyzModem_flush+0x2c>
33d193e0:	e5933000 	ldr	r3, [r3]
33d193e4:	e28d1003 	add	r1, sp, #3	; 0x3
33d193e8:	e5d30000 	ldrb	r0, [r3]
33d193ec:	ebffff90 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
33d193f0:	e3500000 	cmp	r0, #0	; 0x0
33d193f4:	1afffff8 	bne	33d193dc <xyzModem_flush+0x8>
	return;
33d193f8:	e28dd004 	add	sp, sp, #4	; 0x4
33d193fc:	e8bd8000 	pop	{pc}
33d19400:	33d60c6c 	.word	0x33d60c6c

33d19404 <xyzModem_get_hdr>:
    }
}

static int
xyzModem_get_hdr (void)
{
33d19404:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
33d19408:	e59f42bc 	ldr	r4, [pc, #700]	; 33d196cc <xyzModem_get_hdr+0x2c8>
33d1940c:	e5943430 	ldr	r3, [r4, #1072]
static int
xyzModem_get_hdr (void)
{
  char c;
  int res;
  bool hdr_found = false;
33d19410:	e3a05000 	mov	r5, #0	; 0x0
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
33d19414:	e3530000 	cmp	r3, #0	; 0x0
    }
}

static int
xyzModem_get_hdr (void)
{
33d19418:	e24dd004 	sub	sp, sp, #4	; 0x4
  int i, can_total, hdr_chars;
  unsigned short cksum;

  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
33d1941c:	e1a07005 	mov	r7, r5
  hdr_chars = 0;
33d19420:	e1a06005 	mov	r6, r5

  if (xyz.tx_ack)
33d19424:	0a000004 	beq	33d1943c <xyzModem_get_hdr+0x38>
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d19428:	e5943000 	ldr	r3, [r4]
33d1942c:	e3a01006 	mov	r1, #6	; 0x6
33d19430:	e5d30000 	ldrb	r0, [r3]
33d19434:	ebffff95 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
      xyz.tx_ack = false;
33d19438:	e5845430 	str	r5, [r4, #1072]
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
33d1943c:	e59f4288 	ldr	r4, [pc, #648]	; 33d196cc <xyzModem_get_hdr+0x2c8>
33d19440:	e5943000 	ldr	r3, [r4]
33d19444:	e28da003 	add	sl, sp, #3	; 0x3
33d19448:	e5d30000 	ldrb	r0, [r3]
33d1944c:	e1a0100a 	mov	r1, sl
33d19450:	ebffff77 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
33d19454:	e3500000 	cmp	r0, #0	; 0x0
33d19458:	0a000026 	beq	33d194f8 <xyzModem_get_hdr+0xf4>
	{
	  hdr_chars++;
	  switch (c)
33d1945c:	e5dd2003 	ldrb	r2, [sp, #3]
33d19460:	e20230ff 	and	r3, r2, #255	; 0xff
33d19464:	e3530002 	cmp	r3, #2	; 0x2
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  hdr_chars++;
33d19468:	e2866001 	add	r6, r6, #1	; 0x1
	  switch (c)
33d1946c:	0a00000d 	beq	33d194a8 <xyzModem_get_hdr+0xa4>
33d19470:	ca000002 	bgt	33d19480 <xyzModem_get_hdr+0x7c>
33d19474:	e3530001 	cmp	r3, #1	; 0x1
33d19478:	0a000005 	beq	33d19494 <xyzModem_get_hdr+0x90>
33d1947c:	ea000021 	b	33d19508 <xyzModem_get_hdr+0x104>
33d19480:	e3530004 	cmp	r3, #4	; 0x4
33d19484:	0a000013 	beq	33d194d8 <xyzModem_get_hdr+0xd4>
33d19488:	e3530018 	cmp	r3, #24	; 0x18
33d1948c:	0a000009 	beq	33d194b8 <xyzModem_get_hdr+0xb4>
33d19490:	ea00001c 	b	33d19508 <xyzModem_get_hdr+0x104>
	    {
	    case SOH:
	      xyz.total_SOH++;
33d19494:	e594341c 	ldr	r3, [r4, #1052]
	    case STX:
	      if (c == STX)
33d19498:	e3520002 	cmp	r2, #2	; 0x2
	{
	  hdr_chars++;
	  switch (c)
	    {
	    case SOH:
	      xyz.total_SOH++;
33d1949c:	e2833001 	add	r3, r3, #1	; 0x1
33d194a0:	e584341c 	str	r3, [r4, #1052]
	    case STX:
	      if (c == STX)
33d194a4:	1a000019 	bne	33d19510 <xyzModem_get_hdr+0x10c>
		xyz.total_STX++;
33d194a8:	e5943420 	ldr	r3, [r4, #1056]
33d194ac:	e2833001 	add	r3, r3, #1	; 0x1
33d194b0:	e5843420 	str	r3, [r4, #1056]
	      hdr_found = true;
	      break;
33d194b4:	ea000015 	b	33d19510 <xyzModem_get_hdr+0x10c>
	    case CAN:
	      xyz.total_CAN++;
33d194b8:	e5943424 	ldr	r3, [r4, #1060]
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
33d194bc:	e2877001 	add	r7, r7, #1	; 0x1
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
33d194c0:	e2833001 	add	r3, r3, #1	; 0x1
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
33d194c4:	e3570003 	cmp	r7, #3	; 0x3
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
33d194c8:	e5843424 	str	r3, [r4, #1060]
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
33d194cc:	1a00000d 	bne	33d19508 <xyzModem_get_hdr+0x104>
		{
		  return xyzModem_cancel;
33d194d0:	e3e00004 	mvn	r0, #4	; 0x4
33d194d4:	ea00007a 	b	33d196c4 <xyzModem_get_hdr+0x2c0>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
33d194d8:	e3560001 	cmp	r6, #1	; 0x1
33d194dc:	1a000009 	bne	33d19508 <xyzModem_get_hdr+0x104>
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d194e0:	e5943000 	ldr	r3, [r4]
33d194e4:	e3a01006 	mov	r1, #6	; 0x6
33d194e8:	e5d30000 	ldrb	r0, [r3]
33d194ec:	ebffff67 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
33d194f0:	e3e00003 	mvn	r0, #3	; 0x3
33d194f4:	ea000072 	b	33d196c4 <xyzModem_get_hdr+0x2c0>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
33d194f8:	ebffffb5 	bl	33d193d4 <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
33d194fc:	e59f01cc 	ldr	r0, [pc, #460]	; 33d196d0 <xyzModem_get_hdr+0x2cc>
33d19500:	ebff9e41 	bl	33d00e0c <udelay>
33d19504:	ea00006b 	b	33d196b8 <xyzModem_get_hdr+0x2b4>
	  return xyzModem_timeout;
33d19508:	e3550000 	cmp	r5, #0	; 0x0
33d1950c:	0affffca 	beq	33d1943c <xyzModem_get_hdr+0x38>
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
33d19510:	e59f51b4 	ldr	r5, [pc, #436]	; 33d196cc <xyzModem_get_hdr+0x2c8>
33d19514:	e5953000 	ldr	r3, [r5]
33d19518:	e2851b01 	add	r1, r5, #1024	; 0x400
33d1951c:	e5d30000 	ldrb	r0, [r3]
33d19520:	e2811008 	add	r1, r1, #8	; 0x8
33d19524:	ebffff42 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
33d19528:	e3500000 	cmp	r0, #0	; 0x0
33d1952c:	0a000031 	beq	33d195f8 <xyzModem_get_hdr+0x1f4>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
33d19530:	e5953000 	ldr	r3, [r5]
33d19534:	e2851b01 	add	r1, r5, #1024	; 0x400
33d19538:	e5d30000 	ldrb	r0, [r3]
33d1953c:	e2811009 	add	r1, r1, #9	; 0x9
33d19540:	ebffff3b 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
33d19544:	e3500000 	cmp	r0, #0	; 0x0
33d19548:	0a00002a 	beq	33d195f8 <xyzModem_get_hdr+0x1f4>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
33d1954c:	e5dd3003 	ldrb	r3, [sp, #3]
33d19550:	e3530001 	cmp	r3, #1	; 0x1
33d19554:	13a03b01 	movne	r3, #1024	; 0x400
33d19558:	03a03080 	moveq	r3, #128	; 0x80
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
33d1955c:	e3a04000 	mov	r4, #0	; 0x0
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
33d19560:	e2852004 	add	r2, r5, #4	; 0x4
  for (i = 0; i < xyz.len; i++)
33d19564:	e1540003 	cmp	r4, r3
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
33d19568:	e1a01005 	mov	r1, r5
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
33d1956c:	e5853410 	str	r3, [r5, #1040]
  xyz.bufp = xyz.pkt;
33d19570:	e5852404 	str	r2, [r5, #1028]
  for (i = 0; i < xyz.len; i++)
33d19574:	aa00000d 	bge	33d195b0 <xyzModem_get_hdr+0x1ac>
33d19578:	e1a05002 	mov	r5, r2
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
33d1957c:	e5913000 	ldr	r3, [r1]
33d19580:	e1a0100a 	mov	r1, sl
33d19584:	e5d30000 	ldrb	r0, [r3]
33d19588:	ebffff29 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
33d1958c:	e3500000 	cmp	r0, #0	; 0x0
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
33d19590:	e2844001 	add	r4, r4, #1	; 0x1
33d19594:	e59f1130 	ldr	r1, [pc, #304]	; 33d196cc <xyzModem_get_hdr+0x2c8>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
33d19598:	0a000046 	beq	33d196b8 <xyzModem_get_hdr+0x2b4>
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
33d1959c:	e5913410 	ldr	r3, [r1, #1040]
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
33d195a0:	e5dd2003 	ldrb	r2, [sp, #3]
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
33d195a4:	e1540003 	cmp	r4, r3
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
33d195a8:	e4c52001 	strb	r2, [r5], #1
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
33d195ac:	bafffff2 	blt	33d1957c <xyzModem_get_hdr+0x178>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
33d195b0:	e59f5114 	ldr	r5, [pc, #276]	; 33d196cc <xyzModem_get_hdr+0x2c8>
33d195b4:	e5953000 	ldr	r3, [r5]
33d195b8:	e2851b01 	add	r1, r5, #1024	; 0x400
33d195bc:	e5d30000 	ldrb	r0, [r3]
33d195c0:	e281100a 	add	r1, r1, #10	; 0xa
33d195c4:	ebffff1a 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
33d195c8:	e3500000 	cmp	r0, #0	; 0x0
33d195cc:	0a000009 	beq	33d195f8 <xyzModem_get_hdr+0x1f4>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
33d195d0:	e5953428 	ldr	r3, [r5, #1064]
33d195d4:	e3530000 	cmp	r3, #0	; 0x0
33d195d8:	0a000008 	beq	33d19600 <xyzModem_get_hdr+0x1fc>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
33d195dc:	e5953000 	ldr	r3, [r5]
33d195e0:	e2851b01 	add	r1, r5, #1024	; 0x400
33d195e4:	e5d30000 	ldrb	r0, [r3]
33d195e8:	e281100b 	add	r1, r1, #11	; 0xb
33d195ec:	ebffff10 	bl	33d19234 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
33d195f0:	e3500000 	cmp	r0, #0	; 0x0
33d195f4:	1a000001 	bne	33d19600 <xyzModem_get_hdr+0x1fc>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
33d195f8:	e2400003 	sub	r0, r0, #3	; 0x3
33d195fc:	ea000030 	b	33d196c4 <xyzModem_get_hdr+0x2c0>
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
33d19600:	e59f30cc 	ldr	r3, [pc, #204]	; 33d196d4 <xyzModem_get_hdr+0x2d0>
33d19604:	e59f20cc 	ldr	r2, [pc, #204]	; 33d196d8 <xyzModem_get_hdr+0x2d4>
33d19608:	e7d53003 	ldrb	r3, [r5, r3]
33d1960c:	e7d52002 	ldrb	r2, [r5, r2]
33d19610:	e0233002 	eor	r3, r3, r2
33d19614:	e35300ff 	cmp	r3, #255	; 0xff
33d19618:	e59f40ac 	ldr	r4, [pc, #172]	; 33d196cc <xyzModem_get_hdr+0x2c8>
33d1961c:	0a000002 	beq	33d1962c <xyzModem_get_hdr+0x228>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
33d19620:	ebffff6b 	bl	33d193d4 <xyzModem_flush>
      return xyzModem_frame;
33d19624:	e3e00005 	mvn	r0, #5	; 0x5
33d19628:	ea000025 	b	33d196c4 <xyzModem_get_hdr+0x2c0>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
33d1962c:	e5943428 	ldr	r3, [r4, #1064]
33d19630:	e3530000 	cmp	r3, #0	; 0x0
33d19634:	e5941410 	ldr	r1, [r4, #1040]
33d19638:	0a00000a 	beq	33d19668 <xyzModem_get_hdr+0x264>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
33d1963c:	e2840004 	add	r0, r4, #4	; 0x4
33d19640:	eb0001a1 	bl	33d19ccc <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
33d19644:	e59f3090 	ldr	r3, [pc, #144]	; 33d196dc <xyzModem_get_hdr+0x2d8>
33d19648:	e7d42003 	ldrb	r2, [r4, r3]
33d1964c:	e2433001 	sub	r3, r3, #1	; 0x1
33d19650:	e7d43003 	ldrb	r3, [r4, r3]
      return xyzModem_frame;
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
33d19654:	e1a00800 	lsl	r0, r0, #16
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
33d19658:	e1822403 	orr	r2, r2, r3, lsl #8
33d1965c:	e1520820 	cmp	r2, r0, lsr #16
33d19660:	0a000016 	beq	33d196c0 <xyzModem_get_hdr+0x2bc>
33d19664:	ea000011 	b	33d196b0 <xyzModem_get_hdr+0x2ac>
	  return xyzModem_cksum;
	}
    }
  else
    {
      cksum = 0;
33d19668:	e1a00003 	mov	r0, r3
      for (i = 0; i < xyz.len; i++)
33d1966c:	e1530001 	cmp	r3, r1
33d19670:	e1a04003 	mov	r4, r3
33d19674:	aa000007 	bge	33d19698 <xyzModem_get_hdr+0x294>
	{
	  cksum += xyz.pkt[i];
33d19678:	e0843005 	add	r3, r4, r5
33d1967c:	e5d33004 	ldrb	r3, [r3, #4]
33d19680:	e0803003 	add	r3, r0, r3
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
33d19684:	e2844001 	add	r4, r4, #1	; 0x1
	{
	  cksum += xyz.pkt[i];
33d19688:	e1a03803 	lsl	r3, r3, #16
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
33d1968c:	e1540001 	cmp	r4, r1
	{
	  cksum += xyz.pkt[i];
33d19690:	e1a00823 	lsr	r0, r3, #16
33d19694:	eafffff6 	b	33d19674 <xyzModem_get_hdr+0x270>
	}
      if (xyz.crc1 != (cksum & 0xFF))
33d19698:	e59f3040 	ldr	r3, [pc, #64]	; 33d196e0 <xyzModem_get_hdr+0x2dc>
33d1969c:	e59f2028 	ldr	r2, [pc, #40]	; 33d196cc <xyzModem_get_hdr+0x2c8>
33d196a0:	e7d22003 	ldrb	r2, [r2, r3]
33d196a4:	e20030ff 	and	r3, r0, #255	; 0xff
33d196a8:	e1520003 	cmp	r2, r3
33d196ac:	0a000003 	beq	33d196c0 <xyzModem_get_hdr+0x2bc>
	{
	  ZM_DEBUG (zm_dprintf
		    ("Checksum error - recvd: %x, computed: %x\n", xyz.crc1,
		     cksum & 0xFF));
	  return xyzModem_cksum;
33d196b0:	e3e00006 	mvn	r0, #6	; 0x6
33d196b4:	ea000002 	b	33d196c4 <xyzModem_get_hdr+0x2c0>
	  xyz.pkt[i] = c;
	}
      else
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
33d196b8:	e3e00002 	mvn	r0, #2	; 0x2
33d196bc:	ea000000 	b	33d196c4 <xyzModem_get_hdr+0x2c0>
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
33d196c0:	e3a00000 	mov	r0, #0	; 0x0
}
33d196c4:	e28dd004 	add	sp, sp, #4	; 0x4
33d196c8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d196cc:	33d60c6c 	.word	0x33d60c6c
33d196d0:	0003d090 	.word	0x0003d090
33d196d4:	00000408 	.word	0x00000408
33d196d8:	00000409 	.word	0x00000409
33d196dc:	0000040b 	.word	0x0000040b
33d196e0:	0000040a 	.word	0x0000040a

33d196e4 <xyzModem_stream_open>:

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
33d196e4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy;
  xyz.__chan = &dummy;
33d196e8:	e59f4150 	ldr	r4, [pc, #336]	; 33d19840 <xyzModem_stream_open+0x15c>
xyzModem_stream_open (connection_info_t * info, int *err)
{
#ifdef REDBOOT
  int console_chan;
#endif
  int stat = 0;
33d196ec:	e3a05000 	mov	r5, #0	; 0x0
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
33d196f0:	e24dd004 	sub	sp, sp, #4	; 0x4
/* TODO: CHECK ! */
  int dummy;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
33d196f4:	e3a03001 	mov	r3, #1	; 0x1
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy;
  xyz.__chan = &dummy;
33d196f8:	e584d000 	str	sp, [r4]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
33d196fc:	e5843428 	str	r3, [r4, #1064]
#else
/* TODO: CHECK ! */
  int dummy;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
33d19700:	e5845410 	str	r5, [r4, #1040]
  xyz.crc_mode = true;
  xyz.at_eof = false;
33d19704:	e584542c 	str	r5, [r4, #1068]
  xyz.tx_ack = false;
33d19708:	e5845430 	str	r5, [r4, #1072]
  xyz.mode = info->mode;
33d1970c:	e5903004 	ldr	r3, [r0, #4]
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
33d19710:	e1a0a001 	mov	sl, r1
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
33d19714:	e5dd0000 	ldrb	r0, [sp]
33d19718:	e3a01043 	mov	r1, #67	; 0x43
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
33d1971c:	e5843414 	str	r3, [r4, #1044]
  xyz.total_retries = 0;
33d19720:	e5845418 	str	r5, [r4, #1048]
  xyz.total_SOH = 0;
33d19724:	e584541c 	str	r5, [r4, #1052]
  xyz.total_STX = 0;
33d19728:	e5845420 	str	r5, [r4, #1056]
  xyz.total_CAN = 0;
33d1972c:	e5845424 	str	r5, [r4, #1060]
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
33d19730:	e5845438 	str	r5, [r4, #1080]
  xyz.file_length = 0;
33d19734:	e5845434 	str	r5, [r4, #1076]
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
33d19738:	ebfffed4 	bl	33d19290 <CYGACC_COMM_IF_PUTC>

  if (xyz.mode == xyzModem_xmodem)
33d1973c:	e5942414 	ldr	r2, [r4, #1044]
33d19740:	e3520001 	cmp	r2, #1	; 0x1
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
33d19744:	059f30f8 	ldreq	r3, [pc, #248]	; 33d19844 <xyzModem_stream_open+0x160>
#ifdef REDBOOT
  int console_chan;
#endif
  int stat = 0;
  int retries = xyzModem_MAX_RETRIES;
  int crc_retries = xyzModem_MAX_RETRIES_WITH_CRC;
33d19748:	e3a0700a 	mov	r7, #10	; 0xa

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
      return 0;
33d1974c:	01a0c005 	moveq	ip, r5
  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
33d19750:	07c42003 	strbeq	r2, [r4, r3]
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
33d19754:	0a000036 	beq	33d19834 <xyzModem_stream_open+0x150>
	  xyz.total_retries++;
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
	{
	  break;
33d19758:	e3a06013 	mov	r6, #19	; 0x13
      return 0;
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
33d1975c:	ebffff28 	bl	33d19404 <xyzModem_get_hdr>
      if (stat == 0)
33d19760:	e2505000 	subs	r5, r0, #0	; 0x0
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
33d19764:	e59f40d4 	ldr	r4, [pc, #212]	; 33d19840 <xyzModem_stream_open+0x15c>
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
33d19768:	e59f00d8 	ldr	r0, [pc, #216]	; 33d19848 <xyzModem_stream_open+0x164>
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
      if (stat == 0)
33d1976c:	1a000016 	bne	33d197cc <xyzModem_stream_open+0xe8>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
33d19770:	e59f30d4 	ldr	r3, [pc, #212]	; 33d1984c <xyzModem_stream_open+0x168>
33d19774:	e7d43003 	ldrb	r3, [r4, r3]
33d19778:	e3530000 	cmp	r3, #0	; 0x0
33d1977c:	1a00000a 	bne	33d197ac <xyzModem_stream_open+0xc8>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
33d19780:	e5940404 	ldr	r0, [r4, #1028]
33d19784:	e4d03001 	ldrb	r3, [r0], #1
33d19788:	e20320ff 	and	r2, r3, #255	; 0xff
33d1978c:	e3520000 	cmp	r2, #0	; 0x0
33d19790:	e5840404 	str	r0, [r4, #1028]
33d19794:	1afffff9 	bne	33d19780 <xyzModem_stream_open+0x9c>
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
33d19798:	e59f30b0 	ldr	r3, [pc, #176]	; 33d19850 <xyzModem_stream_open+0x16c>
33d1979c:	e59f10b0 	ldr	r1, [pc, #176]	; 33d19854 <xyzModem_stream_open+0x170>
33d197a0:	ebfffebd 	bl	33d1929c <parse_num>
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
33d197a4:	e3a03001 	mov	r3, #1	; 0x1
33d197a8:	e5843430 	str	r3, [r4, #1072]
	    }
	  xyz.next_blk = 1;
33d197ac:	e59f008c 	ldr	r0, [pc, #140]	; 33d19840 <xyzModem_stream_open+0x15c>
	  xyz.len = 0;
33d197b0:	e3a01000 	mov	r1, #0	; 0x0
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
33d197b4:	e59f3088 	ldr	r3, [pc, #136]	; 33d19844 <xyzModem_stream_open+0x160>
33d197b8:	e3a02001 	mov	r2, #1	; 0x1
	  xyz.len = 0;
	  return 0;
33d197bc:	e1a0c001 	mov	ip, r1
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
33d197c0:	e7c02003 	strb	r2, [r0, r3]
	  xyz.len = 0;
33d197c4:	e5801410 	str	r1, [r0, #1040]
	  return 0;
33d197c8:	ea000019 	b	33d19834 <xyzModem_stream_open+0x150>
	}
      else if (stat == xyzModem_timeout)
33d197cc:	e3750003 	cmn	r5, #3	; 0x3
33d197d0:	1a000010 	bne	33d19818 <xyzModem_stream_open+0x134>
	{
	  if (--crc_retries <= 0)
33d197d4:	e2477001 	sub	r7, r7, #1	; 0x1
33d197d8:	e3570000 	cmp	r7, #0	; 0x0
	    xyz.crc_mode = false;
33d197dc:	d59f305c 	ldrle	r3, [pc, #92]	; 33d19840 <xyzModem_stream_open+0x15c>
33d197e0:	d3a02000 	movle	r2, #0	; 0x0
33d197e4:	d5832428 	strle	r2, [r3, #1064]
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
33d197e8:	ebff9d87 	bl	33d00e0c <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
33d197ec:	e5941428 	ldr	r1, [r4, #1064]
33d197f0:	e5943000 	ldr	r3, [r4]
33d197f4:	e3510000 	cmp	r1, #0	; 0x0
33d197f8:	e5d30000 	ldrb	r0, [r3]
33d197fc:	03a01015 	moveq	r1, #21	; 0x15
33d19800:	13a01043 	movne	r1, #67	; 0x43
33d19804:	ebfffea1 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  xyz.total_retries++;
33d19808:	e5943418 	ldr	r3, [r4, #1048]
33d1980c:	e2833001 	add	r3, r3, #1	; 0x1
33d19810:	e5843418 	str	r3, [r4, #1048]
33d19814:	ea000001 	b	33d19820 <xyzModem_stream_open+0x13c>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
33d19818:	e3750005 	cmn	r5, #5	; 0x5
33d1981c:	0a000002 	beq	33d1982c <xyzModem_stream_open+0x148>
	{
	  break;
33d19820:	e3560000 	cmp	r6, #0	; 0x0
33d19824:	e2466001 	sub	r6, r6, #1	; 0x1
33d19828:	caffffcb 	bgt	33d1975c <xyzModem_stream_open+0x78>
	}
    }
  *err = stat;
33d1982c:	e58a5000 	str	r5, [sl]
  ZM_DEBUG (zm_flush ());
  return -1;
33d19830:	e3e0c000 	mvn	ip, #0	; 0x0
}
33d19834:	e1a0000c 	mov	r0, ip
33d19838:	e28dd004 	add	sp, sp, #4	; 0x4
33d1983c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d19840:	33d60c6c 	.word	0x33d60c6c
33d19844:	0000040c 	.word	0x0000040c
33d19848:	0007a120 	.word	0x0007a120
33d1984c:	00000408 	.word	0x00000408
33d19850:	33d25a00 	.word	0x33d25a00
33d19854:	33d610a0 	.word	0x33d610a0

33d19858 <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
33d19858:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
	  xyz.bufp += len;
33d1985c:	e59fc290 	ldr	ip, [pc, #656]	; 33d19af4 <xyzModem_stream_read+0x29c>
33d19860:	e59c342c 	ldr	r3, [ip, #1068]
33d19864:	e2733001 	rsbs	r3, r3, #1	; 0x1
33d19868:	33a03000 	movcc	r3, #0	; 0x0
33d1986c:	e3510000 	cmp	r1, #0	; 0x0
33d19870:	d3a03000 	movle	r3, #0	; 0x0
33d19874:	e1a07001 	mov	r7, r1
33d19878:	e3530000 	cmp	r3, #0	; 0x0
  return -1;
}

int
xyzModem_stream_read (char *buf, int size, int *err)
{
33d1987c:	e1a0a000 	mov	sl, r0
33d19880:	e1a0b002 	mov	fp, r2
  int stat, total, len;
  int retries;

  total = 0;
33d19884:	e3a09000 	mov	r9, #0	; 0x0
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
	  xyz.bufp += len;
33d19888:	0a000097 	beq	33d19aec <xyzModem_stream_read+0x294>
  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
    {
      if (xyz.len == 0)
33d1988c:	e59c3410 	ldr	r3, [ip, #1040]
33d19890:	e3530000 	cmp	r3, #0	; 0x0
33d19894:	1a000078 	bne	33d19a7c <xyzModem_stream_read+0x224>
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
33d19898:	e3a06013 	mov	r6, #19	; 0x13
      if (xyz.len == 0)
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
33d1989c:	ebfffed8 	bl	33d19404 <xyzModem_get_hdr>
	      if (stat == 0)
33d198a0:	e2505000 	subs	r5, r0, #0	; 0x0
		{
		  if (xyz.blk == xyz.next_blk)
33d198a4:	e59fc248 	ldr	ip, [pc, #584]	; 33d19af4 <xyzModem_stream_read+0x29c>
33d198a8:	e59f4248 	ldr	r4, [pc, #584]	; 33d19af8 <xyzModem_stream_read+0x2a0>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
33d198ac:	1a000040 	bne	33d199b4 <xyzModem_stream_read+0x15c>
		{
		  if (xyz.blk == xyz.next_blk)
33d198b0:	e59f3244 	ldr	r3, [pc, #580]	; 33d19afc <xyzModem_stream_read+0x2a4>
33d198b4:	e7dce004 	ldrb	lr, [ip, r4]
33d198b8:	e7dc0003 	ldrb	r0, [ip, r3]
33d198bc:	e20e20ff 	and	r2, lr, #255	; 0xff
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
33d198c0:	e2423001 	sub	r3, r2, #1	; 0x1
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
33d198c4:	e1500002 	cmp	r0, r2
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d198c8:	e3a01006 	mov	r1, #6	; 0x6
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
33d198cc:	e20330ff 	and	r3, r3, #255	; 0xff
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
33d198d0:	1a000030 	bne	33d19998 <xyzModem_stream_read+0x140>
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
33d198d4:	e59c3414 	ldr	r3, [ip, #1044]
33d198d8:	e3530001 	cmp	r3, #1	; 0x1
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
33d198dc:	e28e3001 	add	r3, lr, #1	; 0x1
33d198e0:	e7cc3004 	strb	r3, [ip, r4]
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
33d198e4:	e3a03001 	mov	r3, #1	; 0x1
33d198e8:	e58c3430 	str	r3, [ip, #1072]
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
33d198ec:	0a000002 	beq	33d198fc <xyzModem_stream_read+0xa4>
33d198f0:	e59c3434 	ldr	r3, [ip, #1076]
33d198f4:	e3530000 	cmp	r3, #0	; 0x0
33d198f8:	1a000016 	bne	33d19958 <xyzModem_stream_read+0x100>
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
33d198fc:	e59c0404 	ldr	r0, [ip, #1028]
33d19900:	e59c1410 	ldr	r1, [ip, #1040]
33d19904:	e0802001 	add	r2, r0, r1
33d19908:	e5523001 	ldrb	r3, [r2, #-1]
33d1990c:	e353001a 	cmp	r3, #26	; 0x1a
33d19910:	1a000010 	bne	33d19958 <xyzModem_stream_read+0x100>
33d19914:	e5523002 	ldrb	r3, [r2, #-2]
33d19918:	e353001a 	cmp	r3, #26	; 0x1a
33d1991c:	1a00000d 	bne	33d19958 <xyzModem_stream_read+0x100>
33d19920:	e5523003 	ldrb	r3, [r2, #-3]
33d19924:	e353001a 	cmp	r3, #26	; 0x1a
33d19928:	1a00000a 	bne	33d19958 <xyzModem_stream_read+0x100>
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
33d1992c:	e3510000 	cmp	r1, #0	; 0x0
33d19930:	0a000008 	beq	33d19958 <xyzModem_stream_read+0x100>
33d19934:	e59c3410 	ldr	r3, [ip, #1040]
33d19938:	e2433001 	sub	r3, r3, #1	; 0x1
33d1993c:	e3530000 	cmp	r3, #0	; 0x0
33d19940:	e0802003 	add	r2, r0, r3
33d19944:	e58c3410 	str	r3, [ip, #1040]
33d19948:	0a000002 	beq	33d19958 <xyzModem_stream_read+0x100>
33d1994c:	e5523001 	ldrb	r3, [r2, #-1]
33d19950:	e353001a 	cmp	r3, #26	; 0x1a
33d19954:	0afffff6 	beq	33d19934 <xyzModem_stream_read+0xdc>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
33d19958:	e59f1194 	ldr	r1, [pc, #404]	; 33d19af4 <xyzModem_stream_read+0x29c>
33d1995c:	e5913414 	ldr	r3, [r1, #1044]
33d19960:	e3530001 	cmp	r3, #1	; 0x1
33d19964:	0a000044 	beq	33d19a7c <xyzModem_stream_read+0x224>
33d19968:	e5912434 	ldr	r2, [r1, #1076]
33d1996c:	e3520000 	cmp	r2, #0	; 0x0
33d19970:	0a000041 	beq	33d19a7c <xyzModem_stream_read+0x224>
			{
			  xyz.read_length += xyz.len;
33d19974:	e5910410 	ldr	r0, [r1, #1040]
33d19978:	e5913438 	ldr	r3, [r1, #1080]
33d1997c:	e0833000 	add	r3, r3, r0
			  if (xyz.read_length > xyz.file_length)
33d19980:	e1530002 	cmp	r3, r2
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
			{
			  xyz.read_length += xyz.len;
33d19984:	e5813438 	str	r3, [r1, #1080]
			  if (xyz.read_length > xyz.file_length)
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
33d19988:	80623003 	rsbhi	r3, r2, r3
33d1998c:	80633000 	rsbhi	r3, r3, r0
33d19990:	85813410 	strhi	r3, [r1, #1040]
33d19994:	ea000038 	b	33d19a7c <xyzModem_stream_read+0x224>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
33d19998:	e1500003 	cmp	r0, r3
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
33d1999c:	13e05007 	mvnne	r5, #7	; 0x7
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
33d199a0:	1a000005 	bne	33d199bc <xyzModem_stream_read+0x164>
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d199a4:	e59c3000 	ldr	r3, [ip]
33d199a8:	e5d30000 	ldrb	r0, [r3]
33d199ac:	ebfffe37 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
		      continue;	/* Need new header */
33d199b0:	ea000028 	b	33d19a58 <xyzModem_stream_read+0x200>
		  else
		    {
		      stat = xyzModem_sequence;
		    }
		}
	      if (stat == xyzModem_cancel)
33d199b4:	e3750005 	cmn	r5, #5	; 0x5
33d199b8:	0a000029 	beq	33d19a64 <xyzModem_stream_read+0x20c>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
33d199bc:	e3750004 	cmn	r5, #4	; 0x4
33d199c0:	e59f412c 	ldr	r4, [pc, #300]	; 33d19af4 <xyzModem_stream_read+0x29c>
33d199c4:	1a000019 	bne	33d19a30 <xyzModem_stream_read+0x1d8>
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d199c8:	e5943000 	ldr	r3, [r4]
33d199cc:	e3a01006 	mov	r1, #6	; 0x6
33d199d0:	e5d30000 	ldrb	r0, [r3]
33d199d4:	ebfffe2d 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
33d199d8:	e5943414 	ldr	r3, [r4, #1044]
33d199dc:	e3530002 	cmp	r3, #2	; 0x2
33d199e0:	1a00000f 	bne	33d19a24 <xyzModem_stream_read+0x1cc>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
33d199e4:	e5941428 	ldr	r1, [r4, #1064]
33d199e8:	e5943000 	ldr	r3, [r4]
33d199ec:	e3510000 	cmp	r1, #0	; 0x0
33d199f0:	03a01015 	moveq	r1, #21	; 0x15
33d199f4:	13a01043 	movne	r1, #67	; 0x43
33d199f8:	e5d30000 	ldrb	r0, [r3]
33d199fc:	ebfffe23 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
33d19a00:	e5943418 	ldr	r3, [r4, #1048]
33d19a04:	e2833001 	add	r3, r3, #1	; 0x1
33d19a08:	e5843418 	str	r3, [r4, #1048]
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
33d19a0c:	ebfffe7c 	bl	33d19404 <xyzModem_get_hdr>
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d19a10:	e5943000 	ldr	r3, [r4]
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
33d19a14:	e1a05000 	mov	r5, r0
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
33d19a18:	e3a01006 	mov	r1, #6	; 0x6
33d19a1c:	e5d30000 	ldrb	r0, [r3]
33d19a20:	ebfffe1a 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
33d19a24:	e3a03001 	mov	r3, #1	; 0x1
33d19a28:	e584342c 	str	r3, [r4, #1068]
		  break;
33d19a2c:	ea00000c 	b	33d19a64 <xyzModem_stream_read+0x20c>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
33d19a30:	e5941428 	ldr	r1, [r4, #1064]
33d19a34:	e5943000 	ldr	r3, [r4]
33d19a38:	e3510000 	cmp	r1, #0	; 0x0
33d19a3c:	e5d30000 	ldrb	r0, [r3]
33d19a40:	03a01015 	moveq	r1, #21	; 0x15
33d19a44:	13a01043 	movne	r1, #67	; 0x43
33d19a48:	ebfffe10 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	      xyz.total_retries++;
33d19a4c:	e5943418 	ldr	r3, [r4, #1048]
33d19a50:	e2833001 	add	r3, r3, #1	; 0x1
33d19a54:	e5843418 	str	r3, [r4, #1048]
33d19a58:	e3560000 	cmp	r6, #0	; 0x0
33d19a5c:	e2466001 	sub	r6, r6, #1	; 0x1
33d19a60:	caffff8d 	bgt	33d1989c <xyzModem_stream_read+0x44>
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
33d19a64:	e3550000 	cmp	r5, #0	; 0x0
	    {
	      *err = stat;
	      xyz.len = -1;
33d19a68:	b59f3084 	ldrlt	r3, [pc, #132]	; 33d19af4 <xyzModem_stream_read+0x29c>
33d19a6c:	b3e02000 	mvnlt	r2, #0	; 0x0
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
	    {
	      *err = stat;
33d19a70:	b58b5000 	strlt	r5, [fp]
	      xyz.len = -1;
33d19a74:	b5832410 	strlt	r2, [r3, #1040]
	      return total;
33d19a78:	ba00001b 	blt	33d19aec <xyzModem_stream_read+0x294>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
33d19a7c:	e59f5070 	ldr	r5, [pc, #112]	; 33d19af4 <xyzModem_stream_read+0x29c>
33d19a80:	e595342c 	ldr	r3, [r5, #1068]
33d19a84:	e3530000 	cmp	r3, #0	; 0x0
33d19a88:	1a00000f 	bne	33d19acc <xyzModem_stream_read+0x274>
	{
	  len = xyz.len;
33d19a8c:	e5954410 	ldr	r4, [r5, #1040]
	  if (size < len)
	    len = size;
33d19a90:	e1540007 	cmp	r4, r7
33d19a94:	a1a04007 	movge	r4, r7
	  memcpy (buf, xyz.bufp, len);
33d19a98:	e1a0000a 	mov	r0, sl
33d19a9c:	e1a02004 	mov	r2, r4
33d19aa0:	e5951404 	ldr	r1, [r5, #1028]
33d19aa4:	eb00024e 	bl	33d1a3e4 <memcpy>
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
33d19aa8:	e5953410 	ldr	r3, [r5, #1040]
	  xyz.bufp += len;
33d19aac:	e5952404 	ldr	r2, [r5, #1028]
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
33d19ab0:	e0643003 	rsb	r3, r4, r3
	  xyz.bufp += len;
33d19ab4:	e0822004 	add	r2, r2, r4
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
33d19ab8:	e5853410 	str	r3, [r5, #1040]
	  xyz.bufp += len;
33d19abc:	e5852404 	str	r2, [r5, #1028]
	{
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
33d19ac0:	e0647007 	rsb	r7, r4, r7
	  buf += len;
33d19ac4:	e08aa004 	add	sl, sl, r4
	  total += len;
33d19ac8:	e0899004 	add	r9, r9, r4
	  xyz.len -= len;
	  xyz.bufp += len;
33d19acc:	e595342c 	ldr	r3, [r5, #1068]
33d19ad0:	e2733001 	rsbs	r3, r3, #1	; 0x1
33d19ad4:	33a03000 	movcc	r3, #0	; 0x0
33d19ad8:	e3570000 	cmp	r7, #0	; 0x0
33d19adc:	d3a03000 	movle	r3, #0	; 0x0
33d19ae0:	e1a0c005 	mov	ip, r5
33d19ae4:	e3530000 	cmp	r3, #0	; 0x0
33d19ae8:	eaffff66 	b	33d19888 <xyzModem_stream_read+0x30>
	}
    }
  return total;
}
33d19aec:	e1a00009 	mov	r0, r9
33d19af0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d19af4:	33d60c6c 	.word	0x33d60c6c
33d19af8:	0000040c 	.word	0x0000040c
33d19afc:	00000408 	.word	0x00000408

33d19b00 <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
33d19b00:	e92d4010 	push	{r4, lr}
  diag_printf
33d19b04:	e59f103c 	ldr	r1, [pc, #60]	; 33d19b48 <xyzModem_stream_close+0x48>
33d19b08:	e591c428 	ldr	ip, [r1, #1064]
33d19b0c:	e59f0038 	ldr	r0, [pc, #56]	; 33d19b4c <xyzModem_stream_close+0x4c>
33d19b10:	e5914418 	ldr	r4, [r1, #1048]
33d19b14:	e591e424 	ldr	lr, [r1, #1060]
33d19b18:	e35c0000 	cmp	ip, #0	; 0x0
33d19b1c:	e591241c 	ldr	r2, [r1, #1052]
33d19b20:	e5913420 	ldr	r3, [r1, #1056]
  return total;
}

void
xyzModem_stream_close (int *err)
{
33d19b24:	e24dd008 	sub	sp, sp, #8	; 0x8
  diag_printf
33d19b28:	e59f1020 	ldr	r1, [pc, #32]	; 33d19b50 <xyzModem_stream_close+0x50>
33d19b2c:	01a01000 	moveq	r1, r0
33d19b30:	e59f001c 	ldr	r0, [pc, #28]	; 33d19b54 <xyzModem_stream_close+0x54>
33d19b34:	e58de000 	str	lr, [sp]
33d19b38:	e58d4004 	str	r4, [sp, #4]
33d19b3c:	ebfff521 	bl	33d16fc8 <printf>
33d19b40:	e28dd008 	add	sp, sp, #8	; 0x8
33d19b44:	e8bd8010 	pop	{r4, pc}
33d19b48:	33d60c6c 	.word	0x33d60c6c
33d19b4c:	33d2cd38 	.word	0x33d2cd38
33d19b50:	33d2cd40 	.word	0x33d2cd40
33d19b54:	33d2cd44 	.word	0x33d2cd44

33d19b58 <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
33d19b58:	e3500000 	cmp	r0, #0	; 0x0

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
33d19b5c:	e92d4010 	push	{r4, lr}
33d19b60:	e1a04001 	mov	r4, r1
  int c;

  if (abort)
33d19b64:	0a000028 	beq	33d19c0c <xyzModem_stream_terminate+0xb4>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
33d19b68:	e59f40b8 	ldr	r4, [pc, #184]	; 33d19c28 <xyzModem_stream_terminate+0xd0>
33d19b6c:	e5943414 	ldr	r3, [r4, #1044]
33d19b70:	e2433001 	sub	r3, r3, #1	; 0x1
33d19b74:	e3530001 	cmp	r3, #1	; 0x1
33d19b78:	88bd8010 	pophi	{r4, pc}
	{
	case xyzModem_xmodem:
	case xyzModem_ymodem:
	  /* The X/YMODEM Spec seems to suggest that multiple CAN followed by an equal */
	  /* number of Backspaces is a friendly way to get the other end to abort. */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
33d19b7c:	e5943000 	ldr	r3, [r4]
33d19b80:	e3a01018 	mov	r1, #24	; 0x18
33d19b84:	e5d30000 	ldrb	r0, [r3]
33d19b88:	ebfffdc0 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
33d19b8c:	e5943000 	ldr	r3, [r4]
33d19b90:	e3a01018 	mov	r1, #24	; 0x18
33d19b94:	e5d30000 	ldrb	r0, [r3]
33d19b98:	ebfffdbc 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
33d19b9c:	e5943000 	ldr	r3, [r4]
33d19ba0:	e3a01018 	mov	r1, #24	; 0x18
33d19ba4:	e5d30000 	ldrb	r0, [r3]
33d19ba8:	ebfffdb8 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
33d19bac:	e5943000 	ldr	r3, [r4]
33d19bb0:	e3a01018 	mov	r1, #24	; 0x18
33d19bb4:	e5d30000 	ldrb	r0, [r3]
33d19bb8:	ebfffdb4 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
33d19bbc:	e5943000 	ldr	r3, [r4]
33d19bc0:	e3a01008 	mov	r1, #8	; 0x8
33d19bc4:	e5d30000 	ldrb	r0, [r3]
33d19bc8:	ebfffdb0 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
33d19bcc:	e5943000 	ldr	r3, [r4]
33d19bd0:	e3a01008 	mov	r1, #8	; 0x8
33d19bd4:	e5d30000 	ldrb	r0, [r3]
33d19bd8:	ebfffdac 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
33d19bdc:	e5943000 	ldr	r3, [r4]
33d19be0:	e3a01008 	mov	r1, #8	; 0x8
33d19be4:	e5d30000 	ldrb	r0, [r3]
33d19be8:	ebfffda8 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
33d19bec:	e5943000 	ldr	r3, [r4]
33d19bf0:	e3a01008 	mov	r1, #8	; 0x8
33d19bf4:	e5d30000 	ldrb	r0, [r3]
33d19bf8:	ebfffda4 	bl	33d19290 <CYGACC_COMM_IF_PUTC>
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
33d19bfc:	ebfffdf4 	bl	33d193d4 <xyzModem_flush>
	  xyz.at_eof = true;
33d19c00:	e3a03001 	mov	r3, #1	; 0x1
33d19c04:	e584342c 	str	r3, [r4, #1068]
	  break;
33d19c08:	e8bd8010 	pop	{r4, pc}
       * previous recieved blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
33d19c0c:	e1a0e00f 	mov	lr, pc
33d19c10:	e1a0f004 	mov	pc, r4
33d19c14:	e3500000 	cmp	r0, #0	; 0x0
33d19c18:	aafffffb 	bge	33d19c0c <xyzModem_stream_terminate+0xb4>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
33d19c1c:	e59f0008 	ldr	r0, [pc, #8]	; 33d19c2c <xyzModem_stream_terminate+0xd4>
    }
}
33d19c20:	e8bd4010 	pop	{r4, lr}
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
33d19c24:	eaff9c78 	b	33d00e0c <udelay>
33d19c28:	33d60c6c 	.word	0x33d60c6c
33d19c2c:	0003d090 	.word	0x0003d090

33d19c30 <xyzModem_error>:
}

char *
xyzModem_error (int err)
{
  switch (err)
33d19c30:	e2800008 	add	r0, r0, #8	; 0x8
33d19c34:	e3500007 	cmp	r0, #7	; 0x7
33d19c38:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
33d19c3c:	ea000017 	b	33d19ca0 <xyzModem_error+0x70>
33d19c40:	33d19c98 	.word	0x33d19c98
33d19c44:	33d19c90 	.word	0x33d19c90
33d19c48:	33d19c88 	.word	0x33d19c88
33d19c4c:	33d19c80 	.word	0x33d19c80
33d19c50:	33d19c78 	.word	0x33d19c78
33d19c54:	33d19c70 	.word	0x33d19c70
33d19c58:	33d19c68 	.word	0x33d19c68
33d19c5c:	33d19c60 	.word	0x33d19c60
    {
    case xyzModem_access:
      return "Can't access file";
33d19c60:	e59f0040 	ldr	r0, [pc, #64]	; 33d19ca8 <xyzModem_error+0x78>
33d19c64:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_noZmodem:
      return "Sorry, zModem not available yet";
33d19c68:	e59f003c 	ldr	r0, [pc, #60]	; 33d19cac <xyzModem_error+0x7c>
33d19c6c:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_timeout:
      return "Timed out";
33d19c70:	e59f0038 	ldr	r0, [pc, #56]	; 33d19cb0 <xyzModem_error+0x80>
33d19c74:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_eof:
      return "End of file";
33d19c78:	e59f0034 	ldr	r0, [pc, #52]	; 33d19cb4 <xyzModem_error+0x84>
33d19c7c:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_cancel:
      return "Cancelled";
33d19c80:	e59f0030 	ldr	r0, [pc, #48]	; 33d19cb8 <xyzModem_error+0x88>
33d19c84:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_frame:
      return "Invalid framing";
33d19c88:	e59f002c 	ldr	r0, [pc, #44]	; 33d19cbc <xyzModem_error+0x8c>
33d19c8c:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_cksum:
      return "CRC/checksum error";
33d19c90:	e59f0028 	ldr	r0, [pc, #40]	; 33d19cc0 <xyzModem_error+0x90>
33d19c94:	e1a0f00e 	mov	pc, lr
      break;
    case xyzModem_sequence:
      return "Block sequence error";
33d19c98:	e59f0024 	ldr	r0, [pc, #36]	; 33d19cc4 <xyzModem_error+0x94>
33d19c9c:	e1a0f00e 	mov	pc, lr
      break;
    default:
      return "Unknown error";
33d19ca0:	e59f0020 	ldr	r0, [pc, #32]	; 33d19cc8 <xyzModem_error+0x98>
      break;
    }
}
33d19ca4:	e1a0f00e 	mov	pc, lr
33d19ca8:	33d2cd88 	.word	0x33d2cd88
33d19cac:	33d2cd9c 	.word	0x33d2cd9c
33d19cb0:	33d2cdbc 	.word	0x33d2cdbc
33d19cb4:	33d2cdc8 	.word	0x33d2cdc8
33d19cb8:	33d2cdd4 	.word	0x33d2cdd4
33d19cbc:	33d2cde0 	.word	0x33d2cde0
33d19cc0:	33d2cdf0 	.word	0x33d2cdf0
33d19cc4:	33d2ce04 	.word	0x33d2ce04
33d19cc8:	33d2ce1c 	.word	0x33d2ce1c

33d19ccc <cyg_crc16>:
cyg_crc16(unsigned char *buf, int len)
{
    int i;
    uint16_t cksum;

    cksum = 0;
33d19ccc:	e3a0c000 	mov	ip, #0	; 0x0
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
33d19cd0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
33d19cd4:	e15c0001 	cmp	ip, r1
33d19cd8:	e1a0e00c 	mov	lr, ip
33d19cdc:	aa00000a 	bge	33d19d0c <cyg_crc16+0x40>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
33d19ce0:	e4d03001 	ldrb	r3, [r0], #1
33d19ce4:	e59f2028 	ldr	r2, [pc, #40]	; 33d19d14 <cyg_crc16+0x48>
33d19ce8:	e023342c 	eor	r3, r3, ip, lsr #8
33d19cec:	e1a03083 	lsl	r3, r3, #1
33d19cf0:	e19330b2 	ldrh	r3, [r3, r2]
33d19cf4:	e023340c 	eor	r3, r3, ip, lsl #8
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
33d19cf8:	e28ee001 	add	lr, lr, #1	; 0x1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
33d19cfc:	e1a03803 	lsl	r3, r3, #16
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
33d19d00:	e15e0001 	cmp	lr, r1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
33d19d04:	e1a0c823 	lsr	ip, r3, #16
33d19d08:	eafffff3 	b	33d19cdc <cyg_crc16+0x10>
    }
    return cksum;
}
33d19d0c:	e1a0000c 	mov	r0, ip
33d19d10:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d19d14:	33d249dc 	.word	0x33d249dc

33d19d18 <crc32>:
/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
33d19d18:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
33d19d1c:	e3520007 	cmp	r2, #7	; 0x7
/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
33d19d20:	e1a0e002 	mov	lr, r2
33d19d24:	e1a0c001 	mov	ip, r1
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
33d19d28:	e1e00000 	mvn	r0, r0
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
33d19d2c:	9a00002b 	bls	33d19de0 <crc32+0xc8>
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
33d19d30:	e4dc3001 	ldrb	r3, [ip], #1
33d19d34:	e59f10d4 	ldr	r1, [pc, #212]	; 33d19e10 <crc32+0xf8>
33d19d38:	e0203003 	eor	r3, r0, r3
33d19d3c:	e20330ff 	and	r3, r3, #255	; 0xff
33d19d40:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19d44:	e4dc3001 	ldrb	r3, [ip], #1
33d19d48:	e0220420 	eor	r0, r2, r0, lsr #8
33d19d4c:	e0203003 	eor	r3, r0, r3
33d19d50:	e20330ff 	and	r3, r3, #255	; 0xff
33d19d54:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19d58:	e4dc3001 	ldrb	r3, [ip], #1
33d19d5c:	e0220420 	eor	r0, r2, r0, lsr #8
33d19d60:	e0203003 	eor	r3, r0, r3
33d19d64:	e20330ff 	and	r3, r3, #255	; 0xff
33d19d68:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19d6c:	e4dc3001 	ldrb	r3, [ip], #1
33d19d70:	e0220420 	eor	r0, r2, r0, lsr #8
33d19d74:	e0203003 	eor	r3, r0, r3
33d19d78:	e20330ff 	and	r3, r3, #255	; 0xff
33d19d7c:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19d80:	e4dc3001 	ldrb	r3, [ip], #1
33d19d84:	e0220420 	eor	r0, r2, r0, lsr #8
33d19d88:	e0203003 	eor	r3, r0, r3
33d19d8c:	e20330ff 	and	r3, r3, #255	; 0xff
33d19d90:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19d94:	e4dc3001 	ldrb	r3, [ip], #1
33d19d98:	e0220420 	eor	r0, r2, r0, lsr #8
33d19d9c:	e0203003 	eor	r3, r0, r3
33d19da0:	e20330ff 	and	r3, r3, #255	; 0xff
33d19da4:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19da8:	e4dc3001 	ldrb	r3, [ip], #1
33d19dac:	e0220420 	eor	r0, r2, r0, lsr #8
33d19db0:	e0203003 	eor	r3, r0, r3
33d19db4:	e20330ff 	and	r3, r3, #255	; 0xff
33d19db8:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19dbc:	e4dc3001 	ldrb	r3, [ip], #1
33d19dc0:	e0220420 	eor	r0, r2, r0, lsr #8
33d19dc4:	e0203003 	eor	r3, r0, r3
33d19dc8:	e20330ff 	and	r3, r3, #255	; 0xff
33d19dcc:	e7913103 	ldr	r3, [r1, r3, lsl #2]
      len -= 8;
33d19dd0:	e24ee008 	sub	lr, lr, #8	; 0x8
33d19dd4:	e35e0007 	cmp	lr, #7	; 0x7
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
33d19dd8:	e0230420 	eor	r0, r3, r0, lsr #8
33d19ddc:	eaffffd2 	b	33d19d2c <crc32+0x14>
      len -= 8;
    }
    if (len) do {
33d19de0:	e35e0000 	cmp	lr, #0	; 0x0
33d19de4:	0a000007 	beq	33d19e08 <crc32+0xf0>
      DO1(buf);
33d19de8:	e4dc3001 	ldrb	r3, [ip], #1
33d19dec:	e59f201c 	ldr	r2, [pc, #28]	; 33d19e10 <crc32+0xf8>
33d19df0:	e0203003 	eor	r3, r0, r3
33d19df4:	e20330ff 	and	r3, r3, #255	; 0xff
33d19df8:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    } while (--len);
33d19dfc:	e25ee001 	subs	lr, lr, #1	; 0x1
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
33d19e00:	e0230420 	eor	r0, r3, r0, lsr #8
    } while (--len);
33d19e04:	1afffff7 	bne	33d19de8 <crc32+0xd0>
    return crc ^ 0xffffffffL;
}
33d19e08:	e1e00000 	mvn	r0, r0
33d19e0c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d19e10:	33d24bdc 	.word	0x33d24bdc

33d19e14 <crc32_no_comp>:

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uLong ZEXPORT crc32_no_comp(uLong crc, const Bytef *buf, uInt len)
{
33d19e14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
      make_crc_table();
#endif
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
33d19e18:	e3520007 	cmp	r2, #7	; 0x7

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uLong ZEXPORT crc32_no_comp(uLong crc, const Bytef *buf, uInt len)
{
33d19e1c:	e1a0e002 	mov	lr, r2
33d19e20:	e1a0c001 	mov	ip, r1
      make_crc_table();
#endif
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
33d19e24:	9a00002b 	bls	33d19ed8 <crc32_no_comp+0xc4>
    if (crc_table_empty)
      make_crc_table();
#endif
    while (len >= 8)
    {
      DO8(buf);
33d19e28:	e4dc3001 	ldrb	r3, [ip], #1
33d19e2c:	e59f10d0 	ldr	r1, [pc, #208]	; 33d19f04 <crc32_no_comp+0xf0>
33d19e30:	e0203003 	eor	r3, r0, r3
33d19e34:	e20330ff 	and	r3, r3, #255	; 0xff
33d19e38:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19e3c:	e4dc3001 	ldrb	r3, [ip], #1
33d19e40:	e0220420 	eor	r0, r2, r0, lsr #8
33d19e44:	e0203003 	eor	r3, r0, r3
33d19e48:	e20330ff 	and	r3, r3, #255	; 0xff
33d19e4c:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19e50:	e4dc3001 	ldrb	r3, [ip], #1
33d19e54:	e0220420 	eor	r0, r2, r0, lsr #8
33d19e58:	e0203003 	eor	r3, r0, r3
33d19e5c:	e20330ff 	and	r3, r3, #255	; 0xff
33d19e60:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19e64:	e4dc3001 	ldrb	r3, [ip], #1
33d19e68:	e0220420 	eor	r0, r2, r0, lsr #8
33d19e6c:	e0203003 	eor	r3, r0, r3
33d19e70:	e20330ff 	and	r3, r3, #255	; 0xff
33d19e74:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19e78:	e4dc3001 	ldrb	r3, [ip], #1
33d19e7c:	e0220420 	eor	r0, r2, r0, lsr #8
33d19e80:	e0203003 	eor	r3, r0, r3
33d19e84:	e20330ff 	and	r3, r3, #255	; 0xff
33d19e88:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19e8c:	e4dc3001 	ldrb	r3, [ip], #1
33d19e90:	e0220420 	eor	r0, r2, r0, lsr #8
33d19e94:	e0203003 	eor	r3, r0, r3
33d19e98:	e20330ff 	and	r3, r3, #255	; 0xff
33d19e9c:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19ea0:	e4dc3001 	ldrb	r3, [ip], #1
33d19ea4:	e0220420 	eor	r0, r2, r0, lsr #8
33d19ea8:	e0203003 	eor	r3, r0, r3
33d19eac:	e20330ff 	and	r3, r3, #255	; 0xff
33d19eb0:	e7912103 	ldr	r2, [r1, r3, lsl #2]
33d19eb4:	e4dc3001 	ldrb	r3, [ip], #1
33d19eb8:	e0220420 	eor	r0, r2, r0, lsr #8
33d19ebc:	e0203003 	eor	r3, r0, r3
33d19ec0:	e20330ff 	and	r3, r3, #255	; 0xff
33d19ec4:	e7913103 	ldr	r3, [r1, r3, lsl #2]
      len -= 8;
33d19ec8:	e24ee008 	sub	lr, lr, #8	; 0x8
33d19ecc:	e35e0007 	cmp	lr, #7	; 0x7
    if (crc_table_empty)
      make_crc_table();
#endif
    while (len >= 8)
    {
      DO8(buf);
33d19ed0:	e0230420 	eor	r0, r3, r0, lsr #8
33d19ed4:	eaffffd2 	b	33d19e24 <crc32_no_comp+0x10>
      len -= 8;
    }
    if (len) do {
33d19ed8:	e35e0000 	cmp	lr, #0	; 0x0
33d19edc:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
      DO1(buf);
33d19ee0:	e4dc3001 	ldrb	r3, [ip], #1
33d19ee4:	e59f2018 	ldr	r2, [pc, #24]	; 33d19f04 <crc32_no_comp+0xf0>
33d19ee8:	e0203003 	eor	r3, r0, r3
33d19eec:	e20330ff 	and	r3, r3, #255	; 0xff
33d19ef0:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    } while (--len);
33d19ef4:	e25ee001 	subs	lr, lr, #1	; 0x1
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
33d19ef8:	e0230420 	eor	r0, r3, r0, lsr #8
    } while (--len);
33d19efc:	1afffff7 	bne	33d19ee0 <crc32_no_comp+0xcc>

    return crc;
}
33d19f00:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d19f04:	33d24bdc 	.word	0x33d24bdc

33d19f08 <display_options>:
 */

#include <common.h>

int display_options (void)
{
33d19f08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	extern char version_string[];

#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
33d19f0c:	e59f000c 	ldr	r0, [pc, #12]	; 33d19f20 <display_options+0x18>
33d19f10:	e59f100c 	ldr	r1, [pc, #12]	; 33d19f24 <display_options+0x1c>
33d19f14:	ebfff42b 	bl	33d16fc8 <printf>
#endif
	return 0;
}
33d19f18:	e3a00000 	mov	r0, #0	; 0x0
33d19f1c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d19f20:	33d2ce2c 	.word	0x33d2ce2c
33d19f24:	33d247f0 	.word	0x33d247f0

33d19f28 <print_size>:
{
	ulong m, n;
	ulong d = 1 << 20;		/* 1 MB */
	char  c = 'M';

	if (size < d) {			/* print in kB */
33d19f28:	e3500601 	cmp	r0, #1048576	; 0x100000
/*
 * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
 * allow for optional trailing string (like "\n")
 */
void print_size (ulong size, const char *s)
{
33d19f2c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong m, n;
	ulong d = 1 << 20;		/* 1 MB */
33d19f30:	e3a04601 	mov	r4, #1048576	; 0x100000
	char  c = 'M';

	if (size < d) {			/* print in kB */
		c = 'k';
		d = 1 << 10;
33d19f34:	33a04b01 	movcc	r4, #1024	; 0x400
/*
 * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
 * allow for optional trailing string (like "\n")
 */
void print_size (ulong size, const char *s)
{
33d19f38:	e1a07001 	mov	r7, r1
	ulong m, n;
	ulong d = 1 << 20;		/* 1 MB */
	char  c = 'M';
33d19f3c:	e3a0a04d 	mov	sl, #77	; 0x4d
	if (size < d) {			/* print in kB */
		c = 'k';
		d = 1 << 10;
	}

	n = size / d;
33d19f40:	e1a01004 	mov	r1, r4
	ulong m, n;
	ulong d = 1 << 20;		/* 1 MB */
	char  c = 'M';

	if (size < d) {			/* print in kB */
		c = 'k';
33d19f44:	328aa01e 	addcc	sl, sl, #30	; 0x1e
/*
 * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
 * allow for optional trailing string (like "\n")
 */
void print_size (ulong size, const char *s)
{
33d19f48:	e1a06000 	mov	r6, r0
	if (size < d) {			/* print in kB */
		c = 'k';
		d = 1 << 10;
	}

	n = size / d;
33d19f4c:	ebff9d23 	bl	33d013e0 <__udivsi3>
33d19f50:	e1a05000 	mov	r5, r0

	m = (10 * (size - (n * d)) + (d / 2) ) / d;
33d19f54:	e0000594 	mul	r0, r4, r5
33d19f58:	e0600006 	rsb	r0, r0, r6
33d19f5c:	e1a030a4 	lsr	r3, r4, #1
33d19f60:	e0800100 	add	r0, r0, r0, lsl #2
33d19f64:	e1a01004 	mov	r1, r4
33d19f68:	e0830080 	add	r0, r3, r0, lsl #1
33d19f6c:	ebff9d1b 	bl	33d013e0 <__udivsi3>
33d19f70:	e1a04000 	mov	r4, r0

	if (m >= 10) {
33d19f74:	e3540009 	cmp	r4, #9	; 0x9
		m -= 10;
		n += 1;
33d19f78:	82855001 	addhi	r5, r5, #1	; 0x1
	n = size / d;

	m = (10 * (size - (n * d)) + (d / 2) ) / d;

	if (m >= 10) {
		m -= 10;
33d19f7c:	8244400a 	subhi	r4, r4, #10	; 0xa
		n += 1;
	}

	printf ("%2ld", n);
33d19f80:	e59f0028 	ldr	r0, [pc, #40]	; 33d19fb0 <print_size+0x88>
33d19f84:	e1a01005 	mov	r1, r5
33d19f88:	ebfff40e 	bl	33d16fc8 <printf>
	if (m) {
33d19f8c:	e3540000 	cmp	r4, #0	; 0x0
		printf (".%ld", m);
33d19f90:	e1a01004 	mov	r1, r4
33d19f94:	e59f0018 	ldr	r0, [pc, #24]	; 33d19fb4 <print_size+0x8c>
33d19f98:	1bfff40a 	blne	33d16fc8 <printf>
	}
	printf (" %cB%s", c, s);
33d19f9c:	e59f0014 	ldr	r0, [pc, #20]	; 33d19fb8 <print_size+0x90>
33d19fa0:	e1a0100a 	mov	r1, sl
33d19fa4:	e1a02007 	mov	r2, r7
33d19fa8:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
33d19fac:	eafff405 	b	33d16fc8 <printf>
33d19fb0:	33d2ce34 	.word	0x33d2ce34
33d19fb4:	33d2ce3c 	.word	0x33d2ce3c
33d19fb8:	33d2ce44 	.word	0x33d2ce44

33d19fbc <strcpy>:
 * @dest: Where to copy the string to
 * @src: Where to copy the string from
 */
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;
33d19fbc:	e1a02000 	mov	r2, r0

	while ((*dest++ = *src++) != '\0')
33d19fc0:	e4d13001 	ldrb	r3, [r1], #1
33d19fc4:	e3530000 	cmp	r3, #0	; 0x0
33d19fc8:	e4c03001 	strb	r3, [r0], #1
33d19fcc:	1afffffb 	bne	33d19fc0 <strcpy+0x4>
		/* nothing */;
	return tmp;
}
33d19fd0:	e1a00002 	mov	r0, r2
33d19fd4:	e1a0f00e 	mov	pc, lr

33d19fd8 <strncpy>:
 * However, the result is not %NUL-terminated if the source exceeds
 * @count bytes.
 */
char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;
33d19fd8:	e1a0c000 	mov	ip, r0

	while (count-- && (*dest++ = *src++) != '\0')
33d19fdc:	e2522001 	subs	r2, r2, #1	; 0x1
33d19fe0:	3a000003 	bcc	33d19ff4 <strncpy+0x1c>
33d19fe4:	e4d13001 	ldrb	r3, [r1], #1
33d19fe8:	e3530000 	cmp	r3, #0	; 0x0
33d19fec:	e4c03001 	strb	r3, [r0], #1
33d19ff0:	1afffff9 	bne	33d19fdc <strncpy+0x4>
		/* nothing */;

	return tmp;
}
33d19ff4:	e1a0000c 	mov	r0, ip
33d19ff8:	e1a0f00e 	mov	pc, lr

33d19ffc <strcat>:
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;

	while (*dest)
		dest++;
33d19ffc:	e5d03000 	ldrb	r3, [r0]
 * @dest: The string to be appended to
 * @src: The string to append to it
 */
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;
33d1a000:	e1a02000 	mov	r2, r0

	while (*dest)
		dest++;
33d1a004:	e3530000 	cmp	r3, #0	; 0x0
33d1a008:	15f03001 	ldrbne	r3, [r0, #1]!
33d1a00c:	1afffffc 	bne	33d1a004 <strcat+0x8>
	while ((*dest++ = *src++) != '\0')
33d1a010:	e4d13001 	ldrb	r3, [r1], #1
33d1a014:	e3530000 	cmp	r3, #0	; 0x0
33d1a018:	e4c03001 	strb	r3, [r0], #1
33d1a01c:	1afffffb 	bne	33d1a010 <strcat+0x14>
		;

	return tmp;
}
33d1a020:	e1a00002 	mov	r0, r2
33d1a024:	e1a0f00e 	mov	pc, lr

33d1a028 <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
33d1a028:	e3520000 	cmp	r2, #0	; 0x0
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;
33d1a02c:	e1a0c000 	mov	ip, r0

	if (count) {
33d1a030:	0a00000a 	beq	33d1a060 <strncat+0x38>
		while (*dest)
			dest++;
33d1a034:	e5d03000 	ldrb	r3, [r0]
33d1a038:	e3530000 	cmp	r3, #0	; 0x0
33d1a03c:	15f03001 	ldrbne	r3, [r0, #1]!
33d1a040:	1afffffc 	bne	33d1a038 <strncat+0x10>
		while ((*dest++ = *src++)) {
			if (--count == 0) {
				*dest = '\0';
				break;
33d1a044:	e4d13001 	ldrb	r3, [r1], #1
33d1a048:	e3530000 	cmp	r3, #0	; 0x0
33d1a04c:	e4c03001 	strb	r3, [r0], #1
33d1a050:	0a000002 	beq	33d1a060 <strncat+0x38>

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
			if (--count == 0) {
33d1a054:	e2522001 	subs	r2, r2, #1	; 0x1
33d1a058:	1afffff9 	bne	33d1a044 <strncat+0x1c>
				*dest = '\0';
33d1a05c:	e5c02000 	strb	r2, [r0]
			}
		}
	}

	return tmp;
}
33d1a060:	e1a0000c 	mov	r0, ip
33d1a064:	e1a0f00e 	mov	pc, lr

33d1a068 <strcmp>:
int strcmp(const char * cs,const char * ct)
{
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
33d1a068:	e5d02000 	ldrb	r2, [r0]
33d1a06c:	e4d13001 	ldrb	r3, [r1], #1
33d1a070:	e0633002 	rsb	r3, r3, r2
33d1a074:	e1b0cc03 	lsls	ip, r3, #24
33d1a078:	e2800001 	add	r0, r0, #1	; 0x1
33d1a07c:	e20330ff 	and	r3, r3, #255	; 0xff
33d1a080:	1a000001 	bne	33d1a08c <strcmp+0x24>
33d1a084:	e3520000 	cmp	r2, #0	; 0x0
33d1a088:	1afffff6 	bne	33d1a068 <strcmp>
			break;
	}

	return __res;
33d1a08c:	e1a00c03 	lsl	r0, r3, #24
}
33d1a090:	e1a00c40 	asr	r0, r0, #24
33d1a094:	e1a0f00e 	mov	pc, lr

33d1a098 <strncmp>:
	register signed char __res = 0;

	while (count) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
			break;
		count--;
33d1a098:	e3520000 	cmp	r2, #0	; 0x0
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
33d1a09c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	register signed char __res = 0;
33d1a0a0:	e3a03000 	mov	r3, #0	; 0x0

	while (count) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
			break;
		count--;
33d1a0a4:	0a00000a 	beq	33d1a0d4 <strncmp+0x3c>
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
33d1a0a8:	e5d0c000 	ldrb	ip, [r0]
33d1a0ac:	e4d13001 	ldrb	r3, [r1], #1
33d1a0b0:	e063300c 	rsb	r3, r3, ip
33d1a0b4:	e1b0ec03 	lsls	lr, r3, #24
33d1a0b8:	e2800001 	add	r0, r0, #1	; 0x1
33d1a0bc:	e20330ff 	and	r3, r3, #255	; 0xff
33d1a0c0:	1a000003 	bne	33d1a0d4 <strncmp+0x3c>
33d1a0c4:	e35c0000 	cmp	ip, #0	; 0x0
33d1a0c8:	0a000001 	beq	33d1a0d4 <strncmp+0x3c>
			break;
		count--;
33d1a0cc:	e2522001 	subs	r2, r2, #1	; 0x1
33d1a0d0:	1afffff4 	bne	33d1a0a8 <strncmp+0x10>
	}

	return __res;
33d1a0d4:	e1a00c03 	lsl	r0, r3, #24
}
33d1a0d8:	e1a00c40 	asr	r0, r0, #24
33d1a0dc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1a0e0 <strchr>:
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
33d1a0e0:	e5d03000 	ldrb	r3, [r0]
 * strchr - Find the first occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
33d1a0e4:	e1a02000 	mov	r2, r0
	for(; *s != (char) c; ++s)
33d1a0e8:	e20110ff 	and	r1, r1, #255	; 0xff
33d1a0ec:	e1530001 	cmp	r3, r1
33d1a0f0:	0a000004 	beq	33d1a108 <strchr+0x28>
		if (*s == '\0')
33d1a0f4:	e20300ff 	and	r0, r3, #255	; 0xff
33d1a0f8:	e3500000 	cmp	r0, #0	; 0x0
33d1a0fc:	01a0f00e 	moveq	pc, lr
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
33d1a100:	e5f23001 	ldrb	r3, [r2, #1]!
33d1a104:	eafffff8 	b	33d1a0ec <strchr+0xc>
		if (*s == '\0')
			return NULL;
	return (char *) s;
33d1a108:	e1a00002 	mov	r0, r2
}
33d1a10c:	e1a0f00e 	mov	pc, lr

33d1a110 <strlen>:
 */
size_t strlen(const char * s)
{
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
33d1a110:	e5d03000 	ldrb	r3, [r0]
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
33d1a114:	e1a02000 	mov	r2, r0
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
33d1a118:	e3530000 	cmp	r3, #0	; 0x0
33d1a11c:	0a000002 	beq	33d1a12c <strlen+0x1c>
33d1a120:	e5f03001 	ldrb	r3, [r0, #1]!
33d1a124:	e3530000 	cmp	r3, #0	; 0x0
33d1a128:	eafffffb 	b	33d1a11c <strlen+0xc>
		/* nothing */;
	return sc - s;
}
33d1a12c:	e0620000 	rsb	r0, r2, r0
33d1a130:	e1a0f00e 	mov	pc, lr

33d1a134 <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
33d1a134:	e92d4030 	push	{r4, r5, lr}
33d1a138:	e1a04000 	mov	r4, r0
33d1a13c:	e1a05001 	mov	r5, r1
       const char *p = s + strlen(s);
33d1a140:	ebfffff2 	bl	33d1a110 <strlen>
33d1a144:	e0840000 	add	r0, r4, r0
       do {
	   if (*p == (char)c)
33d1a148:	e5d02000 	ldrb	r2, [r0]
33d1a14c:	e20530ff 	and	r3, r5, #255	; 0xff
33d1a150:	e1520003 	cmp	r2, r3
33d1a154:	08bd8030 	popeq	{r4, r5, pc}
	       return (char *)p;
       } while (--p >= s);
33d1a158:	e2400001 	sub	r0, r0, #1	; 0x1
33d1a15c:	e1500004 	cmp	r0, r4
33d1a160:	2afffff8 	bcs	33d1a148 <strrchr+0x14>
       return NULL;
33d1a164:	e3a00000 	mov	r0, #0	; 0x0
}
33d1a168:	e8bd8030 	pop	{r4, r5, pc}

33d1a16c <strnlen>:
 */
size_t strnlen(const char * s, size_t count)
{
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
33d1a16c:	e2411001 	sub	r1, r1, #1	; 0x1
33d1a170:	e3710001 	cmn	r1, #1	; 0x1
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
33d1a174:	e1a02000 	mov	r2, r0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
33d1a178:	0a000007 	beq	33d1a19c <strnlen+0x30>
33d1a17c:	e5d23000 	ldrb	r3, [r2]
33d1a180:	e3530000 	cmp	r3, #0	; 0x0
33d1a184:	0a000004 	beq	33d1a19c <strnlen+0x30>
33d1a188:	e2411001 	sub	r1, r1, #1	; 0x1
33d1a18c:	e3710001 	cmn	r1, #1	; 0x1
33d1a190:	e2800001 	add	r0, r0, #1	; 0x1
33d1a194:	15d03000 	ldrbne	r3, [r0]
33d1a198:	1afffff8 	bne	33d1a180 <strnlen+0x14>
		/* nothing */;
	return sc - s;
}
33d1a19c:	e0620000 	rsb	r0, r2, r0
33d1a1a0:	e1a0f00e 	mov	pc, lr

33d1a1a4 <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
33d1a1a4:	e92d4010 	push	{r4, lr}
	char *new;

	if ((s == NULL)	||
33d1a1a8:	e2504000 	subs	r4, r0, #0	; 0x0
33d1a1ac:	0a000005 	beq	33d1a1c8 <strdup+0x24>
33d1a1b0:	ebffffd6 	bl	33d1a110 <strlen>
33d1a1b4:	e2800001 	add	r0, r0, #1	; 0x1
33d1a1b8:	ebfff52a 	bl	33d17668 <malloc>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
33d1a1bc:	e1a01004 	mov	r1, r4
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
33d1a1c0:	e2504000 	subs	r4, r0, #0	; 0x0
33d1a1c4:	1a000001 	bne	33d1a1d0 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
33d1a1c8:	e3a00000 	mov	r0, #0	; 0x0
33d1a1cc:	e8bd8010 	pop	{r4, pc}
	}

	strcpy (new, s);
33d1a1d0:	ebffff79 	bl	33d19fbc <strcpy>
	return new;
33d1a1d4:	e1a00004 	mov	r0, r4
}
33d1a1d8:	e8bd8010 	pop	{r4, pc}

33d1a1dc <strspn>:
 * 	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
33d1a1dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
33d1a1e0:	e5d03000 	ldrb	r3, [r0]
 */
size_t strspn(const char *s, const char *accept)
{
	const char *p;
	const char *a;
	size_t count = 0;
33d1a1e4:	e3a0e000 	mov	lr, #0	; 0x0

	for (p = s; *p != '\0'; ++p) {
33d1a1e8:	e3530000 	cmp	r3, #0	; 0x0
33d1a1ec:	0a000010 	beq	33d1a234 <strspn+0x58>
		for (a = accept; *a != '\0'; ++a) {
33d1a1f0:	e5d12000 	ldrb	r2, [r1]
33d1a1f4:	e3520000 	cmp	r2, #0	; 0x0
33d1a1f8:	e1a0c001 	mov	ip, r1
33d1a1fc:	0a00000c 	beq	33d1a234 <strspn+0x58>
			if (*p == *a)
33d1a200:	e5d03000 	ldrb	r3, [r0]
33d1a204:	e1530002 	cmp	r3, r2
33d1a208:	0a000002 	beq	33d1a218 <strspn+0x3c>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
33d1a20c:	e5fc2001 	ldrb	r2, [ip, #1]!
33d1a210:	e3520000 	cmp	r2, #0	; 0x0
33d1a214:	1afffff9 	bne	33d1a200 <strspn+0x24>
			if (*p == *a)
				break;
		}
		if (*a == '\0')
33d1a218:	e5dc3000 	ldrb	r3, [ip]
33d1a21c:	e3530000 	cmp	r3, #0	; 0x0
33d1a220:	0a000003 	beq	33d1a234 <strspn+0x58>
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
33d1a224:	e5f03001 	ldrb	r3, [r0, #1]!
			if (*p == *a)
				break;
		}
		if (*a == '\0')
			return count;
		++count;
33d1a228:	e28ee001 	add	lr, lr, #1	; 0x1
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
33d1a22c:	e3530000 	cmp	r3, #0	; 0x0
33d1a230:	eaffffed 	b	33d1a1ec <strspn+0x10>
			return count;
		++count;
	}

	return count;
}
33d1a234:	e1a0000e 	mov	r0, lr
33d1a238:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1a23c <strpbrk>:
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
33d1a23c:	e5d03000 	ldrb	r3, [r0]
33d1a240:	e3530000 	cmp	r3, #0	; 0x0
33d1a244:	0a00000a 	beq	33d1a274 <strpbrk+0x38>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
33d1a248:	e5d12000 	ldrb	r2, [r1]
33d1a24c:	e1a0c001 	mov	ip, r1
33d1a250:	e3520000 	cmp	r2, #0	; 0x0
33d1a254:	0a000004 	beq	33d1a26c <strpbrk+0x30>
			if (*sc1 == *sc2)
33d1a258:	e5d03000 	ldrb	r3, [r0]
33d1a25c:	e1530002 	cmp	r3, r2
33d1a260:	01a0f00e 	moveq	pc, lr
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
33d1a264:	e5fc2001 	ldrb	r2, [ip, #1]!
33d1a268:	eafffff8 	b	33d1a250 <strpbrk+0x14>
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
33d1a26c:	e5f03001 	ldrb	r3, [r0, #1]!
33d1a270:	eafffff2 	b	33d1a240 <strpbrk+0x4>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
33d1a274:	e3a00000 	mov	r0, #0	; 0x0
}
33d1a278:	e1a0f00e 	mov	pc, lr

33d1a27c <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
33d1a27c:	e92d4030 	push	{r4, r5, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
33d1a280:	e2504000 	subs	r4, r0, #0	; 0x0
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
33d1a284:	e1a05001 	mov	r5, r1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
33d1a288:	1a000004 	bne	33d1a2a0 <strtok+0x24>
33d1a28c:	e59f3068 	ldr	r3, [pc, #104]	; 33d1a2fc <strtok+0x80>
33d1a290:	e5934000 	ldr	r4, [r3]
	if (!sbegin) {
33d1a294:	e3540000 	cmp	r4, #0	; 0x0
		return NULL;
33d1a298:	e1a0c004 	mov	ip, r4
char * strtok(char * s,const char * ct)
{
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
	if (!sbegin) {
33d1a29c:	0a000014 	beq	33d1a2f4 <strtok+0x78>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
33d1a2a0:	e1a00004 	mov	r0, r4
33d1a2a4:	ebffffcc 	bl	33d1a1dc <strspn>
	if (*sbegin == '\0') {
33d1a2a8:	e7f43000 	ldrb	r3, [r4, r0]!
33d1a2ac:	e20320ff 	and	r2, r3, #255	; 0xff
33d1a2b0:	e3520000 	cmp	r2, #0	; 0x0
		___strtok = NULL;
33d1a2b4:	059f3040 	ldreq	r3, [pc, #64]	; 33d1a2fc <strtok+0x80>
		return( NULL );
	}
	send = strpbrk( sbegin, ct);
33d1a2b8:	e1a01005 	mov	r1, r5
33d1a2bc:	e1a00004 	mov	r0, r4
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
		return( NULL );
33d1a2c0:	e1a0c002 	mov	ip, r2
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
33d1a2c4:	05832000 	streq	r2, [r3]
	sbegin  = s ? s : ___strtok;
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
33d1a2c8:	0a000009 	beq	33d1a2f4 <strtok+0x78>
		___strtok = NULL;
		return( NULL );
	}
	send = strpbrk( sbegin, ct);
33d1a2cc:	ebffffda 	bl	33d1a23c <strpbrk>
	if (send && *send != '\0')
33d1a2d0:	e3500000 	cmp	r0, #0	; 0x0
33d1a2d4:	0a000003 	beq	33d1a2e8 <strtok+0x6c>
33d1a2d8:	e5d03000 	ldrb	r3, [r0]
33d1a2dc:	e3530000 	cmp	r3, #0	; 0x0
		*send++ = '\0';
33d1a2e0:	13a03000 	movne	r3, #0	; 0x0
33d1a2e4:	14c03001 	strbne	r3, [r0], #1
	___strtok = send;
33d1a2e8:	e59f300c 	ldr	r3, [pc, #12]	; 33d1a2fc <strtok+0x80>
33d1a2ec:	e5830000 	str	r0, [r3]
	return (sbegin);
33d1a2f0:	e1a0c004 	mov	ip, r4
}
33d1a2f4:	e1a0000c 	mov	r0, ip
33d1a2f8:	e8bd8030 	pop	{r4, r5, pc}
33d1a2fc:	33d610a8 	.word	0x33d610a8

33d1a300 <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
33d1a300:	e92d4030 	push	{r4, r5, lr}
	char *sbegin = *s, *end;
33d1a304:	e5904000 	ldr	r4, [r0]
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
33d1a308:	e1a05000 	mov	r5, r0
	char *sbegin = *s, *end;

	if (sbegin == NULL)
33d1a30c:	e2540000 	subs	r0, r4, #0	; 0x0
		return NULL;
33d1a310:	e1a03004 	mov	r3, r4
 */
char * strsep(char **s, const char *ct)
{
	char *sbegin = *s, *end;

	if (sbegin == NULL)
33d1a314:	0a000005 	beq	33d1a330 <strsep+0x30>
		return NULL;

	end = strpbrk(sbegin, ct);
33d1a318:	ebffffc7 	bl	33d1a23c <strpbrk>
	if (end)
33d1a31c:	e3500000 	cmp	r0, #0	; 0x0
		*end++ = '\0';
33d1a320:	13a03000 	movne	r3, #0	; 0x0
33d1a324:	14c03001 	strbne	r3, [r0], #1
	*s = end;
33d1a328:	e5850000 	str	r0, [r5]

	return sbegin;
33d1a32c:	e1a03004 	mov	r3, r4
}
33d1a330:	e1a00003 	mov	r0, r3
33d1a334:	e8bd8030 	pop	{r4, r5, pc}

33d1a338 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
33d1a338:	e3500000 	cmp	r0, #0	; 0x0
33d1a33c:	0a000002 	beq	33d1a34c <strswab+0x14>
33d1a340:	e5d03000 	ldrb	r3, [r0]
33d1a344:	e3530000 	cmp	r3, #0	; 0x0
33d1a348:	1a000001 	bne	33d1a354 <strswab+0x1c>
		return (NULL);
33d1a34c:	e3a00000 	mov	r0, #0	; 0x0
33d1a350:	e1a0f00e 	mov	pc, lr
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
33d1a354:	e5d03001 	ldrb	r3, [r0, #1]
33d1a358:	e3530000 	cmp	r3, #0	; 0x0
33d1a35c:	e1a0c000 	mov	ip, r0
33d1a360:	e2801001 	add	r1, r0, #1	; 0x1
33d1a364:	01a0f00e 	moveq	pc, lr
		char  tmp;

		tmp = *p;
33d1a368:	e5dc3000 	ldrb	r3, [ip]
		*p  = *q;
33d1a36c:	e5d12000 	ldrb	r2, [r1]
33d1a370:	e4cc2002 	strb	r2, [ip], #2
		*q  = tmp;
33d1a374:	e4c13002 	strb	r3, [r1], #2

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
33d1a378:	e5dc3000 	ldrb	r3, [ip]
33d1a37c:	e3530000 	cmp	r3, #0	; 0x0
33d1a380:	01a0f00e 	moveq	pc, lr
33d1a384:	e5d13000 	ldrb	r3, [r1]
33d1a388:	e3530000 	cmp	r3, #0	; 0x0
33d1a38c:	1afffff5 	bne	33d1a368 <strswab+0x30>
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
33d1a390:	e1a0f00e 	mov	pc, lr

33d1a394 <memset>:
void * memset(void * s,int c,size_t count)
{
	char *xs = (char *) s;

	while (count--)
		*xs++ = c;
33d1a394:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a398:	e3720001 	cmn	r2, #1	; 0x1
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
	char *xs = (char *) s;
33d1a39c:	e1a03000 	mov	r3, r0

	while (count--)
		*xs++ = c;
33d1a3a0:	01a0f00e 	moveq	pc, lr
33d1a3a4:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a3a8:	e3720001 	cmn	r2, #1	; 0x1
33d1a3ac:	e4c31001 	strb	r1, [r3], #1
33d1a3b0:	1afffffb 	bne	33d1a3a4 <memset+0x10>

	return s;
}
33d1a3b4:	e1a0f00e 	mov	pc, lr

33d1a3b8 <bcopy>:
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;

	while (count--)
		*tmp++ = *src++;
33d1a3b8:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a3bc:	e3720001 	cmn	r2, #1	; 0x1
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;
33d1a3c0:	e1a0c001 	mov	ip, r1

	while (count--)
		*tmp++ = *src++;
33d1a3c4:	0a000004 	beq	33d1a3dc <bcopy+0x24>
33d1a3c8:	e4d03001 	ldrb	r3, [r0], #1
33d1a3cc:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a3d0:	e4cc3001 	strb	r3, [ip], #1
33d1a3d4:	e3720001 	cmn	r2, #1	; 0x1
33d1a3d8:	eafffff9 	b	33d1a3c4 <bcopy+0xc>

	return dest;
}
33d1a3dc:	e1a00001 	mov	r0, r1
33d1a3e0:	e1a0f00e 	mov	pc, lr

33d1a3e4 <memcpy>:
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
		*tmp++ = *s++;
33d1a3e4:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a3e8:	e3720001 	cmn	r2, #1	; 0x1
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;
33d1a3ec:	e1a0c000 	mov	ip, r0

	while (count--)
		*tmp++ = *s++;
33d1a3f0:	01a0f00e 	moveq	pc, lr
33d1a3f4:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a3f8:	e4d13001 	ldrb	r3, [r1], #1
33d1a3fc:	e3720001 	cmn	r2, #1	; 0x1
33d1a400:	e4cc3001 	strb	r3, [ip], #1
33d1a404:	1afffffa 	bne	33d1a3f4 <memcpy+0x10>

	return dest;
}
33d1a408:	e1a0f00e 	mov	pc, lr

33d1a40c <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (dest <= src) {
33d1a40c:	e1500001 	cmp	r0, r1
 * @count: The size of the area.
 *
 * Unlike memcpy(), memmove() copes with overlapping areas.
 */
void * memmove(void * dest,const void *src,size_t count)
{
33d1a410:	e2423001 	sub	r3, r2, #1	; 0x1
	char *tmp, *s;

	if (dest <= src) {
33d1a414:	8a000009 	bhi	33d1a440 <memmove+0x34>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
33d1a418:	e3730001 	cmn	r3, #1	; 0x1
33d1a41c:	e1a02003 	mov	r2, r3
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (dest <= src) {
		tmp = (char *) dest;
33d1a420:	e1a0c000 	mov	ip, r0
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
33d1a424:	01a0f00e 	moveq	pc, lr
33d1a428:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a42c:	e4d13001 	ldrb	r3, [r1], #1
33d1a430:	e3720001 	cmn	r2, #1	; 0x1
33d1a434:	e4cc3001 	strb	r3, [ip], #1
33d1a438:	1afffffa 	bne	33d1a428 <memmove+0x1c>
33d1a43c:	e1a0f00e 	mov	pc, lr
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
		while (count--)
			*--tmp = *--s;
33d1a440:	e3730001 	cmn	r3, #1	; 0x1
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
33d1a444:	e0811002 	add	r1, r1, r2
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
33d1a448:	e080c002 	add	ip, r0, r2
		s = (char *) src + count;
		while (count--)
			*--tmp = *--s;
33d1a44c:	e1a02003 	mov	r2, r3
33d1a450:	01a0f00e 	moveq	pc, lr
33d1a454:	e2422001 	sub	r2, r2, #1	; 0x1
33d1a458:	e5713001 	ldrb	r3, [r1, #-1]!
33d1a45c:	e3720001 	cmn	r2, #1	; 0x1
33d1a460:	e56c3001 	strb	r3, [ip, #-1]!
33d1a464:	1afffffa 	bne	33d1a454 <memmove+0x48>
		}

	return dest;
}
33d1a468:	e1a0f00e 	mov	pc, lr

33d1a46c <memcmp>:
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
33d1a46c:	e252c000 	subs	ip, r2, #0	; 0x0
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;
33d1a470:	e3a02000 	mov	r2, #0	; 0x0

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
33d1a474:	0a000007 	beq	33d1a498 <memcmp+0x2c>
		if ((res = *su1 - *su2) != 0)
33d1a478:	e5d02000 	ldrb	r2, [r0]
33d1a47c:	e5d13000 	ldrb	r3, [r1]
33d1a480:	e0522003 	subs	r2, r2, r3
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
33d1a484:	e2800001 	add	r0, r0, #1	; 0x1
33d1a488:	e2811001 	add	r1, r1, #1	; 0x1
		if ((res = *su1 - *su2) != 0)
33d1a48c:	1a000001 	bne	33d1a498 <memcmp+0x2c>
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
33d1a490:	e25cc001 	subs	ip, ip, #1	; 0x1
33d1a494:	1afffff7 	bne	33d1a478 <memcmp+0xc>
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
33d1a498:	e1a00002 	mov	r0, r2
33d1a49c:	e1a0f00e 	mov	pc, lr

33d1a4a0 <memscan>:

	while (size) {
		if (*p == c)
			return (void *) p;
		p++;
		size--;
33d1a4a0:	e3520000 	cmp	r2, #0	; 0x0
33d1a4a4:	01a0f00e 	moveq	pc, lr
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
		if (*p == c)
33d1a4a8:	e5d03000 	ldrb	r3, [r0]
33d1a4ac:	e1530001 	cmp	r3, r1
33d1a4b0:	01a0f00e 	moveq	pc, lr
			return (void *) p;
		p++;
		size--;
33d1a4b4:	e2522001 	subs	r2, r2, #1	; 0x1
	unsigned char * p = (unsigned char *) addr;

	while (size) {
		if (*p == c)
			return (void *) p;
		p++;
33d1a4b8:	e2800001 	add	r0, r0, #1	; 0x1
		size--;
33d1a4bc:	1afffff9 	bne	33d1a4a8 <memscan+0x8>
	}
	return (void *) p;
}
33d1a4c0:	e1a0f00e 	mov	pc, lr

33d1a4c4 <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
33d1a4c4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d1a4c8:	e1a05000 	mov	r5, r0
	int l1, l2;

	l2 = strlen(s2);
33d1a4cc:	e1a00001 	mov	r0, r1
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
33d1a4d0:	e1a07001 	mov	r7, r1
	int l1, l2;

	l2 = strlen(s2);
33d1a4d4:	ebffff0d 	bl	33d1a110 <strlen>
	if (!l2)
33d1a4d8:	e2506000 	subs	r6, r0, #0	; 0x0
33d1a4dc:	1a000001 	bne	33d1a4e8 <strstr+0x24>
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
33d1a4e0:	e1a00005 	mov	r0, r5
33d1a4e4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	int l1, l2;

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
33d1a4e8:	e1a00005 	mov	r0, r5
33d1a4ec:	ebffff07 	bl	33d1a110 <strlen>
33d1a4f0:	e1a04000 	mov	r4, r0
	while (l1 >= l2) {
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
33d1a4f4:	e1500006 	cmp	r0, r6
33d1a4f8:	ba000009 	blt	33d1a524 <strstr+0x60>
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
		if (!memcmp(s1,s2,l2))
33d1a4fc:	e1a00005 	mov	r0, r5
33d1a500:	e1a01007 	mov	r1, r7
33d1a504:	e1a02006 	mov	r2, r6
33d1a508:	ebffffd7 	bl	33d1a46c <memcmp>
33d1a50c:	e3500000 	cmp	r0, #0	; 0x0
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
33d1a510:	e2444001 	sub	r4, r4, #1	; 0x1
		if (!memcmp(s1,s2,l2))
33d1a514:	0afffff1 	beq	33d1a4e0 <strstr+0x1c>
			return (char *) s1;
		s1++;
33d1a518:	e1540006 	cmp	r4, r6
33d1a51c:	e2855001 	add	r5, r5, #1	; 0x1
33d1a520:	eafffff4 	b	33d1a4f8 <strstr+0x34>
	}
	return NULL;
33d1a524:	e3a00000 	mov	r0, #0	; 0x0
}
33d1a528:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d1a52c <memchr>:
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
33d1a52c:	e252c001 	subs	ip, r2, #1	; 0x1
33d1a530:	3a000007 	bcc	33d1a554 <memchr+0x28>
33d1a534:	e2400001 	sub	r0, r0, #1	; 0x1
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
33d1a538:	e5f02001 	ldrb	r2, [r0, #1]!
33d1a53c:	e20130ff 	and	r3, r1, #255	; 0xff
33d1a540:	e1520003 	cmp	r2, r3
			return (void *)(p-1);
33d1a544:	e24cc001 	sub	ip, ip, #1	; 0x1
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
33d1a548:	01a0f00e 	moveq	pc, lr
			return (void *)(p-1);
33d1a54c:	e37c0001 	cmn	ip, #1	; 0x1
33d1a550:	1afffff8 	bne	33d1a538 <memchr+0xc>
		}
	}
	return NULL;
33d1a554:	e3a00000 	mov	r0, #0	; 0x0
}
33d1a558:	e1a0f00e 	mov	pc, lr

33d1a55c <simple_strtoul>:
/*cmd_boot.c*/
extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
#endif

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
33d1a55c:	e92d4010 	push	{r4, lr}
	unsigned long result = 0,value;

	if (*cp == '0') {
33d1a560:	e5d03000 	ldrb	r3, [r0]
33d1a564:	e3530030 	cmp	r3, #48	; 0x30
/*cmd_boot.c*/
extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
#endif

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
33d1a568:	e1a04001 	mov	r4, r1
33d1a56c:	e1a0e002 	mov	lr, r2
	unsigned long result = 0,value;
33d1a570:	e3a01000 	mov	r1, #0	; 0x0

	if (*cp == '0') {
33d1a574:	1a00000c 	bne	33d1a5ac <simple_strtoul+0x50>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
33d1a578:	e5f03001 	ldrb	r3, [r0, #1]!
33d1a57c:	e3530078 	cmp	r3, #120	; 0x78
33d1a580:	1a000006 	bne	33d1a5a0 <simple_strtoul+0x44>
33d1a584:	e5d03001 	ldrb	r3, [r0, #1]
33d1a588:	e59f207c 	ldr	r2, [pc, #124]	; 33d1a60c <simple_strtoul+0xb0>
33d1a58c:	e7d23003 	ldrb	r3, [r2, r3]
33d1a590:	e3130044 	tst	r3, #68	; 0x44
			base = 16;
			cp++;
33d1a594:	12800001 	addne	r0, r0, #1	; 0x1
	unsigned long result = 0,value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
			base = 16;
33d1a598:	13a0e010 	movne	lr, #16	; 0x10
{
	unsigned long result = 0,value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
33d1a59c:	1a000007 	bne	33d1a5c0 <simple_strtoul+0x64>
			base = 16;
			cp++;
		}
		if (!base) {
33d1a5a0:	e35e0000 	cmp	lr, #0	; 0x0
			base = 8;
33d1a5a4:	028ee008 	addeq	lr, lr, #8	; 0x8
33d1a5a8:	ea000004 	b	33d1a5c0 <simple_strtoul+0x64>
		}
	}
	if (!base) {
33d1a5ac:	e3520000 	cmp	r2, #0	; 0x0
		base = 10;
33d1a5b0:	0282e00a 	addeq	lr, r2, #10	; 0xa
33d1a5b4:	ea000001 	b	33d1a5c0 <simple_strtoul+0x64>
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
33d1a5b8:	e021319e 	mla	r1, lr, r1, r3
		cp++;
33d1a5bc:	e2800001 	add	r0, r0, #1	; 0x1
33d1a5c0:	e5d0c000 	ldrb	ip, [r0]
33d1a5c4:	e59f3040 	ldr	r3, [pc, #64]	; 33d1a60c <simple_strtoul+0xb0>
33d1a5c8:	e7d3200c 	ldrb	r2, [r3, ip]
33d1a5cc:	e3120044 	tst	r2, #68	; 0x44
33d1a5d0:	e24c3030 	sub	r3, ip, #48	; 0x30
33d1a5d4:	0a000008 	beq	33d1a5fc <simple_strtoul+0xa0>
33d1a5d8:	e3120004 	tst	r2, #4	; 0x4
33d1a5dc:	1a000004 	bne	33d1a5f4 <simple_strtoul+0x98>
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
33d1a5e0:	e24c3020 	sub	r3, ip, #32	; 0x20
33d1a5e4:	e20330ff 	and	r3, r3, #255	; 0xff
33d1a5e8:	e3120002 	tst	r2, #2	; 0x2
		c -= 'A'-'a';
	return c;
}

static inline unsigned char __toupper(unsigned char c)
{
33d1a5ec:	e2433037 	sub	r3, r3, #55	; 0x37
33d1a5f0:	024c3037 	subeq	r3, ip, #55	; 0x37
33d1a5f4:	e153000e 	cmp	r3, lr
33d1a5f8:	3affffee 	bcc	33d1a5b8 <simple_strtoul+0x5c>
	}
	if (endp)
33d1a5fc:	e3540000 	cmp	r4, #0	; 0x0
		*endp = (char *)cp;
33d1a600:	15840000 	strne	r0, [r4]
	return result;
}
33d1a604:	e1a00001 	mov	r0, r1
33d1a608:	e8bd8010 	pop	{r4, pc}
33d1a60c:	33d3657c 	.word	0x33d3657c

33d1a610 <simple_strtol>:

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
33d1a610:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if(*cp=='-')
33d1a614:	e5d03000 	ldrb	r3, [r0]
33d1a618:	e353002d 	cmp	r3, #45	; 0x2d
33d1a61c:	0a000001 	beq	33d1a628 <simple_strtol+0x18>
		return -simple_strtoul(cp+1,endp,base);
	return simple_strtoul(cp,endp,base);
}
33d1a620:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoul(cp+1,endp,base);
	return simple_strtoul(cp,endp,base);
33d1a624:	eaffffcc 	b	33d1a55c <simple_strtoul>
}

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoul(cp+1,endp,base);
33d1a628:	e2800001 	add	r0, r0, #1	; 0x1
33d1a62c:	ebffffca 	bl	33d1a55c <simple_strtoul>
	return simple_strtoul(cp,endp,base);
}
33d1a630:	e2600000 	rsb	r0, r0, #0	; 0x0
33d1a634:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1a638 <skip_atoi>:

/* we use this so that we can do without the ctype library */
#define is_digit(c)	((c) >= '0' && (c) <= '9')

static int skip_atoi(const char **s)
{
33d1a638:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
33d1a63c:	e590c000 	ldr	ip, [r0]
33d1a640:	e5dc3000 	ldrb	r3, [ip]
33d1a644:	e2433030 	sub	r3, r3, #48	; 0x30
33d1a648:	e3530009 	cmp	r3, #9	; 0x9

/* we use this so that we can do without the ctype library */
#define is_digit(c)	((c) >= '0' && (c) <= '9')

static int skip_atoi(const char **s)
{
33d1a64c:	e1a0e000 	mov	lr, r0
	int i=0;
33d1a650:	e3a00000 	mov	r0, #0	; 0x0

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
33d1a654:	849df004 	pophi	{pc}		; (ldrhi pc, [sp], #4)
33d1a658:	e4dc1001 	ldrb	r1, [ip], #1
33d1a65c:	e58ec000 	str	ip, [lr]
33d1a660:	e5dc3000 	ldrb	r3, [ip]
33d1a664:	e0802100 	add	r2, r0, r0, lsl #2
33d1a668:	e2433030 	sub	r3, r3, #48	; 0x30
33d1a66c:	e0811082 	add	r1, r1, r2, lsl #1
33d1a670:	e3530009 	cmp	r3, #9	; 0x9
33d1a674:	e2410030 	sub	r0, r1, #48	; 0x30
33d1a678:	9afffff6 	bls	33d1a658 <skip_atoi+0x20>
	return i;
}
33d1a67c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1a680 <number>:
#ifdef CFG_64BIT_VSPRINTF
static char * number(char * str, long long num, int base, int size, int precision ,int type)
#else
static char * number(char * str, long num, int base, int size, int precision ,int type)
#endif
{
33d1a680:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d1a684:	e24dd058 	sub	sp, sp, #88	; 0x58
33d1a688:	e59da07c 	ldr	sl, [sp, #124]
	char c,sign,tmp[66];
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
	int i;

	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
33d1a68c:	e59fc214 	ldr	ip, [pc, #532]	; 33d1a8a8 <number+0x228>
33d1a690:	e59fe214 	ldr	lr, [pc, #532]	; 33d1a8ac <number+0x22c>
{
	char c,sign,tmp[66];
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
	int i;

	if (type & LARGE)
33d1a694:	e31a0040 	tst	sl, #64	; 0x40
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
33d1a698:	11a0e00c 	movne	lr, ip
#ifdef CFG_64BIT_VSPRINTF
static char * number(char * str, long long num, int base, int size, int precision ,int type)
#else
static char * number(char * str, long num, int base, int size, int precision ,int type)
#endif
{
33d1a69c:	e1a05003 	mov	r5, r3
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
	int i;

	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
33d1a6a0:	e31a0010 	tst	sl, #16	; 0x10
		type &= ~ZEROPAD;
	if (base < 2 || base > 36)
33d1a6a4:	e2423002 	sub	r3, r2, #2	; 0x2
	int i;

	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
		type &= ~ZEROPAD;
33d1a6a8:	13caa001 	bicne	sl, sl, #1	; 0x1
	if (base < 2 || base > 36)
33d1a6ac:	e3530022 	cmp	r3, #34	; 0x22
#ifdef CFG_64BIT_VSPRINTF
static char * number(char * str, long long num, int base, int size, int precision ,int type)
#else
static char * number(char * str, long num, int base, int size, int precision ,int type)
#endif
{
33d1a6b0:	e1a06000 	mov	r6, r0
	char c,sign,tmp[66];
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
	int i;

	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
33d1a6b4:	e58de008 	str	lr, [sp, #8]
#ifdef CFG_64BIT_VSPRINTF
static char * number(char * str, long long num, int base, int size, int precision ,int type)
#else
static char * number(char * str, long num, int base, int size, int precision ,int type)
#endif
{
33d1a6b8:	e1a07001 	mov	r7, r1
33d1a6bc:	e1a09002 	mov	r9, r2
33d1a6c0:	e59db078 	ldr	fp, [sp, #120]
	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
		type &= ~ZEROPAD;
	if (base < 2 || base > 36)
		return 0;
33d1a6c4:	83a00000 	movhi	r0, #0	; 0x0

	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
		type &= ~ZEROPAD;
	if (base < 2 || base > 36)
33d1a6c8:	8a000074 	bhi	33d1a8a0 <number+0x220>
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ';
33d1a6cc:	e31a0001 	tst	sl, #1	; 0x1
33d1a6d0:	03a01020 	moveq	r1, #32	; 0x20
33d1a6d4:	13a01030 	movne	r1, #48	; 0x30
	sign = 0;
33d1a6d8:	e3a02000 	mov	r2, #0	; 0x0
	if (type & SIGN) {
33d1a6dc:	e31a0002 	tst	sl, #2	; 0x2
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
		type &= ~ZEROPAD;
	if (base < 2 || base > 36)
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ';
33d1a6e0:	e58d1010 	str	r1, [sp, #16]
	sign = 0;
33d1a6e4:	e58d200c 	str	r2, [sp, #12]
	if (type & SIGN) {
33d1a6e8:	0a00000e 	beq	33d1a728 <number+0xa8>
		if (num < 0) {
33d1a6ec:	e1570002 	cmp	r7, r2
			sign = '-';
33d1a6f0:	b3a0302d 	movlt	r3, #45	; 0x2d
			num = -num;
33d1a6f4:	b2677000 	rsblt	r7, r7, #0	; 0x0
			size--;
33d1a6f8:	b2455001 	sublt	r5, r5, #1	; 0x1
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ';
	sign = 0;
	if (type & SIGN) {
		if (num < 0) {
			sign = '-';
33d1a6fc:	b58d300c 	strlt	r3, [sp, #12]
	if (base < 2 || base > 36)
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ';
	sign = 0;
	if (type & SIGN) {
		if (num < 0) {
33d1a700:	ba000008 	blt	33d1a728 <number+0xa8>
			sign = '-';
			num = -num;
			size--;
		} else if (type & PLUS) {
33d1a704:	e31a0004 	tst	sl, #4	; 0x4
			sign = '+';
33d1a708:	13a0c02b 	movne	ip, #43	; 0x2b
			size--;
33d1a70c:	12455001 	subne	r5, r5, #1	; 0x1
		if (num < 0) {
			sign = '-';
			num = -num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
33d1a710:	158dc00c 	strne	ip, [sp, #12]
	if (type & SIGN) {
		if (num < 0) {
			sign = '-';
			num = -num;
			size--;
		} else if (type & PLUS) {
33d1a714:	1a000003 	bne	33d1a728 <number+0xa8>
			sign = '+';
			size--;
		} else if (type & SPACE) {
33d1a718:	e31a0008 	tst	sl, #8	; 0x8
			sign = ' ';
33d1a71c:	13a0e020 	movne	lr, #32	; 0x20
33d1a720:	158de00c 	strne	lr, [sp, #12]
			size--;
33d1a724:	12455001 	subne	r5, r5, #1	; 0x1
		}
	}
	if (type & SPECIAL) {
33d1a728:	e21a1020 	ands	r1, sl, #32	; 0x20
33d1a72c:	e58d1004 	str	r1, [sp, #4]
33d1a730:	0a000004 	beq	33d1a748 <number+0xc8>
		if (base == 16)
33d1a734:	e3590010 	cmp	r9, #16	; 0x10
			size -= 2;
33d1a738:	02455002 	subeq	r5, r5, #2	; 0x2
			sign = ' ';
			size--;
		}
	}
	if (type & SPECIAL) {
		if (base == 16)
33d1a73c:	0a000001 	beq	33d1a748 <number+0xc8>
			size -= 2;
		else if (base == 8)
33d1a740:	e3590008 	cmp	r9, #8	; 0x8
			size--;
33d1a744:	02455001 	subeq	r5, r5, #1	; 0x1
	}
	i = 0;
	if (num == 0)
33d1a748:	e3570000 	cmp	r7, #0	; 0x0
		if (base == 16)
			size -= 2;
		else if (base == 8)
			size--;
	}
	i = 0;
33d1a74c:	e3a0c000 	mov	ip, #0	; 0x0
	if (num == 0)
		tmp[i++]='0';
33d1a750:	03a03030 	moveq	r3, #48	; 0x30
33d1a754:	028cc001 	addeq	ip, ip, #1	; 0x1
33d1a758:	05cd3014 	strbeq	r3, [sp, #20]
			size -= 2;
		else if (base == 8)
			size--;
	}
	i = 0;
	if (num == 0)
33d1a75c:	0a000010 	beq	33d1a7a4 <number+0x124>
		tmp[i++]='0';
	else while (num != 0)
		tmp[i++] = digits[do_div(num,base)];
33d1a760:	e1a00007 	mov	r0, r7
33d1a764:	e1a01009 	mov	r1, r9
33d1a768:	e58dc000 	str	ip, [sp]
33d1a76c:	eb00104b 	bl	33d1e8a0 <__umodsi3>
33d1a770:	e1a01009 	mov	r1, r9
33d1a774:	e1a04000 	mov	r4, r0
33d1a778:	e1a00007 	mov	r0, r7
33d1a77c:	ebff9b17 	bl	33d013e0 <__udivsi3>
33d1a780:	e59d3008 	ldr	r3, [sp, #8]
33d1a784:	e59dc000 	ldr	ip, [sp]
33d1a788:	e7d32004 	ldrb	r2, [r3, r4]
33d1a78c:	e28de058 	add	lr, sp, #88	; 0x58
33d1a790:	e08c300e 	add	r3, ip, lr
33d1a794:	e2507000 	subs	r7, r0, #0	; 0x0
33d1a798:	e5432044 	strb	r2, [r3, #-68]
33d1a79c:	e28cc001 	add	ip, ip, #1	; 0x1
33d1a7a0:	1affffee 	bne	33d1a760 <number+0xe0>
	if (i > precision)
		precision = i;
33d1a7a4:	e15b000c 	cmp	fp, ip
33d1a7a8:	b1a0b00c 	movlt	fp, ip
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
33d1a7ac:	e31a0011 	tst	sl, #17	; 0x11
		tmp[i++]='0';
	else while (num != 0)
		tmp[i++] = digits[do_div(num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
33d1a7b0:	e06b5005 	rsb	r5, fp, r5
	if (!(type&(ZEROPAD+LEFT)))
33d1a7b4:	1a000006 	bne	33d1a7d4 <number+0x154>
		while(size-->0)
			*str++ = ' ';
33d1a7b8:	e3550000 	cmp	r5, #0	; 0x0
33d1a7bc:	e2455001 	sub	r5, r5, #1	; 0x1
33d1a7c0:	da000003 	ble	33d1a7d4 <number+0x154>
33d1a7c4:	e3a03020 	mov	r3, #32	; 0x20
33d1a7c8:	e4c63001 	strb	r3, [r6], #1
33d1a7cc:	e3550000 	cmp	r5, #0	; 0x0
33d1a7d0:	eafffff9 	b	33d1a7bc <number+0x13c>
	if (sign)
33d1a7d4:	e59d100c 	ldr	r1, [sp, #12]
33d1a7d8:	e3510000 	cmp	r1, #0	; 0x0
		*str++ = sign;
33d1a7dc:	14c61001 	strbne	r1, [r6], #1
	if (type & SPECIAL) {
33d1a7e0:	e59d2004 	ldr	r2, [sp, #4]
33d1a7e4:	e3520000 	cmp	r2, #0	; 0x0
33d1a7e8:	0a000009 	beq	33d1a814 <number+0x194>
		if (base==8)
33d1a7ec:	e3590008 	cmp	r9, #8	; 0x8
			*str++ = '0';
33d1a7f0:	03a03030 	moveq	r3, #48	; 0x30
		while(size-->0)
			*str++ = ' ';
	if (sign)
		*str++ = sign;
	if (type & SPECIAL) {
		if (base==8)
33d1a7f4:	0a000005 	beq	33d1a810 <number+0x190>
			*str++ = '0';
		else if (base==16) {
33d1a7f8:	e3590010 	cmp	r9, #16	; 0x10
33d1a7fc:	1a000004 	bne	33d1a814 <number+0x194>
			*str++ = '0';
33d1a800:	e3a03030 	mov	r3, #48	; 0x30
33d1a804:	e4c63001 	strb	r3, [r6], #1
			*str++ = digits[33];
33d1a808:	e59de008 	ldr	lr, [sp, #8]
33d1a80c:	e5de3021 	ldrb	r3, [lr, #33]
33d1a810:	e4c63001 	strb	r3, [r6], #1
		}
	}
	if (!(type & LEFT))
33d1a814:	e31a0010 	tst	sl, #16	; 0x10
33d1a818:	1a000006 	bne	33d1a838 <number+0x1b8>
		while (size-- > 0)
			*str++ = c;
33d1a81c:	e3550000 	cmp	r5, #0	; 0x0
33d1a820:	e2455001 	sub	r5, r5, #1	; 0x1
33d1a824:	da000003 	ble	33d1a838 <number+0x1b8>
33d1a828:	e59d1010 	ldr	r1, [sp, #16]
33d1a82c:	e4c61001 	strb	r1, [r6], #1
33d1a830:	e3550000 	cmp	r5, #0	; 0x0
33d1a834:	eafffff9 	b	33d1a820 <number+0x1a0>
	while (i < precision--)
		*str++ = '0';
33d1a838:	e15b000c 	cmp	fp, ip
33d1a83c:	e24bb001 	sub	fp, fp, #1	; 0x1
33d1a840:	da000003 	ble	33d1a854 <number+0x1d4>
33d1a844:	e3a03030 	mov	r3, #48	; 0x30
33d1a848:	e4c63001 	strb	r3, [r6], #1
33d1a84c:	e15b000c 	cmp	fp, ip
33d1a850:	eafffff9 	b	33d1a83c <number+0x1bc>
	while (i-- > 0)
		*str++ = tmp[i];
33d1a854:	e35c0000 	cmp	ip, #0	; 0x0
33d1a858:	e24cc001 	sub	ip, ip, #1	; 0x1
33d1a85c:	da000007 	ble	33d1a880 <number+0x200>
33d1a860:	e28d2058 	add	r2, sp, #88	; 0x58
33d1a864:	e08c3002 	add	r3, ip, r2
33d1a868:	e2431044 	sub	r1, r3, #68	; 0x44
33d1a86c:	e4512001 	ldrb	r2, [r1], #-1
33d1a870:	e35c0000 	cmp	ip, #0	; 0x0
33d1a874:	e4c62001 	strb	r2, [r6], #1
33d1a878:	e24cc001 	sub	ip, ip, #1	; 0x1
33d1a87c:	cafffffa 	bgt	33d1a86c <number+0x1ec>
	while (size-- > 0)
		*str++ = ' ';
33d1a880:	e3550000 	cmp	r5, #0	; 0x0
33d1a884:	e2455001 	sub	r5, r5, #1	; 0x1
33d1a888:	da000003 	ble	33d1a89c <number+0x21c>
33d1a88c:	e3a03020 	mov	r3, #32	; 0x20
33d1a890:	e4c63001 	strb	r3, [r6], #1
33d1a894:	e3550000 	cmp	r5, #0	; 0x0
33d1a898:	eafffff9 	b	33d1a884 <number+0x204>
	return str;
33d1a89c:	e1a00006 	mov	r0, r6
}
33d1a8a0:	e28dd058 	add	sp, sp, #88	; 0x58
33d1a8a4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1a8a8:	33d2ce4c 	.word	0x33d2ce4c
33d1a8ac:	33d2ce74 	.word	0x33d2ce74

33d1a8b0 <vsprintf>:

/* Forward decl. needed for IP address printing stuff... */
int sprintf(char * buf, const char *fmt, ...);

int vsprintf(char *buf, const char *fmt, va_list args)
{
33d1a8b0:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
33d1a8b4:	e24dd00c 	sub	sp, sp, #12	; 0xc
33d1a8b8:	e58d1008 	str	r1, [sp, #8]
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'q' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
33d1a8bc:	e5d13000 	ldrb	r3, [r1]

/* Forward decl. needed for IP address printing stuff... */
int sprintf(char * buf, const char *fmt, ...);

int vsprintf(char *buf, const char *fmt, va_list args)
{
33d1a8c0:	e1a09000 	mov	r9, r0
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'q' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
33d1a8c4:	e3530000 	cmp	r3, #0	; 0x0

/* Forward decl. needed for IP address printing stuff... */
int sprintf(char * buf, const char *fmt, ...);

int vsprintf(char *buf, const char *fmt, va_list args)
{
33d1a8c8:	e1a04002 	mov	r4, r2
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'q' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
33d1a8cc:	e1a07000 	mov	r7, r0
33d1a8d0:	0a0000ea 	beq	33d1ac80 <vsprintf+0x3d0>
		if (*fmt != '%') {
33d1a8d4:	e5d11000 	ldrb	r1, [r1]
33d1a8d8:	e3510025 	cmp	r1, #37	; 0x25
			*str++ = *fmt;
33d1a8dc:	14c71001 	strbne	r1, [r7], #1
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'q' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
		if (*fmt != '%') {
33d1a8e0:	1a0000df 	bne	33d1ac64 <vsprintf+0x3b4>
			*str++ = *fmt;
			continue;
		}

		/* process flags */
		flags = 0;
33d1a8e4:	e3a0a000 	mov	sl, #0	; 0x0
		repeat:
			++fmt;		/* this also skips first '%' */
33d1a8e8:	e59d3008 	ldr	r3, [sp, #8]
33d1a8ec:	e2831001 	add	r1, r3, #1	; 0x1
33d1a8f0:	e58d1008 	str	r1, [sp, #8]
			switch (*fmt) {
33d1a8f4:	e5d33001 	ldrb	r3, [r3, #1]
33d1a8f8:	e353002b 	cmp	r3, #43	; 0x2b
33d1a8fc:	0a00000c 	beq	33d1a934 <vsprintf+0x84>
33d1a900:	ca000004 	bgt	33d1a918 <vsprintf+0x68>
33d1a904:	e3530020 	cmp	r3, #32	; 0x20
33d1a908:	0a00000b 	beq	33d1a93c <vsprintf+0x8c>
33d1a90c:	e3530023 	cmp	r3, #35	; 0x23
33d1a910:	0a00000b 	beq	33d1a944 <vsprintf+0x94>
33d1a914:	ea00000e 	b	33d1a954 <vsprintf+0xa4>
33d1a918:	e353002d 	cmp	r3, #45	; 0x2d
33d1a91c:	0a000002 	beq	33d1a92c <vsprintf+0x7c>
33d1a920:	e3530030 	cmp	r3, #48	; 0x30
33d1a924:	0a000008 	beq	33d1a94c <vsprintf+0x9c>
33d1a928:	ea000009 	b	33d1a954 <vsprintf+0xa4>
				case '-': flags |= LEFT; goto repeat;
33d1a92c:	e38aa010 	orr	sl, sl, #16	; 0x10
33d1a930:	eaffffec 	b	33d1a8e8 <vsprintf+0x38>
				case '+': flags |= PLUS; goto repeat;
33d1a934:	e38aa004 	orr	sl, sl, #4	; 0x4
33d1a938:	eaffffea 	b	33d1a8e8 <vsprintf+0x38>
				case ' ': flags |= SPACE; goto repeat;
33d1a93c:	e38aa008 	orr	sl, sl, #8	; 0x8
33d1a940:	eaffffe8 	b	33d1a8e8 <vsprintf+0x38>
				case '#': flags |= SPECIAL; goto repeat;
33d1a944:	e38aa020 	orr	sl, sl, #32	; 0x20
33d1a948:	eaffffe6 	b	33d1a8e8 <vsprintf+0x38>
				case '0': flags |= ZEROPAD; goto repeat;
33d1a94c:	e38aa001 	orr	sl, sl, #1	; 0x1
33d1a950:	eaffffe4 	b	33d1a8e8 <vsprintf+0x38>
				}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
33d1a954:	e5d12000 	ldrb	r2, [r1]
33d1a958:	e2423030 	sub	r3, r2, #48	; 0x30
33d1a95c:	e3530009 	cmp	r3, #9	; 0x9
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
				}

		/* get field width */
		field_width = -1;
33d1a960:	e3e06000 	mvn	r6, #0	; 0x0
		if (is_digit(*fmt))
33d1a964:	8a000003 	bhi	33d1a978 <vsprintf+0xc8>
			field_width = skip_atoi(&fmt);
33d1a968:	e28d0008 	add	r0, sp, #8	; 0x8
33d1a96c:	ebffff31 	bl	33d1a638 <skip_atoi>
33d1a970:	e1a06000 	mov	r6, r0
33d1a974:	ea000008 	b	33d1a99c <vsprintf+0xec>
		else if (*fmt == '*') {
33d1a978:	e352002a 	cmp	r2, #42	; 0x2a
33d1a97c:	1a000006 	bne	33d1a99c <vsprintf+0xec>
			++fmt;
33d1a980:	e2813001 	add	r3, r1, #1	; 0x1
33d1a984:	e58d3008 	str	r3, [sp, #8]
			/* it's the next argument */
			field_width = va_arg(args, int);
33d1a988:	e5946000 	ldr	r6, [r4]
			if (field_width < 0) {
33d1a98c:	e3560000 	cmp	r6, #0	; 0x0
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
33d1a990:	e2844004 	add	r4, r4, #4	; 0x4
			if (field_width < 0) {
				field_width = -field_width;
33d1a994:	b2666000 	rsblt	r6, r6, #0	; 0x0
				flags |= LEFT;
33d1a998:	b38aa010 	orrlt	sl, sl, #16	; 0x10
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
33d1a99c:	e59d2008 	ldr	r2, [sp, #8]
33d1a9a0:	e5d23000 	ldrb	r3, [r2]
33d1a9a4:	e353002e 	cmp	r3, #46	; 0x2e
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
33d1a9a8:	e3e0c000 	mvn	ip, #0	; 0x0
		if (*fmt == '.') {
33d1a9ac:	1a000011 	bne	33d1a9f8 <vsprintf+0x148>
			++fmt;
33d1a9b0:	e2821001 	add	r1, r2, #1	; 0x1
33d1a9b4:	e58d1008 	str	r1, [sp, #8]
			if (is_digit(*fmt))
33d1a9b8:	e5d22001 	ldrb	r2, [r2, #1]
33d1a9bc:	e2423030 	sub	r3, r2, #48	; 0x30
33d1a9c0:	e3530009 	cmp	r3, #9	; 0x9
33d1a9c4:	8a000003 	bhi	33d1a9d8 <vsprintf+0x128>
				precision = skip_atoi(&fmt);
33d1a9c8:	e28d0008 	add	r0, sp, #8	; 0x8
33d1a9cc:	ebffff19 	bl	33d1a638 <skip_atoi>
33d1a9d0:	e1a0c000 	mov	ip, r0
33d1a9d4:	ea000004 	b	33d1a9ec <vsprintf+0x13c>
			else if (*fmt == '*') {
33d1a9d8:	e352002a 	cmp	r2, #42	; 0x2a
33d1a9dc:	1a000004 	bne	33d1a9f4 <vsprintf+0x144>
				++fmt;
33d1a9e0:	e2813001 	add	r3, r1, #1	; 0x1
33d1a9e4:	e58d3008 	str	r3, [sp, #8]
				/* it's the next argument */
				precision = va_arg(args, int);
33d1a9e8:	e494c004 	ldr	ip, [r4], #4
			}
			if (precision < 0)
33d1a9ec:	e35c0000 	cmp	ip, #0	; 0x0
33d1a9f0:	aa000000 	bge	33d1a9f8 <vsprintf+0x148>
				precision = 0;
33d1a9f4:	e3a0c000 	mov	ip, #0	; 0x0
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
33d1a9f8:	e59d3008 	ldr	r3, [sp, #8]
33d1a9fc:	e5d32000 	ldrb	r2, [r3]
33d1aa00:	e352006c 	cmp	r2, #108	; 0x6c
33d1aa04:	13520068 	cmpne	r2, #104	; 0x68
			if (precision < 0)
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
33d1aa08:	e3e01000 	mvn	r1, #0	; 0x0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
33d1aa0c:	0a000001 	beq	33d1aa18 <vsprintf+0x168>
33d1aa10:	e3520071 	cmp	r2, #113	; 0x71
33d1aa14:	1a000002 	bne	33d1aa24 <vsprintf+0x174>
			qualifier = *fmt;
			++fmt;
33d1aa18:	e2833001 	add	r3, r3, #1	; 0x1
33d1aa1c:	e58d3008 	str	r3, [sp, #8]
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
			qualifier = *fmt;
33d1aa20:	e1a01002 	mov	r1, r2
		}

		/* default base */
		base = 10;

		switch (*fmt) {
33d1aa24:	e59d3008 	ldr	r3, [sp, #8]
33d1aa28:	e5d33000 	ldrb	r3, [r3]
33d1aa2c:	e353006e 	cmp	r3, #110	; 0x6e
			qualifier = *fmt;
			++fmt;
		}

		/* default base */
		base = 10;
33d1aa30:	e3a0200a 	mov	r2, #10	; 0xa

		switch (*fmt) {
33d1aa34:	0a00005d 	beq	33d1abb0 <vsprintf+0x300>
33d1aa38:	ca00000d 	bgt	33d1aa74 <vsprintf+0x1c4>
33d1aa3c:	e3530063 	cmp	r3, #99	; 0x63
33d1aa40:	0a000018 	beq	33d1aaa8 <vsprintf+0x1f8>
33d1aa44:	ca000005 	bgt	33d1aa60 <vsprintf+0x1b0>
33d1aa48:	e3530025 	cmp	r3, #37	; 0x25
				*ip = (str - buf);
			}
			continue;

		case '%':
			*str++ = '%';
33d1aa4c:	04c73001 	strbeq	r3, [r7], #1
		}

		/* default base */
		base = 10;

		switch (*fmt) {
33d1aa50:	0a000083 	beq	33d1ac64 <vsprintf+0x3b4>
33d1aa54:	e3530058 	cmp	r3, #88	; 0x58
33d1aa58:	0a00005c 	beq	33d1abd0 <vsprintf+0x320>
33d1aa5c:	ea000060 	b	33d1abe4 <vsprintf+0x334>
33d1aa60:	e3530064 	cmp	r3, #100	; 0x64
33d1aa64:	0a00005c 	beq	33d1abdc <vsprintf+0x32c>
33d1aa68:	e3530069 	cmp	r3, #105	; 0x69
33d1aa6c:	0a00005a 	beq	33d1abdc <vsprintf+0x32c>
33d1aa70:	ea00005b 	b	33d1abe4 <vsprintf+0x334>
33d1aa74:	e3530073 	cmp	r3, #115	; 0x73
33d1aa78:	0a00001f 	beq	33d1aafc <vsprintf+0x24c>
33d1aa7c:	ca000004 	bgt	33d1aa94 <vsprintf+0x1e4>
33d1aa80:	e353006f 	cmp	r3, #111	; 0x6f
33d1aa84:	0a00004f 	beq	33d1abc8 <vsprintf+0x318>
33d1aa88:	e3530070 	cmp	r3, #112	; 0x70
33d1aa8c:	0a00003a 	beq	33d1ab7c <vsprintf+0x2cc>
33d1aa90:	ea000053 	b	33d1abe4 <vsprintf+0x334>
33d1aa94:	e3530075 	cmp	r3, #117	; 0x75
33d1aa98:	0a00005a 	beq	33d1ac08 <vsprintf+0x358>
33d1aa9c:	e3530078 	cmp	r3, #120	; 0x78
33d1aaa0:	0a00004b 	beq	33d1abd4 <vsprintf+0x324>
33d1aaa4:	ea00004e 	b	33d1abe4 <vsprintf+0x334>
		case 'c':
			if (!(flags & LEFT))
33d1aaa8:	e31a0010 	tst	sl, #16	; 0x10
33d1aaac:	1a000007 	bne	33d1aad0 <vsprintf+0x220>
				while (--field_width > 0)
					*str++ = ' ';
33d1aab0:	e2466001 	sub	r6, r6, #1	; 0x1
33d1aab4:	e3560000 	cmp	r6, #0	; 0x0
33d1aab8:	da000004 	ble	33d1aad0 <vsprintf+0x220>
33d1aabc:	e3a03020 	mov	r3, #32	; 0x20
33d1aac0:	e2466001 	sub	r6, r6, #1	; 0x1
33d1aac4:	e4c73001 	strb	r3, [r7], #1
33d1aac8:	e3560000 	cmp	r6, #0	; 0x0
33d1aacc:	eafffff9 	b	33d1aab8 <vsprintf+0x208>
			*str++ = (unsigned char) va_arg(args, int);
33d1aad0:	e5943000 	ldr	r3, [r4]
			while (--field_width > 0)
				*str++ = ' ';
33d1aad4:	e2466001 	sub	r6, r6, #1	; 0x1
		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
33d1aad8:	e4c73001 	strb	r3, [r7], #1
			while (--field_width > 0)
				*str++ = ' ';
33d1aadc:	e3560000 	cmp	r6, #0	; 0x0
		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
33d1aae0:	e2844004 	add	r4, r4, #4	; 0x4
			while (--field_width > 0)
				*str++ = ' ';
33d1aae4:	da00005e 	ble	33d1ac64 <vsprintf+0x3b4>
33d1aae8:	e3a03020 	mov	r3, #32	; 0x20
33d1aaec:	e2466001 	sub	r6, r6, #1	; 0x1
33d1aaf0:	e4c73001 	strb	r3, [r7], #1
33d1aaf4:	e3560000 	cmp	r6, #0	; 0x0
33d1aaf8:	eafffff9 	b	33d1aae4 <vsprintf+0x234>
			continue;

		case 's':
			s = va_arg(args, char *);
33d1aafc:	e5945000 	ldr	r5, [r4]
			if (!s)
				s = "<NULL>";
33d1ab00:	e59f318c 	ldr	r3, [pc, #396]	; 33d1ac94 <vsprintf+0x3e4>
33d1ab04:	e3550000 	cmp	r5, #0	; 0x0
33d1ab08:	01a05003 	moveq	r5, r3

			len = strnlen(s, precision);
33d1ab0c:	e1a0100c 	mov	r1, ip
33d1ab10:	e1a00005 	mov	r0, r5
33d1ab14:	ebfffd94 	bl	33d1a16c <strnlen>

			if (!(flags & LEFT))
33d1ab18:	e31a0010 	tst	sl, #16	; 0x10
			while (--field_width > 0)
				*str++ = ' ';
			continue;

		case 's':
			s = va_arg(args, char *);
33d1ab1c:	e2844004 	add	r4, r4, #4	; 0x4
			if (!s)
				s = "<NULL>";

			len = strnlen(s, precision);

			if (!(flags & LEFT))
33d1ab20:	1a000006 	bne	33d1ab40 <vsprintf+0x290>
				while (len < field_width--)
					*str++ = ' ';
33d1ab24:	e1560000 	cmp	r6, r0
33d1ab28:	e2466001 	sub	r6, r6, #1	; 0x1
33d1ab2c:	da000003 	ble	33d1ab40 <vsprintf+0x290>
33d1ab30:	e3a03020 	mov	r3, #32	; 0x20
33d1ab34:	e4c73001 	strb	r3, [r7], #1
33d1ab38:	e1560000 	cmp	r6, r0
33d1ab3c:	eafffff9 	b	33d1ab28 <vsprintf+0x278>
			for (i = 0; i < len; ++i)
33d1ab40:	e3a02000 	mov	r2, #0	; 0x0
33d1ab44:	e1520000 	cmp	r2, r0
33d1ab48:	aa000004 	bge	33d1ab60 <vsprintf+0x2b0>
				*str++ = *s++;
33d1ab4c:	e4d53001 	ldrb	r3, [r5], #1
			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
33d1ab50:	e2822001 	add	r2, r2, #1	; 0x1
				*str++ = *s++;
33d1ab54:	e4c73001 	strb	r3, [r7], #1
			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
33d1ab58:	e1520000 	cmp	r2, r0
33d1ab5c:	eafffff9 	b	33d1ab48 <vsprintf+0x298>
				*str++ = *s++;
			while (len < field_width--)
				*str++ = ' ';
33d1ab60:	e1560000 	cmp	r6, r0
33d1ab64:	e2466001 	sub	r6, r6, #1	; 0x1
33d1ab68:	da00003d 	ble	33d1ac64 <vsprintf+0x3b4>
33d1ab6c:	e3a03020 	mov	r3, #32	; 0x20
33d1ab70:	e4c73001 	strb	r3, [r7], #1
33d1ab74:	e1560000 	cmp	r6, r0
33d1ab78:	eafffff9 	b	33d1ab64 <vsprintf+0x2b4>
			continue;

		case 'p':
			if (field_width == -1) {
33d1ab7c:	e3760001 	cmn	r6, #1	; 0x1
				field_width = 2*sizeof(void *);
33d1ab80:	02866009 	addeq	r6, r6, #9	; 0x9
				flags |= ZEROPAD;
			}
			str = number(str,
33d1ab84:	e5941000 	ldr	r1, [r4]
			continue;

		case 'p':
			if (field_width == -1) {
				field_width = 2*sizeof(void *);
				flags |= ZEROPAD;
33d1ab88:	038aa001 	orreq	sl, sl, #1	; 0x1
			}
			str = number(str,
33d1ab8c:	e1a00007 	mov	r0, r7
33d1ab90:	e1a03006 	mov	r3, r6
33d1ab94:	e3a02010 	mov	r2, #16	; 0x10
33d1ab98:	e58dc000 	str	ip, [sp]
33d1ab9c:	e58da004 	str	sl, [sp, #4]
33d1aba0:	ebfffeb6 	bl	33d1a680 <number>
33d1aba4:	e2844004 	add	r4, r4, #4	; 0x4
33d1aba8:	e1a07000 	mov	r7, r0
				(unsigned long) va_arg(args, void *), 16,
				field_width, precision, flags);
			continue;
33d1abac:	ea00002c 	b	33d1ac64 <vsprintf+0x3b4>
		case 'n':
			if (qualifier == 'l') {
				long * ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int * ip = va_arg(args, int *);
33d1abb0:	e5943000 	ldr	r3, [r4]
33d1abb4:	e2840004 	add	r0, r4, #4	; 0x4
33d1abb8:	e0692007 	rsb	r2, r9, r7
33d1abbc:	e1a04000 	mov	r4, r0
				*ip = (str - buf);
33d1abc0:	e5832000 	str	r2, [r3]
			}
			continue;
33d1abc4:	ea000026 	b	33d1ac64 <vsprintf+0x3b4>
			*str++ = '%';
			continue;

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
33d1abc8:	e3a02008 	mov	r2, #8	; 0x8
			break;
33d1abcc:	ea00000d 	b	33d1ac08 <vsprintf+0x358>

		case 'X':
			flags |= LARGE;
33d1abd0:	e38aa040 	orr	sl, sl, #64	; 0x40
		case 'x':
			base = 16;
33d1abd4:	e3a02010 	mov	r2, #16	; 0x10
			break;
33d1abd8:	ea00000a 	b	33d1ac08 <vsprintf+0x358>

		case 'd':
		case 'i':
			flags |= SIGN;
33d1abdc:	e38aa002 	orr	sl, sl, #2	; 0x2
		case 'u':
			break;
33d1abe0:	ea000008 	b	33d1ac08 <vsprintf+0x358>

		default:
			*str++ = '%';
33d1abe4:	e3a03025 	mov	r3, #37	; 0x25
33d1abe8:	e4c73001 	strb	r3, [r7], #1
			if (*fmt)
33d1abec:	e59d3008 	ldr	r3, [sp, #8]
33d1abf0:	e5d32000 	ldrb	r2, [r3]
33d1abf4:	e3520000 	cmp	r2, #0	; 0x0
				*str++ = *fmt;
33d1abf8:	14c72001 	strbne	r2, [r7], #1
			else
				--fmt;
33d1abfc:	02433001 	subeq	r3, r3, #1	; 0x1
33d1ac00:	058d3008 	streq	r3, [sp, #8]
			continue;
33d1ac04:	ea000016 	b	33d1ac64 <vsprintf+0x3b4>
#ifdef CFG_64BIT_VSPRINTF
		if (qualifier == 'q')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else
#endif
		if (qualifier == 'l')
33d1ac08:	e351006c 	cmp	r1, #108	; 0x6c
			num = va_arg(args, unsigned long);
33d1ac0c:	01a03004 	moveq	r3, r4
33d1ac10:	05931000 	ldreq	r1, [r3]
33d1ac14:	02844004 	addeq	r4, r4, #4	; 0x4
#ifdef CFG_64BIT_VSPRINTF
		if (qualifier == 'q')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else
#endif
		if (qualifier == 'l')
33d1ac18:	0a00000b 	beq	33d1ac4c <vsprintf+0x39c>
			num = va_arg(args, unsigned long);
		else if (qualifier == 'h') {
33d1ac1c:	e3510068 	cmp	r1, #104	; 0x68
33d1ac20:	e20a3002 	and	r3, sl, #2	; 0x2
33d1ac24:	12840004 	addne	r0, r4, #4	; 0x4
			if (flags & SIGN)
				num = (short) num;
		} else if (flags & SIGN)
			num = va_arg(args, int);
		else
			num = va_arg(args, unsigned int);
33d1ac28:	11a03004 	movne	r3, r4
33d1ac2c:	15931000 	ldrne	r1, [r3]
33d1ac30:	11a04000 	movne	r4, r0
			num = va_arg(args, unsigned long long);
		else
#endif
		if (qualifier == 'l')
			num = va_arg(args, unsigned long);
		else if (qualifier == 'h') {
33d1ac34:	1a000004 	bne	33d1ac4c <vsprintf+0x39c>
			num = (unsigned short) va_arg(args, int);
33d1ac38:	e1d410b0 	ldrh	r1, [r4]
			if (flags & SIGN)
33d1ac3c:	e3530000 	cmp	r3, #0	; 0x0
				num = (short) num;
33d1ac40:	11a03801 	lslne	r3, r1, #16
		else
#endif
		if (qualifier == 'l')
			num = va_arg(args, unsigned long);
		else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
33d1ac44:	e2844004 	add	r4, r4, #4	; 0x4
			if (flags & SIGN)
				num = (short) num;
33d1ac48:	11a01843 	asrne	r1, r3, #16
		} else if (flags & SIGN)
			num = va_arg(args, int);
		else
			num = va_arg(args, unsigned int);
		str = number(str, num, base, field_width, precision, flags);
33d1ac4c:	e1a00007 	mov	r0, r7
33d1ac50:	e1a03006 	mov	r3, r6
33d1ac54:	e58dc000 	str	ip, [sp]
33d1ac58:	e58da004 	str	sl, [sp, #4]
33d1ac5c:	ebfffe87 	bl	33d1a680 <number>
33d1ac60:	e1a07000 	mov	r7, r0
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'q' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
33d1ac64:	e59d3008 	ldr	r3, [sp, #8]
33d1ac68:	e2832001 	add	r2, r3, #1	; 0x1
33d1ac6c:	e58d2008 	str	r2, [sp, #8]
33d1ac70:	e5d33001 	ldrb	r3, [r3, #1]
33d1ac74:	e1a01002 	mov	r1, r2
33d1ac78:	e3530000 	cmp	r3, #0	; 0x0
33d1ac7c:	eaffff13 	b	33d1a8d0 <vsprintf+0x20>
			num = va_arg(args, int);
		else
			num = va_arg(args, unsigned int);
		str = number(str, num, base, field_width, precision, flags);
	}
	*str = '\0';
33d1ac80:	e3a03000 	mov	r3, #0	; 0x0
	return str-buf;
}
33d1ac84:	e0690007 	rsb	r0, r9, r7
			num = va_arg(args, int);
		else
			num = va_arg(args, unsigned int);
		str = number(str, num, base, field_width, precision, flags);
	}
	*str = '\0';
33d1ac88:	e5c73000 	strb	r3, [r7]
	return str-buf;
}
33d1ac8c:	e28dd00c 	add	sp, sp, #12	; 0xc
33d1ac90:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
33d1ac94:	33d2ce9c 	.word	0x33d2ce9c

33d1ac98 <printk>:
 * One effect of this deferred printing is that code which calls printk() and
 * then changes console_loglevel may break. This is because console_loglevel
 * is inspected when the actual printing occurs.
 */
int printk(const char *fmt, ...)
{
33d1ac98:	e92d000f 	push	{r0, r1, r2, r3}
33d1ac9c:	e92d4030 	push	{r4, r5, lr}
	char *p;
	static char printk_buf[1024];

	/* Emit the output into the temporary buffer */
	va_start(args, fmt);
	printed_len = vsprintf(printk_buf, fmt, args);
33d1aca0:	e59f4048 	ldr	r4, [pc, #72]	; 33d1acf0 <printk+0x58>
33d1aca4:	e59d100c 	ldr	r1, [sp, #12]
33d1aca8:	e1a00004 	mov	r0, r4
33d1acac:	e28d2010 	add	r2, sp, #16	; 0x10
33d1acb0:	ebfffefe 	bl	33d1a8b0 <vsprintf>

	/*
	 * Copy the output into log_buf.  If the caller didn't provide
	 * appropriate log level tags, we insert them here
	 */
	for (p = printk_buf; *p; p++) {
33d1acb4:	e5d43000 	ldrb	r3, [r4]
	char *p;
	static char printk_buf[1024];

	/* Emit the output into the temporary buffer */
	va_start(args, fmt);
	printed_len = vsprintf(printk_buf, fmt, args);
33d1acb8:	e1a05000 	mov	r5, r0

	/*
	 * Copy the output into log_buf.  If the caller didn't provide
	 * appropriate log level tags, we insert them here
	 */
	for (p = printk_buf; *p; p++) {
33d1acbc:	e3530000 	cmp	r3, #0	; 0x0
33d1acc0:	0a000006 	beq	33d1ace0 <printk+0x48>
		if (*p == '\n')
33d1acc4:	e353000a 	cmp	r3, #10	; 0xa
			putc('\r');
33d1acc8:	e3a0000d 	mov	r0, #13	; 0xd
33d1accc:	0bfff0ac 	bleq	33d16f84 <putc>
		putc(*p);
33d1acd0:	e5d40000 	ldrb	r0, [r4]
33d1acd4:	ebfff0aa 	bl	33d16f84 <putc>

	/*
	 * Copy the output into log_buf.  If the caller didn't provide
	 * appropriate log level tags, we insert them here
	 */
	for (p = printk_buf; *p; p++) {
33d1acd8:	e5f43001 	ldrb	r3, [r4, #1]!
33d1acdc:	eafffff6 	b	33d1acbc <printk+0x24>
			putc('\r');
		putc(*p);
	}

	return printed_len;
}
33d1ace0:	e1a00005 	mov	r0, r5
33d1ace4:	e8bd4030 	pop	{r4, r5, lr}
33d1ace8:	e28dd010 	add	sp, sp, #16	; 0x10
33d1acec:	e1a0f00e 	mov	pc, lr
33d1acf0:	33d610ac 	.word	0x33d610ac

33d1acf4 <sprintf>:

int sprintf(char * buf, const char *fmt, ...)
{
33d1acf4:	e92d000e 	push	{r1, r2, r3}
33d1acf8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	va_list args;
	int i;

	va_start(args, fmt);
	i=vsprintf(buf,fmt,args);
33d1acfc:	e59d1004 	ldr	r1, [sp, #4]
33d1ad00:	e28d2008 	add	r2, sp, #8	; 0x8
33d1ad04:	ebfffee9 	bl	33d1a8b0 <vsprintf>
	va_end(args);
	return i;
}
33d1ad08:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d1ad0c:	e28dd00c 	add	sp, sp, #12	; 0xc
33d1ad10:	e1a0f00e 	mov	pc, lr

33d1ad14 <panic>:

void panic(const char *fmt, ...)
{
33d1ad14:	e92d000f 	push	{r0, r1, r2, r3}
33d1ad18:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	va_list	args;
	va_start(args, fmt);
	vprintf(fmt, args);
33d1ad1c:	e59d0004 	ldr	r0, [sp, #4]
33d1ad20:	e28d1008 	add	r1, sp, #8	; 0x8
33d1ad24:	ebfff0b5 	bl	33d17000 <vprintf>
	putc('\n');
33d1ad28:	e3a0000a 	mov	r0, #10	; 0xa
33d1ad2c:	ebfff094 	bl	33d16f84 <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
33d1ad30:	e59f0020 	ldr	r0, [pc, #32]	; 33d1ad58 <panic+0x44>
33d1ad34:	ebff9834 	bl	33d00e0c <udelay>
	do_reset (NULL, 0, 0, NULL);
33d1ad38:	e3a00000 	mov	r0, #0	; 0x0
33d1ad3c:	e1a01000 	mov	r1, r0
33d1ad40:	e1a02000 	mov	r2, r0
33d1ad44:	e1a03000 	mov	r3, r0
33d1ad48:	eb000d31 	bl	33d1e214 <do_reset>
33d1ad4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
33d1ad50:	e28dd010 	add	sp, sp, #16	; 0x10
33d1ad54:	e1a0f00e 	mov	pc, lr
33d1ad58:	000186a0 	.word	0x000186a0

33d1ad5c <inflate_codes_free>:


local void inflate_codes_free(c, z)
inflate_codes_statef *c;
z_stream *z;
{
33d1ad5c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d1ad60:	e1a03001 	mov	r3, r1
  ZFREE(z, c, sizeof(struct inflate_codes_state));
33d1ad64:	e3a0201c 	mov	r2, #28	; 0x1c
33d1ad68:	e1a01000 	mov	r1, r0
33d1ad6c:	e5930028 	ldr	r0, [r3, #40]
33d1ad70:	e1a0e00f 	mov	lr, pc
33d1ad74:	e593f024 	ldr	pc, [r3, #36]
33d1ad78:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1ad7c <inflate_trees_free>:
inflate_huft *t;        /* table to free */
z_stream *z;            /* for zfree function */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
33d1ad7c:	e92d4030 	push	{r4, r5, lr}
  p = t;
  while (p != Z_NULL)
  {
    q = (--p)->next;
    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
    p = q;
33d1ad80:	e3500000 	cmp	r0, #0	; 0x0
inflate_huft *t;        /* table to free */
z_stream *z;            /* for zfree function */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
33d1ad84:	e1a05001 	mov	r5, r1
  p = t;
  while (p != Z_NULL)
  {
    q = (--p)->next;
    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
    p = q;
33d1ad88:	0a000009 	beq	33d1adb4 <inflate_trees_free+0x38>

  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != Z_NULL)
  {
    q = (--p)->next;
33d1ad8c:	e2400008 	sub	r0, r0, #8	; 0x8
    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
33d1ad90:	e8900014 	ldm	r0, {r2, r4}
33d1ad94:	e1a01000 	mov	r1, r0
33d1ad98:	e1a02182 	lsl	r2, r2, #3
33d1ad9c:	e5950028 	ldr	r0, [r5, #40]
33d1ada0:	e1a0e00f 	mov	lr, pc
33d1ada4:	e595f024 	ldr	pc, [r5, #36]
    p = q;
33d1ada8:	e1a00004 	mov	r0, r4
33d1adac:	e3540000 	cmp	r4, #0	; 0x0
33d1adb0:	eafffff4 	b	33d1ad88 <inflate_trees_free+0xc>
  }
  return Z_OK;
}
33d1adb4:	e3a00000 	mov	r0, #0	; 0x0
33d1adb8:	e8bd8030 	pop	{r4, r5, pc}

33d1adbc <inflate_blocks_reset>:

local void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_stream *z;
uLongf *c;
{
33d1adbc:	e92d4070 	push	{r4, r5, r6, lr}
  if (s->checkfn != Z_NULL)
33d1adc0:	e5903038 	ldr	r3, [r0, #56]
33d1adc4:	e3530000 	cmp	r3, #0	; 0x0
    *c = s->check;
33d1adc8:	1590303c 	ldrne	r3, [r0, #60]
33d1adcc:	15823000 	strne	r3, [r2]
  if (s->mode == BTREE || s->mode == DTREE)
33d1add0:	e5903000 	ldr	r3, [r0]
33d1add4:	e2433004 	sub	r3, r3, #4	; 0x4
33d1add8:	e3530001 	cmp	r3, #1	; 0x1

local void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_stream *z;
uLongf *c;
{
33d1addc:	e1a04000 	mov	r4, r0
33d1ade0:	e1a06001 	mov	r6, r1
  if (s->checkfn != Z_NULL)
    *c = s->check;
  if (s->mode == BTREE || s->mode == DTREE)
    ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
33d1ade4:	95902018 	ldrls	r2, [r0, #24]
33d1ade8:	95910028 	ldrls	r0, [r1, #40]
33d1adec:	91a02102 	lslls	r2, r2, #2
33d1adf0:	9594100c 	ldrls	r1, [r4, #12]
33d1adf4:	91a0e00f 	movls	lr, pc
33d1adf8:	9596f024 	ldrls	pc, [r6, #36]
  if (s->mode == CODES)
33d1adfc:	e5943000 	ldr	r3, [r4]
33d1ae00:	e3530006 	cmp	r3, #6	; 0x6
33d1ae04:	1a000008 	bne	33d1ae2c <inflate_blocks_reset+0x70>
  {
    inflate_codes_free(s->sub.decode.codes, z);
33d1ae08:	e594000c 	ldr	r0, [r4, #12]
33d1ae0c:	e1a01006 	mov	r1, r6
33d1ae10:	ebffffd1 	bl	33d1ad5c <inflate_codes_free>
    inflate_trees_free(s->sub.decode.td, z);
33d1ae14:	e1a01006 	mov	r1, r6
33d1ae18:	e5940008 	ldr	r0, [r4, #8]
33d1ae1c:	ebffffd6 	bl	33d1ad7c <inflate_trees_free>
    inflate_trees_free(s->sub.decode.tl, z);
33d1ae20:	e5940004 	ldr	r0, [r4, #4]
33d1ae24:	e1a01006 	mov	r1, r6
33d1ae28:	ebffffd3 	bl	33d1ad7c <inflate_trees_free>
  }
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
33d1ae2c:	e594c038 	ldr	ip, [r4, #56]
    inflate_trees_free(s->sub.decode.tl, z);
  }
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
33d1ae30:	e5943028 	ldr	r3, [r4, #40]
  {
    inflate_codes_free(s->sub.decode.codes, z);
    inflate_trees_free(s->sub.decode.td, z);
    inflate_trees_free(s->sub.decode.tl, z);
  }
  s->mode = TYPE;
33d1ae34:	e3a05000 	mov	r5, #0	; 0x0
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
33d1ae38:	e35c0000 	cmp	ip, #0	; 0x0
    inflate_trees_free(s->sub.decode.tl, z);
  }
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
33d1ae3c:	e5843030 	str	r3, [r4, #48]
  {
    inflate_codes_free(s->sub.decode.codes, z);
    inflate_trees_free(s->sub.decode.td, z);
    inflate_trees_free(s->sub.decode.tl, z);
  }
  s->mode = TYPE;
33d1ae40:	e5845000 	str	r5, [r4]
  s->bitk = 0;
33d1ae44:	e5845020 	str	r5, [r4, #32]
  s->bitb = 0;
33d1ae48:	e5845024 	str	r5, [r4, #36]
  s->read = s->write = s->window;
33d1ae4c:	e5843034 	str	r3, [r4, #52]
  if (s->checkfn != Z_NULL)
33d1ae50:	0a000005 	beq	33d1ae6c <inflate_blocks_reset+0xb0>
    s->check = (*s->checkfn)(0L, Z_NULL, 0);
33d1ae54:	e1a00005 	mov	r0, r5
33d1ae58:	e1a01005 	mov	r1, r5
33d1ae5c:	e1a02005 	mov	r2, r5
33d1ae60:	e1a0e00f 	mov	lr, pc
33d1ae64:	e1a0f00c 	mov	pc, ip
33d1ae68:	e584003c 	str	r0, [r4, #60]
  if (z->outcb != Z_NULL)
33d1ae6c:	e5963030 	ldr	r3, [r6, #48]
33d1ae70:	e3530000 	cmp	r3, #0	; 0x0
33d1ae74:	08bd8070 	popeq	{r4, r5, r6, pc}
    (*z->outcb)(Z_NULL, 0);
33d1ae78:	e1a00005 	mov	r0, r5
33d1ae7c:	e1a01005 	mov	r1, r5
33d1ae80:	e1a0e00f 	mov	lr, pc
33d1ae84:	e1a0f003 	mov	pc, r3
33d1ae88:	e8bd8070 	pop	{r4, r5, r6, pc}

33d1ae8c <inflateEnd>:
}


int inflateEnd(z)
z_stream *z;
{
33d1ae8c:	e92d4030 	push	{r4, r5, lr}
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
33d1ae90:	e2504000 	subs	r4, r0, #0	; 0x0
}


int inflateEnd(z)
z_stream *z;
{
33d1ae94:	e24dd004 	sub	sp, sp, #4	; 0x4
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
33d1ae98:	e3e02001 	mvn	r2, #1	; 0x1
int inflateEnd(z)
z_stream *z;
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
33d1ae9c:	0a00001f 	beq	33d1af20 <inflateEnd+0x94>
33d1aea0:	e594001c 	ldr	r0, [r4, #28]
33d1aea4:	e3500000 	cmp	r0, #0	; 0x0
33d1aea8:	0a00001c 	beq	33d1af20 <inflateEnd+0x94>
33d1aeac:	e5943024 	ldr	r3, [r4, #36]
33d1aeb0:	e3530000 	cmp	r3, #0	; 0x0
33d1aeb4:	0a000019 	beq	33d1af20 <inflateEnd+0x94>
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
33d1aeb8:	e5905014 	ldr	r5, [r0, #20]
33d1aebc:	e2550000 	subs	r0, r5, #0	; 0x0
local int inflate_blocks_free(s, z, c)
inflate_blocks_statef *s;
z_stream *z;
uLongf *c;
{
  inflate_blocks_reset(s, z, c);
33d1aec0:	e1a01004 	mov	r1, r4
33d1aec4:	e1a0200d 	mov	r2, sp
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
33d1aec8:	0a00000c 	beq	33d1af00 <inflateEnd+0x74>
local int inflate_blocks_free(s, z, c)
inflate_blocks_statef *s;
z_stream *z;
uLongf *c;
{
  inflate_blocks_reset(s, z, c);
33d1aecc:	ebffffba 	bl	33d1adbc <inflate_blocks_reset>
  ZFREE(z, s->window, s->end - s->window);
33d1aed0:	e285302c 	add	r3, r5, #44	; 0x2c
33d1aed4:	e813000c 	ldmda	r3, {r2, r3}
33d1aed8:	e0432002 	sub	r2, r3, r2
33d1aedc:	e5940028 	ldr	r0, [r4, #40]
33d1aee0:	e5951028 	ldr	r1, [r5, #40]
33d1aee4:	e1a0e00f 	mov	lr, pc
33d1aee8:	e594f024 	ldr	pc, [r4, #36]
  ZFREE(z, s, sizeof(struct inflate_blocks_state));
33d1aeec:	e1a01005 	mov	r1, r5
33d1aef0:	e5940028 	ldr	r0, [r4, #40]
33d1aef4:	e3a02040 	mov	r2, #64	; 0x40
33d1aef8:	e1a0e00f 	mov	lr, pc
33d1aefc:	e594f024 	ldr	pc, [r4, #36]

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z, &c);
  ZFREE(z, z->state, sizeof(struct internal_state));
33d1af00:	e3a02018 	mov	r2, #24	; 0x18
33d1af04:	e5940028 	ldr	r0, [r4, #40]
33d1af08:	e594101c 	ldr	r1, [r4, #28]
33d1af0c:	e1a0e00f 	mov	lr, pc
33d1af10:	e594f024 	ldr	pc, [r4, #36]
  z->state = Z_NULL;
33d1af14:	e3a03000 	mov	r3, #0	; 0x0
33d1af18:	e584301c 	str	r3, [r4, #28]
  Trace((stderr, "inflate: end\n"));
  return Z_OK;
33d1af1c:	e1a02003 	mov	r2, r3
}
33d1af20:	e1a00002 	mov	r0, r2
33d1af24:	e28dd004 	add	sp, sp, #4	; 0x4
33d1af28:	e8bd8030 	pop	{r4, r5, pc}

33d1af2c <inflateReset>:
};


int inflateReset(z)
z_stream *z;
{
33d1af2c:	e92d4010 	push	{r4, lr}
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
33d1af30:	e3500000 	cmp	r0, #0	; 0x0
};


int inflateReset(z)
z_stream *z;
{
33d1af34:	e24dd004 	sub	sp, sp, #4	; 0x4
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
33d1af38:	e3e03001 	mvn	r3, #1	; 0x1
int inflateReset(z)
z_stream *z;
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
33d1af3c:	0a000011 	beq	33d1af88 <inflateReset+0x5c>
33d1af40:	e590c01c 	ldr	ip, [r0, #28]
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
33d1af44:	e3a04000 	mov	r4, #0	; 0x0
int inflateReset(z)
z_stream *z;
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
33d1af48:	e15c0004 	cmp	ip, r4
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, &c);
33d1af4c:	e1a01000 	mov	r1, r0
33d1af50:	e1a0200d 	mov	r2, sp
int inflateReset(z)
z_stream *z;
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
33d1af54:	0a00000b 	beq	33d1af88 <inflateReset+0x5c>
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
33d1af58:	e5804014 	str	r4, [r0, #20]
33d1af5c:	e5804008 	str	r4, [r0, #8]
  z->msg = Z_NULL;
33d1af60:	e5804018 	str	r4, [r0, #24]
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
33d1af64:	e59c300c 	ldr	r3, [ip, #12]
33d1af68:	e3530000 	cmp	r3, #0	; 0x0
33d1af6c:	13a03002 	movne	r3, #2	; 0x2
33d1af70:	03a03000 	moveq	r3, #0	; 0x0
33d1af74:	e58c3000 	str	r3, [ip]
  inflate_blocks_reset(z->state->blocks, z, &c);
33d1af78:	e590301c 	ldr	r3, [r0, #28]
33d1af7c:	e5930014 	ldr	r0, [r3, #20]
33d1af80:	ebffff8d 	bl	33d1adbc <inflate_blocks_reset>
  Trace((stderr, "inflate: reset\n"));
  return Z_OK;
33d1af84:	e1a03004 	mov	r3, r4
}
33d1af88:	e1a00003 	mov	r0, r3
33d1af8c:	e28dd004 	add	sp, sp, #4	; 0x4
33d1af90:	e8bd8010 	pop	{r4, pc}

33d1af94 <inflateSync>:
}


int inflateSync(z)
z_stream *z;
{
33d1af94:	e92d4070 	push	{r4, r5, r6, lr}
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
33d1af98:	e2506000 	subs	r6, r0, #0	; 0x0
33d1af9c:	0a000002 	beq	33d1afac <inflateSync+0x18>
33d1afa0:	e596201c 	ldr	r2, [r6, #28]
33d1afa4:	e3520000 	cmp	r2, #0	; 0x0
33d1afa8:	1a000001 	bne	33d1afb4 <inflateSync+0x20>
    return Z_STREAM_ERROR;
33d1afac:	e3e00001 	mvn	r0, #1	; 0x1
33d1afb0:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (z->state->mode != BAD)
33d1afb4:	e5923000 	ldr	r3, [r2]
33d1afb8:	e3530008 	cmp	r3, #8	; 0x8
  {
    z->state->mode = BAD;
33d1afbc:	13a03008 	movne	r3, #8	; 0x8
33d1afc0:	15823000 	strne	r3, [r2]
    z->state->sub.marker = 0;
33d1afc4:	1596201c 	ldrne	r2, [r6, #28]
33d1afc8:	12433008 	subne	r3, r3, #8	; 0x8
33d1afcc:	15823004 	strne	r3, [r2, #4]
  }
  if ((n = z->avail_in) == 0)
33d1afd0:	e596c004 	ldr	ip, [r6, #4]
33d1afd4:	e35c0000 	cmp	ip, #0	; 0x0
    return Z_BUF_ERROR;
33d1afd8:	03e00004 	mvneq	r0, #4	; 0x4
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
33d1afdc:	08bd8070 	popeq	{r4, r5, r6, pc}
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;
33d1afe0:	e596e01c 	ldr	lr, [r6, #28]
33d1afe4:	e59e1004 	ldr	r1, [lr, #4]
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
33d1afe8:	e5960000 	ldr	r0, [r6]
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
33d1afec:	e3510003 	cmp	r1, #3	; 0x3
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
33d1aff0:	e1a04000 	mov	r4, r0
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
33d1aff4:	8a000014 	bhi	33d1b04c <inflateSync+0xb8>
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    if (*p == (Byte)(m < 2 ? 0 : 0xff))
33d1aff8:	e5d02000 	ldrb	r2, [r0]
33d1affc:	e3510001 	cmp	r1, #1	; 0x1
33d1b000:	e20230ff 	and	r3, r2, #255	; 0xff
33d1b004:	8a000001 	bhi	33d1b010 <inflateSync+0x7c>
33d1b008:	e3530000 	cmp	r3, #0	; 0x0
33d1b00c:	ea000000 	b	33d1b014 <inflateSync+0x80>
33d1b010:	e35300ff 	cmp	r3, #255	; 0xff
      m++;
33d1b014:	02811001 	addeq	r1, r1, #1	; 0x1
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    if (*p == (Byte)(m < 2 ? 0 : 0xff))
33d1b018:	0a000002 	beq	33d1b028 <inflateSync+0x94>
      m++;
    else if (*p)
33d1b01c:	e3520000 	cmp	r2, #0	; 0x0
      m = 0;
    else
      m = 4 - m;
33d1b020:	e2611004 	rsb	r1, r1, #4	; 0x4
  while (n && m < 4)
  {
    if (*p == (Byte)(m < 2 ? 0 : 0xff))
      m++;
    else if (*p)
      m = 0;
33d1b024:	13a01000 	movne	r1, #0	; 0x0
    else
      m = 4 - m;
    p++, n--;
33d1b028:	e25cc001 	subs	ip, ip, #1	; 0x1
33d1b02c:	03a03000 	moveq	r3, #0	; 0x0
33d1b030:	13a03001 	movne	r3, #1	; 0x1
33d1b034:	e3510003 	cmp	r1, #3	; 0x3
33d1b038:	83a03000 	movhi	r3, #0	; 0x0
33d1b03c:	92033001 	andls	r3, r3, #1	; 0x1
33d1b040:	e3530000 	cmp	r3, #0	; 0x0
33d1b044:	e2800001 	add	r0, r0, #1	; 0x1
33d1b048:	1affffea 	bne	33d1aff8 <inflateSync+0x64>
  }

  /* restore */
  z->total_in += p - z->next_in;
33d1b04c:	e5963008 	ldr	r3, [r6, #8]
33d1b050:	e0642000 	rsb	r2, r4, r0
33d1b054:	e0833002 	add	r3, r3, r2
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
33d1b058:	e3510004 	cmp	r1, #4	; 0x4
    p++, n--;
  }

  /* restore */
  z->total_in += p - z->next_in;
  z->next_in = p;
33d1b05c:	e5860000 	str	r0, [r6]
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  z->total_in += p - z->next_in;
33d1b060:	e5863008 	str	r3, [r6, #8]
  z->next_in = p;
  z->avail_in = n;
33d1b064:	e586c004 	str	ip, [r6, #4]
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
33d1b068:	13e00002 	mvnne	r0, #2	; 0x2

  /* restore */
  z->total_in += p - z->next_in;
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;
33d1b06c:	e58e1004 	str	r1, [lr, #4]

  /* return no joy or set up to restart on a new block */
  if (m != 4)
33d1b070:	18bd8070 	popne	{r4, r5, r6, pc}
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
33d1b074:	e1a00006 	mov	r0, r6
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
33d1b078:	e5964008 	ldr	r4, [r6, #8]
33d1b07c:	e5965014 	ldr	r5, [r6, #20]
  inflateReset(z);
33d1b080:	ebffffa9 	bl	33d1af2c <inflateReset>
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
33d1b084:	e596201c 	ldr	r2, [r6, #28]
33d1b088:	e3a03002 	mov	r3, #2	; 0x2
  return Z_OK;
33d1b08c:	e3a00000 	mov	r0, #0	; 0x0
  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
33d1b090:	e5864008 	str	r4, [r6, #8]
33d1b094:	e5865014 	str	r5, [r6, #20]
  z->state->mode = BLOCKS;
33d1b098:	e5823000 	str	r3, [r2]
  return Z_OK;
}
33d1b09c:	e8bd8070 	pop	{r4, r5, r6, pc}

33d1b0a0 <inflateInit2>:


int inflateInit2(z, w)
z_stream *z;
int w;
{
33d1b0a0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  /* initialize state */
  if (z == Z_NULL)
33d1b0a4:	e2505000 	subs	r5, r0, #0	; 0x0


int inflateInit2(z, w)
z_stream *z;
int w;
{
33d1b0a8:	e24dd004 	sub	sp, sp, #4	; 0x4
33d1b0ac:	e1a06001 	mov	r6, r1
  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
33d1b0b0:	02400002 	subeq	r0, r0, #2	; 0x2
int inflateInit2(z, w)
z_stream *z;
int w;
{
  /* initialize state */
  if (z == Z_NULL)
33d1b0b4:	0a00004e 	beq	33d1b1f4 <inflateInit2+0x154>
    return Z_STREAM_ERROR;
/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
  if ((z->state = (struct internal_state FAR *)
33d1b0b8:	e5950028 	ldr	r0, [r5, #40]
33d1b0bc:	e3a01001 	mov	r1, #1	; 0x1
33d1b0c0:	e3a02018 	mov	r2, #24	; 0x18
33d1b0c4:	e1a0e00f 	mov	lr, pc
33d1b0c8:	e595f020 	ldr	pc, [r5, #32]
33d1b0cc:	e3500000 	cmp	r0, #0	; 0x0
33d1b0d0:	e585001c 	str	r0, [r5, #28]
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
33d1b0d4:	02400004 	subeq	r0, r0, #4	; 0x4
  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
  if ((z->state = (struct internal_state FAR *)
33d1b0d8:	0a000045 	beq	33d1b1f4 <inflateInit2+0x154>
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;
33d1b0dc:	e3a0b000 	mov	fp, #0	; 0x0
33d1b0e0:	e580b014 	str	fp, [r0, #20]

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
33d1b0e4:	e595301c 	ldr	r3, [r5, #28]
33d1b0e8:	e583b00c 	str	fp, [r3, #12]
  if (w < 0)
33d1b0ec:	e156000b 	cmp	r6, fp
  {
    w = - w;
    z->state->nowrap = 1;
33d1b0f0:	b595201c 	ldrlt	r2, [r5, #28]
33d1b0f4:	b3a03001 	movlt	r3, #1	; 0x1

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
33d1b0f8:	b2666000 	rsblt	r6, r6, #0	; 0x0
    z->state->nowrap = 1;
33d1b0fc:	b582300c 	strlt	r3, [r2, #12]
  }

  /* set window size */
  if (w < 8 || w > 15)
33d1b100:	e2463008 	sub	r3, r6, #8	; 0x8
33d1b104:	e3530007 	cmp	r3, #7	; 0x7
33d1b108:	9a000003 	bls	33d1b11c <inflateInit2+0x7c>
  {
    inflateEnd(z);
33d1b10c:	e1a00005 	mov	r0, r5
33d1b110:	ebffff5d 	bl	33d1ae8c <inflateEnd>
    return Z_STREAM_ERROR;
33d1b114:	e3e00001 	mvn	r0, #1	; 0x1
33d1b118:	ea000035 	b	33d1b1f4 <inflateInit2+0x154>
  }
  z->state->wbits = (uInt)w;
33d1b11c:	e595301c 	ldr	r3, [r5, #28]
33d1b120:	e5836010 	str	r6, [r3, #16]

  /* create inflate_blocks state */
  if ((z->state->blocks =
33d1b124:	e595301c 	ldr	r3, [r5, #28]
33d1b128:	e58d3000 	str	r3, [sp]

local inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_stream *z;
check_func c;
uInt w;
{
33d1b12c:	e593c00c 	ldr	ip, [r3, #12]
33d1b130:	e3a07001 	mov	r7, #1	; 0x1
33d1b134:	e59f30c0 	ldr	r3, [pc, #192]	; 33d1b1fc <inflateInit2+0x15c>
33d1b138:	e35c0000 	cmp	ip, #0	; 0x0
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
33d1b13c:	e5950028 	ldr	r0, [r5, #40]
33d1b140:	e1a01007 	mov	r1, r7
33d1b144:	e3a02040 	mov	r2, #64	; 0x40

local inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_stream *z;
check_func c;
uInt w;
{
33d1b148:	01a09003 	moveq	r9, r3
33d1b14c:	13a09000 	movne	r9, #0	; 0x0
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
33d1b150:	e1a0e00f 	mov	lr, pc
33d1b154:	e595f020 	ldr	pc, [r5, #32]
33d1b158:	e2504000 	subs	r4, r0, #0	; 0x0

local inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_stream *z;
check_func c;
uInt w;
{
33d1b15c:	e1a0a617 	lsl	sl, r7, r6
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
33d1b160:	0a000017 	beq	33d1b1c4 <inflateInit2+0x124>
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
33d1b164:	e1a01007 	mov	r1, r7
33d1b168:	e5950028 	ldr	r0, [r5, #40]
33d1b16c:	e1a0200a 	mov	r2, sl
33d1b170:	e1a0e00f 	mov	lr, pc
33d1b174:	e595f020 	ldr	pc, [r5, #32]
33d1b178:	e3500000 	cmp	r0, #0	; 0x0
33d1b17c:	e1a06000 	mov	r6, r0
33d1b180:	e5840028 	str	r0, [r4, #40]
33d1b184:	1a000006 	bne	33d1b1a4 <inflateInit2+0x104>
  {
    ZFREE(z, s, sizeof(struct inflate_blocks_state));
33d1b188:	e5950028 	ldr	r0, [r5, #40]
33d1b18c:	e1a01004 	mov	r1, r4
33d1b190:	e3a02040 	mov	r2, #64	; 0x40
33d1b194:	e1a0e00f 	mov	lr, pc
33d1b198:	e595f024 	ldr	pc, [r5, #36]
33d1b19c:	e1a00006 	mov	r0, r6
33d1b1a0:	ea000008 	b	33d1b1c8 <inflateInit2+0x128>
    return Z_NULL;
  }
  s->end = s->window + w;
33d1b1a4:	e080300a 	add	r3, r0, sl
33d1b1a8:	e584302c 	str	r3, [r4, #44]
  s->checkfn = c;
33d1b1ac:	e5849038 	str	r9, [r4, #56]
  s->mode = TYPE;
33d1b1b0:	e584b000 	str	fp, [r4]
  Trace((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, &s->check);
33d1b1b4:	e1a00004 	mov	r0, r4
33d1b1b8:	e1a01005 	mov	r1, r5
33d1b1bc:	e284203c 	add	r2, r4, #60	; 0x3c
33d1b1c0:	ebfffefd 	bl	33d1adbc <inflate_blocks_reset>
33d1b1c4:	e1a00004 	mov	r0, r4

local inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_stream *z;
check_func c;
uInt w;
{
33d1b1c8:	e59d3000 	ldr	r3, [sp]
33d1b1cc:	e3500000 	cmp	r0, #0	; 0x0
33d1b1d0:	e5830014 	str	r0, [r3, #20]
33d1b1d4:	1a000003 	bne	33d1b1e8 <inflateInit2+0x148>
  /* create inflate_blocks state */
  if ((z->state->blocks =
       inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, 1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
33d1b1d8:	e1a00005 	mov	r0, r5
33d1b1dc:	ebffff2a 	bl	33d1ae8c <inflateEnd>
    return Z_MEM_ERROR;
33d1b1e0:	e3e00003 	mvn	r0, #3	; 0x3
33d1b1e4:	ea000002 	b	33d1b1f4 <inflateInit2+0x154>
  }
  Trace((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
33d1b1e8:	e1a00005 	mov	r0, r5
33d1b1ec:	ebffff4e 	bl	33d1af2c <inflateReset>
  return Z_OK;
33d1b1f0:	e3a00000 	mov	r0, #0	; 0x0
}
33d1b1f4:	e28dd004 	add	sp, sp, #4	; 0x4
33d1b1f8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1b1fc:	33d1d7d0 	.word	0x33d1d7d0

33d1b200 <inflateInit>:


int inflateInit(z)
z_stream *z;
{
  return inflateInit2(z, DEF_WBITS);
33d1b200:	e3a0100f 	mov	r1, #15	; 0xf
33d1b204:	eaffffa5 	b	33d1b0a0 <inflateInit2>

33d1b208 <inflate_codes_new>:

local inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl, *td;
z_stream *z;
{
33d1b208:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d1b20c:	e59dc014 	ldr	ip, [sp, #20]
33d1b210:	e1a05000 	mov	r5, r0
33d1b214:	e1a06001 	mov	r6, r1
33d1b218:	e1a07002 	mov	r7, r2
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
33d1b21c:	e59c0028 	ldr	r0, [ip, #40]
33d1b220:	e3a0201c 	mov	r2, #28	; 0x1c
33d1b224:	e3a01001 	mov	r1, #1	; 0x1

local inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl, *td;
z_stream *z;
{
33d1b228:	e1a04003 	mov	r4, r3
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
33d1b22c:	e1a0e00f 	mov	lr, pc
33d1b230:	e59cf020 	ldr	pc, [ip, #32]
33d1b234:	e2502000 	subs	r2, r0, #0	; 0x0
33d1b238:	08bd80f0 	popeq	{r4, r5, r6, r7, pc}
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
33d1b23c:	e3a03000 	mov	r3, #0	; 0x0
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
33d1b240:	e5824018 	str	r4, [r2, #24]
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
33d1b244:	e5823000 	str	r3, [r2]
    c->lbits = (Byte)bl;
33d1b248:	e5c25010 	strb	r5, [r2, #16]
    c->dbits = (Byte)bd;
33d1b24c:	e5c26011 	strb	r6, [r2, #17]
    c->ltree = tl;
33d1b250:	e5827014 	str	r7, [r2, #20]
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}
33d1b254:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d1b258 <inflateIncomp>:
 * will have been updated if need be.
 */

int inflateIncomp(z)
z_stream *z;
{
33d1b258:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    if (z->state->mode != BLOCKS)
33d1b25c:	e590201c 	ldr	r2, [r0, #28]
33d1b260:	e5923000 	ldr	r3, [r2]
33d1b264:	e3530002 	cmp	r3, #2	; 0x2
 * will have been updated if need be.
 */

int inflateIncomp(z)
z_stream *z;
{
33d1b268:	e24dd008 	sub	sp, sp, #8	; 0x8
33d1b26c:	e1a07000 	mov	r7, r0
    if (z->state->mode != BLOCKS)
33d1b270:	1a000008 	bne	33d1b298 <inflateIncomp+0x40>
 * will have been updated if need be.
 */
local int inflate_addhistory(s, z)
inflate_blocks_statef *s;
z_stream *z;
{
33d1b274:	e5924014 	ldr	r4, [r2, #20]
    Bytef *p;             /* input data pointer */
    uInt n;               /* bytes available there */
    Bytef *q;             /* output window write pointer */
    uInt m;               /* bytes to end of window or read pointer */

    if (s->read != s->write)
33d1b278:	e2840030 	add	r0, r4, #48	; 0x30
33d1b27c:	e8900009 	ldm	r0, {r0, r3}
33d1b280:	e1500003 	cmp	r0, r3
33d1b284:	13e00001 	mvnne	r0, #1	; 0x1
33d1b288:	1a00003e 	bne	33d1b388 <inflateIncomp+0x130>
	return Z_STREAM_ERROR;
    if (s->mode != TYPE)
33d1b28c:	e5943000 	ldr	r3, [r4]
33d1b290:	e3530000 	cmp	r3, #0	; 0x0
33d1b294:	0a000001 	beq	33d1b2a0 <inflateIncomp+0x48>
33d1b298:	e3e00002 	mvn	r0, #2	; 0x2
33d1b29c:	ea000039 	b	33d1b388 <inflateIncomp+0x130>
	return Z_DATA_ERROR;

    /* we're ready to rock */
    LOAD
33d1b2a0:	e594302c 	ldr	r3, [r4, #44]
33d1b2a4:	e060b003 	rsb	fp, r0, r3
33d1b2a8:	e5943024 	ldr	r3, [r4, #36]
33d1b2ac:	e8970600 	ldm	r7, {r9, sl}
33d1b2b0:	e58d3004 	str	r3, [sp, #4]
33d1b2b4:	e5943020 	ldr	r3, [r4, #32]
33d1b2b8:	e58d3000 	str	r3, [sp]
33d1b2bc:	e1a06000 	mov	r6, r0
	z->total_out += t;
	s->read = q;    /* drag read pointer forward */
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
	    s->read = q = s->window;
	    m = WAVAIL;
33d1b2c0:	e35a0000 	cmp	sl, #0	; 0x0
33d1b2c4:	0a000023 	beq	33d1b358 <inflateIncomp+0x100>
    while (n) {
	t = n;  /* how many to do */
	/* is there room until end of buffer? */
	if (t > m) t = m;
	/* update check information */
	if (s->checkfn != Z_NULL)
33d1b2c8:	e5943038 	ldr	r3, [r4, #56]
     * pointers as needed.
     */
    while (n) {
	t = n;  /* how many to do */
	/* is there room until end of buffer? */
	if (t > m) t = m;
33d1b2cc:	e15b000a 	cmp	fp, sl
33d1b2d0:	31a0500b 	movcc	r5, fp
33d1b2d4:	21a0500a 	movcs	r5, sl
	/* update check information */
	if (s->checkfn != Z_NULL)
33d1b2d8:	e3530000 	cmp	r3, #0	; 0x0
	    s->check = (*s->checkfn)(s->check, q, t);
33d1b2dc:	e1a01006 	mov	r1, r6
33d1b2e0:	e1a02005 	mov	r2, r5
    while (n) {
	t = n;  /* how many to do */
	/* is there room until end of buffer? */
	if (t > m) t = m;
	/* update check information */
	if (s->checkfn != Z_NULL)
33d1b2e4:	0a000003 	beq	33d1b2f8 <inflateIncomp+0xa0>
	    s->check = (*s->checkfn)(s->check, q, t);
33d1b2e8:	e594003c 	ldr	r0, [r4, #60]
33d1b2ec:	e1a0e00f 	mov	lr, pc
33d1b2f0:	e1a0f003 	mov	pc, r3
33d1b2f4:	e584003c 	str	r0, [r4, #60]
	/* output callback */
	if (z->outcb != Z_NULL)
33d1b2f8:	e5973030 	ldr	r3, [r7, #48]
33d1b2fc:	e3530000 	cmp	r3, #0	; 0x0
	    (*z->outcb)(q, t);
33d1b300:	e1a00006 	mov	r0, r6
33d1b304:	e1a01005 	mov	r1, r5
33d1b308:	11a0e00f 	movne	lr, pc
33d1b30c:	11a0f003 	movne	pc, r3
	zmemcpy(q, p, t);
33d1b310:	e1a00006 	mov	r0, r6
33d1b314:	e1a01009 	mov	r1, r9
33d1b318:	e1a02005 	mov	r2, r5
33d1b31c:	ebfffc30 	bl	33d1a3e4 <memcpy>
	q += t;
	p += t;
	n -= t;
	z->total_out += t;
33d1b320:	e5973014 	ldr	r3, [r7, #20]
33d1b324:	e0833005 	add	r3, r3, r5
33d1b328:	e5873014 	str	r3, [r7, #20]
	s->read = q;    /* drag read pointer forward */
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
33d1b32c:	e594302c 	ldr	r3, [r4, #44]
	    s->check = (*s->checkfn)(s->check, q, t);
	/* output callback */
	if (z->outcb != Z_NULL)
	    (*z->outcb)(q, t);
	zmemcpy(q, p, t);
	q += t;
33d1b330:	e0866005 	add	r6, r6, r5
	p += t;
	n -= t;
	z->total_out += t;
	s->read = q;    /* drag read pointer forward */
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
33d1b334:	e1560003 	cmp	r6, r3
	zmemcpy(q, p, t);
	q += t;
	p += t;
	n -= t;
	z->total_out += t;
	s->read = q;    /* drag read pointer forward */
33d1b338:	e5846030 	str	r6, [r4, #48]
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
	    s->read = q = s->window;
33d1b33c:	05946028 	ldreq	r6, [r4, #40]
	if (z->outcb != Z_NULL)
	    (*z->outcb)(q, t);
	zmemcpy(q, p, t);
	q += t;
	p += t;
	n -= t;
33d1b340:	e065a00a 	rsb	sl, r5, sl
	z->total_out += t;
	s->read = q;    /* drag read pointer forward */
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
	    s->read = q = s->window;
	    m = WAVAIL;
33d1b344:	0066b003 	rsbeq	fp, r6, r3
	n -= t;
	z->total_out += t;
	s->read = q;    /* drag read pointer forward */
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
	    s->read = q = s->window;
33d1b348:	05846030 	streq	r6, [r4, #48]
	/* output callback */
	if (z->outcb != Z_NULL)
	    (*z->outcb)(q, t);
	zmemcpy(q, p, t);
	q += t;
	p += t;
33d1b34c:	e0899005 	add	r9, r9, r5
	z->total_out += t;
	s->read = q;    /* drag read pointer forward */
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
	    s->read = q = s->window;
	    m = WAVAIL;
33d1b350:	e35a0000 	cmp	sl, #0	; 0x0
33d1b354:	eaffffda 	b	33d1b2c4 <inflateIncomp+0x6c>
	}
    }
    UPDATE
33d1b358:	e59d3004 	ldr	r3, [sp, #4]
33d1b35c:	e5843024 	str	r3, [r4, #36]
33d1b360:	e59d3000 	ldr	r3, [sp]
33d1b364:	e5843020 	str	r3, [r4, #32]
33d1b368:	e5973000 	ldr	r3, [r7]
33d1b36c:	e5972008 	ldr	r2, [r7, #8]
33d1b370:	e0633009 	rsb	r3, r3, r9
33d1b374:	e0822003 	add	r2, r2, r3
33d1b378:	e8870600 	stm	r7, {r9, sl}
33d1b37c:	e5872008 	str	r2, [r7, #8]
33d1b380:	e5846034 	str	r6, [r4, #52]
33d1b384:	e3a00000 	mov	r0, #0	; 0x0
z_stream *z;
{
    if (z->state->mode != BLOCKS)
	return Z_DATA_ERROR;
    return inflate_addhistory(z->state->blocks, z);
}
33d1b388:	e28dd008 	add	sp, sp, #8	; 0x8
33d1b38c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d1b390 <inflate_flush>:
/* copy as much as possible from the sliding window to the output area */
local int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1b390:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
33d1b394:	e5903034 	ldr	r3, [r0, #52]
  uInt n;
  Bytef *p, *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;
33d1b398:	e5905030 	ldr	r5, [r0, #48]

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
33d1b39c:	e1550003 	cmp	r5, r3
33d1b3a0:	8590302c 	ldrhi	r3, [r0, #44]
33d1b3a4:	e0654003 	rsb	r4, r5, r3
  if (n > z->avail_out) n = z->avail_out;
33d1b3a8:	e5913010 	ldr	r3, [r1, #16]
/* copy as much as possible from the sliding window to the output area */
local int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1b3ac:	e1a09002 	mov	r9, r2
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;
33d1b3b0:	e5912014 	ldr	r2, [r1, #20]
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
33d1b3b4:	e1540003 	cmp	r4, r3
33d1b3b8:	21a04003 	movcs	r4, r3
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
33d1b3bc:	e0643003 	rsb	r3, r4, r3
  z->total_out += n;
33d1b3c0:	e0822004 	add	r2, r2, r4
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
33d1b3c4:	e5813010 	str	r3, [r1, #16]
  z->total_out += n;
33d1b3c8:	e5812014 	str	r2, [r1, #20]
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;
33d1b3cc:	e2543000 	subs	r3, r4, #0	; 0x0
33d1b3d0:	13a03001 	movne	r3, #1	; 0x1
33d1b3d4:	e3790005 	cmn	r9, #5	; 0x5
  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
33d1b3d8:	e590c038 	ldr	ip, [r0, #56]
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;
33d1b3dc:	13a03000 	movne	r3, #0	; 0x0
33d1b3e0:	e3530000 	cmp	r3, #0	; 0x0
33d1b3e4:	13a09000 	movne	r9, #0	; 0x0
  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
33d1b3e8:	e35c0000 	cmp	ip, #0	; 0x0
/* copy as much as possible from the sliding window to the output area */
local int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1b3ec:	e1a06000 	mov	r6, r0
33d1b3f0:	e1a07001 	mov	r7, r1
  uInt n;
  Bytef *p, *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
33d1b3f4:	e591a00c 	ldr	sl, [r1, #12]
  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
33d1b3f8:	0a000005 	beq	33d1b414 <inflate_flush+0x84>
    s->check = (*s->checkfn)(s->check, q, n);
33d1b3fc:	e590003c 	ldr	r0, [r0, #60]
33d1b400:	e1a01005 	mov	r1, r5
33d1b404:	e1a02004 	mov	r2, r4
33d1b408:	e1a0e00f 	mov	lr, pc
33d1b40c:	e1a0f00c 	mov	pc, ip
33d1b410:	e586003c 	str	r0, [r6, #60]

  /* output callback */
  if (z->outcb != Z_NULL)
33d1b414:	e5973030 	ldr	r3, [r7, #48]
33d1b418:	e3530000 	cmp	r3, #0	; 0x0
    (*z->outcb)(q, n);
33d1b41c:	11a00005 	movne	r0, r5
33d1b420:	11a01004 	movne	r1, r4
33d1b424:	11a0e00f 	movne	lr, pc
33d1b428:	11a0f003 	movne	pc, r3

  /* copy as far as end of window */
  zmemcpy(p, q, n);
33d1b42c:	e1a0000a 	mov	r0, sl
33d1b430:	e1a01005 	mov	r1, r5
33d1b434:	e1a02004 	mov	r2, r4
33d1b438:	ebfffbe9 	bl	33d1a3e4 <memcpy>
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
33d1b43c:	e596202c 	ldr	r2, [r6, #44]
    (*z->outcb)(q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;
33d1b440:	e0855004 	add	r5, r5, r4

  /* see if more to copy at beginning of window */
  if (q == s->end)
33d1b444:	e1550002 	cmp	r5, r2
  if (z->outcb != Z_NULL)
    (*z->outcb)(q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
33d1b448:	e08aa004 	add	sl, sl, r4
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
33d1b44c:	1a000028 	bne	33d1b4f4 <inflate_flush+0x164>
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
33d1b450:	e5963034 	ldr	r3, [r6, #52]

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
33d1b454:	e5965028 	ldr	r5, [r6, #40]
    if (s->write == s->end)
33d1b458:	e1530002 	cmp	r3, r2
      s->write = s->window;
33d1b45c:	05865034 	streq	r5, [r6, #52]

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
33d1b460:	e5962034 	ldr	r2, [r6, #52]
    if (n > z->avail_out) n = z->avail_out;
33d1b464:	e5973010 	ldr	r3, [r7, #16]
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
33d1b468:	e0654002 	rsb	r4, r5, r2
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;
33d1b46c:	e5972014 	ldr	r2, [r7, #20]
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
33d1b470:	e1540003 	cmp	r4, r3
33d1b474:	21a04003 	movcs	r4, r3
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
33d1b478:	e0643003 	rsb	r3, r4, r3
    z->total_out += n;
33d1b47c:	e0822004 	add	r2, r2, r4
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
33d1b480:	e5873010 	str	r3, [r7, #16]
    z->total_out += n;
33d1b484:	e5872014 	str	r2, [r7, #20]
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;
33d1b488:	e2543000 	subs	r3, r4, #0	; 0x0
33d1b48c:	13a03001 	movne	r3, #1	; 0x1
33d1b490:	e3790005 	cmn	r9, #5	; 0x5
    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
33d1b494:	e596c038 	ldr	ip, [r6, #56]
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;
33d1b498:	13a03000 	movne	r3, #0	; 0x0
33d1b49c:	e3530000 	cmp	r3, #0	; 0x0
33d1b4a0:	13a09000 	movne	r9, #0	; 0x0
    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
33d1b4a4:	e35c0000 	cmp	ip, #0	; 0x0
33d1b4a8:	0a000005 	beq	33d1b4c4 <inflate_flush+0x134>
      s->check = (*s->checkfn)(s->check, q, n);
33d1b4ac:	e596003c 	ldr	r0, [r6, #60]
33d1b4b0:	e1a01005 	mov	r1, r5
33d1b4b4:	e1a02004 	mov	r2, r4
33d1b4b8:	e1a0e00f 	mov	lr, pc
33d1b4bc:	e1a0f00c 	mov	pc, ip
33d1b4c0:	e586003c 	str	r0, [r6, #60]

    /* output callback */
    if (z->outcb != Z_NULL)
33d1b4c4:	e5973030 	ldr	r3, [r7, #48]
33d1b4c8:	e3530000 	cmp	r3, #0	; 0x0
	(*z->outcb)(q, n);
33d1b4cc:	11a00005 	movne	r0, r5
33d1b4d0:	11a01004 	movne	r1, r4
33d1b4d4:	11a0e00f 	movne	lr, pc
33d1b4d8:	11a0f003 	movne	pc, r3

    /* copy */
    zmemcpy(p, q, n);
33d1b4dc:	e1a0000a 	mov	r0, sl
33d1b4e0:	e1a01005 	mov	r1, r5
33d1b4e4:	e1a02004 	mov	r2, r4
33d1b4e8:	ebfffbbd 	bl	33d1a3e4 <memcpy>
    p += n;
    q += n;
33d1b4ec:	e0855004 	add	r5, r5, r4
    if (z->outcb != Z_NULL)
	(*z->outcb)(q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
33d1b4f0:	e08aa004 	add	sl, sl, r4
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}
33d1b4f4:	e1a00009 	mov	r0, r9
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
33d1b4f8:	e587a00c 	str	sl, [r7, #12]
  s->read = q;
33d1b4fc:	e5865030 	str	r5, [r6, #48]

  /* done */
  return r;
}
33d1b500:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

33d1b504 <huft_build>:
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
{
33d1b504:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d1b508:	e24dde57 	sub	sp, sp, #1392	; 0x570
33d1b50c:	e24dd004 	sub	sp, sp, #4	; 0x4
  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
33d1b510:	e3a0c000 	mov	ip, #0	; 0x0
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
{
33d1b514:	e58d1034 	str	r1, [sp, #52]
  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
33d1b518:	e58dc570 	str	ip, [sp, #1392]
33d1b51c:	e58dc534 	str	ip, [sp, #1332]
33d1b520:	e58dc538 	str	ip, [sp, #1336]
33d1b524:	e58dc53c 	str	ip, [sp, #1340]
33d1b528:	e58dc540 	str	ip, [sp, #1344]
33d1b52c:	e58dc544 	str	ip, [sp, #1348]
33d1b530:	e58dc548 	str	ip, [sp, #1352]
33d1b534:	e58dc54c 	str	ip, [sp, #1356]
33d1b538:	e58dc550 	str	ip, [sp, #1360]
33d1b53c:	e58dc554 	str	ip, [sp, #1364]
33d1b540:	e58dc558 	str	ip, [sp, #1368]
33d1b544:	e58dc55c 	str	ip, [sp, #1372]
33d1b548:	e58dc560 	str	ip, [sp, #1376]
33d1b54c:	e58dc564 	str	ip, [sp, #1380]
33d1b550:	e58dc568 	str	ip, [sp, #1384]
33d1b554:	e58dc56c 	str	ip, [sp, #1388]
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
{
33d1b558:	e59d159c 	ldr	r1, [sp, #1436]
33d1b55c:	e58d2030 	str	r2, [sp, #48]
33d1b560:	e58d302c 	str	r3, [sp, #44]
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
33d1b564:	e59d4034 	ldr	r4, [sp, #52]
33d1b568:	e3a07000 	mov	r7, #0	; 0x0
33d1b56c:	e3a06000 	mov	r6, #0	; 0x0
33d1b570:	e1a0a000 	mov	sl, r0
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
33d1b574:	e49a3004 	ldr	r3, [sl], #4
33d1b578:	e28d5e57 	add	r5, sp, #1392	; 0x570
33d1b57c:	e2855004 	add	r5, r5, #4	; 0x4
33d1b580:	e0852103 	add	r2, r5, r3, lsl #2
33d1b584:	e5123040 	ldr	r3, [r2, #-64]
  } while (--i);
33d1b588:	e2544001 	subs	r4, r4, #1	; 0x1
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
33d1b58c:	e2833001 	add	r3, r3, #1	; 0x1
33d1b590:	e5023040 	str	r3, [r2, #-64]
  } while (--i);
33d1b594:	1afffff6 	bne	33d1b574 <huft_build+0x70>
  if (c[0] == n)                /* null input--all zero length codes */
33d1b598:	e59d3534 	ldr	r3, [sp, #1332]
33d1b59c:	e59dc034 	ldr	ip, [sp, #52]
33d1b5a0:	e153000c 	cmp	r3, ip
  {
    *t = (inflate_huft *)Z_NULL;
33d1b5a4:	059de598 	ldreq	lr, [sp, #1432]
    *m = 0;
    return Z_OK;
33d1b5a8:	01a00004 	moveq	r0, r4
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
33d1b5ac:	058e4000 	streq	r4, [lr]
    *m = 0;
33d1b5b0:	05814000 	streq	r4, [r1]
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
33d1b5b4:	0a00014e 	beq	33d1baf4 <huft_build+0x5f0>
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
33d1b5b8:	e5912000 	ldr	r2, [r1]
33d1b5bc:	e58d2018 	str	r2, [sp, #24]
33d1b5c0:	e28d2e57 	add	r2, sp, #1392	; 0x570
  for (j = 1; j <= BMAX; j++)
33d1b5c4:	e3a05001 	mov	r5, #1	; 0x1
33d1b5c8:	e2822008 	add	r2, r2, #8	; 0x8
    if (c[j])
33d1b5cc:	e5123040 	ldr	r3, [r2, #-64]
33d1b5d0:	e3530000 	cmp	r3, #0	; 0x0
33d1b5d4:	e2822004 	add	r2, r2, #4	; 0x4
33d1b5d8:	1a000002 	bne	33d1b5e8 <huft_build+0xe4>
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
33d1b5dc:	e2855001 	add	r5, r5, #1	; 0x1
33d1b5e0:	e355000f 	cmp	r5, #15	; 0xf
33d1b5e4:	9afffff8 	bls	33d1b5cc <huft_build+0xc8>
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
33d1b5e8:	e59d3018 	ldr	r3, [sp, #24]
33d1b5ec:	e1530005 	cmp	r3, r5
33d1b5f0:	31a03005 	movcc	r3, r5
  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
33d1b5f4:	e58d501c 	str	r5, [sp, #28]
  if ((uInt)l < j)
    l = j;
33d1b5f8:	e58d3018 	str	r3, [sp, #24]
  for (i = BMAX; i; i--)
33d1b5fc:	e3a0400f 	mov	r4, #15	; 0xf
33d1b600:	e28d2e5b 	add	r2, sp, #1456	; 0x5b0
    if (c[i])
33d1b604:	e5123040 	ldr	r3, [r2, #-64]
33d1b608:	e3530000 	cmp	r3, #0	; 0x0
33d1b60c:	e2422004 	sub	r2, r2, #4	; 0x4
33d1b610:	1a000001 	bne	33d1b61c <huft_build+0x118>
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
33d1b614:	e2544001 	subs	r4, r4, #1	; 0x1
33d1b618:	1afffff9 	bne	33d1b604 <huft_build+0x100>
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
33d1b61c:	e59dc018 	ldr	ip, [sp, #24]
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
33d1b620:	e3a03001 	mov	r3, #1	; 0x1
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
33d1b624:	e15c0004 	cmp	ip, r4
33d1b628:	21a0c004 	movcs	ip, r4
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
33d1b62c:	e1a03513 	lsl	r3, r3, r5
33d1b630:	e1550004 	cmp	r5, r4
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
33d1b634:	e58d4024 	str	r4, [sp, #36]
  if ((uInt)l > i)
    l = i;
33d1b638:	e58dc018 	str	ip, [sp, #24]
  *m = l;
33d1b63c:	e581c000 	str	ip, [r1]


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
33d1b640:	e58d3014 	str	r3, [sp, #20]
33d1b644:	2a00000c 	bcs	33d1b67c <huft_build+0x178>
33d1b648:	e28dee57 	add	lr, sp, #1392	; 0x570
33d1b64c:	e28ee004 	add	lr, lr, #4	; 0x4
33d1b650:	e08e2105 	add	r2, lr, r5, lsl #2
    if ((y -= c[j]) < 0)
33d1b654:	e5123040 	ldr	r3, [r2, #-64]
33d1b658:	e59d1014 	ldr	r1, [sp, #20]
33d1b65c:	e0511003 	subs	r1, r1, r3
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
33d1b660:	e1a01081 	lsl	r1, r1, #1
33d1b664:	e2855001 	add	r5, r5, #1	; 0x1
33d1b668:	e2822004 	add	r2, r2, #4	; 0x4
33d1b66c:	e58d1014 	str	r1, [sp, #20]
    if ((y -= c[j]) < 0)
33d1b670:	4a00011c 	bmi	33d1bae8 <huft_build+0x5e4>
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
33d1b674:	e1550004 	cmp	r5, r4
33d1b678:	3afffff5 	bcc	33d1b654 <huft_build+0x150>
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
33d1b67c:	e28d3e57 	add	r3, sp, #1392	; 0x570
33d1b680:	e2833004 	add	r3, r3, #4	; 0x4
33d1b684:	e0832104 	add	r2, r3, r4, lsl #2
33d1b688:	e5123040 	ldr	r3, [r2, #-64]
33d1b68c:	e59d5014 	ldr	r5, [sp, #20]
33d1b690:	e0555003 	subs	r5, r5, r3
33d1b694:	e58d5014 	str	r5, [sp, #20]
33d1b698:	4a000112 	bmi	33d1bae8 <huft_build+0x5e4>
    return Z_DATA_ERROR;
  c[i] += y;
33d1b69c:	e59dc014 	ldr	ip, [sp, #20]


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
33d1b6a0:	e3a05000 	mov	r5, #0	; 0x0
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;
33d1b6a4:	e083300c 	add	r3, r3, ip


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
33d1b6a8:	e28d1044 	add	r1, sp, #68	; 0x44
33d1b6ac:	e28dae53 	add	sl, sp, #1328	; 0x530
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;
33d1b6b0:	e5023040 	str	r3, [r2, #-64]


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
33d1b6b4:	e58d503c 	str	r5, [sp, #60]
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
33d1b6b8:	e2544001 	subs	r4, r4, #1	; 0x1
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
33d1b6bc:	e28aa008 	add	sl, sl, #8	; 0x8
33d1b6c0:	e2411004 	sub	r1, r1, #4	; 0x4
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
33d1b6c4:	0a000004 	beq	33d1b6dc <huft_build+0x1d8>
33d1b6c8:	e49a3004 	ldr	r3, [sl], #4
33d1b6cc:	e0855003 	add	r5, r5, r3
33d1b6d0:	e4815004 	str	r5, [r1], #4
33d1b6d4:	e2544001 	subs	r4, r4, #1	; 0x1
33d1b6d8:	eafffff9 	b	33d1b6c4 <huft_build+0x1c0>
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
33d1b6dc:	e1a0a000 	mov	sl, r0
33d1b6e0:	e3a04000 	mov	r4, #0	; 0x0
  do {
    if ((j = *p++) != 0)
33d1b6e4:	e49a5004 	ldr	r5, [sl], #4
      v[x[j]++] = i;
33d1b6e8:	e28dee57 	add	lr, sp, #1392	; 0x570
33d1b6ec:	e28ee004 	add	lr, lr, #4	; 0x4


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
33d1b6f0:	e3550000 	cmp	r5, #0	; 0x0
      v[x[j]++] = i;
33d1b6f4:	e08e1105 	add	r1, lr, r5, lsl #2
33d1b6f8:	1511353c 	ldrne	r3, [r1, #-1340]
33d1b6fc:	108e2103 	addne	r2, lr, r3, lsl #2
33d1b700:	12833001 	addne	r3, r3, #1	; 0x1
33d1b704:	150244fc 	strne	r4, [r2, #-1276]
33d1b708:	1501353c 	strne	r3, [r1, #-1340]
  } while (++i < n);
33d1b70c:	e59d0034 	ldr	r0, [sp, #52]
33d1b710:	e2844001 	add	r4, r4, #1	; 0x1
33d1b714:	e1540000 	cmp	r4, r0
33d1b718:	3afffff1 	bcc	33d1b6e4 <huft_build+0x1e0>
33d1b71c:	e3a04000 	mov	r4, #0	; 0x0
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
33d1b720:	e59d101c 	ldr	r1, [sp, #28]
33d1b724:	e59d2024 	ldr	r2, [sp, #36]


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
33d1b728:	e3e03000 	mvn	r3, #0	; 0x0
  w = -l;                       /* bits decoded == (l * h) */
33d1b72c:	e59d5018 	ldr	r5, [sp, #24]
  } while (++i < n);


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
33d1b730:	e28da084 	add	sl, sp, #132	; 0x84
      v[x[j]++] = i;
  } while (++i < n);


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
33d1b734:	e58d4038 	str	r4, [sp, #56]
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
33d1b738:	e58d44f8 	str	r4, [sp, #1272]


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
33d1b73c:	e58d3020 	str	r3, [sp, #32]
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */
33d1b740:	e58d4010 	str	r4, [sp, #16]
  } while (++i < n);


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
33d1b744:	e24aa00c 	sub	sl, sl, #12	; 0xc
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
33d1b748:	e1510002 	cmp	r1, r2

  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
33d1b74c:	e265b000 	rsb	fp, r5, #0	; 0x0
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
33d1b750:	e1a0e004 	mov	lr, r4
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
33d1b754:	ca0000da 	bgt	33d1bac4 <huft_build+0x5c0>
  {
    a = c[k];
33d1b758:	e59dc01c 	ldr	ip, [sp, #28]
33d1b75c:	e28d0e57 	add	r0, sp, #1392	; 0x570
33d1b760:	e1a0c10c 	lsl	ip, ip, #2
33d1b764:	e58dc00c 	str	ip, [sp, #12]
33d1b768:	e2800004 	add	r0, r0, #4	; 0x4
33d1b76c:	e08c3000 	add	r3, ip, r0
33d1b770:	e5133040 	ldr	r3, [r3, #-64]

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
	h--;                    /* don't need to update q */
	w -= l;
33d1b774:	e2433001 	sub	r3, r3, #1	; 0x1
33d1b778:	e3730001 	cmn	r3, #1	; 0x1
33d1b77c:	e58d3028 	str	r3, [sp, #40]
33d1b780:	0a0000c9 	beq	33d1baac <huft_build+0x5a8>
33d1b784:	e59d2020 	ldr	r2, [sp, #32]
33d1b788:	e0801102 	add	r1, r0, r2, lsl #2
33d1b78c:	e58d1004 	str	r1, [sp, #4]
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
	  u[h-1][j] = r;        /* connect to last table */
33d1b790:	e28d3018 	add	r3, sp, #24	; 0x18
33d1b794:	e8930028 	ldm	r3, {r3, r5}
33d1b798:	e08bc003 	add	ip, fp, r3
33d1b79c:	e155000c 	cmp	r5, ip
33d1b7a0:	da000069 	ble	33d1b94c <huft_build+0x448>
33d1b7a4:	e28dee57 	add	lr, sp, #1392	; 0x570
33d1b7a8:	e59d0020 	ldr	r0, [sp, #32]
33d1b7ac:	e28ee004 	add	lr, lr, #4	; 0x4
33d1b7b0:	e08ee100 	add	lr, lr, r0, lsl #2
33d1b7b4:	e58de008 	str	lr, [sp, #8]
	h++;
	w += l;                 /* previous table always l bits */

	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
33d1b7b8:	e59d101c 	ldr	r1, [sp, #28]
33d1b7bc:	e3a03001 	mov	r3, #1	; 0x1
33d1b7c0:	e06c5001 	rsb	r5, ip, r1
33d1b7c4:	e1a02513 	lsl	r2, r3, r5
      {
	h++;
	w += l;                 /* previous table always l bits */

	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
33d1b7c8:	e59d3024 	ldr	r3, [sp, #36]
33d1b7cc:	e06c3003 	rsb	r3, ip, r3
33d1b7d0:	e58d3010 	str	r3, [sp, #16]
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
33d1b7d4:	e59de028 	ldr	lr, [sp, #40]
      {
	h++;
	w += l;                 /* previous table always l bits */

	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
33d1b7d8:	e59d1010 	ldr	r1, [sp, #16]
33d1b7dc:	e59d0018 	ldr	r0, [sp, #24]
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
33d1b7e0:	e28e3001 	add	r3, lr, #1	; 0x1
      {
	h++;
	w += l;                 /* previous table always l bits */

	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
33d1b7e4:	e1500001 	cmp	r0, r1
33d1b7e8:	21a00001 	movcs	r0, r1
33d1b7ec:	e59de004 	ldr	lr, [sp, #4]
33d1b7f0:	e59d1008 	ldr	r1, [sp, #8]
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
33d1b7f4:	e1520003 	cmp	r2, r3
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
	h++;
33d1b7f8:	e59d3020 	ldr	r3, [sp, #32]
33d1b7fc:	e28ee004 	add	lr, lr, #4	; 0x4
33d1b800:	e2833001 	add	r3, r3, #1	; 0x1
33d1b804:	e2811004 	add	r1, r1, #4	; 0x4
	w += l;                 /* previous table always l bits */
33d1b808:	e1a0b00c 	mov	fp, ip
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
	h++;
33d1b80c:	e58d3020 	str	r3, [sp, #32]
33d1b810:	e58de004 	str	lr, [sp, #4]
33d1b814:	e58d1008 	str	r1, [sp, #8]
	w += l;                 /* previous table always l bits */

	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
33d1b818:	e58d0010 	str	r0, [sp, #16]
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
33d1b81c:	9a000010 	bls	33d1b864 <huft_build+0x360>
	{                       /* too few codes for k-w bit table */
	  f -= a + 1;           /* deduct codes from patterns left */
33d1b820:	e59de028 	ldr	lr, [sp, #40]
33d1b824:	e06e3002 	rsb	r3, lr, r2
33d1b828:	e2432001 	sub	r2, r3, #1	; 0x1
	  xp = c + k;
33d1b82c:	e59de00c 	ldr	lr, [sp, #12]
33d1b830:	e28d3e53 	add	r3, sp, #1328	; 0x530
33d1b834:	e2833004 	add	r3, r3, #4	; 0x4
	  if (j < z)
33d1b838:	e1550000 	cmp	r5, r0
	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
	{                       /* too few codes for k-w bit table */
	  f -= a + 1;           /* deduct codes from patterns left */
	  xp = c + k;
33d1b83c:	e083100e 	add	r1, r3, lr
	  if (j < z)
33d1b840:	2a000007 	bcs	33d1b864 <huft_build+0x360>
	    while (++j < z)     /* try smaller tables up to z bits */
	    {
	      if ((f <<= 1) <= *++xp)
		break;          /* enough codes to use up j bits */
	      f -= *xp;         /* else deduct codes from patterns */
33d1b844:	e2855001 	add	r5, r5, #1	; 0x1
33d1b848:	e1550000 	cmp	r5, r0
33d1b84c:	2a000004 	bcs	33d1b864 <huft_build+0x360>
	  f -= a + 1;           /* deduct codes from patterns left */
	  xp = c + k;
	  if (j < z)
	    while (++j < z)     /* try smaller tables up to z bits */
	    {
	      if ((f <<= 1) <= *++xp)
33d1b850:	e5b13004 	ldr	r3, [r1, #4]!
33d1b854:	e1a02082 	lsl	r2, r2, #1
33d1b858:	e1520003 	cmp	r2, r3
		break;          /* enough codes to use up j bits */
	      f -= *xp;         /* else deduct codes from patterns */
33d1b85c:	e0632002 	rsb	r2, r3, r2
	  f -= a + 1;           /* deduct codes from patterns left */
	  xp = c + k;
	  if (j < z)
	    while (++j < z)     /* try smaller tables up to z bits */
	    {
	      if ((f <<= 1) <= *++xp)
33d1b860:	8afffff7 	bhi	33d1b844 <huft_build+0x340>
		break;          /* enough codes to use up j bits */
	      f -= *xp;         /* else deduct codes from patterns */
	    }
	}
	z = 1 << j;             /* table entries for j-bit table */
33d1b864:	e3a03001 	mov	r3, #1	; 0x1
33d1b868:	e1a03513 	lsl	r3, r3, r5
33d1b86c:	e58d3010 	str	r3, [sp, #16]

	/* allocate and link in new table */
	if ((q = (inflate_huft *)ZALLOC
33d1b870:	e59d15a0 	ldr	r1, [sp, #1440]
33d1b874:	e2839001 	add	r9, r3, #1	; 0x1
33d1b878:	e5910028 	ldr	r0, [r1, #40]
33d1b87c:	e3a02008 	mov	r2, #8	; 0x8
33d1b880:	e58dc000 	str	ip, [sp]
33d1b884:	e1a01009 	mov	r1, r9
33d1b888:	e59d35a0 	ldr	r3, [sp, #1440]
33d1b88c:	e1a0e00f 	mov	lr, pc
33d1b890:	e593f020 	ldr	pc, [r3, #32]
33d1b894:	e250e000 	subs	lr, r0, #0	; 0x0
33d1b898:	e59dc000 	ldr	ip, [sp]
33d1b89c:	1a000006 	bne	33d1b8bc <huft_build+0x3b8>
	     (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
	{
	  if (h)
33d1b8a0:	e59d5020 	ldr	r5, [sp, #32]
33d1b8a4:	e3550000 	cmp	r5, #0	; 0x0
	    inflate_trees_free(u[0], zs);
33d1b8a8:	159d15a0 	ldrne	r1, [sp, #1440]
33d1b8ac:	159d04f8 	ldrne	r0, [sp, #1272]
33d1b8b0:	1bfffd31 	blne	33d1ad7c <inflate_trees_free>
	  return Z_MEM_ERROR;   /* not enough memory */
33d1b8b4:	e3e00003 	mvn	r0, #3	; 0x3
33d1b8b8:	ea00008d 	b	33d1baf4 <huft_build+0x5f0>
	}
	q->word.Nalloc = z + 1;
33d1b8bc:	e58e9000 	str	r9, [lr]
#ifdef DEBUG_ZLIB
	inflate_hufts += z + 1;
#endif
	*t = q + 1;             /* link to list for huft_free() */
33d1b8c0:	e59d0598 	ldr	r0, [sp, #1432]
33d1b8c4:	e28e2008 	add	r2, lr, #8	; 0x8
	*(t = &(q->next)) = Z_NULL;
33d1b8c8:	e3a03000 	mov	r3, #0	; 0x0
	}
	q->word.Nalloc = z + 1;
#ifdef DEBUG_ZLIB
	inflate_hufts += z + 1;
#endif
	*t = q + 1;             /* link to list for huft_free() */
33d1b8cc:	e5802000 	str	r2, [r0]
	*(t = &(q->next)) = Z_NULL;
33d1b8d0:	e58e3004 	str	r3, [lr, #4]
	u[h] = ++q;             /* table starts after link */

	/* connect to last table, if there is one */
	if (h)
33d1b8d4:	e59d1020 	ldr	r1, [sp, #32]
	q->word.Nalloc = z + 1;
#ifdef DEBUG_ZLIB
	inflate_hufts += z + 1;
#endif
	*t = q + 1;             /* link to list for huft_free() */
	*(t = &(q->next)) = Z_NULL;
33d1b8d8:	e28ee004 	add	lr, lr, #4	; 0x4
33d1b8dc:	e58de598 	str	lr, [sp, #1432]
	u[h] = ++q;             /* table starts after link */
33d1b8e0:	e1a0e002 	mov	lr, r2
33d1b8e4:	e59d2008 	ldr	r2, [sp, #8]

	/* connect to last table, if there is one */
	if (h)
33d1b8e8:	e1510003 	cmp	r1, r3
#ifdef DEBUG_ZLIB
	inflate_hufts += z + 1;
#endif
	*t = q + 1;             /* link to list for huft_free() */
	*(t = &(q->next)) = Z_NULL;
	u[h] = ++q;             /* table starts after link */
33d1b8ec:	e502e07c 	str	lr, [r2, #-124]

	/* connect to last table, if there is one */
	if (h)
33d1b8f0:	0a000010 	beq	33d1b938 <huft_build+0x434>
	{
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
33d1b8f4:	e59d3018 	ldr	r3, [sp, #24]
	  r.exop = (Byte)j;     /* bits in this table */
33d1b8f8:	e20500ff 	and	r0, r5, #255	; 0xff
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
	  u[h-1][j] = r;        /* connect to last table */
33d1b8fc:	e59d5008 	ldr	r5, [sp, #8]

	/* connect to last table, if there is one */
	if (h)
	{
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
33d1b900:	e20320ff 	and	r2, r3, #255	; 0xff
33d1b904:	e3c63cff 	bic	r3, r6, #65280	; 0xff00
33d1b908:	e1836402 	orr	r6, r3, r2, lsl #8
	  r.exop = (Byte)j;     /* bits in this table */
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
	  u[h-1][j] = r;        /* connect to last table */
33d1b90c:	e5153080 	ldr	r3, [r5, #-128]
	{
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
33d1b910:	e59d5018 	ldr	r5, [sp, #24]
	/* connect to last table, if there is one */
	if (h)
	{
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
33d1b914:	e3c620ff 	bic	r2, r6, #255	; 0xff
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
33d1b918:	e065100c 	rsb	r1, r5, ip
	/* connect to last table, if there is one */
	if (h)
	{
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
33d1b91c:	e1806002 	orr	r6, r0, r2
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
33d1b920:	e1a05134 	lsr	r5, r4, r1
	u[h] = ++q;             /* table starts after link */

	/* connect to last table, if there is one */
	if (h)
	{
	  x[h] = i;             /* save pattern for backing up */
33d1b924:	e59d0008 	ldr	r0, [sp, #8]
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
	  u[h-1][j] = r;        /* connect to last table */
33d1b928:	e0833185 	add	r3, r3, r5, lsl #3
	if (h)
	{
	  x[h] = i;             /* save pattern for backing up */
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
	  r.next = q;           /* pointer to this table */
33d1b92c:	e1a0700e 	mov	r7, lr
	u[h] = ++q;             /* table starts after link */

	/* connect to last table, if there is one */
	if (h)
	{
	  x[h] = i;             /* save pattern for backing up */
33d1b930:	e500453c 	str	r4, [r0, #-1340]
	  r.bits = (Byte)l;     /* bits to dump before this table */
	  r.exop = (Byte)j;     /* bits in this table */
	  r.next = q;           /* pointer to this table */
	  j = i >> (w - l);     /* (get around Turbo C bug) */
	  u[h-1][j] = r;        /* connect to last table */
33d1b934:	e88300c0 	stm	r3, {r6, r7}
33d1b938:	e28d1018 	add	r1, sp, #24	; 0x18
33d1b93c:	e8910006 	ldm	r1, {r1, r2}
33d1b940:	e08cc001 	add	ip, ip, r1
33d1b944:	e152000c 	cmp	r2, ip
33d1b948:	caffff9a 	bgt	33d1b7b8 <huft_build+0x2b4>
	}
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
33d1b94c:	e59d301c 	ldr	r3, [sp, #28]
      if (p >= v + n)
33d1b950:	e59dc034 	ldr	ip, [sp, #52]
33d1b954:	e28d5078 	add	r5, sp, #120	; 0x78
	  u[h-1][j] = r;        /* connect to last table */
	}
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
33d1b958:	e06b0003 	rsb	r0, fp, r3
      if (p >= v + n)
33d1b95c:	e085310c 	add	r3, r5, ip, lsl #2
33d1b960:	e15a0003 	cmp	sl, r3
	  u[h-1][j] = r;        /* connect to last table */
	}
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
33d1b964:	e20020ff 	and	r2, r0, #255	; 0xff
33d1b968:	e3c63cff 	bic	r3, r6, #65280	; 0xff00
33d1b96c:	e1836402 	orr	r6, r3, r2, lsl #8
      if (p >= v + n)
	r.exop = 128 + 64;      /* out of values--invalid code */
33d1b970:	23c6303f 	biccs	r3, r6, #63	; 0x3f
33d1b974:	238360c0 	orrcs	r6, r3, #192	; 0xc0
	}
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
33d1b978:	2a000016 	bcs	33d1b9d8 <huft_build+0x4d4>
	r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
33d1b97c:	e59a1000 	ldr	r1, [sl]
33d1b980:	e59d2030 	ldr	r2, [sp, #48]
33d1b984:	e1510002 	cmp	r1, r2
33d1b988:	2a000007 	bcs	33d1b9ac <huft_build+0x4a8>
      {
	r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
33d1b98c:	e35100ff 	cmp	r1, #255	; 0xff
33d1b990:	93a02000 	movls	r2, #0	; 0x0
33d1b994:	83a02060 	movhi	r2, #96	; 0x60
33d1b998:	e20220ff 	and	r2, r2, #255	; 0xff
33d1b99c:	e3c630ff 	bic	r3, r6, #255	; 0xff
33d1b9a0:	e1826003 	orr	r6, r2, r3
	r.base = *p++;          /* simple code is just the value */
33d1b9a4:	e1a07001 	mov	r7, r1
33d1b9a8:	ea000009 	b	33d1b9d4 <huft_build+0x4d0>
      }
      else
      {
	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
33d1b9ac:	e59d5030 	ldr	r5, [sp, #48]
33d1b9b0:	e59dc594 	ldr	ip, [sp, #1428]
33d1b9b4:	e0653001 	rsb	r3, r5, r1
33d1b9b8:	e79c2103 	ldr	r2, [ip, r3, lsl #2]
33d1b9bc:	e2822050 	add	r2, r2, #80	; 0x50
33d1b9c0:	e3c610ff 	bic	r1, r6, #255	; 0xff
33d1b9c4:	e20220ff 	and	r2, r2, #255	; 0xff
33d1b9c8:	e1826001 	orr	r6, r2, r1
	r.base = d[*p++ - s];
33d1b9cc:	e59d102c 	ldr	r1, [sp, #44]
33d1b9d0:	e7917103 	ldr	r7, [r1, r3, lsl #2]
33d1b9d4:	e28aa004 	add	sl, sl, #4	; 0x4
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
33d1b9d8:	e59d2010 	ldr	r2, [sp, #16]
33d1b9dc:	e1a05b34 	lsr	r5, r4, fp
	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
	r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
33d1b9e0:	e3a03001 	mov	r3, #1	; 0x1
      for (j = i >> w; j < z; j += f)
33d1b9e4:	e1550002 	cmp	r5, r2
	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
	r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
33d1b9e8:	e1a02013 	lsl	r2, r3, r0
      for (j = i >> w; j < z; j += f)
33d1b9ec:	2a000005 	bcs	33d1ba08 <huft_build+0x504>
33d1b9f0:	e59dc010 	ldr	ip, [sp, #16]
	q[j] = r;
33d1b9f4:	e08e3185 	add	r3, lr, r5, lsl #3
	r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
33d1b9f8:	e0855002 	add	r5, r5, r2
33d1b9fc:	e155000c 	cmp	r5, ip
	q[j] = r;
33d1ba00:	e88300c0 	stm	r3, {r6, r7}
33d1ba04:	eafffff8 	b	33d1b9ec <huft_build+0x4e8>

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
33d1ba08:	e59d001c 	ldr	r0, [sp, #28]
33d1ba0c:	e3a03001 	mov	r3, #1	; 0x1
33d1ba10:	e2402001 	sub	r2, r0, #1	; 0x1
33d1ba14:	e1a05213 	lsl	r5, r3, r2
33d1ba18:	e1140005 	tst	r4, r5
	i ^= j;
33d1ba1c:	10244005 	eorne	r4, r4, r5
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
	q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
33d1ba20:	11a050a5 	lsrne	r5, r5, #1
33d1ba24:	1afffffb 	bne	33d1ba18 <huft_build+0x514>

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
	h--;                    /* don't need to update q */
	w -= l;
33d1ba28:	e3a00001 	mov	r0, #1	; 0x1
33d1ba2c:	e59d1004 	ldr	r1, [sp, #4]
33d1ba30:	e1a03b10 	lsl	r3, r0, fp
	q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
	i ^= j;
      i ^= j;
33d1ba34:	e0244005 	eor	r4, r4, r5

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
	h--;                    /* don't need to update q */
	w -= l;
33d1ba38:	e2433001 	sub	r3, r3, #1	; 0x1
33d1ba3c:	e511253c 	ldr	r2, [r1, #-1340]
33d1ba40:	e0043003 	and	r3, r4, r3
33d1ba44:	e1530002 	cmp	r3, r2
33d1ba48:	0a000012 	beq	33d1ba98 <huft_build+0x594>
33d1ba4c:	e28d2e57 	add	r2, sp, #1392	; 0x570
33d1ba50:	e59d3020 	ldr	r3, [sp, #32]
33d1ba54:	e2822004 	add	r2, r2, #4	; 0x4
33d1ba58:	e0821103 	add	r1, r2, r3, lsl #2
33d1ba5c:	e59d5018 	ldr	r5, [sp, #24]
33d1ba60:	e065b00b 	rsb	fp, r5, fp
33d1ba64:	e2411004 	sub	r1, r1, #4	; 0x4
33d1ba68:	e1a03b10 	lsl	r3, r0, fp
33d1ba6c:	e511253c 	ldr	r2, [r1, #-1340]
33d1ba70:	e2433001 	sub	r3, r3, #1	; 0x1
33d1ba74:	e0043003 	and	r3, r4, r3
      i ^= j;

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
	h--;                    /* don't need to update q */
33d1ba78:	e59dc020 	ldr	ip, [sp, #32]
	w -= l;
33d1ba7c:	e1530002 	cmp	r3, r2
33d1ba80:	e59d2004 	ldr	r2, [sp, #4]
      i ^= j;

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
	h--;                    /* don't need to update q */
33d1ba84:	e24cc001 	sub	ip, ip, #1	; 0x1
33d1ba88:	e2422004 	sub	r2, r2, #4	; 0x4
33d1ba8c:	e58dc020 	str	ip, [sp, #32]
33d1ba90:	e58d2004 	str	r2, [sp, #4]
	w -= l;
33d1ba94:	1afffff0 	bne	33d1ba5c <huft_build+0x558>
33d1ba98:	e59d3028 	ldr	r3, [sp, #40]
33d1ba9c:	e2433001 	sub	r3, r3, #1	; 0x1
33d1baa0:	e3730001 	cmn	r3, #1	; 0x1
33d1baa4:	e58d3028 	str	r3, [sp, #40]
33d1baa8:	1affff38 	bne	33d1b790 <huft_build+0x28c>
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
33d1baac:	e59d501c 	ldr	r5, [sp, #28]
33d1bab0:	e59dc024 	ldr	ip, [sp, #36]
33d1bab4:	e2855001 	add	r5, r5, #1	; 0x1
33d1bab8:	e155000c 	cmp	r5, ip
33d1babc:	e58d501c 	str	r5, [sp, #28]
33d1bac0:	eaffff23 	b	33d1b754 <huft_build+0x250>
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
33d1bac4:	e59d0024 	ldr	r0, [sp, #36]
33d1bac8:	e59de014 	ldr	lr, [sp, #20]
33d1bacc:	e35e0000 	cmp	lr, #0	; 0x0
33d1bad0:	13500001 	cmpne	r0, #1	; 0x1
33d1bad4:	03a03000 	moveq	r3, #0	; 0x0
33d1bad8:	13a03001 	movne	r3, #1	; 0x1
33d1badc:	13e00004 	mvnne	r0, #4	; 0x4
33d1bae0:	1a000003 	bne	33d1baf4 <huft_build+0x5f0>
33d1bae4:	ea000001 	b	33d1baf0 <huft_build+0x5ec>


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
33d1bae8:	e3e00002 	mvn	r0, #2	; 0x2
33d1baec:	ea000000 	b	33d1baf4 <huft_build+0x5f0>
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
33d1baf0:	e1a00003 	mov	r0, r3
}
33d1baf4:	e28ddf5d 	add	sp, sp, #372	; 0x174
33d1baf8:	e28ddb01 	add	sp, sp, #1024	; 0x400
33d1bafc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d1bb00 <falloc>:
uInt s;         /* size of item */
{
  Assert(s == sizeof(inflate_huft) && n <= fixed_left,
	 "inflate_trees falloc overflow");
  if (q) s++; /* to make some compilers happy */
  fixed_left -= n;
33d1bb00:	e59f3014 	ldr	r3, [pc, #20]	; 33d1bb1c <falloc+0x1c>
33d1bb04:	e5930000 	ldr	r0, [r3]
33d1bb08:	e0610000 	rsb	r0, r1, r0
33d1bb0c:	e5830000 	str	r0, [r3]
  return (voidpf)(fixed_mem + fixed_left);
}
33d1bb10:	e59f3008 	ldr	r3, [pc, #8]	; 33d1bb20 <falloc+0x20>
33d1bb14:	e0830180 	add	r0, r3, r0, lsl #3
33d1bb18:	e1a0f00e 	mov	pc, lr
33d1bb1c:	33d36918 	.word	0x33d36918
33d1bb20:	33d614b4 	.word	0x33d614b4

33d1bb24 <ffree>:
voidpf p;
uInt n;
{
  Assert(0, "inflate_trees ffree called!");
  if (q) q = p; /* to make some compilers happy */
}
33d1bb24:	e1a0f00e 	mov	pc, lr

33d1bb28 <inflate>:
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int inflate(z, f)
z_stream *z;
int f;
{
33d1bb28:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  int r;
  uInt b;

  if (z == Z_NULL || z->next_in == Z_NULL)
33d1bb2c:	e2506000 	subs	r6, r0, #0	; 0x0
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int inflate(z, f)
z_stream *z;
int f;
{
33d1bb30:	e24dde53 	sub	sp, sp, #1328	; 0x530
33d1bb34:	e58d1058 	str	r1, [sp, #88]
  int r;
  uInt b;

  if (z == Z_NULL || z->next_in == Z_NULL)
33d1bb38:	0a000714 	beq	33d1d790 <inflate+0x1c68>
33d1bb3c:	e5963000 	ldr	r3, [r6]
33d1bb40:	e3530000 	cmp	r3, #0	; 0x0
    return Z_STREAM_ERROR;
  r = Z_BUF_ERROR;
33d1bb44:	13e07004 	mvnne	r7, #4	; 0x4
int f;
{
  int r;
  uInt b;

  if (z == Z_NULL || z->next_in == Z_NULL)
33d1bb48:	0a000710 	beq	33d1d790 <inflate+0x1c68>
    return Z_STREAM_ERROR;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
33d1bb4c:	e596101c 	ldr	r1, [r6, #28]
33d1bb50:	e5913000 	ldr	r3, [r1]
33d1bb54:	e3530008 	cmp	r3, #8	; 0x8
33d1bb58:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d1bb5c:	ea00070b 	b	33d1d790 <inflate+0x1c68>
33d1bb60:	33d1bb84 	.word	0x33d1bb84
33d1bb64:	33d1bc10 	.word	0x33d1bc10
33d1bb68:	33d1bc8c 	.word	0x33d1bc8c
33d1bb6c:	33d1d640 	.word	0x33d1d640
33d1bb70:	33d1d684 	.word	0x33d1d684
33d1bb74:	33d1d6cc 	.word	0x33d1d6cc
33d1bb78:	33d1d714 	.word	0x33d1d714
33d1bb7c:	33d1d788 	.word	0x33d1d788
33d1bb80:	33d1d7c4 	.word	0x33d1d7c4
  {
    case METHOD:
      NEEDBYTE
33d1bb84:	e5962004 	ldr	r2, [r6, #4]
33d1bb88:	e3520000 	cmp	r2, #0	; 0x0
33d1bb8c:	0a000701 	beq	33d1d798 <inflate+0x1c70>
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
33d1bb90:	e5963008 	ldr	r3, [r6, #8]
33d1bb94:	e2422001 	sub	r2, r2, #1	; 0x1
33d1bb98:	e2833001 	add	r3, r3, #1	; 0x1
33d1bb9c:	e986000c 	stmib	r6, {r2, r3}
33d1bba0:	e5963000 	ldr	r3, [r6]
33d1bba4:	e4d32001 	ldrb	r2, [r3], #1
33d1bba8:	e5863000 	str	r3, [r6]
33d1bbac:	e5812004 	str	r2, [r1, #4]
33d1bbb0:	e202100f 	and	r1, r2, #15	; 0xf
33d1bbb4:	e3510008 	cmp	r1, #8	; 0x8
33d1bbb8:	e596401c 	ldr	r4, [r6, #28]
      {
	z->state->mode = BAD;
33d1bbbc:	13a03008 	movne	r3, #8	; 0x8
33d1bbc0:	15843000 	strne	r3, [r4]
    return Z_STREAM_ERROR;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
33d1bbc4:	e3a07000 	mov	r7, #0	; 0x0
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
      {
	z->state->mode = BAD;
	z->msg = "unknown compression method";
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1bbc8:	1596201c 	ldrne	r2, [r6, #28]
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
      {
	z->state->mode = BAD;
	z->msg = "unknown compression method";
33d1bbcc:	159f3f88 	ldrne	r3, [pc, #3976]	; 33d1cb5c <inflate+0x1034>
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
33d1bbd0:	1a0006e6 	bne	33d1d770 <inflate+0x1c48>
	z->state->mode = BAD;
	z->msg = "unknown compression method";
	z->state->sub.marker = 5;       /* can't try inflateSync */
	break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
33d1bbd4:	e5943004 	ldr	r3, [r4, #4]
33d1bbd8:	e5942010 	ldr	r2, [r4, #16]
33d1bbdc:	e1a03223 	lsr	r3, r3, #4
33d1bbe0:	e2833008 	add	r3, r3, #8	; 0x8
33d1bbe4:	e1530002 	cmp	r3, r2
33d1bbe8:	9a000006 	bls	33d1bc08 <inflate+0xe0>
      {
	z->state->mode = BAD;
33d1bbec:	e5841000 	str	r1, [r4]
	z->msg = "invalid window size";
33d1bbf0:	e59f2f68 	ldr	r2, [pc, #3944]	; 33d1cb60 <inflate+0x1038>
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1bbf4:	e596301c 	ldr	r3, [r6, #28]
	break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
	z->state->mode = BAD;
	z->msg = "invalid window size";
33d1bbf8:	e5862018 	str	r2, [r6, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1bbfc:	e3a02005 	mov	r2, #5	; 0x5
33d1bc00:	e5832004 	str	r2, [r3, #4]
	break;
33d1bc04:	eaffffd0 	b	33d1bb4c <inflate+0x24>
      }
      z->state->mode = FLAG;
33d1bc08:	e3a03001 	mov	r3, #1	; 0x1
33d1bc0c:	e5843000 	str	r3, [r4]
    case FLAG:
      NEEDBYTE
33d1bc10:	e5962004 	ldr	r2, [r6, #4]
33d1bc14:	e3520000 	cmp	r2, #0	; 0x0
33d1bc18:	0a0006de 	beq	33d1d798 <inflate+0x1c70>
      if ((b = NEXTBYTE) & 0x20)
33d1bc1c:	e5963008 	ldr	r3, [r6, #8]
33d1bc20:	e2422001 	sub	r2, r2, #1	; 0x1
33d1bc24:	e2833001 	add	r3, r3, #1	; 0x1
33d1bc28:	e986000c 	stmib	r6, {r2, r3}
33d1bc2c:	e5963000 	ldr	r3, [r6]
33d1bc30:	e4d32001 	ldrb	r2, [r3], #1
33d1bc34:	e596401c 	ldr	r4, [r6, #28]
33d1bc38:	e3120020 	tst	r2, #32	; 0x20
33d1bc3c:	e5863000 	str	r3, [r6]
      {
	z->state->mode = BAD;
33d1bc40:	13a03008 	movne	r3, #8	; 0x8
33d1bc44:	15843000 	strne	r3, [r4]
	break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      if ((b = NEXTBYTE) & 0x20)
33d1bc48:	e20220ff 	and	r2, r2, #255	; 0xff
	z->state->sub.marker = 5;       /* can't try inflateSync */
	break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
33d1bc4c:	e3a07000 	mov	r7, #0	; 0x0
      if ((b = NEXTBYTE) & 0x20)
      {
	z->state->mode = BAD;
	z->msg = "invalid reserved bit";
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1bc50:	1596201c 	ldrne	r2, [r6, #28]
    case FLAG:
      NEEDBYTE
      if ((b = NEXTBYTE) & 0x20)
      {
	z->state->mode = BAD;
	z->msg = "invalid reserved bit";
33d1bc54:	159f3f08 	ldrne	r3, [pc, #3848]	; 33d1cb64 <inflate+0x103c>
	break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      if ((b = NEXTBYTE) & 0x20)
33d1bc58:	1a0006c4 	bne	33d1d770 <inflate+0x1c48>
	z->state->mode = BAD;
	z->msg = "invalid reserved bit";
	z->state->sub.marker = 5;       /* can't try inflateSync */
	break;
      }
      if (((z->state->sub.method << 8) + b) % 31)
33d1bc5c:	e5940004 	ldr	r0, [r4, #4]
33d1bc60:	e3a0101f 	mov	r1, #31	; 0x1f
33d1bc64:	e0820400 	add	r0, r2, r0, lsl #8
33d1bc68:	eb000b0c 	bl	33d1e8a0 <__umodsi3>
33d1bc6c:	e3500000 	cmp	r0, #0	; 0x0
      {
	z->state->mode = BAD;
33d1bc70:	13a03008 	movne	r3, #8	; 0x8
33d1bc74:	15843000 	strne	r3, [r4]
	z->msg = "incorrect header check";
33d1bc78:	159f3ee8 	ldrne	r3, [pc, #3816]	; 33d1cb68 <inflate+0x1040>
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1bc7c:	1596201c 	ldrne	r2, [r6, #28]
	z->state->mode = BAD;
	z->msg = "invalid reserved bit";
	z->state->sub.marker = 5;       /* can't try inflateSync */
	break;
      }
      if (((z->state->sub.method << 8) + b) % 31)
33d1bc80:	1a0006ba 	bne	33d1d770 <inflate+0x1c48>
	z->msg = "incorrect header check";
	z->state->sub.marker = 5;       /* can't try inflateSync */
	break;
      }
      Trace((stderr, "inflate: zlib header ok\n"));
      z->state->mode = BLOCKS;
33d1bc84:	e3a03002 	mov	r3, #2	; 0x2
33d1bc88:	e5843000 	str	r3, [r4]

local int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1bc8c:	e596301c 	ldr	r3, [r6, #28]
33d1bc90:	e5935014 	ldr	r5, [r3, #20]
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1bc94:	e5950034 	ldr	r0, [r5, #52]
33d1bc98:	e58d004c 	str	r0, [sp, #76]
33d1bc9c:	e5953030 	ldr	r3, [r5, #48]

local int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1bca0:	e58d7054 	str	r7, [sp, #84]
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1bca4:	e5961004 	ldr	r1, [r6, #4]
33d1bca8:	e1500003 	cmp	r0, r3
33d1bcac:	e5969000 	ldr	r9, [r6]
33d1bcb0:	e58d1050 	str	r1, [sp, #80]
33d1bcb4:	30603003 	rsbcc	r3, r0, r3
33d1bcb8:	e2857020 	add	r7, r5, #32	; 0x20
33d1bcbc:	e8970480 	ldm	r7, {r7, sl}
33d1bcc0:	3243b001 	subcc	fp, r3, #1	; 0x1
33d1bcc4:	3a000052 	bcc	33d1be14 <inflate+0x2ec>
33d1bcc8:	ea00004e 	b	33d1be08 <inflate+0x2e0>
	  r = Z_DATA_ERROR;
	  LEAVE
      }
      break;
    case LENS:
      NEEDBITS(32)
33d1bccc:	e585a024 	str	sl, [r5, #36]
33d1bcd0:	e5857020 	str	r7, [r5, #32]
33d1bcd4:	e5963000 	ldr	r3, [r6]
33d1bcd8:	e5962008 	ldr	r2, [r6, #8]
33d1bcdc:	e59d1050 	ldr	r1, [sp, #80]
33d1bce0:	e0633009 	rsb	r3, r3, r9
33d1bce4:	e0822003 	add	r2, r2, r3
33d1bce8:	e9860006 	stmib	r6, {r1, r2}
33d1bcec:	e5869000 	str	r9, [r6]
33d1bcf0:	e59d204c 	ldr	r2, [sp, #76]
33d1bcf4:	e5852034 	str	r2, [r5, #52]
33d1bcf8:	e59d2054 	ldr	r2, [sp, #84]
33d1bcfc:	e1a00005 	mov	r0, r5
33d1bd00:	e1a01006 	mov	r1, r6
33d1bd04:	ea000622 	b	33d1d594 <inflate+0x1a6c>
      if (((~b) >> 16) != (b & 0xffff))
      {
	s->mode = BADB;
33d1bd08:	e3a03009 	mov	r3, #9	; 0x9
33d1bd0c:	e5853000 	str	r3, [r5]
	z->msg = "invalid stored block lengths";
33d1bd10:	e59f3e54 	ldr	r3, [pc, #3668]	; 33d1cb6c <inflate+0x1044>
33d1bd14:	ea000100 	b	33d1c11c <inflate+0x5f4>
      if (t < 19)
	t = 19;
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
	r = Z_MEM_ERROR;
	LEAVE
33d1bd18:	e585a024 	str	sl, [r5, #36]
33d1bd1c:	e5857020 	str	r7, [r5, #32]
33d1bd20:	e5963000 	ldr	r3, [r6]
33d1bd24:	e5962008 	ldr	r2, [r6, #8]
33d1bd28:	e59dc050 	ldr	ip, [sp, #80]
33d1bd2c:	e0633009 	rsb	r3, r3, r9
33d1bd30:	e0822003 	add	r2, r2, r3
33d1bd34:	e586c004 	str	ip, [r6, #4]
33d1bd38:	e5862008 	str	r2, [r6, #8]
33d1bd3c:	e5869000 	str	r9, [r6]
33d1bd40:	e59d004c 	ldr	r0, [sp, #76]
33d1bd44:	e5850034 	str	r0, [r5, #52]
33d1bd48:	ea00001d 	b	33d1bdc4 <inflate+0x29c>
	}
	else /* c == 16..18 */
	{
	  i = c == 18 ? 7 : c - 14;
	  j = c == 18 ? 11 : 3;
	  NEEDBITS(t + i)
33d1bd4c:	e585a024 	str	sl, [r5, #36]
33d1bd50:	e5857020 	str	r7, [r5, #32]
33d1bd54:	e5963000 	ldr	r3, [r6]
33d1bd58:	e5962008 	ldr	r2, [r6, #8]
33d1bd5c:	e59dc050 	ldr	ip, [sp, #80]
33d1bd60:	e0633009 	rsb	r3, r3, r9
33d1bd64:	e0822003 	add	r2, r2, r3
33d1bd68:	e586c004 	str	ip, [r6, #4]
33d1bd6c:	e5862008 	str	r2, [r6, #8]
33d1bd70:	e5869000 	str	r9, [r6]
33d1bd74:	e59d004c 	ldr	r0, [sp, #76]
33d1bd78:	e5850034 	str	r0, [r5, #52]
33d1bd7c:	eaffffdd 	b	33d1bcf8 <inflate+0x1d0>
	  LEAVE
	}
	Tracev((stderr, "inflate:       trees ok\n"));
	if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
	{
	  inflate_trees_free(td, z);
33d1bd80:	e1a01006 	mov	r1, r6
33d1bd84:	e59d005c 	ldr	r0, [sp, #92]
33d1bd88:	ebfffbfb 	bl	33d1ad7c <inflate_trees_free>
	  inflate_trees_free(tl, z);
33d1bd8c:	e1a01006 	mov	r1, r6
33d1bd90:	e59d0060 	ldr	r0, [sp, #96]
33d1bd94:	ebfffbf8 	bl	33d1ad7c <inflate_trees_free>
	  r = Z_MEM_ERROR;
	  LEAVE
33d1bd98:	e585a024 	str	sl, [r5, #36]
33d1bd9c:	e5857020 	str	r7, [r5, #32]
33d1bda0:	e5963000 	ldr	r3, [r6]
33d1bda4:	e5962008 	ldr	r2, [r6, #8]
33d1bda8:	e59d1050 	ldr	r1, [sp, #80]
33d1bdac:	e0633009 	rsb	r3, r3, r9
33d1bdb0:	e0822003 	add	r2, r2, r3
33d1bdb4:	e9860006 	stmib	r6, {r1, r2}
33d1bdb8:	e5869000 	str	r9, [r6]
33d1bdbc:	e59d204c 	ldr	r2, [sp, #76]
33d1bdc0:	e5852034 	str	r2, [r5, #52]
33d1bdc4:	e1a00005 	mov	r0, r5
33d1bdc8:	e1a01006 	mov	r1, r6
33d1bdcc:	e3e02003 	mvn	r2, #3	; 0x3
33d1bdd0:	ea0005ef 	b	33d1d594 <inflate+0x1a6c>
      }
      s->mode = DRY;
    case DRY:
      FLUSH
      if (s->read != s->write)
	LEAVE
33d1bdd4:	e585a024 	str	sl, [r5, #36]
33d1bdd8:	e5857020 	str	r7, [r5, #32]
33d1bddc:	e5963000 	ldr	r3, [r6]
33d1bde0:	e5962008 	ldr	r2, [r6, #8]
33d1bde4:	e0633009 	rsb	r3, r3, r9
33d1bde8:	e0822003 	add	r2, r2, r3
33d1bdec:	e59d3050 	ldr	r3, [sp, #80]
33d1bdf0:	e5862008 	str	r2, [r6, #8]
33d1bdf4:	e5863004 	str	r3, [r6, #4]
33d1bdf8:	e5869000 	str	r9, [r6]
33d1bdfc:	e59db04c 	ldr	fp, [sp, #76]
33d1be00:	e585b034 	str	fp, [r5, #52]
33d1be04:	eaffffbb 	b	33d1bcf8 <inflate+0x1d0>
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1be08:	e595302c 	ldr	r3, [r5, #44]
33d1be0c:	e59dc04c 	ldr	ip, [sp, #76]
33d1be10:	e06cb003 	rsb	fp, ip, r3

  /* process input based on current state */
  while (1) switch (s->mode)
33d1be14:	e5953000 	ldr	r3, [r5]
33d1be18:	e3530009 	cmp	r3, #9	; 0x9
33d1be1c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d1be20:	ea0005cc 	b	33d1d558 <inflate+0x1a30>
33d1be24:	33d1be4c 	.word	0x33d1be4c
33d1be28:	33d1c160 	.word	0x33d1c160
33d1be2c:	33d1c1d0 	.word	0x33d1c1d0
33d1be30:	33d1c318 	.word	0x33d1c318
33d1be34:	33d1c408 	.word	0x33d1c408
33d1be38:	33d1c580 	.word	0x33d1c580
33d1be3c:	33d1c920 	.word	0x33d1c920
33d1be40:	33d1d4b0 	.word	0x33d1d4b0
33d1be44:	33d1d4ec 	.word	0x33d1d4ec
33d1be48:	33d1d528 	.word	0x33d1d528
  {
    case TYPE:
      NEEDBITS(3)
33d1be4c:	e3570002 	cmp	r7, #2	; 0x2
33d1be50:	8a00000b 	bhi	33d1be84 <inflate+0x35c>
33d1be54:	e59d0050 	ldr	r0, [sp, #80]
33d1be58:	e3500000 	cmp	r0, #0	; 0x0
33d1be5c:	0affffdc 	beq	33d1bdd4 <inflate+0x2ac>
33d1be60:	e4d93001 	ldrb	r3, [r9], #1
33d1be64:	e18aa713 	orr	sl, sl, r3, lsl r7
33d1be68:	e2877008 	add	r7, r7, #8	; 0x8
33d1be6c:	e2400001 	sub	r0, r0, #1	; 0x1
33d1be70:	e3a01000 	mov	r1, #0	; 0x0
33d1be74:	e3570002 	cmp	r7, #2	; 0x2
33d1be78:	e58d0050 	str	r0, [sp, #80]
33d1be7c:	e58d1054 	str	r1, [sp, #84]
33d1be80:	eafffff2 	b	33d1be50 <inflate+0x328>
      t = (uInt)b & 7;
33d1be84:	e20a4007 	and	r4, sl, #7	; 0x7
      s->last = t & 1;
33d1be88:	e20a3001 	and	r3, sl, #1	; 0x1
      switch (t >> 1)
33d1be8c:	e1a020a4 	lsr	r2, r4, #1
  while (1) switch (s->mode)
  {
    case TYPE:
      NEEDBITS(3)
      t = (uInt)b & 7;
      s->last = t & 1;
33d1be90:	e585301c 	str	r3, [r5, #28]
      switch (t >> 1)
33d1be94:	e3520003 	cmp	r2, #3	; 0x3
33d1be98:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
33d1be9c:	eaffffdc 	b	33d1be14 <inflate+0x2ec>
33d1bea0:	33d1beb0 	.word	0x33d1beb0
33d1bea4:	33d1becc 	.word	0x33d1becc
33d1bea8:	33d1c0f8 	.word	0x33d1c0f8
33d1beac:	33d1c108 	.word	0x33d1c108
      {
	case 0:                         /* stored */
	  Trace((stderr, "inflate:     stored block%s\n",
		 s->last ? " (last)" : ""));
	  DUMPBITS(3)
33d1beb0:	e2477003 	sub	r7, r7, #3	; 0x3
	  t = k & 7;                    /* go to byte boundary */
33d1beb4:	e2074007 	and	r4, r7, #7	; 0x7
      switch (t >> 1)
      {
	case 0:                         /* stored */
	  Trace((stderr, "inflate:     stored block%s\n",
		 s->last ? " (last)" : ""));
	  DUMPBITS(3)
33d1beb8:	e1a0a1aa 	lsr	sl, sl, #3
	  t = k & 7;                    /* go to byte boundary */
	  DUMPBITS(t)
33d1bebc:	e0647007 	rsb	r7, r4, r7
33d1bec0:	e1a0a43a 	lsr	sl, sl, r4
	  s->mode = LENS;               /* get length of stored block */
33d1bec4:	e3a03001 	mov	r3, #1	; 0x1
33d1bec8:	ea00056e 	b	33d1d488 <inflate+0x1960>
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
{
  /* build fixed tables if not built already--lock out other instances */
  while (++fixed_lock > 1)
    fixed_lock--;
33d1becc:	e59f1c9c 	ldr	r1, [pc, #3228]	; 33d1cb70 <inflate+0x1048>
33d1bed0:	e5913000 	ldr	r3, [r1]
local int inflate_trees_fixed(bl, bd, tl, td)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
{
33d1bed4:	e28d2080 	add	r2, sp, #128	; 0x80
33d1bed8:	e28dc080 	add	ip, sp, #128	; 0x80
33d1bedc:	e28d0070 	add	r0, sp, #112	; 0x70
  /* build fixed tables if not built already--lock out other instances */
  while (++fixed_lock > 1)
    fixed_lock--;
33d1bee0:	e2833001 	add	r3, r3, #1	; 0x1
local int inflate_trees_fixed(bl, bd, tl, td)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
{
33d1bee4:	e2422008 	sub	r2, r2, #8	; 0x8
33d1bee8:	e24cc00c 	sub	ip, ip, #12	; 0xc
33d1beec:	e2400004 	sub	r0, r0, #4	; 0x4
33d1bef0:	e58d2048 	str	r2, [sp, #72]
33d1bef4:	e58dc044 	str	ip, [sp, #68]
33d1bef8:	e58d0040 	str	r0, [sp, #64]
  /* build fixed tables if not built already--lock out other instances */
  while (++fixed_lock > 1)
    fixed_lock--;
33d1befc:	e5813000 	str	r3, [r1]
33d1bf00:	e3530001 	cmp	r3, #1	; 0x1
33d1bf04:	da000006 	ble	33d1bf24 <inflate+0x3fc>
33d1bf08:	e5912000 	ldr	r2, [r1]
33d1bf0c:	e2423001 	sub	r3, r2, #1	; 0x1
33d1bf10:	e5813000 	str	r3, [r1]
33d1bf14:	e59f1c54 	ldr	r1, [pc, #3156]	; 33d1cb70 <inflate+0x1048>
33d1bf18:	e3520001 	cmp	r2, #1	; 0x1
33d1bf1c:	e5812000 	str	r2, [r1]
33d1bf20:	eafffff7 	b	33d1bf04 <inflate+0x3dc>
  if (!fixed_built)
33d1bf24:	e59f1c48 	ldr	r1, [pc, #3144]	; 33d1cb74 <inflate+0x104c>
33d1bf28:	e5912000 	ldr	r2, [r1]
33d1bf2c:	e3520000 	cmp	r2, #0	; 0x0
33d1bf30:	1a00004e 	bne	33d1c070 <inflate+0x548>
    int k;              /* temporary variable */
    unsigned c[288];    /* length list for huft_build */
    z_stream z;         /* for falloc function */

    /* set up fake z_stream for memory routines */
    z.zalloc = falloc;
33d1bf34:	e59f3c3c 	ldr	r3, [pc, #3132]	; 33d1cb78 <inflate+0x1050>
33d1bf38:	e58d309c 	str	r3, [sp, #156]
    z.zfree = ffree;
33d1bf3c:	e59f3c38 	ldr	r3, [pc, #3128]	; 33d1cb7c <inflate+0x1054>
33d1bf40:	e58d30a0 	str	r3, [sp, #160]
    z.opaque = Z_NULL;
33d1bf44:	e58d20a4 	str	r2, [sp, #164]
33d1bf48:	e3a0108f 	mov	r1, #143	; 0x8f
33d1bf4c:	e28d2e53 	add	r2, sp, #1328	; 0x530

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
33d1bf50:	e3a03008 	mov	r3, #8	; 0x8
33d1bf54:	e2511001 	subs	r1, r1, #1	; 0x1
33d1bf58:	e5023480 	str	r3, [r2, #-1152]
33d1bf5c:	e2822004 	add	r2, r2, #4	; 0x4
33d1bf60:	5afffffa 	bpl	33d1bf50 <inflate+0x428>
33d1bf64:	e3a01090 	mov	r1, #144	; 0x90
33d1bf68:	e28d2e77 	add	r2, sp, #1904	; 0x770
    for (; k < 256; k++)
33d1bf6c:	e2811001 	add	r1, r1, #1	; 0x1
      c[k] = 9;
33d1bf70:	e3a03009 	mov	r3, #9	; 0x9
    z.opaque = Z_NULL;

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
33d1bf74:	e35100ff 	cmp	r1, #255	; 0xff
      c[k] = 9;
33d1bf78:	e5023480 	str	r3, [r2, #-1152]
33d1bf7c:	e2822004 	add	r2, r2, #4	; 0x4
    z.opaque = Z_NULL;

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
33d1bf80:	dafffff9 	ble	33d1bf6c <inflate+0x444>
      c[k] = 9;
    for (; k < 280; k++)
33d1bf84:	e59f0bf4 	ldr	r0, [pc, #3060]	; 33d1cb80 <inflate+0x1058>
33d1bf88:	e1510000 	cmp	r1, r0
33d1bf8c:	ca000007 	bgt	33d1bfb0 <inflate+0x488>
33d1bf90:	e28d3e53 	add	r3, sp, #1328	; 0x530
33d1bf94:	e0832101 	add	r2, r3, r1, lsl #2
33d1bf98:	e2811001 	add	r1, r1, #1	; 0x1
      c[k] = 7;
33d1bf9c:	e3a03007 	mov	r3, #7	; 0x7
    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
33d1bfa0:	e1510000 	cmp	r1, r0
      c[k] = 7;
33d1bfa4:	e5023480 	str	r3, [r2, #-1152]
33d1bfa8:	e2822004 	add	r2, r2, #4	; 0x4
    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
33d1bfac:	dafffff9 	ble	33d1bf98 <inflate+0x470>
      c[k] = 7;
    for (; k < 288; k++)
33d1bfb0:	e59f0bcc 	ldr	r0, [pc, #3020]	; 33d1cb84 <inflate+0x105c>
33d1bfb4:	e1510000 	cmp	r1, r0
33d1bfb8:	ca000007 	bgt	33d1bfdc <inflate+0x4b4>
33d1bfbc:	e28dce53 	add	ip, sp, #1328	; 0x530
33d1bfc0:	e08c2101 	add	r2, ip, r1, lsl #2
33d1bfc4:	e2811001 	add	r1, r1, #1	; 0x1
      c[k] = 8;
33d1bfc8:	e3a03008 	mov	r3, #8	; 0x8
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
33d1bfcc:	e1510000 	cmp	r1, r0
      c[k] = 8;
33d1bfd0:	e5023480 	str	r3, [r2, #-1152]
33d1bfd4:	e2822004 	add	r2, r2, #4	; 0x4
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
33d1bfd8:	dafffff9 	ble	33d1bfc4 <inflate+0x49c>
      c[k] = 8;
    fixed_bl = 7;
33d1bfdc:	e59feba4 	ldr	lr, [pc, #2980]	; 33d1cb88 <inflate+0x1060>
33d1bfe0:	e3a0c007 	mov	ip, #7	; 0x7
33d1bfe4:	e58ec000 	str	ip, [lr]
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
33d1bfe8:	e59fcb9c 	ldr	ip, [pc, #2972]	; 33d1cb8c <inflate+0x1064>
33d1bfec:	e28d4080 	add	r4, sp, #128	; 0x80
33d1bff0:	e58dc000 	str	ip, [sp]
33d1bff4:	e59fcb94 	ldr	ip, [pc, #2964]	; 33d1cb90 <inflate+0x1068>
33d1bff8:	e3a01e12 	mov	r1, #288	; 0x120
33d1bffc:	e59f3b90 	ldr	r3, [pc, #2960]	; 33d1cb94 <inflate+0x106c>
33d1c000:	e2444004 	sub	r4, r4, #4	; 0x4
33d1c004:	e28d00b0 	add	r0, sp, #176	; 0xb0
33d1c008:	e59f2bb8 	ldr	r2, [pc, #3000]	; 33d1cbc8 <inflate+0x10a0>
33d1c00c:	e98d5000 	stmib	sp, {ip, lr}
33d1c010:	e58d400c 	str	r4, [sp, #12]
33d1c014:	ebfffd3a 	bl	33d1b504 <huft_build>
33d1c018:	e28d3e53 	add	r3, sp, #1328	; 0x530
33d1c01c:	e3a0101d 	mov	r1, #29	; 0x1d

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
33d1c020:	e3a0c005 	mov	ip, #5	; 0x5
33d1c024:	e2511001 	subs	r1, r1, #1	; 0x1
33d1c028:	e503c480 	str	ip, [r3, #-1152]
33d1c02c:	e2833004 	add	r3, r3, #4	; 0x4
33d1c030:	5afffffa 	bpl	33d1c020 <inflate+0x4f8>
    fixed_bd = 5;
33d1c034:	e59feb5c 	ldr	lr, [pc, #2908]	; 33d1cb98 <inflate+0x1070>
33d1c038:	e58ec000 	str	ip, [lr]
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
33d1c03c:	e59fcb58 	ldr	ip, [pc, #2904]	; 33d1cb9c <inflate+0x1074>
33d1c040:	e58dc000 	str	ip, [sp]
33d1c044:	e59fcb54 	ldr	ip, [pc, #2900]	; 33d1cba0 <inflate+0x1078>
33d1c048:	e59f3b54 	ldr	r3, [pc, #2900]	; 33d1cba4 <inflate+0x107c>
33d1c04c:	e28d00b0 	add	r0, sp, #176	; 0xb0
33d1c050:	e3a0101e 	mov	r1, #30	; 0x1e
33d1c054:	e3a02000 	mov	r2, #0	; 0x0
33d1c058:	e98d5000 	stmib	sp, {ip, lr}
33d1c05c:	e58d400c 	str	r4, [sp, #12]
33d1c060:	ebfffd27 	bl	33d1b504 <huft_build>

    /* done */
    fixed_built = 1;
33d1c064:	e59f0b08 	ldr	r0, [pc, #2824]	; 33d1cb74 <inflate+0x104c>
33d1c068:	e3a03001 	mov	r3, #1	; 0x1
33d1c06c:	e5803000 	str	r3, [r0]
  }
  fixed_lock--;
  *bl = fixed_bl;
33d1c070:	e59f3b10 	ldr	r3, [pc, #2832]	; 33d1cb88 <inflate+0x1060>
33d1c074:	e5930000 	ldr	r0, [r3]
  *bd = fixed_bd;
33d1c078:	e59f3b18 	ldr	r3, [pc, #2840]	; 33d1cb98 <inflate+0x1070>
33d1c07c:	e5931000 	ldr	r1, [r3]
  *tl = fixed_tl;
33d1c080:	e59f3b08 	ldr	r3, [pc, #2824]	; 33d1cb90 <inflate+0x1068>

    /* done */
    fixed_built = 1;
  }
  fixed_lock--;
  *bl = fixed_bl;
33d1c084:	e59dc048 	ldr	ip, [sp, #72]
  *bd = fixed_bd;
  *tl = fixed_tl;
33d1c088:	e5932000 	ldr	r2, [r3]
  *td = fixed_td;
33d1c08c:	e59f3b0c 	ldr	r3, [pc, #2828]	; 33d1cba0 <inflate+0x1078>
33d1c090:	e5933000 	ldr	r3, [r3]

    /* done */
    fixed_built = 1;
  }
  fixed_lock--;
  *bl = fixed_bl;
33d1c094:	e58c0000 	str	r0, [ip]
  *bd = fixed_bd;
33d1c098:	e59d0044 	ldr	r0, [sp, #68]
33d1c09c:	e5801000 	str	r1, [r0]
  *tl = fixed_tl;
  *td = fixed_td;
33d1c0a0:	e59d1040 	ldr	r1, [sp, #64]
    fixed_built = 1;
  }
  fixed_lock--;
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
33d1c0a4:	e58d2070 	str	r2, [sp, #112]
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);

    /* done */
    fixed_built = 1;
  }
  fixed_lock--;
33d1c0a8:	e59feac0 	ldr	lr, [pc, #2752]	; 33d1cb70 <inflate+0x1048>
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
33d1c0ac:	e5813000 	str	r3, [r1]
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);

    /* done */
    fixed_built = 1;
  }
  fixed_lock--;
33d1c0b0:	e59ec000 	ldr	ip, [lr]
33d1c0b4:	e24cc001 	sub	ip, ip, #1	; 0x1
	  {
	    uInt bl, bd;
	    inflate_huft *tl, *td;

	    inflate_trees_fixed(&bl, &bd, &tl, &td);
	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
33d1c0b8:	e59d0078 	ldr	r0, [sp, #120]
33d1c0bc:	e59d1074 	ldr	r1, [sp, #116]
33d1c0c0:	e59d2070 	ldr	r2, [sp, #112]
33d1c0c4:	e59d306c 	ldr	r3, [sp, #108]
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);

    /* done */
    fixed_built = 1;
  }
  fixed_lock--;
33d1c0c8:	e58ec000 	str	ip, [lr]
	  {
	    uInt bl, bd;
	    inflate_huft *tl, *td;

	    inflate_trees_fixed(&bl, &bd, &tl, &td);
	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
33d1c0cc:	e58d6000 	str	r6, [sp]
33d1c0d0:	ebfffc4c 	bl	33d1b208 <inflate_codes_new>
	    if (s->sub.decode.codes == Z_NULL)
33d1c0d4:	e3500000 	cmp	r0, #0	; 0x0
	  {
	    uInt bl, bd;
	    inflate_huft *tl, *td;

	    inflate_trees_fixed(&bl, &bd, &tl, &td);
	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
33d1c0d8:	e585000c 	str	r0, [r5, #12]
	    if (s->sub.decode.codes == Z_NULL)
33d1c0dc:	0affff0d 	beq	33d1bd18 <inflate+0x1f0>
	    {
	      r = Z_MEM_ERROR;
	      LEAVE
	    }
	    s->sub.decode.tl = Z_NULL;  /* don't try to free these */
33d1c0e0:	e3a02000 	mov	r2, #0	; 0x0
	    s->sub.decode.td = Z_NULL;
	  }
	  DUMPBITS(3)
33d1c0e4:	e1a0a1aa 	lsr	sl, sl, #3
33d1c0e8:	e2477003 	sub	r7, r7, #3	; 0x3
	  s->mode = CODES;
33d1c0ec:	e3a03006 	mov	r3, #6	; 0x6
	    {
	      r = Z_MEM_ERROR;
	      LEAVE
	    }
	    s->sub.decode.tl = Z_NULL;  /* don't try to free these */
	    s->sub.decode.td = Z_NULL;
33d1c0f0:	e5852008 	str	r2, [r5, #8]
33d1c0f4:	ea000032 	b	33d1c1c4 <inflate+0x69c>
	  s->mode = CODES;
	  break;
	case 2:                         /* dynamic */
	  Trace((stderr, "inflate:     dynamic codes block%s\n",
		 s->last ? " (last)" : ""));
	  DUMPBITS(3)
33d1c0f8:	e1a0a1aa 	lsr	sl, sl, #3
33d1c0fc:	e2477003 	sub	r7, r7, #3	; 0x3
	  s->mode = TABLE;
33d1c100:	e3a03003 	mov	r3, #3	; 0x3
33d1c104:	ea0004df 	b	33d1d488 <inflate+0x1960>
	  break;
	case 3:                         /* illegal */
	  DUMPBITS(3)
	  s->mode = BADB;
33d1c108:	e3a03009 	mov	r3, #9	; 0x9
33d1c10c:	e5853000 	str	r3, [r5]
	  z->msg = "invalid block type";
33d1c110:	e59f3a90 	ldr	r3, [pc, #2704]	; 33d1cba8 <inflate+0x1080>
		 s->last ? " (last)" : ""));
	  DUMPBITS(3)
	  s->mode = TABLE;
	  break;
	case 3:                         /* illegal */
	  DUMPBITS(3)
33d1c114:	e1a0a1aa 	lsr	sl, sl, #3
33d1c118:	e2477003 	sub	r7, r7, #3	; 0x3
	  s->mode = BADB;
	  z->msg = "invalid block type";
33d1c11c:	e5863018 	str	r3, [r6, #24]
	  r = Z_DATA_ERROR;
	  LEAVE
33d1c120:	e585a024 	str	sl, [r5, #36]
33d1c124:	e5857020 	str	r7, [r5, #32]
33d1c128:	e5963000 	ldr	r3, [r6]
33d1c12c:	e5962008 	ldr	r2, [r6, #8]
33d1c130:	e0633009 	rsb	r3, r3, r9
33d1c134:	e0822003 	add	r2, r2, r3
33d1c138:	e59d3050 	ldr	r3, [sp, #80]
33d1c13c:	e5862008 	str	r2, [r6, #8]
33d1c140:	e5863004 	str	r3, [r6, #4]
33d1c144:	e5869000 	str	r9, [r6]
33d1c148:	e59db04c 	ldr	fp, [sp, #76]
33d1c14c:	e585b034 	str	fp, [r5, #52]
33d1c150:	e1a00005 	mov	r0, r5
33d1c154:	e1a01006 	mov	r1, r6
33d1c158:	e3e02002 	mvn	r2, #2	; 0x2
33d1c15c:	ea00050c 	b	33d1d594 <inflate+0x1a6c>
      }
      break;
    case LENS:
      NEEDBITS(32)
33d1c160:	e357001f 	cmp	r7, #31	; 0x1f
33d1c164:	8a00000b 	bhi	33d1c198 <inflate+0x670>
33d1c168:	e59dc050 	ldr	ip, [sp, #80]
33d1c16c:	e35c0000 	cmp	ip, #0	; 0x0
33d1c170:	0afffed5 	beq	33d1bccc <inflate+0x1a4>
33d1c174:	e4d93001 	ldrb	r3, [r9], #1
33d1c178:	e18aa713 	orr	sl, sl, r3, lsl r7
33d1c17c:	e2877008 	add	r7, r7, #8	; 0x8
33d1c180:	e24cc001 	sub	ip, ip, #1	; 0x1
33d1c184:	e3a00000 	mov	r0, #0	; 0x0
33d1c188:	e357001f 	cmp	r7, #31	; 0x1f
33d1c18c:	e58dc050 	str	ip, [sp, #80]
33d1c190:	e58d0054 	str	r0, [sp, #84]
33d1c194:	eafffff2 	b	33d1c164 <inflate+0x63c>
      if (((~b) >> 16) != (b & 0xffff))
33d1c198:	e1e0200a 	mvn	r2, sl
33d1c19c:	e1a0380a 	lsl	r3, sl, #16
33d1c1a0:	e1a02822 	lsr	r2, r2, #16
33d1c1a4:	e1a03823 	lsr	r3, r3, #16
33d1c1a8:	e1520003 	cmp	r2, r3
33d1c1ac:	1afffed5 	bne	33d1bd08 <inflate+0x1e0>
	z->msg = "invalid stored block lengths";
	r = Z_DATA_ERROR;
	LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
33d1c1b0:	e3a07000 	mov	r7, #0	; 0x0
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : TYPE;
33d1c1b4:	e1520007 	cmp	r2, r7
33d1c1b8:	13a03002 	movne	r3, #2	; 0x2
33d1c1bc:	01a03007 	moveq	r3, r7
	z->msg = "invalid stored block lengths";
	r = Z_DATA_ERROR;
	LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
33d1c1c0:	e1a0a007 	mov	sl, r7
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : TYPE;
33d1c1c4:	e5853000 	str	r3, [r5]
	s->mode = BADB;
	z->msg = "invalid stored block lengths";
	r = Z_DATA_ERROR;
	LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
33d1c1c8:	e5852004 	str	r2, [r5, #4]
      b = k = 0;                      /* dump bits */
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : TYPE;
      break;
33d1c1cc:	eaffff10 	b	33d1be14 <inflate+0x2ec>
    case STORED:
      if (n == 0)
33d1c1d0:	e59d1050 	ldr	r1, [sp, #80]
33d1c1d4:	e3510000 	cmp	r1, #0	; 0x0
33d1c1d8:	0afffedb 	beq	33d1bd4c <inflate+0x224>
	LEAVE
      NEEDOUT
33d1c1dc:	e35b0000 	cmp	fp, #0	; 0x0
33d1c1e0:	1a00002e 	bne	33d1c2a0 <inflate+0x778>
33d1c1e4:	e595102c 	ldr	r1, [r5, #44]
33d1c1e8:	e59d204c 	ldr	r2, [sp, #76]
33d1c1ec:	e1520001 	cmp	r2, r1
33d1c1f0:	1a00000b 	bne	33d1c224 <inflate+0x6fc>
33d1c1f4:	e5953030 	ldr	r3, [r5, #48]
33d1c1f8:	e5952028 	ldr	r2, [r5, #40]
33d1c1fc:	e1530002 	cmp	r3, r2
33d1c200:	0a000007 	beq	33d1c224 <inflate+0x6fc>
33d1c204:	e58d204c 	str	r2, [sp, #76]
33d1c208:	e1520003 	cmp	r2, r3
33d1c20c:	259d304c 	ldrcs	r3, [sp, #76]
33d1c210:	30623003 	rsbcc	r3, r2, r3
33d1c214:	3243b001 	subcc	fp, r3, #1	; 0x1
33d1c218:	2063b001 	rsbcs	fp, r3, r1
33d1c21c:	e35b0000 	cmp	fp, #0	; 0x0
33d1c220:	1a00001e 	bne	33d1c2a0 <inflate+0x778>
33d1c224:	e59db04c 	ldr	fp, [sp, #76]
33d1c228:	e585b034 	str	fp, [r5, #52]
33d1c22c:	e59d2054 	ldr	r2, [sp, #84]
33d1c230:	e1a01006 	mov	r1, r6
33d1c234:	e1a00005 	mov	r0, r5
33d1c238:	ebfffc54 	bl	33d1b390 <inflate_flush>
33d1c23c:	e58d0054 	str	r0, [sp, #84]
33d1c240:	e595c034 	ldr	ip, [r5, #52]
33d1c244:	e58dc04c 	str	ip, [sp, #76]
33d1c248:	e5952030 	ldr	r2, [r5, #48]
33d1c24c:	e15c0002 	cmp	ip, r2
33d1c250:	2595302c 	ldrcs	r3, [r5, #44]
33d1c254:	259d004c 	ldrcs	r0, [sp, #76]
33d1c258:	306c3002 	rsbcc	r3, ip, r2
33d1c25c:	3243b001 	subcc	fp, r3, #1	; 0x1
33d1c260:	2060b003 	rsbcs	fp, r0, r3
33d1c264:	e595102c 	ldr	r1, [r5, #44]
33d1c268:	e59d304c 	ldr	r3, [sp, #76]
33d1c26c:	e1530001 	cmp	r3, r1
33d1c270:	1a000008 	bne	33d1c298 <inflate+0x770>
33d1c274:	e5953028 	ldr	r3, [r5, #40]
33d1c278:	e1520003 	cmp	r2, r3
33d1c27c:	0a000005 	beq	33d1c298 <inflate+0x770>
33d1c280:	e58d304c 	str	r3, [sp, #76]
33d1c284:	e1530002 	cmp	r3, r2
33d1c288:	259dc04c 	ldrcs	ip, [sp, #76]
33d1c28c:	30633002 	rsbcc	r3, r3, r2
33d1c290:	3243b001 	subcc	fp, r3, #1	; 0x1
33d1c294:	206cb001 	rsbcs	fp, ip, r1
33d1c298:	e35b0000 	cmp	fp, #0	; 0x0
33d1c29c:	0afffe8a 	beq	33d1bccc <inflate+0x1a4>
      t = s->sub.left;
      if (t > n) t = n;
33d1c2a0:	e59d0050 	ldr	r0, [sp, #80]
      break;
    case STORED:
      if (n == 0)
	LEAVE
      NEEDOUT
      t = s->sub.left;
33d1c2a4:	e5954004 	ldr	r4, [r5, #4]
      if (t > n) t = n;
33d1c2a8:	e1540000 	cmp	r4, r0
33d1c2ac:	21a04000 	movcs	r4, r0
      if (t > m) t = m;
33d1c2b0:	e154000b 	cmp	r4, fp
33d1c2b4:	21a0400b 	movcs	r4, fp
      zmemcpy(q, p, t);
33d1c2b8:	e1a01009 	mov	r1, r9
33d1c2bc:	e1a02004 	mov	r2, r4
33d1c2c0:	e59d004c 	ldr	r0, [sp, #76]
33d1c2c4:	ebfff846 	bl	33d1a3e4 <memcpy>
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
33d1c2c8:	e5953004 	ldr	r3, [r5, #4]
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
33d1c2cc:	e59d1050 	ldr	r1, [sp, #80]
      q += t;  m -= t;
33d1c2d0:	e59d204c 	ldr	r2, [sp, #76]
      if ((s->sub.left -= t) != 0)
33d1c2d4:	e0643003 	rsb	r3, r4, r3
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
33d1c2d8:	e0641001 	rsb	r1, r4, r1
      q += t;  m -= t;
33d1c2dc:	e0822004 	add	r2, r2, r4
      if ((s->sub.left -= t) != 0)
33d1c2e0:	e3530000 	cmp	r3, #0	; 0x0
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
33d1c2e4:	e58d1050 	str	r1, [sp, #80]
      q += t;  m -= t;
33d1c2e8:	e58d204c 	str	r2, [sp, #76]
      if ((s->sub.left -= t) != 0)
33d1c2ec:	e5853004 	str	r3, [r5, #4]
      s->mode = s->sub.left ? STORED : TYPE;
      break;
    case STORED:
      if (n == 0)
	LEAVE
      NEEDOUT
33d1c2f0:	e3a03000 	mov	r3, #0	; 0x0
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
33d1c2f4:	e0899004 	add	r9, r9, r4
      q += t;  m -= t;
33d1c2f8:	e064b00b 	rsb	fp, r4, fp
      s->mode = s->sub.left ? STORED : TYPE;
      break;
    case STORED:
      if (n == 0)
	LEAVE
      NEEDOUT
33d1c2fc:	e58d3054 	str	r3, [sp, #84]
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
33d1c300:	1afffec3 	bne	33d1be14 <inflate+0x2ec>
	break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
	      z->total_out + (q >= s->read ? q - s->read :
	      (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
33d1c304:	e595301c 	ldr	r3, [r5, #28]
33d1c308:	e3530000 	cmp	r3, #0	; 0x0
33d1c30c:	13a03007 	movne	r3, #7	; 0x7
33d1c310:	03a03000 	moveq	r3, #0	; 0x0
33d1c314:	ea00045b 	b	33d1d488 <inflate+0x1960>
      break;
    case TABLE:
      NEEDBITS(14)
33d1c318:	e357000d 	cmp	r7, #13	; 0xd
33d1c31c:	8a00000b 	bhi	33d1c350 <inflate+0x828>
33d1c320:	e59db050 	ldr	fp, [sp, #80]
33d1c324:	e35b0000 	cmp	fp, #0	; 0x0
33d1c328:	0afffea9 	beq	33d1bdd4 <inflate+0x2ac>
33d1c32c:	e4d93001 	ldrb	r3, [r9], #1
33d1c330:	e18aa713 	orr	sl, sl, r3, lsl r7
33d1c334:	e2877008 	add	r7, r7, #8	; 0x8
33d1c338:	e24bb001 	sub	fp, fp, #1	; 0x1
33d1c33c:	e3a0c000 	mov	ip, #0	; 0x0
33d1c340:	e357000d 	cmp	r7, #13	; 0xd
33d1c344:	e58db050 	str	fp, [sp, #80]
33d1c348:	e58dc054 	str	ip, [sp, #84]
33d1c34c:	eafffff2 	b	33d1c31c <inflate+0x7f4>
      s->sub.trees.table = t = (uInt)b & 0x3fff;
33d1c350:	e1a0490a 	lsl	r4, sl, #18
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
33d1c354:	e20a201f 	and	r2, sl, #31	; 0x1f
	      (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
33d1c358:	e1a04924 	lsr	r4, r4, #18
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
33d1c35c:	e352001d 	cmp	r2, #29	; 0x1d
	      (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
33d1c360:	e5854004 	str	r4, [r5, #4]
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
33d1c364:	8a000003 	bhi	33d1c378 <inflate+0x850>
33d1c368:	e1a032a4 	lsr	r3, r4, #5
33d1c36c:	e203101f 	and	r1, r3, #31	; 0x1f
33d1c370:	e351001d 	cmp	r1, #29	; 0x1d
33d1c374:	9a00000f 	bls	33d1c3b8 <inflate+0x890>
      {
	s->mode = BADB;
33d1c378:	e3a03009 	mov	r3, #9	; 0x9
33d1c37c:	e5853000 	str	r3, [r5]
	z->msg = "too many length or distance symbols";
33d1c380:	e59f3824 	ldr	r3, [pc, #2084]	; 33d1cbac <inflate+0x1084>
33d1c384:	e5863018 	str	r3, [r6, #24]
	r = Z_DATA_ERROR;
	LEAVE
33d1c388:	e585a024 	str	sl, [r5, #36]
33d1c38c:	e5857020 	str	r7, [r5, #32]
33d1c390:	e5963000 	ldr	r3, [r6]
33d1c394:	e5962008 	ldr	r2, [r6, #8]
33d1c398:	e59d0050 	ldr	r0, [sp, #80]
33d1c39c:	e0633009 	rsb	r3, r3, r9
33d1c3a0:	e0822003 	add	r2, r2, r3
33d1c3a4:	e9860005 	stmib	r6, {r0, r2}
33d1c3a8:	e5869000 	str	r9, [r6]
33d1c3ac:	e59d104c 	ldr	r1, [sp, #76]
33d1c3b0:	e5851034 	str	r1, [r5, #52]
33d1c3b4:	eaffff65 	b	33d1c150 <inflate+0x628>
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
33d1c3b8:	e0823001 	add	r3, r2, r1
33d1c3bc:	e2834c01 	add	r4, r3, #256	; 0x100
33d1c3c0:	e2844002 	add	r4, r4, #2	; 0x2
      if (t < 19)
	t = 19;
33d1c3c4:	e3540012 	cmp	r4, #18	; 0x12
33d1c3c8:	93a04013 	movls	r4, #19	; 0x13
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
33d1c3cc:	e5960028 	ldr	r0, [r6, #40]
33d1c3d0:	e1a01004 	mov	r1, r4
33d1c3d4:	e3a02004 	mov	r2, #4	; 0x4
33d1c3d8:	e1a0e00f 	mov	lr, pc
33d1c3dc:	e596f020 	ldr	pc, [r6, #32]
33d1c3e0:	e3500000 	cmp	r0, #0	; 0x0
33d1c3e4:	e585000c 	str	r0, [r5, #12]
33d1c3e8:	0afffe4a 	beq	33d1bd18 <inflate+0x1f0>
	r = Z_MEM_ERROR;
	LEAVE
      }
      s->sub.trees.nblens = t;
      DUMPBITS(14)
      s->sub.trees.index = 0;
33d1c3ec:	e3a03000 	mov	r3, #0	; 0x0
33d1c3f0:	e5853008 	str	r3, [r5, #8]
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
33d1c3f4:	e2833004 	add	r3, r3, #4	; 0x4
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
	r = Z_MEM_ERROR;
	LEAVE
      }
      s->sub.trees.nblens = t;
33d1c3f8:	e5854018 	str	r4, [r5, #24]
      DUMPBITS(14)
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
33d1c3fc:	e5853000 	str	r3, [r5]
      {
	r = Z_MEM_ERROR;
	LEAVE
      }
      s->sub.trees.nblens = t;
      DUMPBITS(14)
33d1c400:	e1a0a72a 	lsr	sl, sl, #14
33d1c404:	e247700e 	sub	r7, r7, #14	; 0xe
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
	NEEDBITS(3)
	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
	DUMPBITS(3)
33d1c408:	e5953004 	ldr	r3, [r5, #4]
33d1c40c:	e5952008 	ldr	r2, [r5, #8]
33d1c410:	e1a03523 	lsr	r3, r3, #10
33d1c414:	e2833004 	add	r3, r3, #4	; 0x4
33d1c418:	e1520003 	cmp	r2, r3
33d1c41c:	2a00001c 	bcs	33d1c494 <inflate+0x96c>
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
	NEEDBITS(3)
33d1c420:	e3570002 	cmp	r7, #2	; 0x2
33d1c424:	8a00000b 	bhi	33d1c458 <inflate+0x930>
33d1c428:	e59d2050 	ldr	r2, [sp, #80]
33d1c42c:	e3520000 	cmp	r2, #0	; 0x0
33d1c430:	0afffe25 	beq	33d1bccc <inflate+0x1a4>
33d1c434:	e4d93001 	ldrb	r3, [r9], #1
33d1c438:	e18aa713 	orr	sl, sl, r3, lsl r7
33d1c43c:	e2877008 	add	r7, r7, #8	; 0x8
33d1c440:	e2422001 	sub	r2, r2, #1	; 0x1
33d1c444:	e3a03000 	mov	r3, #0	; 0x0
33d1c448:	e3570002 	cmp	r7, #2	; 0x2
33d1c44c:	e58d2050 	str	r2, [sp, #80]
33d1c450:	e58d3054 	str	r3, [sp, #84]
33d1c454:	eafffff2 	b	33d1c424 <inflate+0x8fc>
	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
33d1c458:	e5952008 	ldr	r2, [r5, #8]
33d1c45c:	e59f374c 	ldr	r3, [pc, #1868]	; 33d1cbb0 <inflate+0x1088>
33d1c460:	e595100c 	ldr	r1, [r5, #12]
33d1c464:	e7930102 	ldr	r0, [r3, r2, lsl #2]
33d1c468:	e20a3007 	and	r3, sl, #7	; 0x7
33d1c46c:	e7813100 	str	r3, [r1, r0, lsl #2]
	DUMPBITS(3)
33d1c470:	e5953004 	ldr	r3, [r5, #4]
33d1c474:	e1a03523 	lsr	r3, r3, #10
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
	NEEDBITS(3)
	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
33d1c478:	e2822001 	add	r2, r2, #1	; 0x1
	DUMPBITS(3)
33d1c47c:	e2833004 	add	r3, r3, #4	; 0x4
33d1c480:	e1520003 	cmp	r2, r3
33d1c484:	e1a0a1aa 	lsr	sl, sl, #3
33d1c488:	e2477003 	sub	r7, r7, #3	; 0x3
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
	NEEDBITS(3)
	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
33d1c48c:	e5852008 	str	r2, [r5, #8]
33d1c490:	eaffffe1 	b	33d1c41c <inflate+0x8f4>
	DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
33d1c494:	e595c008 	ldr	ip, [r5, #8]
33d1c498:	e35c0012 	cmp	ip, #18	; 0x12
33d1c49c:	8a000009 	bhi	33d1c4c8 <inflate+0x9a0>
33d1c4a0:	e59f3708 	ldr	r3, [pc, #1800]	; 33d1cbb0 <inflate+0x1088>
33d1c4a4:	e28c0001 	add	r0, ip, #1	; 0x1
33d1c4a8:	e793110c 	ldr	r1, [r3, ip, lsl #2]
33d1c4ac:	e595200c 	ldr	r2, [r5, #12]
33d1c4b0:	e3a03000 	mov	r3, #0	; 0x0
33d1c4b4:	e1a0c000 	mov	ip, r0
33d1c4b8:	e3500012 	cmp	r0, #18	; 0x12
33d1c4bc:	e7823101 	str	r3, [r2, r1, lsl #2]
33d1c4c0:	e5850008 	str	r0, [r5, #8]
33d1c4c4:	eafffff4 	b	33d1c49c <inflate+0x974>
inflate_huft * FAR *tb; /* bits tree result */
z_stream *z;            /* for zfree function */
{
  int r;

  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
33d1c4c8:	e3a04000 	mov	r4, #0	; 0x0
33d1c4cc:	e3a01013 	mov	r1, #19	; 0x13
	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
	DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
33d1c4d0:	e3a03007 	mov	r3, #7	; 0x7
33d1c4d4:	e5853010 	str	r3, [r5, #16]
local int inflate_trees_bits(c, bb, tb, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
z_stream *z;            /* for zfree function */
{
33d1c4d8:	e595000c 	ldr	r0, [r5, #12]
  int r;

  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
33d1c4dc:	e1a03004 	mov	r3, r4
local int inflate_trees_bits(c, bb, tb, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
z_stream *z;            /* for zfree function */
{
33d1c4e0:	e285e010 	add	lr, r5, #16	; 0x10
33d1c4e4:	e285c014 	add	ip, r5, #20	; 0x14
  int r;

  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
33d1c4e8:	e1a02001 	mov	r2, r1
33d1c4ec:	e88d5010 	stm	sp, {r4, ip, lr}
33d1c4f0:	e58d600c 	str	r6, [sp, #12]
33d1c4f4:	ebfffc02 	bl	33d1b504 <huft_build>
  if (r == Z_DATA_ERROR)
33d1c4f8:	e3700003 	cmn	r0, #3	; 0x3
    z->msg = "oversubscribed dynamic bit lengths tree";
33d1c4fc:	059f36b0 	ldreq	r3, [pc, #1712]	; 33d1cbb4 <inflate+0x108c>
33d1c500:	05863018 	streq	r3, [r6, #24]
z_stream *z;            /* for zfree function */
{
  int r;

  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
  if (r == Z_DATA_ERROR)
33d1c504:	0a000007 	beq	33d1c528 <inflate+0xa00>
    z->msg = "oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR)
33d1c508:	e3700005 	cmn	r0, #5	; 0x5
33d1c50c:	1a000005 	bne	33d1c528 <inflate+0xa00>
  {
    inflate_trees_free(*tb, z);
33d1c510:	e5950014 	ldr	r0, [r5, #20]
33d1c514:	e1a01006 	mov	r1, r6
33d1c518:	ebfffa17 	bl	33d1ad7c <inflate_trees_free>
    z->msg = "incomplete dynamic bit lengths tree";
33d1c51c:	e59f3694 	ldr	r3, [pc, #1684]	; 33d1cbb8 <inflate+0x1090>
33d1c520:	e5863018 	str	r3, [r6, #24]
    r = Z_DATA_ERROR;
33d1c524:	e3e00002 	mvn	r0, #2	; 0x2
      while (s->sub.trees.index < 19)
	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
			     &s->sub.trees.tb, z);
      if (t != Z_OK)
33d1c528:	e2504000 	subs	r4, r0, #0	; 0x0
33d1c52c:	0a000010 	beq	33d1c574 <inflate+0xa4c>
      {
	r = t;
	if (r == Z_DATA_ERROR)
33d1c530:	e3740003 	cmn	r4, #3	; 0x3
	  s->mode = BADB;
33d1c534:	03a03009 	moveq	r3, #9	; 0x9
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
			     &s->sub.trees.tb, z);
      if (t != Z_OK)
      {
	r = t;
33d1c538:	e58d4054 	str	r4, [sp, #84]
	if (r == Z_DATA_ERROR)
	  s->mode = BADB;
33d1c53c:	05853000 	streq	r3, [r5]
	LEAVE
33d1c540:	e585a024 	str	sl, [r5, #36]
33d1c544:	e5857020 	str	r7, [r5, #32]
33d1c548:	e5963000 	ldr	r3, [r6]
33d1c54c:	e5962008 	ldr	r2, [r6, #8]
33d1c550:	e59db050 	ldr	fp, [sp, #80]
33d1c554:	e0633009 	rsb	r3, r3, r9
33d1c558:	e0822003 	add	r2, r2, r3
33d1c55c:	e586b004 	str	fp, [r6, #4]
33d1c560:	e5862008 	str	r2, [r6, #8]
33d1c564:	e5869000 	str	r9, [r6]
33d1c568:	e59dc04c 	ldr	ip, [sp, #76]
33d1c56c:	e585c034 	str	ip, [r5, #52]
33d1c570:	eafffde0 	b	33d1bcf8 <inflate+0x1d0>
      }
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
33d1c574:	e3a03005 	mov	r3, #5	; 0x5
	r = t;
	if (r == Z_DATA_ERROR)
	  s->mode = BADB;
	LEAVE
      }
      s->sub.trees.index = 0;
33d1c578:	e5854008 	str	r4, [r5, #8]
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
33d1c57c:	e5853000 	str	r3, [r5]
	  }
	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
	  do {
	    s->sub.trees.blens[i++] = c;
	  } while (--j);
	  s->sub.trees.index = i;
33d1c580:	e5954004 	ldr	r4, [r5, #4]
33d1c584:	e1a03b04 	lsl	r3, r4, #22
33d1c588:	e204201f 	and	r2, r4, #31	; 0x1f
33d1c58c:	e0822da3 	add	r2, r2, r3, lsr #27
33d1c590:	e2822c01 	add	r2, r2, #256	; 0x100
33d1c594:	e5953008 	ldr	r3, [r5, #8]
33d1c598:	e2822002 	add	r2, r2, #2	; 0x2
33d1c59c:	e1530002 	cmp	r3, r2
33d1c5a0:	2a000067 	bcs	33d1c744 <inflate+0xc1c>
	     s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
	inflate_huft *h;
	uInt i, j, c;

	t = s->sub.trees.bb;
33d1c5a4:	e5954010 	ldr	r4, [r5, #16]
	NEEDBITS(t)
33d1c5a8:	e1570004 	cmp	r7, r4
33d1c5ac:	2a00000b 	bcs	33d1c5e0 <inflate+0xab8>
33d1c5b0:	e59d0050 	ldr	r0, [sp, #80]
33d1c5b4:	e3500000 	cmp	r0, #0	; 0x0
33d1c5b8:	0afffe05 	beq	33d1bdd4 <inflate+0x2ac>
33d1c5bc:	e4d93001 	ldrb	r3, [r9], #1
33d1c5c0:	e18aa713 	orr	sl, sl, r3, lsl r7
33d1c5c4:	e2877008 	add	r7, r7, #8	; 0x8
33d1c5c8:	e2400001 	sub	r0, r0, #1	; 0x1
33d1c5cc:	e3a01000 	mov	r1, #0	; 0x0
33d1c5d0:	e1570004 	cmp	r7, r4
33d1c5d4:	e58d0050 	str	r0, [sp, #80]
33d1c5d8:	e58d1054 	str	r1, [sp, #84]
33d1c5dc:	eafffff2 	b	33d1c5ac <inflate+0xa84>
	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
33d1c5e0:	e59f15ec 	ldr	r1, [pc, #1516]	; 33d1cbd4 <inflate+0x10ac>
33d1c5e4:	e7913104 	ldr	r3, [r1, r4, lsl #2]
33d1c5e8:	e5952014 	ldr	r2, [r5, #20]
33d1c5ec:	e00a3003 	and	r3, sl, r3
33d1c5f0:	e0822183 	add	r2, r2, r3, lsl #3
	t = h->word.what.Bits;
	c = h->more.Base;
33d1c5f4:	e5920004 	ldr	r0, [r2, #4]
	if (c < 16)
33d1c5f8:	e350000f 	cmp	r0, #15	; 0xf
	uInt i, j, c;

	t = s->sub.trees.bb;
	NEEDBITS(t)
	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
	t = h->word.what.Bits;
33d1c5fc:	e5d24001 	ldrb	r4, [r2, #1]
	c = h->more.Base;
	if (c < 16)
33d1c600:	8a000007 	bhi	33d1c624 <inflate+0xafc>
	{
	  DUMPBITS(t)
	  s->sub.trees.blens[s->sub.trees.index++] = c;
33d1c604:	e2852008 	add	r2, r5, #8	; 0x8
33d1c608:	e892000c 	ldm	r2, {r2, r3}
	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
	t = h->word.what.Bits;
	c = h->more.Base;
	if (c < 16)
	{
	  DUMPBITS(t)
33d1c60c:	e0647007 	rsb	r7, r4, r7
	  s->sub.trees.blens[s->sub.trees.index++] = c;
33d1c610:	e7830102 	str	r0, [r3, r2, lsl #2]
	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
	t = h->word.what.Bits;
	c = h->more.Base;
	if (c < 16)
	{
	  DUMPBITS(t)
33d1c614:	e1a0a43a 	lsr	sl, sl, r4
	  s->sub.trees.blens[s->sub.trees.index++] = c;
33d1c618:	e2822001 	add	r2, r2, #1	; 0x1
33d1c61c:	e5852008 	str	r2, [r5, #8]
33d1c620:	eaffffd6 	b	33d1c580 <inflate+0xa58>
	}
	else /* c == 16..18 */
	{
	  i = c == 18 ? 7 : c - 14;
33d1c624:	e3500012 	cmp	r0, #18	; 0x12
33d1c628:	03a0c007 	moveq	ip, #7	; 0x7
33d1c62c:	1240c00e 	subne	ip, r0, #14	; 0xe
	  j = c == 18 ? 11 : 3;
	  NEEDBITS(t + i)
33d1c630:	e084200c 	add	r2, r4, ip
	  s->sub.trees.blens[s->sub.trees.index++] = c;
	}
	else /* c == 16..18 */
	{
	  i = c == 18 ? 7 : c - 14;
	  j = c == 18 ? 11 : 3;
33d1c634:	03a0e00b 	moveq	lr, #11	; 0xb
33d1c638:	13a0e003 	movne	lr, #3	; 0x3
	  NEEDBITS(t + i)
33d1c63c:	e1570002 	cmp	r7, r2
33d1c640:	2a00000c 	bcs	33d1c678 <inflate+0xb50>
33d1c644:	e59d3050 	ldr	r3, [sp, #80]
33d1c648:	e3530000 	cmp	r3, #0	; 0x0
33d1c64c:	0afffdbe 	beq	33d1bd4c <inflate+0x224>
33d1c650:	e4d93001 	ldrb	r3, [r9], #1
33d1c654:	e59db050 	ldr	fp, [sp, #80]
33d1c658:	e18aa713 	orr	sl, sl, r3, lsl r7
33d1c65c:	e2877008 	add	r7, r7, #8	; 0x8
33d1c660:	e24bb001 	sub	fp, fp, #1	; 0x1
33d1c664:	e3a03000 	mov	r3, #0	; 0x0
33d1c668:	e1570002 	cmp	r7, r2
33d1c66c:	e58db050 	str	fp, [sp, #80]
33d1c670:	e58d3054 	str	r3, [sp, #84]
33d1c674:	eafffff1 	b	33d1c640 <inflate+0xb18>
	  DUMPBITS(t)
33d1c678:	e1a0a43a 	lsr	sl, sl, r4
33d1c67c:	e0647007 	rsb	r7, r4, r7
	  j += (uInt)b & inflate_mask[i];
	  DUMPBITS(i)
	  i = s->sub.trees.index;
	  t = s->sub.trees.table;
33d1c680:	e5954004 	ldr	r4, [r5, #4]
	{
	  i = c == 18 ? 7 : c - 14;
	  j = c == 18 ? 11 : 3;
	  NEEDBITS(t + i)
	  DUMPBITS(t)
	  j += (uInt)b & inflate_mask[i];
33d1c684:	e791210c 	ldr	r2, [r1, ip, lsl #2]
	  DUMPBITS(i)
	  i = s->sub.trees.index;
	  t = s->sub.trees.table;
	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
33d1c688:	e204301f 	and	r3, r4, #31	; 0x1f
33d1c68c:	e1a01b04 	lsl	r1, r4, #22
	{
	  i = c == 18 ? 7 : c - 14;
	  j = c == 18 ? 11 : 3;
	  NEEDBITS(t + i)
	  DUMPBITS(t)
	  j += (uInt)b & inflate_mask[i];
33d1c690:	e00a2002 	and	r2, sl, r2
	  DUMPBITS(i)
33d1c694:	e06c7007 	rsb	r7, ip, r7
	  i = s->sub.trees.index;
	  t = s->sub.trees.table;
	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
33d1c698:	e0833da1 	add	r3, r3, r1, lsr #27
	  i = c == 18 ? 7 : c - 14;
	  j = c == 18 ? 11 : 3;
	  NEEDBITS(t + i)
	  DUMPBITS(t)
	  j += (uInt)b & inflate_mask[i];
	  DUMPBITS(i)
33d1c69c:	e1a0ac3a 	lsr	sl, sl, ip
	  i = s->sub.trees.index;
33d1c6a0:	e595c008 	ldr	ip, [r5, #8]
	{
	  i = c == 18 ? 7 : c - 14;
	  j = c == 18 ? 11 : 3;
	  NEEDBITS(t + i)
	  DUMPBITS(t)
	  j += (uInt)b & inflate_mask[i];
33d1c6a4:	e08ee002 	add	lr, lr, r2
	  DUMPBITS(i)
	  i = s->sub.trees.index;
	  t = s->sub.trees.table;
	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
33d1c6a8:	e2833c01 	add	r3, r3, #256	; 0x100
33d1c6ac:	e2833002 	add	r3, r3, #2	; 0x2
33d1c6b0:	e08c200e 	add	r2, ip, lr
33d1c6b4:	e1520003 	cmp	r2, r3
33d1c6b8:	8a000004 	bhi	33d1c6d0 <inflate+0xba8>
33d1c6bc:	e3500010 	cmp	r0, #16	; 0x10
33d1c6c0:	035c0000 	cmpeq	ip, #0	; 0x0
33d1c6c4:	13a03000 	movne	r3, #0	; 0x0
33d1c6c8:	03a03001 	moveq	r3, #1	; 0x1
33d1c6cc:	1a000010 	bne	33d1c714 <inflate+0xbec>
	      (c == 16 && i < 1))
	  {
	    s->mode = BADB;
33d1c6d0:	e3a03009 	mov	r3, #9	; 0x9
33d1c6d4:	e5853000 	str	r3, [r5]
	    z->msg = "invalid bit length repeat";
33d1c6d8:	e59f34dc 	ldr	r3, [pc, #1244]	; 33d1cbbc <inflate+0x1094>
33d1c6dc:	e5863018 	str	r3, [r6, #24]
	    r = Z_DATA_ERROR;
	    LEAVE
33d1c6e0:	e585a024 	str	sl, [r5, #36]
33d1c6e4:	e5857020 	str	r7, [r5, #32]
33d1c6e8:	e5963000 	ldr	r3, [r6]
33d1c6ec:	e5962008 	ldr	r2, [r6, #8]
33d1c6f0:	e59db050 	ldr	fp, [sp, #80]
33d1c6f4:	e0633009 	rsb	r3, r3, r9
33d1c6f8:	e0822003 	add	r2, r2, r3
33d1c6fc:	e586b004 	str	fp, [r6, #4]
33d1c700:	e5862008 	str	r2, [r6, #8]
33d1c704:	e5869000 	str	r9, [r6]
33d1c708:	e59dc04c 	ldr	ip, [sp, #76]
33d1c70c:	e585c034 	str	ip, [r5, #52]
33d1c710:	eafffe8e 	b	33d1c150 <inflate+0x628>
	  }
	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
33d1c714:	e3500010 	cmp	r0, #16	; 0x10
33d1c718:	0595300c 	ldreq	r3, [r5, #12]
33d1c71c:	0083310c 	addeq	r3, r3, ip, lsl #2
33d1c720:	05132004 	ldreq	r2, [r3, #-4]
33d1c724:	11a02003 	movne	r2, r3
	  do {
	    s->sub.trees.blens[i++] = c;
33d1c728:	e595300c 	ldr	r3, [r5, #12]
	  } while (--j);
33d1c72c:	e25ee001 	subs	lr, lr, #1	; 0x1
	    r = Z_DATA_ERROR;
	    LEAVE
	  }
	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
	  do {
	    s->sub.trees.blens[i++] = c;
33d1c730:	e783210c 	str	r2, [r3, ip, lsl #2]
33d1c734:	e28cc001 	add	ip, ip, #1	; 0x1
	  } while (--j);
33d1c738:	1afffffa 	bne	33d1c728 <inflate+0xc00>
	  s->sub.trees.index = i;
33d1c73c:	e585c008 	str	ip, [r5, #8]
33d1c740:	eaffff8e 	b	33d1c580 <inflate+0xa58>
	}
      }
      inflate_trees_free(s->sub.trees.tb, z);
33d1c744:	e1a01006 	mov	r1, r6
33d1c748:	e5950014 	ldr	r0, [r5, #20]
33d1c74c:	ebfff98a 	bl	33d1ad7c <inflate_trees_free>
      s->sub.trees.tb = Z_NULL;
33d1c750:	e3a03000 	mov	r3, #0	; 0x0
33d1c754:	e5853014 	str	r3, [r5, #20]
      {
	uInt bl, bd;
	inflate_huft *tl, *td;
	inflate_codes_statef *c;

	bl = 9;         /* must be <= 9 for lookahead assumptions */
33d1c758:	e2833009 	add	r3, r3, #9	; 0x9
33d1c75c:	e58d3068 	str	r3, [sp, #104]
	bd = 6;         /* must be <= 9 for lookahead assumptions */
33d1c760:	e2433003 	sub	r3, r3, #3	; 0x3
33d1c764:	e58d3064 	str	r3, [sp, #100]
	t = s->sub.trees.table;
33d1c768:	e5954004 	ldr	r4, [r5, #4]
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_stream *z;            /* for zfree function */
{
33d1c76c:	e204301f 	and	r3, r4, #31	; 0x1f
33d1c770:	e283bc01 	add	fp, r3, #256	; 0x100
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
33d1c774:	e59fc410 	ldr	ip, [pc, #1040]	; 33d1cb8c <inflate+0x1064>
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_stream *z;            /* for zfree function */
{
33d1c778:	e1a042a4 	lsr	r4, r4, #5
33d1c77c:	e595000c 	ldr	r0, [r5, #12]
33d1c780:	e28bb001 	add	fp, fp, #1	; 0x1
33d1c784:	e28de070 	add	lr, sp, #112	; 0x70
33d1c788:	e204401f 	and	r4, r4, #31	; 0x1f
33d1c78c:	e24ee008 	sub	lr, lr, #8	; 0x8
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
33d1c790:	e58dc000 	str	ip, [sp]
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_stream *z;            /* for zfree function */
{
33d1c794:	e2844001 	add	r4, r4, #1	; 0x1
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
33d1c798:	e28dc060 	add	ip, sp, #96	; 0x60
33d1c79c:	e1a0100b 	mov	r1, fp
33d1c7a0:	e59f2420 	ldr	r2, [pc, #1056]	; 33d1cbc8 <inflate+0x10a0>
33d1c7a4:	e59f33e8 	ldr	r3, [pc, #1000]	; 33d1cb94 <inflate+0x106c>
33d1c7a8:	e58de008 	str	lr, [sp, #8]
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_stream *z;            /* for zfree function */
{
33d1c7ac:	e58d403c 	str	r4, [sp, #60]
33d1c7b0:	e58d0038 	str	r0, [sp, #56]
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
33d1c7b4:	e58dc004 	str	ip, [sp, #4]
33d1c7b8:	e58d600c 	str	r6, [sp, #12]
33d1c7bc:	ebfffb50 	bl	33d1b504 <huft_build>
33d1c7c0:	e2504000 	subs	r4, r0, #0	; 0x0
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_stream *z;            /* for zfree function */
{
33d1c7c4:	e28d0070 	add	r0, sp, #112	; 0x70
33d1c7c8:	e28de060 	add	lr, sp, #96	; 0x60
33d1c7cc:	e240000c 	sub	r0, r0, #12	; 0xc
33d1c7d0:	e58d0034 	str	r0, [sp, #52]
33d1c7d4:	e24ee004 	sub	lr, lr, #4	; 0x4
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
33d1c7d8:	0a00000c 	beq	33d1c810 <inflate+0xce8>
  {
    if (r == Z_DATA_ERROR)
33d1c7dc:	e3740003 	cmn	r4, #3	; 0x3
      z->msg = "oversubscribed literal/length tree";
33d1c7e0:	059f33d8 	ldreq	r3, [pc, #984]	; 33d1cbc0 <inflate+0x1098>
33d1c7e4:	05863018 	streq	r3, [r6, #24]
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
  {
    if (r == Z_DATA_ERROR)
33d1c7e8:	0a000024 	beq	33d1c880 <inflate+0xd58>
      z->msg = "oversubscribed literal/length tree";
    else if (r == Z_BUF_ERROR)
33d1c7ec:	e3740005 	cmn	r4, #5	; 0x5
33d1c7f0:	1a000022 	bne	33d1c880 <inflate+0xd58>
    {
      inflate_trees_free(*tl, z);
33d1c7f4:	e59d0060 	ldr	r0, [sp, #96]
33d1c7f8:	e1a01006 	mov	r1, r6
33d1c7fc:	ebfff95e 	bl	33d1ad7c <inflate_trees_free>
      z->msg = "incomplete literal/length tree";
33d1c800:	e59f33bc 	ldr	r3, [pc, #956]	; 33d1cbc4 <inflate+0x109c>
      r = Z_DATA_ERROR;
33d1c804:	e2844002 	add	r4, r4, #2	; 0x2
    if (r == Z_DATA_ERROR)
      z->msg = "oversubscribed literal/length tree";
    else if (r == Z_BUF_ERROR)
    {
      inflate_trees_free(*tl, z);
      z->msg = "incomplete literal/length tree";
33d1c808:	e5863018 	str	r3, [r6, #24]
33d1c80c:	ea00001b 	b	33d1c880 <inflate+0xd58>
    }
    return r;
  }

  /* build distance tree */
  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
33d1c810:	e59d1038 	ldr	r1, [sp, #56]
33d1c814:	e59fc380 	ldr	ip, [pc, #896]	; 33d1cb9c <inflate+0x1074>
33d1c818:	e081010b 	add	r0, r1, fp, lsl #2
33d1c81c:	e59db034 	ldr	fp, [sp, #52]
33d1c820:	e1a02004 	mov	r2, r4
33d1c824:	e59d103c 	ldr	r1, [sp, #60]
33d1c828:	e59f3374 	ldr	r3, [pc, #884]	; 33d1cba4 <inflate+0x107c>
33d1c82c:	e88d5000 	stm	sp, {ip, lr}
33d1c830:	e58db008 	str	fp, [sp, #8]
33d1c834:	e58d600c 	str	r6, [sp, #12]
33d1c838:	ebfffb31 	bl	33d1b504 <huft_build>
33d1c83c:	e2504000 	subs	r4, r0, #0	; 0x0
33d1c840:	0a00000e 	beq	33d1c880 <inflate+0xd58>
  {
    if (r == Z_DATA_ERROR)
33d1c844:	e3740003 	cmn	r4, #3	; 0x3
      z->msg = "oversubscribed literal/length tree";
33d1c848:	059f3370 	ldreq	r3, [pc, #880]	; 33d1cbc0 <inflate+0x1098>
33d1c84c:	05863018 	streq	r3, [r6, #24]
  }

  /* build distance tree */
  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
  {
    if (r == Z_DATA_ERROR)
33d1c850:	0a000007 	beq	33d1c874 <inflate+0xd4c>
      z->msg = "oversubscribed literal/length tree";
    else if (r == Z_BUF_ERROR) {
33d1c854:	e3740005 	cmn	r4, #5	; 0x5
33d1c858:	1a000005 	bne	33d1c874 <inflate+0xd4c>
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      inflate_trees_free(*td, z);
33d1c85c:	e59d005c 	ldr	r0, [sp, #92]
33d1c860:	e1a01006 	mov	r1, r6
33d1c864:	ebfff944 	bl	33d1ad7c <inflate_trees_free>
      z->msg = "incomplete literal/length tree";
33d1c868:	e59f3354 	ldr	r3, [pc, #852]	; 33d1cbc4 <inflate+0x109c>
33d1c86c:	e5863018 	str	r3, [r6, #24]
      r = Z_DATA_ERROR;
33d1c870:	e2844002 	add	r4, r4, #2	; 0x2
    }
    inflate_trees_free(*tl, z);
33d1c874:	e59d0060 	ldr	r0, [sp, #96]
33d1c878:	e1a01006 	mov	r1, r6
33d1c87c:	ebfff93e 	bl	33d1ad7c <inflate_trees_free>
	bl = 9;         /* must be <= 9 for lookahead assumptions */
	bd = 6;         /* must be <= 9 for lookahead assumptions */
	t = s->sub.trees.table;
	t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
				  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
	if (t != Z_OK)
33d1c880:	e3540000 	cmp	r4, #0	; 0x0
33d1c884:	0a000010 	beq	33d1c8cc <inflate+0xda4>
	{
	  if (t == (uInt)Z_DATA_ERROR)
33d1c888:	e3740003 	cmn	r4, #3	; 0x3
	    s->mode = BADB;
33d1c88c:	03a03009 	moveq	r3, #9	; 0x9
33d1c890:	05853000 	streq	r3, [r5]
	  r = t;
	  LEAVE
33d1c894:	e585a024 	str	sl, [r5, #36]
33d1c898:	e5857020 	str	r7, [r5, #32]
33d1c89c:	e5963000 	ldr	r3, [r6]
33d1c8a0:	e5962008 	ldr	r2, [r6, #8]
33d1c8a4:	e59dc050 	ldr	ip, [sp, #80]
33d1c8a8:	e0633009 	rsb	r3, r3, r9
33d1c8ac:	e0822003 	add	r2, r2, r3
33d1c8b0:	e5862008 	str	r2, [r6, #8]
33d1c8b4:	e8861200 	stm	r6, {r9, ip}
33d1c8b8:	e59d004c 	ldr	r0, [sp, #76]
33d1c8bc:	e1a02004 	mov	r2, r4
33d1c8c0:	e5850034 	str	r0, [r5, #52]
33d1c8c4:	e1a00005 	mov	r0, r5
33d1c8c8:	eafffd0c 	b	33d1bd00 <inflate+0x1d8>
	}
	Tracev((stderr, "inflate:       trees ok\n"));
	if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
33d1c8cc:	e59d0068 	ldr	r0, [sp, #104]
33d1c8d0:	e59d1064 	ldr	r1, [sp, #100]
33d1c8d4:	e59d2060 	ldr	r2, [sp, #96]
33d1c8d8:	e59d305c 	ldr	r3, [sp, #92]
33d1c8dc:	e58d6000 	str	r6, [sp]
33d1c8e0:	ebfffa48 	bl	33d1b208 <inflate_codes_new>
33d1c8e4:	e2504000 	subs	r4, r0, #0	; 0x0
33d1c8e8:	0afffd24 	beq	33d1bd80 <inflate+0x258>
	  inflate_trees_free(td, z);
	  inflate_trees_free(tl, z);
	  r = Z_MEM_ERROR;
	  LEAVE
	}
	ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
33d1c8ec:	e5952018 	ldr	r2, [r5, #24]
33d1c8f0:	e5960028 	ldr	r0, [r6, #40]
33d1c8f4:	e1a02102 	lsl	r2, r2, #2
33d1c8f8:	e595100c 	ldr	r1, [r5, #12]
33d1c8fc:	e1a0e00f 	mov	lr, pc
33d1c900:	e596f024 	ldr	pc, [r6, #36]
	s->sub.decode.codes = c;
33d1c904:	e585400c 	str	r4, [r5, #12]
	s->sub.decode.tl = tl;
33d1c908:	e59d3060 	ldr	r3, [sp, #96]
33d1c90c:	e5853004 	str	r3, [r5, #4]
	s->sub.decode.td = td;
33d1c910:	e59d305c 	ldr	r3, [sp, #92]
33d1c914:	e5853008 	str	r3, [r5, #8]
      }
      s->mode = CODES;
33d1c918:	e3a03006 	mov	r3, #6	; 0x6
33d1c91c:	e5853000 	str	r3, [r5]
    case CODES:
      UPDATE
33d1c920:	e585a024 	str	sl, [r5, #36]
33d1c924:	e5857020 	str	r7, [r5, #32]
33d1c928:	e5963000 	ldr	r3, [r6]
33d1c92c:	e5962008 	ldr	r2, [r6, #8]
33d1c930:	e59d1050 	ldr	r1, [sp, #80]
33d1c934:	e0633009 	rsb	r3, r3, r9
33d1c938:	e0822003 	add	r2, r2, r3
33d1c93c:	e5869000 	str	r9, [r6]
33d1c940:	e9860006 	stmib	r6, {r1, r2}
33d1c944:	e59d204c 	ldr	r2, [sp, #76]
33d1c948:	e5852034 	str	r2, [r5, #52]

local int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1c94c:	e59db054 	ldr	fp, [sp, #84]
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1c950:	e5953030 	ldr	r3, [r5, #48]

local int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1c954:	e58db030 	str	fp, [sp, #48]
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1c958:	e596c004 	ldr	ip, [r6, #4]
33d1c95c:	e1520003 	cmp	r2, r3
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
33d1c960:	e595a00c 	ldr	sl, [r5, #12]

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1c964:	e596b000 	ldr	fp, [r6]
33d1c968:	e58dc02c 	str	ip, [sp, #44]
33d1c96c:	30623003 	rsbcc	r3, r2, r3
33d1c970:	e2854020 	add	r4, r5, #32	; 0x20
33d1c974:	e8940090 	ldm	r4, {r4, r7}
33d1c978:	e59de04c 	ldr	lr, [sp, #76]
33d1c97c:	32439001 	subcc	r9, r3, #1	; 0x1
33d1c980:	3a00002d 	bcc	33d1ca3c <inflate+0xf14>
33d1c984:	ea000029 	b	33d1ca30 <inflate+0xf08>
      z->msg = "invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
33d1c988:	e5857024 	str	r7, [r5, #36]
33d1c98c:	e5854020 	str	r4, [r5, #32]
33d1c990:	e59d102c 	ldr	r1, [sp, #44]
33d1c994:	e5963000 	ldr	r3, [r6]
33d1c998:	e5962008 	ldr	r2, [r6, #8]
33d1c99c:	e063300b 	rsb	r3, r3, fp
33d1c9a0:	e5861004 	str	r1, [r6, #4]
33d1c9a4:	e0822003 	add	r2, r2, r3
33d1c9a8:	e5862008 	str	r2, [r6, #8]
33d1c9ac:	e586b000 	str	fp, [r6]
33d1c9b0:	e585e034 	str	lr, [r5, #52]
33d1c9b4:	e59d2030 	ldr	r2, [sp, #48]
33d1c9b8:	e1a00005 	mov	r0, r5
33d1c9bc:	e1a01006 	mov	r1, r6
33d1c9c0:	ea000291 	b	33d1d40c <inflate+0x18e4>
      z->msg = "invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
33d1c9c4:	e5857024 	str	r7, [r5, #36]
33d1c9c8:	e5854020 	str	r4, [r5, #32]
33d1c9cc:	e5963000 	ldr	r3, [r6]
33d1c9d0:	e5962008 	ldr	r2, [r6, #8]
33d1c9d4:	e063300b 	rsb	r3, r3, fp
33d1c9d8:	e59dc02c 	ldr	ip, [sp, #44]
33d1c9dc:	e0822003 	add	r2, r2, r3
33d1c9e0:	e586c004 	str	ip, [r6, #4]
33d1c9e4:	eaffffef 	b	33d1c9a8 <inflate+0xe80>
      if ((uInt)(q - s->window) < c->sub.copy.dist)
	f = s->end - (c->sub.copy.dist - (q - s->window));
#endif
      while (c->len)
      {
	NEEDOUT
33d1c9e8:	e5857024 	str	r7, [r5, #36]
33d1c9ec:	e5854020 	str	r4, [r5, #32]
33d1c9f0:	e5963000 	ldr	r3, [r6]
33d1c9f4:	e5962008 	ldr	r2, [r6, #8]
33d1c9f8:	e063300b 	rsb	r3, r3, fp
33d1c9fc:	e59d002c 	ldr	r0, [sp, #44]
33d1ca00:	e0822003 	add	r2, r2, r3
33d1ca04:	e5860004 	str	r0, [r6, #4]
33d1ca08:	eaffffe6 	b	33d1c9a8 <inflate+0xe80>
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      FLUSH
      if (s->read != s->write)
	LEAVE
33d1ca0c:	e5857024 	str	r7, [r5, #36]
33d1ca10:	e5854020 	str	r4, [r5, #32]
33d1ca14:	e5963000 	ldr	r3, [r6]
33d1ca18:	e5962008 	ldr	r2, [r6, #8]
33d1ca1c:	e063300b 	rsb	r3, r3, fp
33d1ca20:	e0822003 	add	r2, r2, r3
33d1ca24:	e59d302c 	ldr	r3, [sp, #44]
33d1ca28:	e5863004 	str	r3, [r6, #4]
33d1ca2c:	eaffffdd 	b	33d1c9a8 <inflate+0xe80>
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
33d1ca30:	e595302c 	ldr	r3, [r5, #44]
33d1ca34:	e59dc04c 	ldr	ip, [sp, #76]
33d1ca38:	e06c9003 	rsb	r9, ip, r3

  /* process input and output based on current state */
  while (1) switch (c->mode)
33d1ca3c:	e59a3000 	ldr	r3, [sl]
33d1ca40:	e3530009 	cmp	r3, #9	; 0x9
33d1ca44:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
33d1ca48:	ea000262 	b	33d1d3d8 <inflate+0x18b0>
33d1ca4c:	33d1ca74 	.word	0x33d1ca74
33d1ca50:	33d1cec4 	.word	0x33d1cec4
33d1ca54:	33d1cfac 	.word	0x33d1cfac
33d1ca58:	33d1d020 	.word	0x33d1d020
33d1ca5c:	33d1d10c 	.word	0x33d1d10c
33d1ca60:	33d1d170 	.word	0x33d1d170
33d1ca64:	33d1d288 	.word	0x33d1d288
33d1ca68:	33d1d34c 	.word	0x33d1d34c
33d1ca6c:	33d1d37c 	.word	0x33d1d37c
33d1ca70:	33d1d3b4 	.word	0x33d1d3b4
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
33d1ca74:	e59f314c 	ldr	r3, [pc, #332]	; 33d1cbc8 <inflate+0x10a0>
33d1ca78:	e59d002c 	ldr	r0, [sp, #44]
33d1ca7c:	e1590003 	cmp	r9, r3
33d1ca80:	83500009 	cmphi	r0, #9	; 0x9
33d1ca84:	9a000108 	bls	33d1ceac <inflate+0x1384>
      {
	UPDATE
33d1ca88:	e5854020 	str	r4, [r5, #32]
33d1ca8c:	e5857024 	str	r7, [r5, #36]
33d1ca90:	e5963000 	ldr	r3, [r6]
33d1ca94:	e5962008 	ldr	r2, [r6, #8]
33d1ca98:	e063300b 	rsb	r3, r3, fp
33d1ca9c:	e0822003 	add	r2, r2, r3
33d1caa0:	e5860004 	str	r0, [r6, #4]
33d1caa4:	e586b000 	str	fp, [r6]
33d1caa8:	e5862008 	str	r2, [r6, #8]
33d1caac:	e585e034 	str	lr, [r5, #52]
local int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl, *td;
inflate_blocks_statef *s;
z_stream *z;
{
33d1cab0:	e59ab014 	ldr	fp, [sl, #20]
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD
33d1cab4:	e5953030 	ldr	r3, [r5, #48]
local int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl, *td;
inflate_blocks_statef *s;
z_stream *z;
{
33d1cab8:	e5da1010 	ldrb	r1, [sl, #16]
33d1cabc:	e5da2011 	ldrb	r2, [sl, #17]
33d1cac0:	e58db028 	str	fp, [sp, #40]
33d1cac4:	e59ac018 	ldr	ip, [sl, #24]
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD
33d1cac8:	e15e0003 	cmp	lr, r3
local int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl, *td;
inflate_blocks_statef *s;
z_stream *z;
{
33d1cacc:	e58dc024 	str	ip, [sp, #36]
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD
33d1cad0:	306e3003 	rsbcc	r3, lr, r3
33d1cad4:	e8960280 	ldm	r6, {r7, r9}
33d1cad8:	e5954024 	ldr	r4, [r5, #36]
33d1cadc:	e595c020 	ldr	ip, [r5, #32]
33d1cae0:	e1a0b00e 	mov	fp, lr
33d1cae4:	32433001 	subcc	r3, r3, #1	; 0x1
33d1cae8:	3a00000d 	bcc	33d1cb24 <inflate+0xffc>
33d1caec:	ea00000a 	b	33d1cb1c <inflate+0xff4>
      }
      else if (e & 32)
      {
	Tracevv((stderr, "inflate:         * end of block\n"));
	UNGRAB
	UPDATE
33d1caf0:	e5851020 	str	r1, [r5, #32]
33d1caf4:	e5854024 	str	r4, [r5, #36]
33d1caf8:	e5963000 	ldr	r3, [r6]
	}
      }
      else if (e & 32)
      {
	Tracevv((stderr, "inflate:         * end of block\n"));
	UNGRAB
33d1cafc:	e1a0e002 	mov	lr, r2
33d1cb00:	e0627007 	rsb	r7, r2, r7
	UPDATE
33d1cb04:	e5962008 	ldr	r2, [r6, #8]
33d1cb08:	e0633007 	rsb	r3, r3, r7
33d1cb0c:	e0822003 	add	r2, r2, r3
	}
      }
      else if (e & 32)
      {
	Tracevv((stderr, "inflate:         * end of block\n"));
	UNGRAB
33d1cb10:	e089900e 	add	r9, r9, lr
	UPDATE
33d1cb14:	e3a01001 	mov	r1, #1	; 0x1
33d1cb18:	ea0000cc 	b	33d1ce50 <inflate+0x1328>
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD
33d1cb1c:	e595302c 	ldr	r3, [r5, #44]
33d1cb20:	e06e3003 	rsb	r3, lr, r3
33d1cb24:	e58d3020 	str	r3, [sp, #32]

  /* initialize masks */
  ml = inflate_mask[bl];
33d1cb28:	e59f30a4 	ldr	r3, [pc, #164]	; 33d1cbd4 <inflate+0x10ac>
  md = inflate_mask[bd];
33d1cb2c:	e7932102 	ldr	r2, [r3, r2, lsl #2]

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
33d1cb30:	e7931101 	ldr	r1, [r3, r1, lsl #2]
  md = inflate_mask[bd];
33d1cb34:	e58d2018 	str	r2, [sp, #24]

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
33d1cb38:	e58d101c 	str	r1, [sp, #28]
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
33d1cb3c:	e35c0013 	cmp	ip, #19	; 0x13
33d1cb40:	8a000025 	bhi	33d1cbdc <inflate+0x10b4>
33d1cb44:	e4d73001 	ldrb	r3, [r7], #1
33d1cb48:	e1844c13 	orr	r4, r4, r3, lsl ip
33d1cb4c:	e28cc008 	add	ip, ip, #8	; 0x8
33d1cb50:	e35c0013 	cmp	ip, #19	; 0x13
33d1cb54:	e2499001 	sub	r9, r9, #1	; 0x1
33d1cb58:	eafffff8 	b	33d1cb40 <inflate+0x1018>
33d1cb5c:	33d2cf04 	.word	0x33d2cf04
33d1cb60:	33d2cf20 	.word	0x33d2cf20
33d1cb64:	33d2cf34 	.word	0x33d2cf34
33d1cb68:	33d2cf4c 	.word	0x33d2cf4c
33d1cb6c:	33d2cf64 	.word	0x33d2cf64
33d1cb70:	33d614b0 	.word	0x33d614b0
33d1cb74:	33d614ac 	.word	0x33d614ac
33d1cb78:	33d1bb00 	.word	0x33d1bb00
33d1cb7c:	33d1bb24 	.word	0x33d1bb24
33d1cb80:	00000117 	.word	0x00000117
33d1cb84:	0000011f 	.word	0x0000011f
33d1cb88:	33d62544 	.word	0x33d62544
33d1cb8c:	33d36820 	.word	0x33d36820
33d1cb90:	33d6254c 	.word	0x33d6254c
33d1cb94:	33d3689c 	.word	0x33d3689c
33d1cb98:	33d62548 	.word	0x33d62548
33d1cb9c:	33d36730 	.word	0x33d36730
33d1cba0:	33d62550 	.word	0x33d62550
33d1cba4:	33d367a8 	.word	0x33d367a8
33d1cba8:	33d2cf84 	.word	0x33d2cf84
33d1cbac:	33d2cf98 	.word	0x33d2cf98
33d1cbb0:	33d366e4 	.word	0x33d366e4
33d1cbb4:	33d2cfbc 	.word	0x33d2cfbc
33d1cbb8:	33d2cfe4 	.word	0x33d2cfe4
33d1cbbc:	33d2d008 	.word	0x33d2d008
33d1cbc0:	33d2d024 	.word	0x33d2d024
33d1cbc4:	33d2d048 	.word	0x33d2d048
33d1cbc8:	00000101 	.word	0x00000101
33d1cbcc:	33d2d068 	.word	0x33d2d068
33d1cbd0:	33d2d084 	.word	0x33d2d084
33d1cbd4:	33d366a0 	.word	0x33d366a0
33d1cbd8:	33d2d09c 	.word	0x33d2d09c
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
33d1cbdc:	e59d001c 	ldr	r0, [sp, #28]
33d1cbe0:	e59d1028 	ldr	r1, [sp, #40]
33d1cbe4:	e0043000 	and	r3, r4, r0
33d1cbe8:	e1a03183 	lsl	r3, r3, #3
33d1cbec:	e7d10003 	ldrb	r0, [r1, r3]
33d1cbf0:	e0812003 	add	r2, r1, r3
33d1cbf4:	e3500000 	cmp	r0, #0	; 0x0
33d1cbf8:	0a000069 	beq	33d1cda4 <inflate+0x127c>
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
33d1cbfc:	e5d23001 	ldrb	r3, [r2, #1]
      if (e & 16)
33d1cc00:	e3100010 	tst	r0, #16	; 0x10
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
33d1cc04:	e063c00c 	rsb	ip, r3, ip
33d1cc08:	e1a04334 	lsr	r4, r4, r3
      if (e & 16)
33d1cc0c:	0a000059 	beq	33d1cd78 <inflate+0x1250>
      {
	/* get extra bits for length */
	e &= 15;
	c = t->base + ((uInt)b & inflate_mask[e]);
33d1cc10:	e51f1044 	ldr	r1, [pc, #-68]	; 33d1cbd4 <inflate+0x10ac>
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
	/* get extra bits for length */
	e &= 15;
33d1cc14:	e200000f 	and	r0, r0, #15	; 0xf
	c = t->base + ((uInt)b & inflate_mask[e]);
33d1cc18:	e7913100 	ldr	r3, [r1, r0, lsl #2]
33d1cc1c:	e5922004 	ldr	r2, [r2, #4]
33d1cc20:	e0043003 	and	r3, r4, r3
	DUMPBITS(e)
33d1cc24:	e060c00c 	rsb	ip, r0, ip
	Tracevv((stderr, "inflate:         * length %u\n", c));

	/* decode distance base of block to copy */
	GRABBITS(15);           /* max bits for distance code */
33d1cc28:	e35c000e 	cmp	ip, #14	; 0xe
      DUMPBITS(t->bits)
      if (e & 16)
      {
	/* get extra bits for length */
	e &= 15;
	c = t->base + ((uInt)b & inflate_mask[e]);
33d1cc2c:	e082e003 	add	lr, r2, r3
	DUMPBITS(e)
33d1cc30:	e1a04034 	lsr	r4, r4, r0
	Tracevv((stderr, "inflate:         * length %u\n", c));

	/* decode distance base of block to copy */
	GRABBITS(15);           /* max bits for distance code */
33d1cc34:	8a000005 	bhi	33d1cc50 <inflate+0x1128>
33d1cc38:	e4d73001 	ldrb	r3, [r7], #1
33d1cc3c:	e1844c13 	orr	r4, r4, r3, lsl ip
33d1cc40:	e28cc008 	add	ip, ip, #8	; 0x8
33d1cc44:	e35c000e 	cmp	ip, #14	; 0xe
33d1cc48:	e2499001 	sub	r9, r9, #1	; 0x1
33d1cc4c:	eafffff8 	b	33d1cc34 <inflate+0x110c>
	e = (t = td + ((uInt)b & md))->exop;
33d1cc50:	e59d2018 	ldr	r2, [sp, #24]
33d1cc54:	e59d1024 	ldr	r1, [sp, #36]
33d1cc58:	e0043002 	and	r3, r4, r2
33d1cc5c:	e1a03183 	lsl	r3, r3, #3
33d1cc60:	e7d10003 	ldrb	r0, [r1, r3]
33d1cc64:	e0812003 	add	r2, r1, r3
	do {
	  DUMPBITS(t->bits)
33d1cc68:	e5d23001 	ldrb	r3, [r2, #1]
	  if (e & 16)
33d1cc6c:	e3100010 	tst	r0, #16	; 0x10

	/* decode distance base of block to copy */
	GRABBITS(15);           /* max bits for distance code */
	e = (t = td + ((uInt)b & md))->exop;
	do {
	  DUMPBITS(t->bits)
33d1cc70:	e063c00c 	rsb	ip, r3, ip
33d1cc74:	e1a04334 	lsr	r4, r4, r3
	  if (e & 16)
33d1cc78:	0a00002d 	beq	33d1cd34 <inflate+0x120c>
	  {
	    /* get extra bits to add to distance base */
	    e &= 15;
33d1cc7c:	e200000f 	and	r0, r0, #15	; 0xf
	    GRABBITS(e)         /* get extra bits (up to 13) */
33d1cc80:	e15c0000 	cmp	ip, r0
33d1cc84:	2a000005 	bcs	33d1cca0 <inflate+0x1178>
33d1cc88:	e4d73001 	ldrb	r3, [r7], #1
33d1cc8c:	e1844c13 	orr	r4, r4, r3, lsl ip
33d1cc90:	e28cc008 	add	ip, ip, #8	; 0x8
33d1cc94:	e15c0000 	cmp	ip, r0
33d1cc98:	e2499001 	sub	r9, r9, #1	; 0x1
33d1cc9c:	eafffff8 	b	33d1cc84 <inflate+0x115c>
	    d = t->base + ((uInt)b & inflate_mask[e]);
33d1cca0:	e51f30d4 	ldr	r3, [pc, #-212]	; 33d1cbd4 <inflate+0x10ac>
33d1cca4:	e7933100 	ldr	r3, [r3, r0, lsl #2]
33d1cca8:	e5922004 	ldr	r2, [r2, #4]
	    DUMPBITS(e)
	    Tracevv((stderr, "inflate:         * distance %u\n", d));

	    /* do the copy */
	    m -= c;
	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
33d1ccac:	e5951028 	ldr	r1, [r5, #40]
	  if (e & 16)
	  {
	    /* get extra bits to add to distance base */
	    e &= 15;
	    GRABBITS(e)         /* get extra bits (up to 13) */
	    d = t->base + ((uInt)b & inflate_mask[e]);
33d1ccb0:	e0043003 	and	r3, r4, r3
	    DUMPBITS(e)
33d1ccb4:	e060c00c 	rsb	ip, r0, ip
33d1ccb8:	e1a04034 	lsr	r4, r4, r0
	    Tracevv((stderr, "inflate:         * distance %u\n", d));

	    /* do the copy */
	    m -= c;
33d1ccbc:	e59d0020 	ldr	r0, [sp, #32]
	  if (e & 16)
	  {
	    /* get extra bits to add to distance base */
	    e &= 15;
	    GRABBITS(e)         /* get extra bits (up to 13) */
	    d = t->base + ((uInt)b & inflate_mask[e]);
33d1ccc0:	e0822003 	add	r2, r2, r3
	    DUMPBITS(e)
	    Tracevv((stderr, "inflate:         * distance %u\n", d));

	    /* do the copy */
	    m -= c;
	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
33d1ccc4:	e061300b 	rsb	r3, r1, fp
	    d = t->base + ((uInt)b & inflate_mask[e]);
	    DUMPBITS(e)
	    Tracevv((stderr, "inflate:         * distance %u\n", d));

	    /* do the copy */
	    m -= c;
33d1ccc8:	e06e0000 	rsb	r0, lr, r0
	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
33d1cccc:	e1530002 	cmp	r3, r2
	    d = t->base + ((uInt)b & inflate_mask[e]);
	    DUMPBITS(e)
	    Tracevv((stderr, "inflate:         * distance %u\n", d));

	    /* do the copy */
	    m -= c;
33d1ccd0:	e58d0020 	str	r0, [sp, #32]
	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
33d1ccd4:	3a000006 	bcc	33d1ccf4 <inflate+0x11cc>
	    {                                   /*  just copy */
	      r = q - d;
33d1ccd8:	e062200b 	rsb	r2, r2, fp
	      *q++ = *r++;  c--;        /* minimum count is three, */
33d1ccdc:	e4d23001 	ldrb	r3, [r2], #1
33d1cce0:	e4cb3001 	strb	r3, [fp], #1
	      *q++ = *r++;  c--;        /*  so unroll loop a little */
33d1cce4:	e4d23001 	ldrb	r3, [r2], #1
33d1cce8:	e4cb3001 	strb	r3, [fp], #1
33d1ccec:	e24ee002 	sub	lr, lr, #2	; 0x2
33d1ccf0:	ea00000a 	b	33d1cd20 <inflate+0x11f8>
	    }
	    else                        /* else offset after destination */
	    {
	      e = d - (q - s->window);  /* bytes from offset to end */
33d1ccf4:	e0630002 	rsb	r0, r3, r2
	      r = s->end - e;           /* pointer to offset */
33d1ccf8:	e595302c 	ldr	r3, [r5, #44]
	      if (c > e)                /* if source crosses, */
33d1ccfc:	e15e0000 	cmp	lr, r0
	      *q++ = *r++;  c--;        /*  so unroll loop a little */
	    }
	    else                        /* else offset after destination */
	    {
	      e = d - (q - s->window);  /* bytes from offset to end */
	      r = s->end - e;           /* pointer to offset */
33d1cd00:	e0602003 	rsb	r2, r0, r3
	      if (c > e)                /* if source crosses, */
33d1cd04:	9a000005 	bls	33d1cd20 <inflate+0x11f8>
	      {
		c -= e;                 /* copy to end of window */
33d1cd08:	e060e00e 	rsb	lr, r0, lr
		do {
		  *q++ = *r++;
33d1cd0c:	e4d23001 	ldrb	r3, [r2], #1
		} while (--e);
33d1cd10:	e2500001 	subs	r0, r0, #1	; 0x1
	      r = s->end - e;           /* pointer to offset */
	      if (c > e)                /* if source crosses, */
	      {
		c -= e;                 /* copy to end of window */
		do {
		  *q++ = *r++;
33d1cd14:	e4cb3001 	strb	r3, [fp], #1
		} while (--e);
33d1cd18:	1afffffb 	bne	33d1cd0c <inflate+0x11e4>
		r = s->window;          /* copy rest from start of window */
33d1cd1c:	e5952028 	ldr	r2, [r5, #40]
	      }
	    }
	    do {                        /* copy all or what's left */
	      *q++ = *r++;
33d1cd20:	e4d23001 	ldrb	r3, [r2], #1
	    } while (--c);
33d1cd24:	e25ee001 	subs	lr, lr, #1	; 0x1
		} while (--e);
		r = s->window;          /* copy rest from start of window */
	      }
	    }
	    do {                        /* copy all or what's left */
	      *q++ = *r++;
33d1cd28:	e4cb3001 	strb	r3, [fp], #1
	    } while (--c);
33d1cd2c:	1afffffb 	bne	33d1cd20 <inflate+0x11f8>
	    break;
33d1cd30:	ea000035 	b	33d1ce0c <inflate+0x12e4>
	  }
	  else if ((e & 64) == 0)
33d1cd34:	e3100040 	tst	r0, #64	; 0x40
33d1cd38:	1a000007 	bne	33d1cd5c <inflate+0x1234>
	    e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
33d1cd3c:	e51f1170 	ldr	r1, [pc, #-368]	; 33d1cbd4 <inflate+0x10ac>
33d1cd40:	e7913100 	ldr	r3, [r1, r0, lsl #2]
33d1cd44:	e5922004 	ldr	r2, [r2, #4]
33d1cd48:	e0043003 	and	r3, r4, r3
33d1cd4c:	e1a03183 	lsl	r3, r3, #3
33d1cd50:	e7d20003 	ldrb	r0, [r2, r3]
33d1cd54:	e0822003 	add	r2, r2, r3
33d1cd58:	eaffffc2 	b	33d1cc68 <inflate+0x1140>
	  else
	  {
	    z->msg = "invalid distance code";
33d1cd5c:	e51f3194 	ldr	r3, [pc, #-404]	; 33d1cbd0 <inflate+0x10a8>
	    UNGRAB
33d1cd60:	e1a0e1ac 	lsr	lr, ip, #3
33d1cd64:	e20cc007 	and	ip, ip, #7	; 0x7
	  }
	  else if ((e & 64) == 0)
	    e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
	  else
	  {
	    z->msg = "invalid distance code";
33d1cd68:	e5863018 	str	r3, [r6, #24]
	    UNGRAB
	    UPDATE
33d1cd6c:	e5854024 	str	r4, [r5, #36]
33d1cd70:	e585c020 	str	ip, [r5, #32]
33d1cd74:	ea00001c 	b	33d1cdec <inflate+0x12c4>
	    return Z_DATA_ERROR;
	  }
	} while (1);
	break;
      }
      if ((e & 64) == 0)
33d1cd78:	e3100040 	tst	r0, #64	; 0x40
33d1cd7c:	1a000011 	bne	33d1cdc8 <inflate+0x12a0>
      {
	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
33d1cd80:	e51f31b4 	ldr	r3, [pc, #-436]	; 33d1cbd4 <inflate+0x10ac>
33d1cd84:	e7933100 	ldr	r3, [r3, r0, lsl #2]
33d1cd88:	e5922004 	ldr	r2, [r2, #4]
33d1cd8c:	e0043003 	and	r3, r4, r3
33d1cd90:	e1a03183 	lsl	r3, r3, #3
33d1cd94:	e7d20003 	ldrb	r0, [r2, r3]
33d1cd98:	e0822003 	add	r2, r2, r3
33d1cd9c:	e3500000 	cmp	r0, #0	; 0x0
33d1cda0:	eaffff94 	b	33d1cbf8 <inflate+0x10d0>
	{
	  DUMPBITS(t->bits)
	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		    "inflate:         * literal '%c'\n" :
		    "inflate:         * literal 0x%02x\n", t->base));
	  *q++ = (Byte)t->base;
33d1cda4:	e5923004 	ldr	r3, [r2, #4]
      }
      if ((e & 64) == 0)
      {
	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
	{
	  DUMPBITS(t->bits)
33d1cda8:	e5d22001 	ldrb	r2, [r2, #1]
	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		    "inflate:         * literal '%c'\n" :
		    "inflate:         * literal 0x%02x\n", t->base));
	  *q++ = (Byte)t->base;
33d1cdac:	e4cb3001 	strb	r3, [fp], #1
      }
      if ((e & 64) == 0)
      {
	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
	{
	  DUMPBITS(t->bits)
33d1cdb0:	e062c00c 	rsb	ip, r2, ip
33d1cdb4:	e1a04234 	lsr	r4, r4, r2
	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		    "inflate:         * literal '%c'\n" :
		    "inflate:         * literal 0x%02x\n", t->base));
	  *q++ = (Byte)t->base;
	  m--;
33d1cdb8:	e59d2020 	ldr	r2, [sp, #32]
33d1cdbc:	e2422001 	sub	r2, r2, #1	; 0x1
33d1cdc0:	e58d2020 	str	r2, [sp, #32]
	  break;
33d1cdc4:	ea000010 	b	33d1ce0c <inflate+0x12e4>
	}
      }
      else if (e & 32)
33d1cdc8:	e3100020 	tst	r0, #32	; 0x20
33d1cdcc:	e20c1007 	and	r1, ip, #7	; 0x7
33d1cdd0:	e1a021ac 	lsr	r2, ip, #3
33d1cdd4:	1affff45 	bne	33d1caf0 <inflate+0xfc8>
	UPDATE
	return Z_STREAM_END;
      }
      else
      {
	z->msg = "invalid literal/length code";
33d1cdd8:	e51f3214 	ldr	r3, [pc, #-532]	; 33d1cbcc <inflate+0x10a4>
33d1cddc:	e5863018 	str	r3, [r6, #24]
	UNGRAB
	UPDATE
33d1cde0:	e5854024 	str	r4, [r5, #36]
33d1cde4:	e5851020 	str	r1, [r5, #32]
	return Z_STREAM_END;
      }
      else
      {
	z->msg = "invalid literal/length code";
	UNGRAB
33d1cde8:	e1a0e002 	mov	lr, r2
	UPDATE
33d1cdec:	e5963000 	ldr	r3, [r6]
	return Z_STREAM_END;
      }
      else
      {
	z->msg = "invalid literal/length code";
	UNGRAB
33d1cdf0:	e06e7007 	rsb	r7, lr, r7
	UPDATE
33d1cdf4:	e5962008 	ldr	r2, [r6, #8]
33d1cdf8:	e0633007 	rsb	r3, r3, r7
33d1cdfc:	e0822003 	add	r2, r2, r3
	return Z_STREAM_END;
      }
      else
      {
	z->msg = "invalid literal/length code";
	UNGRAB
33d1ce00:	e089900e 	add	r9, r9, lr
	UPDATE
33d1ce04:	e3e01002 	mvn	r1, #2	; 0x2
33d1ce08:	ea000010 	b	33d1ce50 <inflate+0x1328>
	return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);
33d1ce0c:	e51f324c 	ldr	r3, [pc, #-588]	; 33d1cbc8 <inflate+0x10a0>
33d1ce10:	e59d0020 	ldr	r0, [sp, #32]
33d1ce14:	e1500003 	cmp	r0, r3
33d1ce18:	83590009 	cmphi	r9, #9	; 0x9
33d1ce1c:	93a01000 	movls	r1, #0	; 0x0
33d1ce20:	83a01001 	movhi	r1, #1	; 0x1
33d1ce24:	8affff44 	bhi	33d1cb3c <inflate+0x1014>

  /* not enough input or output--restore pointers and return */
  UNGRAB
33d1ce28:	e1a0e1ac 	lsr	lr, ip, #3
33d1ce2c:	e20cc007 	and	ip, ip, #7	; 0x7
  UPDATE
33d1ce30:	e5854024 	str	r4, [r5, #36]
33d1ce34:	e585c020 	str	ip, [r5, #32]
33d1ce38:	e5963000 	ldr	r3, [r6]
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
33d1ce3c:	e06e7007 	rsb	r7, lr, r7
  UPDATE
33d1ce40:	e5962008 	ldr	r2, [r6, #8]
33d1ce44:	e0633007 	rsb	r3, r3, r7
33d1ce48:	e0822003 	add	r2, r2, r3
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
33d1ce4c:	e089900e 	add	r9, r9, lr
  UPDATE
33d1ce50:	e5869004 	str	r9, [r6, #4]
33d1ce54:	e5862008 	str	r2, [r6, #8]
33d1ce58:	e5867000 	str	r7, [r6]
33d1ce5c:	e585b034 	str	fp, [r5, #52]
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
	UPDATE
	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
	LOAD
33d1ce60:	e2853030 	add	r3, r5, #48	; 0x30
33d1ce64:	e8934008 	ldm	r3, {r3, lr}
local int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl, *td;
inflate_blocks_statef *s;
z_stream *z;
{
33d1ce68:	e58d1030 	str	r1, [sp, #48]
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
	UPDATE
	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
	LOAD
33d1ce6c:	e5962004 	ldr	r2, [r6, #4]
33d1ce70:	e596b000 	ldr	fp, [r6]
33d1ce74:	e58d202c 	str	r2, [sp, #44]
33d1ce78:	e15e0003 	cmp	lr, r3
33d1ce7c:	2595302c 	ldrcs	r3, [r5, #44]
33d1ce80:	306e3003 	rsbcc	r3, lr, r3
33d1ce84:	32439001 	subcc	r9, r3, #1	; 0x1
33d1ce88:	206e9003 	rsbcs	r9, lr, r3
	if (r != Z_OK)
33d1ce8c:	e3510000 	cmp	r1, #0	; 0x0
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
	UPDATE
	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
	LOAD
33d1ce90:	e2854020 	add	r4, r5, #32	; 0x20
33d1ce94:	e8940090 	ldm	r4, {r4, r7}
	if (r != Z_OK)
33d1ce98:	0a000003 	beq	33d1ceac <inflate+0x1384>
	{
	  c->mode = r == Z_STREAM_END ? WASH : BADCODE;
33d1ce9c:	e3510001 	cmp	r1, #1	; 0x1
33d1cea0:	13a03009 	movne	r3, #9	; 0x9
33d1cea4:	03a03007 	moveq	r3, #7	; 0x7
33d1cea8:	ea000125 	b	33d1d344 <inflate+0x181c>
	  break;
	}
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
33d1ceac:	e5da3010 	ldrb	r3, [sl, #16]
      c->sub.code.tree = c->ltree;
33d1ceb0:	e59a2014 	ldr	r2, [sl, #20]
	  c->mode = r == Z_STREAM_END ? WASH : BADCODE;
	  break;
	}
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
33d1ceb4:	e58a300c 	str	r3, [sl, #12]
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
33d1ceb8:	e3a03001 	mov	r3, #1	; 0x1
	  break;
	}
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
33d1cebc:	e58a2008 	str	r2, [sl, #8]
      c->mode = LEN;
33d1cec0:	e58a3000 	str	r3, [sl]
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
33d1cec4:	e59ac00c 	ldr	ip, [sl, #12]
      NEEDBITS(j)
33d1cec8:	e154000c 	cmp	r4, ip
33d1cecc:	2a00000c 	bcs	33d1cf04 <inflate+0x13dc>
33d1ced0:	e59d302c 	ldr	r3, [sp, #44]
33d1ced4:	e3530000 	cmp	r3, #0	; 0x0
33d1ced8:	0afffec2 	beq	33d1c9e8 <inflate+0xec0>
33d1cedc:	e4db3001 	ldrb	r3, [fp], #1
33d1cee0:	e59d002c 	ldr	r0, [sp, #44]
33d1cee4:	e1877413 	orr	r7, r7, r3, lsl r4
33d1cee8:	e2844008 	add	r4, r4, #8	; 0x8
33d1ceec:	e2400001 	sub	r0, r0, #1	; 0x1
33d1cef0:	e3a01000 	mov	r1, #0	; 0x0
33d1cef4:	e154000c 	cmp	r4, ip
33d1cef8:	e58d002c 	str	r0, [sp, #44]
33d1cefc:	e58d1030 	str	r1, [sp, #48]
33d1cf00:	eafffff1 	b	33d1cecc <inflate+0x13a4>
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
33d1cf04:	e51f3338 	ldr	r3, [pc, #-824]	; 33d1cbd4 <inflate+0x10ac>
33d1cf08:	e793310c 	ldr	r3, [r3, ip, lsl #2]
33d1cf0c:	e59a2008 	ldr	r2, [sl, #8]
33d1cf10:	e0073003 	and	r3, r7, r3
33d1cf14:	e1a03183 	lsl	r3, r3, #3
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
33d1cf18:	e7d21003 	ldrb	r1, [r2, r3]
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
33d1cf1c:	e0822003 	add	r2, r2, r3
      DUMPBITS(t->bits)
33d1cf20:	e5d23001 	ldrb	r3, [r2, #1]
      e = (uInt)(t->exop);
33d1cf24:	e20100ff 	and	r0, r1, #255	; 0xff
      if (e == 0)               /* literal */
33d1cf28:	e3500000 	cmp	r0, #0	; 0x0
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
33d1cf2c:	e0634004 	rsb	r4, r3, r4
33d1cf30:	e1a07337 	lsr	r7, r7, r3
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
	c->sub.lit = t->base;
33d1cf34:	05923004 	ldreq	r3, [r2, #4]
33d1cf38:	058a3008 	streq	r3, [sl, #8]
	Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		 "inflate:         literal '%c'\n" :
		 "inflate:         literal 0x%02x\n", t->base));
	c->mode = LIT;
33d1cf3c:	03a03006 	moveq	r3, #6	; 0x6
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
33d1cf40:	0a0000ff 	beq	33d1d344 <inflate+0x181c>
		 "inflate:         literal '%c'\n" :
		 "inflate:         literal 0x%02x\n", t->base));
	c->mode = LIT;
	break;
      }
      if (e & 16)               /* length */
33d1cf44:	e3110010 	tst	r1, #16	; 0x10
33d1cf48:	0a000005 	beq	33d1cf64 <inflate+0x143c>
      {
	c->sub.copy.get = e & 15;
33d1cf4c:	e201300f 	and	r3, r1, #15	; 0xf
33d1cf50:	e58a3008 	str	r3, [sl, #8]
	c->len = t->base;
33d1cf54:	e5923004 	ldr	r3, [r2, #4]
33d1cf58:	e58a3004 	str	r3, [sl, #4]
	c->mode = LENEXT;
33d1cf5c:	e3a03002 	mov	r3, #2	; 0x2
33d1cf60:	ea0000f7 	b	33d1d344 <inflate+0x181c>
	break;
      }
      if ((e & 64) == 0)        /* next table */
33d1cf64:	e3110040 	tst	r1, #64	; 0x40
33d1cf68:	0a000050 	beq	33d1d0b0 <inflate+0x1588>
      {
	c->sub.code.need = e;
	c->sub.code.tree = t->next;
	break;
      }
      if (e & 32)               /* end of block */
33d1cf6c:	e3110020 	tst	r1, #32	; 0x20
      {
	Tracevv((stderr, "inflate:         end of block\n"));
	c->mode = WASH;
33d1cf70:	13a03007 	movne	r3, #7	; 0x7
33d1cf74:	1a0000f2 	bne	33d1d344 <inflate+0x181c>
	break;
      }
      c->mode = BADCODE;        /* invalid code */
33d1cf78:	e3a03009 	mov	r3, #9	; 0x9
33d1cf7c:	e58a3000 	str	r3, [sl]
      z->msg = "invalid literal/length code";
33d1cf80:	e51f33bc 	ldr	r3, [pc, #-956]	; 33d1cbcc <inflate+0x10a4>
33d1cf84:	e5863018 	str	r3, [r6, #24]
      r = Z_DATA_ERROR;
      LEAVE
33d1cf88:	e5857024 	str	r7, [r5, #36]
33d1cf8c:	e5854020 	str	r4, [r5, #32]
33d1cf90:	e5963000 	ldr	r3, [r6]
33d1cf94:	e5962008 	ldr	r2, [r6, #8]
33d1cf98:	e063300b 	rsb	r3, r3, fp
33d1cf9c:	e0822003 	add	r2, r2, r3
33d1cfa0:	e59d302c 	ldr	r3, [sp, #44]
33d1cfa4:	e5863004 	str	r3, [r6, #4]
33d1cfa8:	ea000050 	b	33d1d0f0 <inflate+0x15c8>
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
33d1cfac:	e59ac008 	ldr	ip, [sl, #8]
      NEEDBITS(j)
33d1cfb0:	e154000c 	cmp	r4, ip
33d1cfb4:	2a00000b 	bcs	33d1cfe8 <inflate+0x14c0>
33d1cfb8:	e59d002c 	ldr	r0, [sp, #44]
33d1cfbc:	e3500000 	cmp	r0, #0	; 0x0
33d1cfc0:	0afffe70 	beq	33d1c988 <inflate+0xe60>
33d1cfc4:	e4db3001 	ldrb	r3, [fp], #1
33d1cfc8:	e1877413 	orr	r7, r7, r3, lsl r4
33d1cfcc:	e2844008 	add	r4, r4, #8	; 0x8
33d1cfd0:	e2400001 	sub	r0, r0, #1	; 0x1
33d1cfd4:	e3a01000 	mov	r1, #0	; 0x0
33d1cfd8:	e154000c 	cmp	r4, ip
33d1cfdc:	e58d002c 	str	r0, [sp, #44]
33d1cfe0:	e58d1030 	str	r1, [sp, #48]
33d1cfe4:	eafffff2 	b	33d1cfb4 <inflate+0x148c>
      c->len += (uInt)b & inflate_mask[j];
33d1cfe8:	e51f341c 	ldr	r3, [pc, #-1052]	; 33d1cbd4 <inflate+0x10ac>
33d1cfec:	e793310c 	ldr	r3, [r3, ip, lsl #2]
33d1cff0:	e59a2004 	ldr	r2, [sl, #4]
33d1cff4:	e0073003 	and	r3, r7, r3
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
33d1cff8:	e5da1011 	ldrb	r1, [sl, #17]
      c->sub.code.tree = c->dtree;
33d1cffc:	e59a0018 	ldr	r0, [sl, #24]
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
33d1d000:	e0822003 	add	r2, r2, r3
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
33d1d004:	e3a03003 	mov	r3, #3	; 0x3
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
33d1d008:	e58a2004 	str	r2, [sl, #4]
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
33d1d00c:	e58a100c 	str	r1, [sl, #12]
      c->sub.code.tree = c->dtree;
33d1d010:	e58a0008 	str	r0, [sl, #8]
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
33d1d014:	e58a3000 	str	r3, [sl]
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
33d1d018:	e06c4004 	rsb	r4, ip, r4
33d1d01c:	e1a07c37 	lsr	r7, r7, ip
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
33d1d020:	e59ac00c 	ldr	ip, [sl, #12]
      NEEDBITS(j)
33d1d024:	e154000c 	cmp	r4, ip
33d1d028:	2a00000b 	bcs	33d1d05c <inflate+0x1534>
33d1d02c:	e59d202c 	ldr	r2, [sp, #44]
33d1d030:	e3520000 	cmp	r2, #0	; 0x0
33d1d034:	0afffe74 	beq	33d1ca0c <inflate+0xee4>
33d1d038:	e4db3001 	ldrb	r3, [fp], #1
33d1d03c:	e1877413 	orr	r7, r7, r3, lsl r4
33d1d040:	e2844008 	add	r4, r4, #8	; 0x8
33d1d044:	e2422001 	sub	r2, r2, #1	; 0x1
33d1d048:	e3a03000 	mov	r3, #0	; 0x0
33d1d04c:	e154000c 	cmp	r4, ip
33d1d050:	e58d202c 	str	r2, [sp, #44]
33d1d054:	e58d3030 	str	r3, [sp, #48]
33d1d058:	eafffff2 	b	33d1d028 <inflate+0x1500>
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
33d1d05c:	e51f3490 	ldr	r3, [pc, #-1168]	; 33d1cbd4 <inflate+0x10ac>
33d1d060:	e793310c 	ldr	r3, [r3, ip, lsl #2]
33d1d064:	e59a2008 	ldr	r2, [sl, #8]
33d1d068:	e0073003 	and	r3, r7, r3
33d1d06c:	e1a03183 	lsl	r3, r3, #3
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
33d1d070:	e7d21003 	ldrb	r1, [r2, r3]
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
33d1d074:	e0822003 	add	r2, r2, r3
      DUMPBITS(t->bits)
33d1d078:	e5d23001 	ldrb	r3, [r2, #1]
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
33d1d07c:	e3110010 	tst	r1, #16	; 0x10
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
33d1d080:	e0634004 	rsb	r4, r3, r4
33d1d084:	e1a07337 	lsr	r7, r7, r3
      e = (uInt)(t->exop);
33d1d088:	e20100ff 	and	r0, r1, #255	; 0xff
      if (e & 16)               /* distance */
33d1d08c:	0a000005 	beq	33d1d0a8 <inflate+0x1580>
      {
	c->sub.copy.get = e & 15;
33d1d090:	e201300f 	and	r3, r1, #15	; 0xf
33d1d094:	e58a3008 	str	r3, [sl, #8]
	c->sub.copy.dist = t->base;
33d1d098:	e5923004 	ldr	r3, [r2, #4]
33d1d09c:	e58a300c 	str	r3, [sl, #12]
	c->mode = DISTEXT;
33d1d0a0:	e3a03004 	mov	r3, #4	; 0x4
33d1d0a4:	ea0000a6 	b	33d1d344 <inflate+0x181c>
	break;
      }
      if ((e & 64) == 0)        /* next table */
33d1d0a8:	e3110040 	tst	r1, #64	; 0x40
33d1d0ac:	1a000003 	bne	33d1d0c0 <inflate+0x1598>
      {
	c->sub.code.need = e;
33d1d0b0:	e58a000c 	str	r0, [sl, #12]
	c->sub.code.tree = t->next;
33d1d0b4:	e5923004 	ldr	r3, [r2, #4]
33d1d0b8:	e58a3008 	str	r3, [sl, #8]
	break;
33d1d0bc:	eafffe5e 	b	33d1ca3c <inflate+0xf14>
      }
      c->mode = BADCODE;        /* invalid code */
33d1d0c0:	e3a03009 	mov	r3, #9	; 0x9
33d1d0c4:	e58a3000 	str	r3, [sl]
      z->msg = "invalid distance code";
33d1d0c8:	e51f3500 	ldr	r3, [pc, #-1280]	; 33d1cbd0 <inflate+0x10a8>
33d1d0cc:	e5863018 	str	r3, [r6, #24]
      r = Z_DATA_ERROR;
      LEAVE
33d1d0d0:	e5857024 	str	r7, [r5, #36]
33d1d0d4:	e5854020 	str	r4, [r5, #32]
33d1d0d8:	e59dc02c 	ldr	ip, [sp, #44]
33d1d0dc:	e5963000 	ldr	r3, [r6]
33d1d0e0:	e5962008 	ldr	r2, [r6, #8]
33d1d0e4:	e063300b 	rsb	r3, r3, fp
33d1d0e8:	e586c004 	str	ip, [r6, #4]
33d1d0ec:	e0822003 	add	r2, r2, r3
33d1d0f0:	e5862008 	str	r2, [r6, #8]
33d1d0f4:	e1a00005 	mov	r0, r5
33d1d0f8:	e1a01006 	mov	r1, r6
33d1d0fc:	e3e02002 	mvn	r2, #2	; 0x2
33d1d100:	e586b000 	str	fp, [r6]
33d1d104:	e585e034 	str	lr, [r5, #52]
33d1d108:	ea0000bf 	b	33d1d40c <inflate+0x18e4>
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
33d1d10c:	e59ac008 	ldr	ip, [sl, #8]
      NEEDBITS(j)
33d1d110:	e154000c 	cmp	r4, ip
33d1d114:	2a00000b 	bcs	33d1d148 <inflate+0x1620>
33d1d118:	e59d002c 	ldr	r0, [sp, #44]
33d1d11c:	e3500000 	cmp	r0, #0	; 0x0
33d1d120:	0afffe27 	beq	33d1c9c4 <inflate+0xe9c>
33d1d124:	e4db3001 	ldrb	r3, [fp], #1
33d1d128:	e1877413 	orr	r7, r7, r3, lsl r4
33d1d12c:	e2844008 	add	r4, r4, #8	; 0x8
33d1d130:	e2400001 	sub	r0, r0, #1	; 0x1
33d1d134:	e3a01000 	mov	r1, #0	; 0x0
33d1d138:	e154000c 	cmp	r4, ip
33d1d13c:	e58d002c 	str	r0, [sp, #44]
33d1d140:	e58d1030 	str	r1, [sp, #48]
33d1d144:	eafffff2 	b	33d1d114 <inflate+0x15ec>
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
33d1d148:	e51f357c 	ldr	r3, [pc, #-1404]	; 33d1cbd4 <inflate+0x10ac>
33d1d14c:	e793310c 	ldr	r3, [r3, ip, lsl #2]
33d1d150:	e59a200c 	ldr	r2, [sl, #12]
33d1d154:	e0073003 	and	r3, r7, r3
33d1d158:	e0822003 	add	r2, r2, r3
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
33d1d15c:	e3a03005 	mov	r3, #5	; 0x5
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
33d1d160:	e58a200c 	str	r2, [sl, #12]
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
33d1d164:	e58a3000 	str	r3, [sl]
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
33d1d168:	e06c4004 	rsb	r4, ip, r4
33d1d16c:	e1a07c37 	lsr	r7, r7, ip
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
#ifndef __TURBOC__ /* Turbo C bug for following expression */
      f = (uInt)(q - s->window) < c->sub.copy.dist ?
33d1d170:	e5953028 	ldr	r3, [r5, #40]
33d1d174:	e59a100c 	ldr	r1, [sl, #12]
33d1d178:	e063300e 	rsb	r3, r3, lr
33d1d17c:	e1530001 	cmp	r3, r1
33d1d180:	3595202c 	ldrcc	r2, [r5, #44]
33d1d184:	30633001 	rsbcc	r3, r3, r1
33d1d188:	3063c002 	rsbcc	ip, r3, r2
      {
	NEEDOUT
	OUTBYTE(*f++)
	if (f == s->end)
	  f = s->window;
	c->len--;
33d1d18c:	e59a3004 	ldr	r3, [sl, #4]
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
#ifndef __TURBOC__ /* Turbo C bug for following expression */
      f = (uInt)(q - s->window) < c->sub.copy.dist ?
33d1d190:	2061c00e 	rsbcs	ip, r1, lr
      {
	NEEDOUT
	OUTBYTE(*f++)
	if (f == s->end)
	  f = s->window;
	c->len--;
33d1d194:	e3530000 	cmp	r3, #0	; 0x0
33d1d198:	0a000038 	beq	33d1d280 <inflate+0x1758>
      if ((uInt)(q - s->window) < c->sub.copy.dist)
	f = s->end - (c->sub.copy.dist - (q - s->window));
#endif
      while (c->len)
      {
	NEEDOUT
33d1d19c:	e3590000 	cmp	r9, #0	; 0x0
33d1d1a0:	1a000029 	bne	33d1d24c <inflate+0x1724>
33d1d1a4:	e595002c 	ldr	r0, [r5, #44]
33d1d1a8:	e15e0000 	cmp	lr, r0
33d1d1ac:	1a00000a 	bne	33d1d1dc <inflate+0x16b4>
33d1d1b0:	e5953030 	ldr	r3, [r5, #48]
33d1d1b4:	e5952028 	ldr	r2, [r5, #40]
33d1d1b8:	e1530002 	cmp	r3, r2
33d1d1bc:	0a000006 	beq	33d1d1dc <inflate+0x16b4>
33d1d1c0:	e1520003 	cmp	r2, r3
33d1d1c4:	30623003 	rsbcc	r3, r2, r3
33d1d1c8:	32439001 	subcc	r9, r3, #1	; 0x1
33d1d1cc:	20629000 	rsbcs	r9, r2, r0
33d1d1d0:	e3590000 	cmp	r9, #0	; 0x0
33d1d1d4:	e1a0e002 	mov	lr, r2
33d1d1d8:	1a00001b 	bne	33d1d24c <inflate+0x1724>
33d1d1dc:	e585e034 	str	lr, [r5, #52]
33d1d1e0:	e59d2030 	ldr	r2, [sp, #48]
33d1d1e4:	e1a01006 	mov	r1, r6
33d1d1e8:	e1a00005 	mov	r0, r5
33d1d1ec:	e58dc014 	str	ip, [sp, #20]
33d1d1f0:	ebfff866 	bl	33d1b390 <inflate_flush>
33d1d1f4:	e58d0030 	str	r0, [sp, #48]
33d1d1f8:	e2852030 	add	r2, r5, #48	; 0x30
33d1d1fc:	e8924004 	ldm	r2, {r2, lr}
33d1d200:	e15e0002 	cmp	lr, r2
33d1d204:	2595302c 	ldrcs	r3, [r5, #44]
33d1d208:	e595102c 	ldr	r1, [r5, #44]
33d1d20c:	306e3002 	rsbcc	r3, lr, r2
33d1d210:	32439001 	subcc	r9, r3, #1	; 0x1
33d1d214:	206e9003 	rsbcs	r9, lr, r3
33d1d218:	e15e0001 	cmp	lr, r1
33d1d21c:	e59dc014 	ldr	ip, [sp, #20]
33d1d220:	1a000007 	bne	33d1d244 <inflate+0x171c>
33d1d224:	e5953028 	ldr	r3, [r5, #40]
33d1d228:	e1520003 	cmp	r2, r3
33d1d22c:	0a000004 	beq	33d1d244 <inflate+0x171c>
33d1d230:	e1530002 	cmp	r3, r2
33d1d234:	e1a0e003 	mov	lr, r3
33d1d238:	30633002 	rsbcc	r3, r3, r2
33d1d23c:	32439001 	subcc	r9, r3, #1	; 0x1
33d1d240:	206e9001 	rsbcs	r9, lr, r1
33d1d244:	e3590000 	cmp	r9, #0	; 0x0
33d1d248:	0afffde6 	beq	33d1c9e8 <inflate+0xec0>
	OUTBYTE(*f++)
33d1d24c:	e4dc3001 	ldrb	r3, [ip], #1
33d1d250:	e4ce3001 	strb	r3, [lr], #1
      if ((uInt)(q - s->window) < c->sub.copy.dist)
	f = s->end - (c->sub.copy.dist - (q - s->window));
#endif
      while (c->len)
      {
	NEEDOUT
33d1d254:	e3a02000 	mov	r2, #0	; 0x0
	OUTBYTE(*f++)
	if (f == s->end)
33d1d258:	e595302c 	ldr	r3, [r5, #44]
      if ((uInt)(q - s->window) < c->sub.copy.dist)
	f = s->end - (c->sub.copy.dist - (q - s->window));
#endif
      while (c->len)
      {
	NEEDOUT
33d1d25c:	e58d2030 	str	r2, [sp, #48]
	OUTBYTE(*f++)
	if (f == s->end)
33d1d260:	e15c0003 	cmp	ip, r3
	  f = s->window;
	c->len--;
33d1d264:	e59a3004 	ldr	r3, [sl, #4]
      while (c->len)
      {
	NEEDOUT
	OUTBYTE(*f++)
	if (f == s->end)
	  f = s->window;
33d1d268:	0595c028 	ldreq	ip, [r5, #40]
	c->len--;
33d1d26c:	e2433001 	sub	r3, r3, #1	; 0x1
	f = s->end - (c->sub.copy.dist - (q - s->window));
#endif
      while (c->len)
      {
	NEEDOUT
	OUTBYTE(*f++)
33d1d270:	e2499001 	sub	r9, r9, #1	; 0x1
	if (f == s->end)
	  f = s->window;
	c->len--;
33d1d274:	e3530000 	cmp	r3, #0	; 0x0
33d1d278:	e58a3004 	str	r3, [sl, #4]
33d1d27c:	eaffffc5 	b	33d1d198 <inflate+0x1670>
      }
      c->mode = START;
33d1d280:	e3a03000 	mov	r3, #0	; 0x0
33d1d284:	ea00002e 	b	33d1d344 <inflate+0x181c>
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
33d1d288:	e3590000 	cmp	r9, #0	; 0x0
33d1d28c:	1a000027 	bne	33d1d330 <inflate+0x1808>
33d1d290:	e595002c 	ldr	r0, [r5, #44]
33d1d294:	e15e0000 	cmp	lr, r0
33d1d298:	1a00000a 	bne	33d1d2c8 <inflate+0x17a0>
33d1d29c:	e5953030 	ldr	r3, [r5, #48]
33d1d2a0:	e5952028 	ldr	r2, [r5, #40]
33d1d2a4:	e1530002 	cmp	r3, r2
33d1d2a8:	0a000006 	beq	33d1d2c8 <inflate+0x17a0>
33d1d2ac:	e1520003 	cmp	r2, r3
33d1d2b0:	30623003 	rsbcc	r3, r2, r3
33d1d2b4:	32439001 	subcc	r9, r3, #1	; 0x1
33d1d2b8:	20629000 	rsbcs	r9, r2, r0
33d1d2bc:	e3590000 	cmp	r9, #0	; 0x0
33d1d2c0:	e1a0e002 	mov	lr, r2
33d1d2c4:	1a000019 	bne	33d1d330 <inflate+0x1808>
33d1d2c8:	e585e034 	str	lr, [r5, #52]
33d1d2cc:	e59d2030 	ldr	r2, [sp, #48]
33d1d2d0:	e1a01006 	mov	r1, r6
33d1d2d4:	e1a00005 	mov	r0, r5
33d1d2d8:	ebfff82c 	bl	33d1b390 <inflate_flush>
33d1d2dc:	e58d0030 	str	r0, [sp, #48]
33d1d2e0:	e2852030 	add	r2, r5, #48	; 0x30
33d1d2e4:	e8924004 	ldm	r2, {r2, lr}
33d1d2e8:	e15e0002 	cmp	lr, r2
33d1d2ec:	2595302c 	ldrcs	r3, [r5, #44]
33d1d2f0:	e595102c 	ldr	r1, [r5, #44]
33d1d2f4:	306e3002 	rsbcc	r3, lr, r2
33d1d2f8:	32439001 	subcc	r9, r3, #1	; 0x1
33d1d2fc:	206e9003 	rsbcs	r9, lr, r3
33d1d300:	e15e0001 	cmp	lr, r1
33d1d304:	1a000007 	bne	33d1d328 <inflate+0x1800>
33d1d308:	e5953028 	ldr	r3, [r5, #40]
33d1d30c:	e1520003 	cmp	r2, r3
33d1d310:	0a000004 	beq	33d1d328 <inflate+0x1800>
33d1d314:	e1530002 	cmp	r3, r2
33d1d318:	e1a0e003 	mov	lr, r3
33d1d31c:	30633002 	rsbcc	r3, r3, r2
33d1d320:	32439001 	subcc	r9, r3, #1	; 0x1
33d1d324:	206e9001 	rsbcs	r9, lr, r1
33d1d328:	e3590000 	cmp	r9, #0	; 0x0
33d1d32c:	0afffd95 	beq	33d1c988 <inflate+0xe60>
      OUTBYTE(c->sub.lit)
33d1d330:	e59a3008 	ldr	r3, [sl, #8]
33d1d334:	e4ce3001 	strb	r3, [lr], #1
	c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
33d1d338:	e3a03000 	mov	r3, #0	; 0x0
33d1d33c:	e58d3030 	str	r3, [sp, #48]
      OUTBYTE(c->sub.lit)
33d1d340:	e2499001 	sub	r9, r9, #1	; 0x1
      c->mode = START;
33d1d344:	e58a3000 	str	r3, [sl]
      break;
33d1d348:	eafffdbb 	b	33d1ca3c <inflate+0xf14>
    case WASH:          /* o: got eob, possibly more output */
      FLUSH
33d1d34c:	e585e034 	str	lr, [r5, #52]
33d1d350:	e59d2030 	ldr	r2, [sp, #48]
33d1d354:	e1a00005 	mov	r0, r5
33d1d358:	e1a01006 	mov	r1, r6
33d1d35c:	ebfff80b 	bl	33d1b390 <inflate_flush>
33d1d360:	e58d0030 	str	r0, [sp, #48]
33d1d364:	e2853030 	add	r3, r5, #48	; 0x30
33d1d368:	e8934008 	ldm	r3, {r3, lr}
      if (s->read != s->write)
33d1d36c:	e153000e 	cmp	r3, lr
33d1d370:	1afffda5 	bne	33d1ca0c <inflate+0xee4>
	LEAVE
      c->mode = END;
33d1d374:	e3a03008 	mov	r3, #8	; 0x8
33d1d378:	e58a3000 	str	r3, [sl]
    case END:
      r = Z_STREAM_END;
      LEAVE
33d1d37c:	e5857024 	str	r7, [r5, #36]
33d1d380:	e5854020 	str	r4, [r5, #32]
33d1d384:	e5963000 	ldr	r3, [r6]
33d1d388:	e5962008 	ldr	r2, [r6, #8]
33d1d38c:	e063300b 	rsb	r3, r3, fp
33d1d390:	e59dc02c 	ldr	ip, [sp, #44]
33d1d394:	e0822003 	add	r2, r2, r3
33d1d398:	e5862008 	str	r2, [r6, #8]
33d1d39c:	e1a00005 	mov	r0, r5
33d1d3a0:	e1a01006 	mov	r1, r6
33d1d3a4:	e3a02001 	mov	r2, #1	; 0x1
33d1d3a8:	e8861800 	stm	r6, {fp, ip}
33d1d3ac:	e585e034 	str	lr, [r5, #52]
33d1d3b0:	ea000015 	b	33d1d40c <inflate+0x18e4>
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
33d1d3b4:	e5857024 	str	r7, [r5, #36]
33d1d3b8:	e5854020 	str	r4, [r5, #32]
33d1d3bc:	e5963000 	ldr	r3, [r6]
33d1d3c0:	e5962008 	ldr	r2, [r6, #8]
33d1d3c4:	e063300b 	rsb	r3, r3, fp
33d1d3c8:	e59d002c 	ldr	r0, [sp, #44]
33d1d3cc:	e0822003 	add	r2, r2, r3
33d1d3d0:	e5860004 	str	r0, [r6, #4]
33d1d3d4:	eaffff45 	b	33d1d0f0 <inflate+0x15c8>
    default:
      r = Z_STREAM_ERROR;
      LEAVE
33d1d3d8:	e5857024 	str	r7, [r5, #36]
33d1d3dc:	e5854020 	str	r4, [r5, #32]
33d1d3e0:	e5963000 	ldr	r3, [r6]
33d1d3e4:	e5962008 	ldr	r2, [r6, #8]
33d1d3e8:	e59d102c 	ldr	r1, [sp, #44]
33d1d3ec:	e063300b 	rsb	r3, r3, fp
33d1d3f0:	e0822003 	add	r2, r2, r3
33d1d3f4:	e9860006 	stmib	r6, {r1, r2}
33d1d3f8:	e586b000 	str	fp, [r6]
33d1d3fc:	e585e034 	str	lr, [r5, #52]
33d1d400:	e1a00005 	mov	r0, r5
33d1d404:	e1a01006 	mov	r1, r6
33d1d408:	e3e02001 	mvn	r2, #1	; 0x1
33d1d40c:	ebfff7df 	bl	33d1b390 <inflate_flush>

local int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1d410:	e58d0054 	str	r0, [sp, #84]
33d1d414:	e3500001 	cmp	r0, #1	; 0x1
33d1d418:	1afffa36 	bne	33d1bcf8 <inflate+0x1d0>
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
	return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
33d1d41c:	e595000c 	ldr	r0, [r5, #12]
33d1d420:	e1a01006 	mov	r1, r6
33d1d424:	ebfff64c 	bl	33d1ad5c <inflate_codes_free>
      inflate_trees_free(s->sub.decode.td, z);
33d1d428:	e1a01006 	mov	r1, r6
33d1d42c:	e5950008 	ldr	r0, [r5, #8]
33d1d430:	ebfff651 	bl	33d1ad7c <inflate_trees_free>
      inflate_trees_free(s->sub.decode.tl, z);
33d1d434:	e5950004 	ldr	r0, [r5, #4]
33d1d438:	e1a01006 	mov	r1, r6
33d1d43c:	ebfff64e 	bl	33d1ad7c <inflate_trees_free>
      LOAD
33d1d440:	e5952034 	ldr	r2, [r5, #52]
33d1d444:	e58d204c 	str	r2, [sp, #76]
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
	return inflate_flush(s, z, r);
      r = Z_OK;
33d1d448:	e3a0b000 	mov	fp, #0	; 0x0
      inflate_codes_free(s->sub.decode.codes, z);
      inflate_trees_free(s->sub.decode.td, z);
      inflate_trees_free(s->sub.decode.tl, z);
      LOAD
33d1d44c:	e5953030 	ldr	r3, [r5, #48]
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
	return inflate_flush(s, z, r);
      r = Z_OK;
33d1d450:	e58db054 	str	fp, [sp, #84]
      inflate_codes_free(s->sub.decode.codes, z);
      inflate_trees_free(s->sub.decode.td, z);
      inflate_trees_free(s->sub.decode.tl, z);
      LOAD
33d1d454:	e8961200 	ldm	r6, {r9, ip}
33d1d458:	e58dc050 	str	ip, [sp, #80]
33d1d45c:	e1520003 	cmp	r2, r3
33d1d460:	2595302c 	ldrcs	r3, [r5, #44]
33d1d464:	259d004c 	ldrcs	r0, [sp, #76]
33d1d468:	30623003 	rsbcc	r3, r2, r3
33d1d46c:	3243b001 	subcc	fp, r3, #1	; 0x1
33d1d470:	2060b003 	rsbcs	fp, r0, r3
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
	      z->total_out + (q >= s->read ? q - s->read :
	      (s->end - s->read) + (q - s->window))));
      if (!s->last)
33d1d474:	e595301c 	ldr	r3, [r5, #28]
33d1d478:	e3530000 	cmp	r3, #0	; 0x0
	return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
      inflate_trees_free(s->sub.decode.td, z);
      inflate_trees_free(s->sub.decode.tl, z);
      LOAD
33d1d47c:	e2857020 	add	r7, r5, #32	; 0x20
33d1d480:	e8970480 	ldm	r7, {r7, sl}
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
	      z->total_out + (q >= s->read ? q - s->read :
	      (s->end - s->read) + (q - s->window))));
      if (!s->last)
33d1d484:	1a000001 	bne	33d1d490 <inflate+0x1968>
      {
	s->mode = TYPE;
33d1d488:	e5853000 	str	r3, [r5]
	break;
33d1d48c:	eafffa60 	b	33d1be14 <inflate+0x2ec>
      }
      if (k > 7)              /* return unused byte, if any */
33d1d490:	e3570007 	cmp	r7, #7	; 0x7
      {
	Assert(k < 16, "inflate_codes grabbed too many bytes")
	k -= 8;
	n++;
33d1d494:	859d1050 	ldrhi	r1, [sp, #80]
	p--;                    /* can always return one */
      }
      s->mode = DRY;
33d1d498:	e3a03007 	mov	r3, #7	; 0x7
      }
      if (k > 7)              /* return unused byte, if any */
      {
	Assert(k < 16, "inflate_codes grabbed too many bytes")
	k -= 8;
	n++;
33d1d49c:	82811001 	addhi	r1, r1, #1	; 0x1
33d1d4a0:	858d1050 	strhi	r1, [sp, #80]
	p--;                    /* can always return one */
      }
      s->mode = DRY;
33d1d4a4:	e5853000 	str	r3, [r5]
	break;
      }
      if (k > 7)              /* return unused byte, if any */
      {
	Assert(k < 16, "inflate_codes grabbed too many bytes")
	k -= 8;
33d1d4a8:	82477008 	subhi	r7, r7, #8	; 0x8
	n++;
	p--;                    /* can always return one */
33d1d4ac:	82499001 	subhi	r9, r9, #1	; 0x1
      }
      s->mode = DRY;
    case DRY:
      FLUSH
33d1d4b0:	e59d204c 	ldr	r2, [sp, #76]
33d1d4b4:	e5852034 	str	r2, [r5, #52]
33d1d4b8:	e59d2054 	ldr	r2, [sp, #84]
33d1d4bc:	e1a00005 	mov	r0, r5
33d1d4c0:	e1a01006 	mov	r1, r6
33d1d4c4:	ebfff7b1 	bl	33d1b390 <inflate_flush>
33d1d4c8:	e58d0054 	str	r0, [sp, #84]
33d1d4cc:	e5953034 	ldr	r3, [r5, #52]
33d1d4d0:	e58d304c 	str	r3, [sp, #76]
      if (s->read != s->write)
33d1d4d4:	e59db04c 	ldr	fp, [sp, #76]
	n++;
	p--;                    /* can always return one */
      }
      s->mode = DRY;
    case DRY:
      FLUSH
33d1d4d8:	e5953030 	ldr	r3, [r5, #48]
      if (s->read != s->write)
33d1d4dc:	e153000b 	cmp	r3, fp
33d1d4e0:	1afffa3b 	bne	33d1bdd4 <inflate+0x2ac>
	LEAVE
      s->mode = DONEB;
33d1d4e4:	e3a03008 	mov	r3, #8	; 0x8
33d1d4e8:	e5853000 	str	r3, [r5]
    case DONEB:
      r = Z_STREAM_END;
      LEAVE
33d1d4ec:	e585a024 	str	sl, [r5, #36]
33d1d4f0:	e5857020 	str	r7, [r5, #32]
33d1d4f4:	e5963000 	ldr	r3, [r6]
33d1d4f8:	e5962008 	ldr	r2, [r6, #8]
33d1d4fc:	e59dc050 	ldr	ip, [sp, #80]
33d1d500:	e0633009 	rsb	r3, r3, r9
33d1d504:	e0822003 	add	r2, r2, r3
33d1d508:	e5862008 	str	r2, [r6, #8]
33d1d50c:	e8861200 	stm	r6, {r9, ip}
33d1d510:	e59d004c 	ldr	r0, [sp, #76]
33d1d514:	e1a01006 	mov	r1, r6
33d1d518:	e5850034 	str	r0, [r5, #52]
33d1d51c:	e3a02001 	mov	r2, #1	; 0x1
33d1d520:	e1a00005 	mov	r0, r5
33d1d524:	ea00001a 	b	33d1d594 <inflate+0x1a6c>
    case BADB:
      r = Z_DATA_ERROR;
      LEAVE
33d1d528:	e585a024 	str	sl, [r5, #36]
33d1d52c:	e5857020 	str	r7, [r5, #32]
33d1d530:	e5963000 	ldr	r3, [r6]
33d1d534:	e5962008 	ldr	r2, [r6, #8]
33d1d538:	e59d1050 	ldr	r1, [sp, #80]
33d1d53c:	e0633009 	rsb	r3, r3, r9
33d1d540:	e0822003 	add	r2, r2, r3
33d1d544:	e9860006 	stmib	r6, {r1, r2}
33d1d548:	e5869000 	str	r9, [r6]
33d1d54c:	e59d204c 	ldr	r2, [sp, #76]
33d1d550:	e5852034 	str	r2, [r5, #52]
33d1d554:	eafffafd 	b	33d1c150 <inflate+0x628>
    default:
      r = Z_STREAM_ERROR;
      LEAVE
33d1d558:	e585a024 	str	sl, [r5, #36]
33d1d55c:	e5857020 	str	r7, [r5, #32]
33d1d560:	e5963000 	ldr	r3, [r6]
33d1d564:	e5962008 	ldr	r2, [r6, #8]
33d1d568:	e0633009 	rsb	r3, r3, r9
33d1d56c:	e0822003 	add	r2, r2, r3
33d1d570:	e59d3050 	ldr	r3, [sp, #80]
33d1d574:	e5862008 	str	r2, [r6, #8]
33d1d578:	e5863004 	str	r3, [r6, #4]
33d1d57c:	e5869000 	str	r9, [r6]
33d1d580:	e59db04c 	ldr	fp, [sp, #76]
33d1d584:	e585b034 	str	fp, [r5, #52]
33d1d588:	e1a00005 	mov	r0, r5
33d1d58c:	e1a01006 	mov	r1, r6
33d1d590:	e3e02001 	mvn	r2, #1	; 0x1
33d1d594:	ebfff77d 	bl	33d1b390 <inflate_flush>
      }
      Trace((stderr, "inflate: zlib header ok\n"));
      z->state->mode = BLOCKS;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
33d1d598:	e59dc058 	ldr	ip, [sp, #88]
33d1d59c:	e35c0005 	cmp	ip, #5	; 0x5

local int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
33d1d5a0:	e1a07000 	mov	r7, r0
      }
      Trace((stderr, "inflate: zlib header ok\n"));
      z->state->mode = BLOCKS;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
33d1d5a4:	1a00000d 	bne	33d1d5e0 <inflate+0x1ab8>
33d1d5a8:	e5962004 	ldr	r2, [r6, #4]
33d1d5ac:	e3520000 	cmp	r2, #0	; 0x0
33d1d5b0:	1a00000a 	bne	33d1d5e0 <inflate+0x1ab8>
33d1d5b4:	e5963010 	ldr	r3, [r6, #16]
33d1d5b8:	e3530000 	cmp	r3, #0	; 0x0
33d1d5bc:	0a000007 	beq	33d1d5e0 <inflate+0x1ab8>
 * At the end of a Deflate-compressed PPP packet, we expect to have seen
 * a `stored' block type value but not the (zero) length bytes.
 */
local int inflate_packet_flush(s)
    inflate_blocks_statef *s;
{
33d1d5c0:	e596301c 	ldr	r3, [r6, #28]
33d1d5c4:	e5931014 	ldr	r1, [r3, #20]
    if (s->mode != LENS)
33d1d5c8:	e5913000 	ldr	r3, [r1]
33d1d5cc:	e3530001 	cmp	r3, #1	; 0x1
33d1d5d0:	13e00002 	mvnne	r0, #2	; 0x2
	return Z_DATA_ERROR;
    s->mode = TYPE;
33d1d5d4:	01a00002 	moveq	r0, r2
33d1d5d8:	05812000 	streq	r2, [r1]
 * At the end of a Deflate-compressed PPP packet, we expect to have seen
 * a `stored' block type value but not the (zero) length bytes.
 */
local int inflate_packet_flush(s)
    inflate_blocks_statef *s;
{
33d1d5dc:	e1a07000 	mov	r7, r0
      z->state->mode = BLOCKS;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
	  r = inflate_packet_flush(z->state->blocks);
      if (r == Z_DATA_ERROR)
33d1d5e0:	e3770003 	cmn	r7, #3	; 0x3
33d1d5e4:	1a000005 	bne	33d1d600 <inflate+0x1ad8>
      {
	z->state->mode = BAD;
33d1d5e8:	e596201c 	ldr	r2, [r6, #28]
33d1d5ec:	e3a03008 	mov	r3, #8	; 0x8
33d1d5f0:	e5823000 	str	r3, [r2]
	z->state->sub.marker = 0;       /* can try inflateSync */
33d1d5f4:	e596201c 	ldr	r2, [r6, #28]
33d1d5f8:	e2433008 	sub	r3, r3, #8	; 0x8
33d1d5fc:	ea00005d 	b	33d1d778 <inflate+0x1c50>
	break;
      }
      if (r != Z_STREAM_END)
33d1d600:	e3570001 	cmp	r7, #1	; 0x1
33d1d604:	1a000066 	bne	33d1d7a4 <inflate+0x1c7c>
	return r;
      r = Z_OK;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
33d1d608:	e596301c 	ldr	r3, [r6, #28]
33d1d60c:	e1a01006 	mov	r1, r6
33d1d610:	e2832004 	add	r2, r3, #4	; 0x4
33d1d614:	e5930014 	ldr	r0, [r3, #20]
33d1d618:	ebfff5e7 	bl	33d1adbc <inflate_blocks_reset>
      if (z->state->nowrap)
33d1d61c:	e596201c 	ldr	r2, [r6, #28]
33d1d620:	e592300c 	ldr	r3, [r2, #12]
33d1d624:	e3530000 	cmp	r3, #0	; 0x0
	z->state->sub.marker = 0;       /* can try inflateSync */
	break;
      }
      if (r != Z_STREAM_END)
	return r;
      r = Z_OK;
33d1d628:	e2477001 	sub	r7, r7, #1	; 0x1
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
	z->state->mode = DONE;
33d1d62c:	13a03007 	movne	r3, #7	; 0x7
33d1d630:	15823000 	strne	r3, [r2]
	break;
33d1d634:	1afff944 	bne	33d1bb4c <inflate+0x24>
      }
      z->state->mode = CHECK4;
33d1d638:	e3a03003 	mov	r3, #3	; 0x3
33d1d63c:	e5823000 	str	r3, [r2]
    case CHECK4:
      NEEDBYTE
33d1d640:	e5962004 	ldr	r2, [r6, #4]
33d1d644:	e3520000 	cmp	r2, #0	; 0x0
33d1d648:	0a000052 	beq	33d1d798 <inflate+0x1c70>
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
33d1d64c:	e5963008 	ldr	r3, [r6, #8]
33d1d650:	e2422001 	sub	r2, r2, #1	; 0x1
33d1d654:	e2833001 	add	r3, r3, #1	; 0x1
33d1d658:	e986000c 	stmib	r6, {r2, r3}
33d1d65c:	e5963000 	ldr	r3, [r6]
33d1d660:	e4d32001 	ldrb	r2, [r3], #1
33d1d664:	e596101c 	ldr	r1, [r6, #28]
33d1d668:	e1a02c02 	lsl	r2, r2, #24
33d1d66c:	e5863000 	str	r3, [r6]
33d1d670:	e5812008 	str	r2, [r1, #8]
      z->state->mode = CHECK3;
33d1d674:	e596201c 	ldr	r2, [r6, #28]
33d1d678:	e3a03004 	mov	r3, #4	; 0x4
33d1d67c:	e5823000 	str	r3, [r2]
	z->state->mode = DONE;
	break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
33d1d680:	e3a07000 	mov	r7, #0	; 0x0
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
33d1d684:	e5962004 	ldr	r2, [r6, #4]
33d1d688:	e3520000 	cmp	r2, #0	; 0x0
33d1d68c:	0a000041 	beq	33d1d798 <inflate+0x1c70>
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
33d1d690:	e5963008 	ldr	r3, [r6, #8]
33d1d694:	e2422001 	sub	r2, r2, #1	; 0x1
33d1d698:	e2833001 	add	r3, r3, #1	; 0x1
33d1d69c:	e986000c 	stmib	r6, {r2, r3}
33d1d6a0:	e5962000 	ldr	r2, [r6]
33d1d6a4:	e596001c 	ldr	r0, [r6, #28]
33d1d6a8:	e4d21001 	ldrb	r1, [r2], #1
33d1d6ac:	e5903008 	ldr	r3, [r0, #8]
33d1d6b0:	e0833801 	add	r3, r3, r1, lsl #16
33d1d6b4:	e5862000 	str	r2, [r6]
33d1d6b8:	e5803008 	str	r3, [r0, #8]
      z->state->mode = CHECK2;
33d1d6bc:	e596201c 	ldr	r2, [r6, #28]
33d1d6c0:	e3a03005 	mov	r3, #5	; 0x5
33d1d6c4:	e5823000 	str	r3, [r2]
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
33d1d6c8:	e3a07000 	mov	r7, #0	; 0x0
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
33d1d6cc:	e5962004 	ldr	r2, [r6, #4]
33d1d6d0:	e3520000 	cmp	r2, #0	; 0x0
33d1d6d4:	0a00002f 	beq	33d1d798 <inflate+0x1c70>
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
33d1d6d8:	e5963008 	ldr	r3, [r6, #8]
33d1d6dc:	e2422001 	sub	r2, r2, #1	; 0x1
33d1d6e0:	e2833001 	add	r3, r3, #1	; 0x1
33d1d6e4:	e986000c 	stmib	r6, {r2, r3}
33d1d6e8:	e5962000 	ldr	r2, [r6]
33d1d6ec:	e596001c 	ldr	r0, [r6, #28]
33d1d6f0:	e4d21001 	ldrb	r1, [r2], #1
33d1d6f4:	e5903008 	ldr	r3, [r0, #8]
33d1d6f8:	e0833401 	add	r3, r3, r1, lsl #8
33d1d6fc:	e5862000 	str	r2, [r6]
33d1d700:	e5803008 	str	r3, [r0, #8]
      z->state->mode = CHECK1;
33d1d704:	e596201c 	ldr	r2, [r6, #28]
33d1d708:	e3a03006 	mov	r3, #6	; 0x6
33d1d70c:	e5823000 	str	r3, [r2]
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
33d1d710:	e3a07000 	mov	r7, #0	; 0x0
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
33d1d714:	e5962004 	ldr	r2, [r6, #4]
33d1d718:	e3520000 	cmp	r2, #0	; 0x0
33d1d71c:	0a00001d 	beq	33d1d798 <inflate+0x1c70>
      z->state->sub.check.need += (uLong)NEXTBYTE;
33d1d720:	e5963008 	ldr	r3, [r6, #8]
33d1d724:	e2422001 	sub	r2, r2, #1	; 0x1
33d1d728:	e2833001 	add	r3, r3, #1	; 0x1
33d1d72c:	e986000c 	stmib	r6, {r2, r3}
33d1d730:	e5962000 	ldr	r2, [r6]
33d1d734:	e596001c 	ldr	r0, [r6, #28]
33d1d738:	e4d21001 	ldrb	r1, [r2], #1
33d1d73c:	e5903008 	ldr	r3, [r0, #8]
33d1d740:	e0833001 	add	r3, r3, r1
33d1d744:	e5862000 	str	r2, [r6]
33d1d748:	e5803008 	str	r3, [r0, #8]

      if (z->state->sub.check.was != z->state->sub.check.need)
33d1d74c:	e596101c 	ldr	r1, [r6, #28]
33d1d750:	e991000c 	ldmib	r1, {r2, r3}
33d1d754:	e1520003 	cmp	r2, r3
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
33d1d758:	e3a07000 	mov	r7, #0	; 0x0
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
33d1d75c:	0a000007 	beq	33d1d780 <inflate+0x1c58>
      {
	z->state->mode = BAD;
33d1d760:	e3a03008 	mov	r3, #8	; 0x8
33d1d764:	e5813000 	str	r3, [r1]
	z->msg = "incorrect data check";
33d1d768:	e51f3b98 	ldr	r3, [pc, #-2968]	; 33d1cbd8 <inflate+0x10b0>
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1d76c:	e596201c 	ldr	r2, [r6, #28]
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
	z->state->mode = BAD;
	z->msg = "incorrect data check";
33d1d770:	e5863018 	str	r3, [r6, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
33d1d774:	e3a03005 	mov	r3, #5	; 0x5
33d1d778:	e5823004 	str	r3, [r2, #4]
	break;
33d1d77c:	eafff8f2 	b	33d1bb4c <inflate+0x24>
      }
      Trace((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
33d1d780:	e3a03007 	mov	r3, #7	; 0x7
33d1d784:	e5813000 	str	r3, [r1]
    case DONE:
      return Z_STREAM_END;
33d1d788:	e3a00001 	mov	r0, #1	; 0x1
33d1d78c:	ea00000d 	b	33d1d7c8 <inflate+0x1ca0>
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
33d1d790:	e3e00001 	mvn	r0, #1	; 0x1
33d1d794:	ea00000b 	b	33d1d7c8 <inflate+0x1ca0>
  }

 empty:
  if (f != Z_PACKET_FLUSH)
33d1d798:	e59d0058 	ldr	r0, [sp, #88]
33d1d79c:	e3500005 	cmp	r0, #5	; 0x5
33d1d7a0:	0a000001 	beq	33d1d7ac <inflate+0x1c84>
	z->state->mode = BAD;
	z->state->sub.marker = 0;       /* can try inflateSync */
	break;
      }
      if (r != Z_STREAM_END)
	return r;
33d1d7a4:	e1a00007 	mov	r0, r7
33d1d7a8:	ea000006 	b	33d1d7c8 <inflate+0x1ca0>
  }

 empty:
  if (f != Z_PACKET_FLUSH)
    return r;
  z->state->mode = BAD;
33d1d7ac:	e596201c 	ldr	r2, [r6, #28]
33d1d7b0:	e3a03008 	mov	r3, #8	; 0x8
33d1d7b4:	e5823000 	str	r3, [r2]
  z->state->sub.marker = 0;       /* can try inflateSync */
33d1d7b8:	e596201c 	ldr	r2, [r6, #28]
33d1d7bc:	e2433008 	sub	r3, r3, #8	; 0x8
33d1d7c0:	e5823004 	str	r3, [r2, #4]
  return Z_DATA_ERROR;
33d1d7c4:	e3e00002 	mvn	r0, #2	; 0x2
}
33d1d7c8:	e28dde53 	add	sp, sp, #1328	; 0x530
33d1d7cc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d1d7d0 <adler32>:
/* ========================================================================= */
uLong adler32(adler, buf, len)
    uLong adler;
    Bytef *buf;
    uInt len;
{
33d1d7d0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned long s1 = adler & 0xffff;
33d1d7d4:	e1a07800 	lsl	r7, r0, #16
/* ========================================================================= */
uLong adler32(adler, buf, len)
    uLong adler;
    Bytef *buf;
    uInt len;
{
33d1d7d8:	e24dd004 	sub	sp, sp, #4	; 0x4
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;
33d1d7dc:	e2519000 	subs	r9, r1, #0	; 0x0
    uLong adler;
    Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
33d1d7e0:	e1a0a820 	lsr	sl, r0, #16
/* ========================================================================= */
uLong adler32(adler, buf, len)
    uLong adler;
    Bytef *buf;
    uInt len;
{
33d1d7e4:	e58d2000 	str	r2, [sp]
    unsigned long s1 = adler & 0xffff;
33d1d7e8:	e1a07827 	lsr	r7, r7, #16
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;
33d1d7ec:	03a00001 	moveq	r0, #1	; 0x1
33d1d7f0:	0a00004f 	beq	33d1d934 <adler32+0x164>
	}
	if (k != 0) do {
	    DO1(buf);
	} while (--k);
	s1 %= BASE;
	s2 %= BASE;
33d1d7f4:	e59d3000 	ldr	r3, [sp]
33d1d7f8:	e3530000 	cmp	r3, #0	; 0x0
33d1d7fc:	0a00004b 	beq	33d1d930 <adler32+0x160>
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
	k = len < NMAX ? len : NMAX;
33d1d800:	e59f3134 	ldr	r3, [pc, #308]	; 33d1d93c <adler32+0x16c>
33d1d804:	e59db000 	ldr	fp, [sp]
33d1d808:	e15b0003 	cmp	fp, r3
33d1d80c:	21a0b003 	movcs	fp, r3
	len -= k;
33d1d810:	e59d3000 	ldr	r3, [sp]
33d1d814:	e06b3003 	rsb	r3, fp, r3
33d1d818:	e58d3000 	str	r3, [sp]
	while (k >= 16) {
	    DO16(buf);
	    k -= 16;
33d1d81c:	e35b000f 	cmp	fp, #15	; 0xf
33d1d820:	da000032 	ble	33d1d8f0 <adler32+0x120>

    while (len > 0) {
	k = len < NMAX ? len : NMAX;
	len -= k;
	while (k >= 16) {
	    DO16(buf);
33d1d824:	e4d93001 	ldrb	r3, [r9], #1
33d1d828:	e4d92001 	ldrb	r2, [r9], #1
33d1d82c:	e4d91001 	ldrb	r1, [r9], #1
33d1d830:	e4d90001 	ldrb	r0, [r9], #1
33d1d834:	e4d9c001 	ldrb	ip, [r9], #1
33d1d838:	e4d9e001 	ldrb	lr, [r9], #1
33d1d83c:	e4d94001 	ldrb	r4, [r9], #1
33d1d840:	e4d95001 	ldrb	r5, [r9], #1
33d1d844:	e4d96001 	ldrb	r6, [r9], #1
33d1d848:	e0877003 	add	r7, r7, r3
33d1d84c:	e08aa007 	add	sl, sl, r7
33d1d850:	e4d93001 	ldrb	r3, [r9], #1
33d1d854:	e0877002 	add	r7, r7, r2
33d1d858:	e08aa007 	add	sl, sl, r7
33d1d85c:	e0877001 	add	r7, r7, r1
33d1d860:	e08aa007 	add	sl, sl, r7
33d1d864:	e0877000 	add	r7, r7, r0
33d1d868:	e4d90001 	ldrb	r0, [r9], #1
33d1d86c:	e08aa007 	add	sl, sl, r7
33d1d870:	e087700c 	add	r7, r7, ip
33d1d874:	e4d92001 	ldrb	r2, [r9], #1
33d1d878:	e08aa007 	add	sl, sl, r7
33d1d87c:	e087700e 	add	r7, r7, lr
33d1d880:	e08aa007 	add	sl, sl, r7
33d1d884:	e0877004 	add	r7, r7, r4
33d1d888:	e4d91001 	ldrb	r1, [r9], #1
33d1d88c:	e08aa007 	add	sl, sl, r7
33d1d890:	e0877005 	add	r7, r7, r5
33d1d894:	e08aa007 	add	sl, sl, r7
33d1d898:	e0877006 	add	r7, r7, r6
33d1d89c:	e08aa007 	add	sl, sl, r7
33d1d8a0:	e0877003 	add	r7, r7, r3
33d1d8a4:	e4d93001 	ldrb	r3, [r9], #1
33d1d8a8:	e08aa007 	add	sl, sl, r7
33d1d8ac:	e0877000 	add	r7, r7, r0
33d1d8b0:	e08aa007 	add	sl, sl, r7
33d1d8b4:	e0877002 	add	r7, r7, r2
33d1d8b8:	e4d92001 	ldrb	r2, [r9], #1
33d1d8bc:	e08aa007 	add	sl, sl, r7
33d1d8c0:	e0877001 	add	r7, r7, r1
33d1d8c4:	e08aa007 	add	sl, sl, r7
33d1d8c8:	e0877003 	add	r7, r7, r3
33d1d8cc:	e4d93001 	ldrb	r3, [r9], #1
33d1d8d0:	e08aa007 	add	sl, sl, r7
33d1d8d4:	e0877002 	add	r7, r7, r2
33d1d8d8:	e08aa007 	add	sl, sl, r7
	    k -= 16;
33d1d8dc:	e24bb010 	sub	fp, fp, #16	; 0x10

    while (len > 0) {
	k = len < NMAX ? len : NMAX;
	len -= k;
	while (k >= 16) {
	    DO16(buf);
33d1d8e0:	e0877003 	add	r7, r7, r3
	    k -= 16;
33d1d8e4:	e35b000f 	cmp	fp, #15	; 0xf

    while (len > 0) {
	k = len < NMAX ? len : NMAX;
	len -= k;
	while (k >= 16) {
	    DO16(buf);
33d1d8e8:	e08aa007 	add	sl, sl, r7
33d1d8ec:	eaffffcb 	b	33d1d820 <adler32+0x50>
	    k -= 16;
	}
	if (k != 0) do {
33d1d8f0:	e35b0000 	cmp	fp, #0	; 0x0
33d1d8f4:	0a000004 	beq	33d1d90c <adler32+0x13c>
	    DO1(buf);
33d1d8f8:	e4d93001 	ldrb	r3, [r9], #1
	} while (--k);
33d1d8fc:	e25bb001 	subs	fp, fp, #1	; 0x1
	while (k >= 16) {
	    DO16(buf);
	    k -= 16;
	}
	if (k != 0) do {
	    DO1(buf);
33d1d900:	e0877003 	add	r7, r7, r3
33d1d904:	e08aa007 	add	sl, sl, r7
	} while (--k);
33d1d908:	1afffffa 	bne	33d1d8f8 <adler32+0x128>
	s1 %= BASE;
33d1d90c:	e1a00007 	mov	r0, r7
33d1d910:	e59f1028 	ldr	r1, [pc, #40]	; 33d1d940 <adler32+0x170>
33d1d914:	eb0003e1 	bl	33d1e8a0 <__umodsi3>
	s2 %= BASE;
33d1d918:	e59f1020 	ldr	r1, [pc, #32]	; 33d1d940 <adler32+0x170>
	    k -= 16;
	}
	if (k != 0) do {
	    DO1(buf);
	} while (--k);
	s1 %= BASE;
33d1d91c:	e1a07000 	mov	r7, r0
	s2 %= BASE;
33d1d920:	e1a0000a 	mov	r0, sl
33d1d924:	eb0003dd 	bl	33d1e8a0 <__umodsi3>
33d1d928:	e1a0a000 	mov	sl, r0
33d1d92c:	eaffffb0 	b	33d1d7f4 <adler32+0x24>
    }
    return (s2 << 16) | s1;
33d1d930:	e187080a 	orr	r0, r7, sl, lsl #16
}
33d1d934:	e28dd004 	add	sp, sp, #4	; 0x4
33d1d938:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1d93c:	000015b0 	.word	0x000015b0
33d1d940:	0000fff1 	.word	0x0000fff1

33d1d944 <board_init>:
int board_init (void)
{
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

	/* set up the I/O ports */
	gpio->GPACON = 0x007FFFFF;
33d1d944:	e59f20a4 	ldr	r2, [pc, #164]	; 33d1d9f0 <board_init+0xac>
33d1d948:	e3a03456 	mov	r3, #1442840576	; 0x56000000

/*
 * Miscellaneous platform dependent initialisations
 */
int board_init (void)
{
33d1d94c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

	/* set up the I/O ports */
	gpio->GPACON = 0x007FFFFF;
33d1d950:	e5832000 	str	r2, [r3]
	gpio->GPBCON = 0x00055555;
33d1d954:	e59f2098 	ldr	r2, [pc, #152]	; 33d1d9f4 <board_init+0xb0>
	gpio->GPBUP = 0x000007FF;
	gpio->GPCCON = 0xAAAAAAAA;
33d1d958:	e59f1098 	ldr	r1, [pc, #152]	; 33d1d9f8 <board_init+0xb4>
{
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

	/* set up the I/O ports */
	gpio->GPACON = 0x007FFFFF;
	gpio->GPBCON = 0x00055555;
33d1d95c:	e5832010 	str	r2, [r3, #16]
	gpio->GPBUP = 0x000007FF;
	gpio->GPCCON = 0xAAAAAAAA;
	gpio->GPCUP = 0x0000FFFF;
33d1d960:	e59f0094 	ldr	r0, [pc, #148]	; 33d1d9fc <board_init+0xb8>
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

	/* set up the I/O ports */
	gpio->GPACON = 0x007FFFFF;
	gpio->GPBCON = 0x00055555;
	gpio->GPBUP = 0x000007FF;
33d1d964:	e59fc094 	ldr	ip, [pc, #148]	; 33d1da00 <board_init+0xbc>
	gpio->GPCUP = 0x0000FFFF;
	gpio->GPDCON = 0xAAAAAAAA;
	gpio->GPDUP = 0x0000FFFF;
	gpio->GPECON = 0xAAAAAAAA;
	gpio->GPEUP = 0x0000FFFF;
	gpio->GPFCON = 0x000055AA;
33d1d968:	e59f2094 	ldr	r2, [pc, #148]	; 33d1da04 <board_init+0xc0>
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

	/* set up the I/O ports */
	gpio->GPACON = 0x007FFFFF;
	gpio->GPBCON = 0x00055555;
	gpio->GPBUP = 0x000007FF;
33d1d96c:	e583c018 	str	ip, [r3, #24]
	gpio->GPCCON = 0xAAAAAAAA;
33d1d970:	e5831020 	str	r1, [r3, #32]
	gpio->GPCUP = 0x0000FFFF;
33d1d974:	e5830028 	str	r0, [r3, #40]
	gpio->GPDCON = 0xAAAAAAAA;
33d1d978:	e5831030 	str	r1, [r3, #48]
	gpio->GPDUP = 0x0000FFFF;
33d1d97c:	e5830038 	str	r0, [r3, #56]
	gpio->GPECON = 0xAAAAAAAA;
33d1d980:	e5831040 	str	r1, [r3, #64]
	gpio->GPEUP = 0x0000FFFF;
33d1d984:	e5830048 	str	r0, [r3, #72]
	gpio->GPFCON = 0x000055AA;
33d1d988:	e5832050 	str	r2, [r3, #80]
	gpio->GPFUP = 0x000000FF;
33d1d98c:	e3a020ff 	mov	r2, #255	; 0xff
33d1d990:	e5832058 	str	r2, [r3, #88]
	gpio->GPGCON = 0xFF94FFBA;
33d1d994:	e59f206c 	ldr	r2, [pc, #108]	; 33d1da08 <board_init+0xc4>
33d1d998:	e5832060 	str	r2, [r3, #96]
	gpio->GPGUP = 0x0000FFEF;
33d1d99c:	e59f2068 	ldr	r2, [pc, #104]	; 33d1da0c <board_init+0xc8>
33d1d9a0:	e5832068 	str	r2, [r3, #104]
	gpio->GPGDAT = gpio->GPGDAT & ((~(1<<4)) | (1<<4)) ;
33d1d9a4:	e5932064 	ldr	r2, [r3, #100]
33d1d9a8:	e5832064 	str	r2, [r3, #100]
	gpio->GPHCON = 0x002AFAAA;
33d1d9ac:	e59f205c 	ldr	r2, [pc, #92]	; 33d1da10 <board_init+0xcc>
33d1d9b0:	e5832070 	str	r2, [r3, #112]
	gpio->GPHUP = 0x000007FF;
	gpio->GPJCON = 0x02aaaaaa;
33d1d9b4:	e59f2058 	ldr	r2, [pc, #88]	; 33d1da14 <board_init+0xd0>
	gpio->GPFUP = 0x000000FF;
	gpio->GPGCON = 0xFF94FFBA;
	gpio->GPGUP = 0x0000FFEF;
	gpio->GPGDAT = gpio->GPGDAT & ((~(1<<4)) | (1<<4)) ;
	gpio->GPHCON = 0x002AFAAA;
	gpio->GPHUP = 0x000007FF;
33d1d9b8:	e583c078 	str	ip, [r3, #120]
	gpio->GPJCON = 0x02aaaaaa;
33d1d9bc:	e58320d0 	str	r2, [r3, #208]
	gpio->GPJUP = 0x00001fff;
33d1d9c0:	e59f2050 	ldr	r2, [pc, #80]	; 33d1da18 <board_init+0xd4>
33d1d9c4:	e58320d8 	str	r2, [r3, #216]

//	S3C24X0_I2S * const i2s = S3C24X0_GetBase_I2S();	//HJ_add 屏蔽IIS,
//	i2s->IISCON = 0x00;					//HJ_add 屏蔽IIS,

	/* arch number of TQ2440-Board */
	gd->bd->bi_arch_number = MACH_TYPE_S3C2440;
33d1d9c8:	e5982000 	ldr	r2, [r8]
33d1d9cc:	e3a030a8 	mov	r3, #168	; 0xa8
33d1d9d0:	e5823014 	str	r3, [r2, #20]

	/* adress of boot parameters */
	gd->bd->bi_boot_params = 0x30000100;
33d1d9d4:	e59f3040 	ldr	r3, [pc, #64]	; 33d1da1c <board_init+0xd8>
33d1d9d8:	e5982000 	ldr	r2, [r8]
33d1d9dc:	e5823018 	str	r3, [r2, #24]

	icache_enable();
33d1d9e0:	eb000211 	bl	33d1e22c <icache_enable>
	dcache_enable();
33d1d9e4:	eb000223 	bl	33d1e278 <dcache_enable>

	return 0;
}
33d1d9e8:	e3a00000 	mov	r0, #0	; 0x0
33d1d9ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1d9f0:	007fffff 	.word	0x007fffff
33d1d9f4:	00055555 	.word	0x00055555
33d1d9f8:	aaaaaaaa 	.word	0xaaaaaaaa
33d1d9fc:	0000ffff 	.word	0x0000ffff
33d1da00:	000007ff 	.word	0x000007ff
33d1da04:	000055aa 	.word	0x000055aa
33d1da08:	ff94ffba 	.word	0xff94ffba
33d1da0c:	0000ffef 	.word	0x0000ffef
33d1da10:	002afaaa 	.word	0x002afaaa
33d1da14:	02aaaaaa 	.word	0x02aaaaaa
33d1da18:	00001fff 	.word	0x00001fff
33d1da1c:	30000100 	.word	0x30000100

33d1da20 <dram_init>:

int dram_init (void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
33d1da20:	e5982000 	ldr	r2, [r8]
33d1da24:	e3a03203 	mov	r3, #805306368	; 0x30000000
33d1da28:	e582301c 	str	r3, [r2, #28]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
33d1da2c:	e5982000 	ldr	r2, [r8]
33d1da30:	e2833335 	add	r3, r3, #-738197504	; 0xd4000000

	return 0;
}
33d1da34:	e3a00000 	mov	r0, #0	; 0x0
}

int dram_init (void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
33d1da38:	e5823020 	str	r3, [r2, #32]

	return 0;
}
33d1da3c:	e1a0f00e 	mov	pc, lr

33d1da40 <flash_init>:

/*-----------------------------------------------------------------------
 */

ulong flash_init (void)
{
33d1da40:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int i, j;
	ulong size = 0;
33d1da44:	e3a06000 	mov	r6, #0	; 0x0

/*-----------------------------------------------------------------------
 */

ulong flash_init (void)
{
33d1da48:	e24dd004 	sub	sp, sp, #4	; 0x4
33d1da4c:	e59f5130 	ldr	r5, [pc, #304]	; 33d1db84 <flash_init+0x144>
33d1da50:	e58d6000 	str	r6, [sp]
	int i, j;
	ulong size = 0;

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
33d1da54:	e1a07006 	mov	r7, r6
33d1da58:	e1a0a006 	mov	sl, r6
33d1da5c:	e1a0b006 	mov	fp, r6
33d1da60:	e1a09006 	mov	r9, r6
		ulong flashbase = 0;

		flash_info[i].flash_id =
33d1da64:	e59fc118 	ldr	ip, [pc, #280]	; 33d1db84 <flash_init+0x144>
33d1da68:	e59f3118 	ldr	r3, [pc, #280]	; 33d1db88 <flash_init+0x148>
{
	int i, j;
	ulong size = 0;

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
		ulong flashbase = 0;
33d1da6c:	e3a04000 	mov	r4, #0	; 0x0
#else
#error "Unknown flash configured"
#endif
			flash_info[i].size = FLASH_BANK_SIZE;
		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
33d1da70:	e28c0058 	add	r0, ip, #88	; 0x58
	ulong size = 0;

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
		ulong flashbase = 0;

		flash_info[i].flash_id =
33d1da74:	e5853008 	str	r3, [r5, #8]
			(AMD_MANUFACT & FLASH_VENDMASK) |
			(AMD_ID_LV800B & FLASH_TYPEMASK);
#else
#error "Unknown flash configured"
#endif
			flash_info[i].size = FLASH_BANK_SIZE;
33d1da78:	e3a03602 	mov	r3, #2097152	; 0x200000
		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
33d1da7c:	e1a01004 	mov	r1, r4
			(AMD_MANUFACT & FLASH_VENDMASK) |
			(AMD_ID_LV800B & FLASH_TYPEMASK);
#else
#error "Unknown flash configured"
#endif
			flash_info[i].size = FLASH_BANK_SIZE;
33d1da80:	e78a300c 	str	r3, [sl, ip]
		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
33d1da84:	e08a0000 	add	r0, sl, r0
			(AMD_ID_LV800B & FLASH_TYPEMASK);
#else
#error "Unknown flash configured"
#endif
			flash_info[i].size = FLASH_BANK_SIZE;
		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
33d1da88:	e3a03013 	mov	r3, #19	; 0x13
		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
33d1da8c:	e3a02013 	mov	r2, #19	; 0x13
			(AMD_ID_LV800B & FLASH_TYPEMASK);
#else
#error "Unknown flash configured"
#endif
			flash_info[i].size = FLASH_BANK_SIZE;
		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
33d1da90:	e1c530b4 	strh	r3, [r5, #4]
		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
33d1da94:	ebfff23e 	bl	33d1a394 <memset>
		if (i == 0)
33d1da98:	e1570004 	cmp	r7, r4
			flashbase = PHYS_FLASH_1;
33d1da9c:	01a04007 	moveq	r4, r7
		else
			panic ("configured too many flash banks!\n");
33d1daa0:	159f00e4 	ldrne	r0, [pc, #228]	; 33d1db8c <flash_init+0x14c>
33d1daa4:	1bfff49a 	blne	33d1ad14 <panic>
		for (j = 0; j < flash_info[i].sector_count; j++) {
33d1daa8:	e1d530b4 	ldrh	r3, [r5, #4]
33d1daac:	e3a00000 	mov	r0, #0	; 0x0
33d1dab0:	e1500003 	cmp	r0, r3
33d1dab4:	aa000016 	bge	33d1db14 <flash_init+0xd4>
				if (j == 3) {
					flash_info[i].start[j] =
						flashbase + 0x8000;
				}
			} else {
				flash_info[i].start[j] =
33d1dab8:	e59f20c4 	ldr	r2, [pc, #196]	; 33d1db84 <flash_init+0x144>
33d1dabc:	e08b3000 	add	r3, fp, r0
33d1dac0:	e1a01800 	lsl	r1, r0, #16
33d1dac4:	e0823103 	add	r3, r2, r3, lsl #2
		if (i == 0)
			flashbase = PHYS_FLASH_1;
		else
			panic ("configured too many flash banks!\n");
		for (j = 0; j < flash_info[i].sector_count; j++) {
			if (j <= 3) {
33d1dac8:	e3500003 	cmp	r0, #3	; 0x3
				if (j == 3) {
					flash_info[i].start[j] =
						flashbase + 0x8000;
				}
			} else {
				flash_info[i].start[j] =
33d1dacc:	e2411803 	sub	r1, r1, #196608	; 0x30000
					flash_info[i].start[j] =
						flashbase + 0;
				}

				/* 2nd and 3rd are both 8 KB */
				if ((j == 1) || (j == 2)) {
33d1dad0:	e240c001 	sub	ip, r0, #1	; 0x1
				if (j == 3) {
					flash_info[i].start[j] =
						flashbase + 0x8000;
				}
			} else {
				flash_info[i].start[j] =
33d1dad4:	c583100c 	strgt	r1, [r3, #12]
		if (i == 0)
			flashbase = PHYS_FLASH_1;
		else
			panic ("configured too many flash banks!\n");
		for (j = 0; j < flash_info[i].sector_count; j++) {
			if (j <= 3) {
33d1dad8:	ca00000a 	bgt	33d1db08 <flash_init+0xc8>
				/* 1st one is 16 KB */
				if (j == 0) {
33d1dadc:	e3500000 	cmp	r0, #0	; 0x0
						flashbase + 0;
				}

				/* 2nd and 3rd are both 8 KB */
				if ((j == 1) || (j == 2)) {
					flash_info[i].start[j] =
33d1dae0:	e0893000 	add	r3, r9, r0
33d1dae4:	e1a01680 	lsl	r1, r0, #13
33d1dae8:	e0823103 	add	r3, r2, r3, lsl #2
			panic ("configured too many flash banks!\n");
		for (j = 0; j < flash_info[i].sector_count; j++) {
			if (j <= 3) {
				/* 1st one is 16 KB */
				if (j == 0) {
					flash_info[i].start[j] =
33d1daec:	0585400c 	streq	r4, [r5, #12]
						flashbase + 0;
				}

				/* 2nd and 3rd are both 8 KB */
				if ((j == 1) || (j == 2)) {
					flash_info[i].start[j] =
33d1daf0:	e2811a02 	add	r1, r1, #8192	; 0x2000
					flash_info[i].start[j] =
						flashbase + 0;
				}

				/* 2nd and 3rd are both 8 KB */
				if ((j == 1) || (j == 2)) {
33d1daf4:	e35c0001 	cmp	ip, #1	; 0x1
					flash_info[i].start[j] =
33d1daf8:	9583100c 	strls	r1, [r3, #12]
								      1) *
						0x2000;
				}

				/* 4th 32 KB */
				if (j == 3) {
33d1dafc:	e3500003 	cmp	r0, #3	; 0x3
					flash_info[i].start[j] =
33d1db00:	03a03902 	moveq	r3, #32768	; 0x8000
33d1db04:	05853018 	streq	r3, [r5, #24]
		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
		if (i == 0)
			flashbase = PHYS_FLASH_1;
		else
			panic ("configured too many flash banks!\n");
		for (j = 0; j < flash_info[i].sector_count; j++) {
33d1db08:	e1d530b4 	ldrh	r3, [r5, #4]
33d1db0c:	e2800001 	add	r0, r0, #1	; 0x1
33d1db10:	eaffffe6 	b	33d1dab0 <flash_init+0x70>
			} else {
				flash_info[i].start[j] =
					flashbase + (j - 3) * MAIN_SECT_SIZE;
			}
		}
		size += flash_info[i].size;
33d1db14:	e59d2000 	ldr	r2, [sp]
33d1db18:	e59f4064 	ldr	r4, [pc, #100]	; 33d1db84 <flash_init+0x144>
ulong flash_init (void)
{
	int i, j;
	ulong size = 0;

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
33d1db1c:	e2877001 	add	r7, r7, #1	; 0x1
			} else {
				flash_info[i].start[j] =
					flashbase + (j - 3) * MAIN_SECT_SIZE;
			}
		}
		size += flash_info[i].size;
33d1db20:	e7943102 	ldr	r3, [r4, r2, lsl #2]
ulong flash_init (void)
{
	int i, j;
	ulong size = 0;

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
33d1db24:	e3570000 	cmp	r7, #0	; 0x0
33d1db28:	e282201b 	add	r2, r2, #27	; 0x1b
			} else {
				flash_info[i].start[j] =
					flashbase + (j - 3) * MAIN_SECT_SIZE;
			}
		}
		size += flash_info[i].size;
33d1db2c:	e0866003 	add	r6, r6, r3
33d1db30:	e289901b 	add	r9, r9, #27	; 0x1b
33d1db34:	e28bb01b 	add	fp, fp, #27	; 0x1b
33d1db38:	e58d2000 	str	r2, [sp]
33d1db3c:	e28aa06c 	add	sl, sl, #108	; 0x6c
33d1db40:	e285506c 	add	r5, r5, #108	; 0x6c
ulong flash_init (void)
{
	int i, j;
	ulong size = 0;

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
33d1db44:	daffffc6 	ble	33d1da64 <flash_init+0x24>
			}
		}
		size += flash_info[i].size;
	}

	flash_protect (FLAG_PROTECT_SET,
33d1db48:	e59f3040 	ldr	r3, [pc, #64]	; 33d1db90 <flash_init+0x150>
33d1db4c:	e5932000 	ldr	r2, [r3]
33d1db50:	e3a00001 	mov	r0, #1	; 0x1
33d1db54:	e1a03004 	mov	r3, r4
33d1db58:	e2422001 	sub	r2, r2, #1	; 0x1
33d1db5c:	e3a01000 	mov	r1, #0	; 0x0
33d1db60:	ebffeb15 	bl	33d187bc <flash_protect>
		       CFG_FLASH_BASE,
		       CFG_FLASH_BASE + monitor_flash_len - 1,
		       &flash_info[0]);

	flash_protect (FLAG_PROTECT_SET,
33d1db64:	e1a03004 	mov	r3, r4
33d1db68:	e3a00001 	mov	r0, #1	; 0x1
33d1db6c:	e3a0181f 	mov	r1, #2031616	; 0x1f0000
33d1db70:	e59f201c 	ldr	r2, [pc, #28]	; 33d1db94 <flash_init+0x154>
33d1db74:	ebffeb10 	bl	33d187bc <flash_protect>
		       CFG_ENV_ADDR,
		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);

	return size;
}
33d1db78:	e1a00006 	mov	r0, r6
33d1db7c:	e28dd004 	add	sp, sp, #4	; 0x4
33d1db80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1db84:	33d62554 	.word	0x33d62554
33d1db88:	0001225b 	.word	0x0001225b
33d1db8c:	33d2d0b4 	.word	0x33d2d0b4
33d1db90:	33d3725c 	.word	0x33d3725c
33d1db94:	0020ffff 	.word	0x0020ffff

33d1db98 <flash_print_info>:

/*-----------------------------------------------------------------------
 */
void flash_print_info (flash_info_t * info)
{
33d1db98:	e92d4030 	push	{r4, r5, lr}
	int i;

	switch (info->flash_id & FLASH_VENDMASK) {
33d1db9c:	e5903008 	ldr	r3, [r0, #8]
33d1dba0:	e1a03823 	lsr	r3, r3, #16
33d1dba4:	e1a03803 	lsl	r3, r3, #16
33d1dba8:	e3530801 	cmp	r3, #65536	; 0x10000
}

/*-----------------------------------------------------------------------
 */
void flash_print_info (flash_info_t * info)
{
33d1dbac:	e1a05000 	mov	r5, r0
	int i;

	switch (info->flash_id & FLASH_VENDMASK) {
	case (AMD_MANUFACT & FLASH_VENDMASK):
		printf ("AMD: ");
33d1dbb0:	059f00c0 	ldreq	r0, [pc, #192]	; 33d1dc78 <flash_print_info+0xe0>
		break;
	default:
		printf ("Unknown Vendor ");
33d1dbb4:	159f00c0 	ldrne	r0, [pc, #192]	; 33d1dc7c <flash_print_info+0xe4>
33d1dbb8:	ebffe502 	bl	33d16fc8 <printf>
		break;
	}

	switch (info->flash_id & FLASH_TYPEMASK) {
33d1dbbc:	e1d520b8 	ldrh	r2, [r5, #8]
33d1dbc0:	e59f30b8 	ldr	r3, [pc, #184]	; 33d1dc80 <flash_print_info+0xe8>
33d1dbc4:	e1520003 	cmp	r2, r3
33d1dbc8:	0a000004 	beq	33d1dbe0 <flash_print_info+0x48>
33d1dbcc:	e283305f 	add	r3, r3, #95	; 0x5f
33d1dbd0:	e1520003 	cmp	r2, r3
	case (AMD_ID_LV400B & FLASH_TYPEMASK):
		printf ("1x Amd29LV400BB (4Mbit)\n");
33d1dbd4:	059f00a8 	ldreq	r0, [pc, #168]	; 33d1dc84 <flash_print_info+0xec>
	default:
		printf ("Unknown Vendor ");
		break;
	}

	switch (info->flash_id & FLASH_TYPEMASK) {
33d1dbd8:	0a000004 	beq	33d1dbf0 <flash_print_info+0x58>
33d1dbdc:	ea000001 	b	33d1dbe8 <flash_print_info+0x50>
	case (AMD_ID_LV400B & FLASH_TYPEMASK):
		printf ("1x Amd29LV400BB (4Mbit)\n");
		break;
	case (AMD_ID_LV800B & FLASH_TYPEMASK):
		printf ("1x Amd29LV800BB (8Mbit)\n");
33d1dbe0:	e59f00a0 	ldr	r0, [pc, #160]	; 33d1dc88 <flash_print_info+0xf0>
33d1dbe4:	ea000001 	b	33d1dbf0 <flash_print_info+0x58>
		break;
	default:
		printf ("Unknown Chip Type\n");
33d1dbe8:	e59f009c 	ldr	r0, [pc, #156]	; 33d1dc8c <flash_print_info+0xf4>
33d1dbec:	ea00001f 	b	33d1dc70 <flash_print_info+0xd8>
	switch (info->flash_id & FLASH_TYPEMASK) {
	case (AMD_ID_LV400B & FLASH_TYPEMASK):
		printf ("1x Amd29LV400BB (4Mbit)\n");
		break;
	case (AMD_ID_LV800B & FLASH_TYPEMASK):
		printf ("1x Amd29LV800BB (8Mbit)\n");
33d1dbf0:	ebffe4f4 	bl	33d16fc8 <printf>
		printf ("Unknown Chip Type\n");
		goto Done;
		break;
	}

	printf ("  Size: %ld MB in %d Sectors\n",
33d1dbf4:	e5951000 	ldr	r1, [r5]
33d1dbf8:	e59f0090 	ldr	r0, [pc, #144]	; 33d1dc90 <flash_print_info+0xf8>
33d1dbfc:	e1a01a21 	lsr	r1, r1, #20
33d1dc00:	e1d520b4 	ldrh	r2, [r5, #4]
33d1dc04:	ebffe4ef 	bl	33d16fc8 <printf>
		info->size >> 20, info->sector_count);

	printf ("  Sector Start Addresses:");
33d1dc08:	e59f0084 	ldr	r0, [pc, #132]	; 33d1dc94 <flash_print_info+0xfc>
33d1dc0c:	ebffe4ed 	bl	33d16fc8 <printf>
	for (i = 0; i < info->sector_count; i++) {
33d1dc10:	e1d530b4 	ldrh	r3, [r5, #4]
33d1dc14:	e3a04000 	mov	r4, #0	; 0x0
33d1dc18:	e1540003 	cmp	r4, r3
33d1dc1c:	aa000012 	bge	33d1dc6c <flash_print_info+0xd4>
		if ((i % 5) == 0) {
33d1dc20:	e3a01005 	mov	r1, #5	; 0x5
33d1dc24:	e1a00004 	mov	r0, r4
33d1dc28:	eb0002dc 	bl	33d1e7a0 <__modsi3>
33d1dc2c:	e3500000 	cmp	r0, #0	; 0x0
			printf ("\n   ");
33d1dc30:	e59f0060 	ldr	r0, [pc, #96]	; 33d1dc98 <flash_print_info+0x100>
33d1dc34:	0bffe4e3 	bleq	33d16fc8 <printf>
		}
		printf (" %08lX%s", info->start[i],
33d1dc38:	e0843005 	add	r3, r4, r5
33d1dc3c:	e5d31058 	ldrb	r1, [r3, #88]
33d1dc40:	e59f3054 	ldr	r3, [pc, #84]	; 33d1dc9c <flash_print_info+0x104>
33d1dc44:	e0850104 	add	r0, r5, r4, lsl #2
33d1dc48:	e3510000 	cmp	r1, #0	; 0x0
33d1dc4c:	e59f204c 	ldr	r2, [pc, #76]	; 33d1dca0 <flash_print_info+0x108>
33d1dc50:	e590100c 	ldr	r1, [r0, #12]
33d1dc54:	01a02003 	moveq	r2, r3
33d1dc58:	e59f0044 	ldr	r0, [pc, #68]	; 33d1dca4 <flash_print_info+0x10c>
33d1dc5c:	ebffe4d9 	bl	33d16fc8 <printf>

	printf ("  Size: %ld MB in %d Sectors\n",
		info->size >> 20, info->sector_count);

	printf ("  Sector Start Addresses:");
	for (i = 0; i < info->sector_count; i++) {
33d1dc60:	e1d530b4 	ldrh	r3, [r5, #4]
33d1dc64:	e2844001 	add	r4, r4, #1	; 0x1
33d1dc68:	eaffffea 	b	33d1dc18 <flash_print_info+0x80>
			printf ("\n   ");
		}
		printf (" %08lX%s", info->start[i],
			info->protect[i] ? " (RO)" : "     ");
	}
	printf ("\n");
33d1dc6c:	e59f0034 	ldr	r0, [pc, #52]	; 33d1dca8 <flash_print_info+0x110>

      Done:;
}
33d1dc70:	e8bd4030 	pop	{r4, r5, lr}
			printf ("\n   ");
		}
		printf (" %08lX%s", info->start[i],
			info->protect[i] ? " (RO)" : "     ");
	}
	printf ("\n");
33d1dc74:	eaffe4d3 	b	33d16fc8 <printf>
33d1dc78:	33d2d0d8 	.word	0x33d2d0d8
33d1dc7c:	33d2d0e0 	.word	0x33d2d0e0
33d1dc80:	0000225b 	.word	0x0000225b
33d1dc84:	33d2d0f0 	.word	0x33d2d0f0
33d1dc88:	33d2d10c 	.word	0x33d2d10c
33d1dc8c:	33d2d128 	.word	0x33d2d128
33d1dc90:	33d2d13c 	.word	0x33d2d13c
33d1dc94:	33d2d15c 	.word	0x33d2d15c
33d1dc98:	33d2d178 	.word	0x33d2d178
33d1dc9c:	33d2d180 	.word	0x33d2d180
33d1dca0:	33d2d188 	.word	0x33d2d188
33d1dca4:	33d2d190 	.word	0x33d2d190
33d1dca8:	33d2bd80 	.word	0x33d2bd80

33d1dcac <flash_erase>:

/*-----------------------------------------------------------------------
 */

int flash_erase (flash_info_t * info, int s_first, int s_last)
{
33d1dcac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int rc = ERR_OK;
	int chip;

	/* first look for protection bits */

	if (info->flash_id == FLASH_UNKNOWN)
33d1dcb0:	e59f31e4 	ldr	r3, [pc, #484]	; 33d1de9c <flash_erase+0x1f0>

/*-----------------------------------------------------------------------
 */

int flash_erase (flash_info_t * info, int s_first, int s_last)
{
33d1dcb4:	e1a09000 	mov	r9, r0
	int rc = ERR_OK;
	int chip;

	/* first look for protection bits */

	if (info->flash_id == FLASH_UNKNOWN)
33d1dcb8:	e5900008 	ldr	r0, [r0, #8]
33d1dcbc:	e1500003 	cmp	r0, r3

/*-----------------------------------------------------------------------
 */

int flash_erase (flash_info_t * info, int s_first, int s_last)
{
33d1dcc0:	e24dd008 	sub	sp, sp, #8	; 0x8
33d1dcc4:	e1a05001 	mov	r5, r1
33d1dcc8:	e1a0a002 	mov	sl, r2
	ushort result;
	int iflag, cflag, prot, sect;
	int rc = ERR_OK;
33d1dccc:	e3a0b000 	mov	fp, #0	; 0x0
	int chip;

	/* first look for protection bits */

	if (info->flash_id == FLASH_UNKNOWN)
		return ERR_UNKNOWN_FLASH_TYPE;
33d1dcd0:	03a00040 	moveq	r0, #64	; 0x40
	int rc = ERR_OK;
	int chip;

	/* first look for protection bits */

	if (info->flash_id == FLASH_UNKNOWN)
33d1dcd4:	0a00006e 	beq	33d1de94 <flash_erase+0x1e8>
		return ERR_UNKNOWN_FLASH_TYPE;

	if ((s_first < 0) || (s_first > s_last)) {
33d1dcd8:	e1510002 	cmp	r1, r2
33d1dcdc:	d3a03000 	movle	r3, #0	; 0x0
33d1dce0:	c3a03001 	movgt	r3, #1	; 0x1
33d1dce4:	e1933fa1 	orrs	r3, r3, r1, lsr #31
		return ERR_INVAL;
33d1dce8:	13a00008 	movne	r0, #8	; 0x8
	/* first look for protection bits */

	if (info->flash_id == FLASH_UNKNOWN)
		return ERR_UNKNOWN_FLASH_TYPE;

	if ((s_first < 0) || (s_first > s_last)) {
33d1dcec:	1a000068 	bne	33d1de94 <flash_erase+0x1e8>
		return ERR_INVAL;
	}

	if ((info->flash_id & FLASH_VENDMASK) !=
33d1dcf0:	e1a03820 	lsr	r3, r0, #16
33d1dcf4:	e1a03803 	lsl	r3, r3, #16
33d1dcf8:	e3530801 	cmp	r3, #65536	; 0x10000
	    (AMD_MANUFACT & FLASH_VENDMASK)) {
		return ERR_UNKNOWN_FLASH_VENDOR;
33d1dcfc:	13a00020 	movne	r0, #32	; 0x20

	if ((s_first < 0) || (s_first > s_last)) {
		return ERR_INVAL;
	}

	if ((info->flash_id & FLASH_VENDMASK) !=
33d1dd00:	1a000063 	bne	33d1de94 <flash_erase+0x1e8>
	    (AMD_MANUFACT & FLASH_VENDMASK)) {
		return ERR_UNKNOWN_FLASH_VENDOR;
	}

	prot = 0;
	for (sect = s_first; sect <= s_last; ++sect) {
33d1dd04:	e1510002 	cmp	r1, r2
33d1dd08:	e1a04001 	mov	r4, r1
	if ((info->flash_id & FLASH_VENDMASK) !=
	    (AMD_MANUFACT & FLASH_VENDMASK)) {
		return ERR_UNKNOWN_FLASH_VENDOR;
	}

	prot = 0;
33d1dd0c:	e1a0200b 	mov	r2, fp
	for (sect = s_first; sect <= s_last; ++sect) {
33d1dd10:	ca00000e 	bgt	33d1dd50 <flash_erase+0xa4>
		if (info->protect[sect]) {
33d1dd14:	e0843009 	add	r3, r4, r9
33d1dd18:	e5d33058 	ldrb	r3, [r3, #88]
	    (AMD_MANUFACT & FLASH_VENDMASK)) {
		return ERR_UNKNOWN_FLASH_VENDOR;
	}

	prot = 0;
	for (sect = s_first; sect <= s_last; ++sect) {
33d1dd1c:	e2844001 	add	r4, r4, #1	; 0x1
		if (info->protect[sect]) {
33d1dd20:	e3530000 	cmp	r3, #0	; 0x0
			prot++;
33d1dd24:	12822001 	addne	r2, r2, #1	; 0x1
	    (AMD_MANUFACT & FLASH_VENDMASK)) {
		return ERR_UNKNOWN_FLASH_VENDOR;
	}

	prot = 0;
	for (sect = s_first; sect <= s_last; ++sect) {
33d1dd28:	e154000a 	cmp	r4, sl
33d1dd2c:	dafffff8 	ble	33d1dd14 <flash_erase+0x68>
		if (info->protect[sect]) {
			prot++;
		}
	}
	if (prot)
33d1dd30:	e3520000 	cmp	r2, #0	; 0x0
		return ERR_PROTECTED;
33d1dd34:	13a00004 	movne	r0, #4	; 0x4
	for (sect = s_first; sect <= s_last; ++sect) {
		if (info->protect[sect]) {
			prot++;
		}
	}
	if (prot)
33d1dd38:	1a000055 	bne	33d1de94 <flash_erase+0x1e8>
33d1dd3c:	ea000003 	b	33d1dd50 <flash_erase+0xa4>
			} while (!chip);

			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;

			if (chip == ERR) {
				rc = ERR_PROG_ERROR;
33d1dd40:	e3a0b080 	mov	fp, #128	; 0x80
				goto outahere;
33d1dd44:	ea000049 	b	33d1de70 <flash_erase+0x1c4>
			}
			if (chip == TMO) {
				rc = ERR_TIMOUT;
33d1dd48:	e3a0b001 	mov	fp, #1	; 0x1
				goto outahere;
33d1dd4c:	ea000047 	b	33d1de70 <flash_erase+0x1c4>
	 * here. Remember that our exception vectors are
	 * at address 0 in the flash, and we don't want a
	 * (ticker) exception to happen while the flash
	 * chip is in programming mode.
	 */
	cflag = icache_status ();
33d1dd50:	eb000143 	bl	33d1e264 <icache_status>
33d1dd54:	e58d0000 	str	r0, [sp]
	icache_disable ();
33d1dd58:	eb00013a 	bl	33d1e248 <icache_disable>
	iflag = disable_interrupts ();
33d1dd5c:	ebff8b3d 	bl	33d00a58 <disable_interrupts>

	/* Start erase on unprotected sectors */
	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
33d1dd60:	e1a04005 	mov	r4, r5
	 * (ticker) exception to happen while the flash
	 * chip is in programming mode.
	 */
	cflag = icache_status ();
	icache_disable ();
	iflag = disable_interrupts ();
33d1dd64:	e58d0004 	str	r0, [sp, #4]

	/* Start erase on unprotected sectors */
	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
33d1dd68:	ea000037 	b	33d1de4c <flash_erase+0x1a0>
				result = *addr;

				/* check timeout */
				if (get_timer_masked () >
				    CFG_FLASH_ERASE_TOUT) {
					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
33d1dd6c:	e59f312c 	ldr	r3, [pc, #300]	; 33d1dea0 <flash_erase+0x1f4>
33d1dd70:	e3a000f0 	mov	r0, #240	; 0xf0
					chip = TMO;
33d1dd74:	e3a06004 	mov	r6, #4	; 0x4
				result = *addr;

				/* check timeout */
				if (get_timer_masked () >
				    CFG_FLASH_ERASE_TOUT) {
					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
33d1dd78:	e1c300b0 	strh	r0, [r3]
					chip = TMO;
					break;
33d1dd7c:	ea000026 	b	33d1de1c <flash_erase+0x170>
	icache_disable ();
	iflag = disable_interrupts ();

	/* Start erase on unprotected sectors */
	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
		printf ("Erasing sector %2d ... ", sect);
33d1dd80:	e1a01004 	mov	r1, r4
33d1dd84:	e59f0118 	ldr	r0, [pc, #280]	; 33d1dea4 <flash_erase+0x1f8>
33d1dd88:	ebffe48e 	bl	33d16fc8 <printf>

		/* arm simple, non interrupt dependent timer */
		reset_timer_masked ();
33d1dd8c:	ebff8bed 	bl	33d00d48 <reset_timer_masked>

		if (info->protect[sect] == 0) {	/* not protected */
33d1dd90:	e0843009 	add	r3, r4, r9
33d1dd94:	e5d31058 	ldrb	r1, [r3, #88]
33d1dd98:	e3510000 	cmp	r1, #0	; 0x0
33d1dd9c:	1a000027 	bne	33d1de40 <flash_erase+0x194>
			vu_short *addr = (vu_short *) (info->start[sect]);
33d1dda0:	e0893104 	add	r3, r9, r4, lsl #2
33d1dda4:	e593700c 	ldr	r7, [r3, #12]

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
33d1dda8:	e59f20f8 	ldr	r2, [pc, #248]	; 33d1dea8 <flash_erase+0x1fc>
		reset_timer_masked ();

		if (info->protect[sect] == 0) {	/* not protected */
			vu_short *addr = (vu_short *) (info->start[sect]);

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
33d1ddac:	e59f30ec 	ldr	r3, [pc, #236]	; 33d1dea0 <flash_erase+0x1f4>
33d1ddb0:	e3a000aa 	mov	r0, #170	; 0xaa
			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
			*addr = CMD_ERASE_CONFIRM;

			/* wait until flash is ready */
			chip = 0;
33d1ddb4:	e1a06001 	mov	r6, r1

		if (info->protect[sect] == 0) {	/* not protected */
			vu_short *addr = (vu_short *) (info->start[sect]);

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
33d1ddb8:	e3a01055 	mov	r1, #85	; 0x55
		reset_timer_masked ();

		if (info->protect[sect] == 0) {	/* not protected */
			vu_short *addr = (vu_short *) (info->start[sect]);

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
33d1ddbc:	e1c300b0 	strh	r0, [r3]
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
33d1ddc0:	e1c210b0 	strh	r1, [r2]
			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
33d1ddc4:	e3a00080 	mov	r0, #128	; 0x80

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
33d1ddc8:	e3a010aa 	mov	r1, #170	; 0xaa
		if (info->protect[sect] == 0) {	/* not protected */
			vu_short *addr = (vu_short *) (info->start[sect]);

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
33d1ddcc:	e1c300b0 	strh	r0, [r3]

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
33d1ddd0:	e1c310b0 	strh	r1, [r3]
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
			*addr = CMD_ERASE_CONFIRM;
33d1ddd4:	e3a00030 	mov	r0, #48	; 0x30
			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
33d1ddd8:	e3a03055 	mov	r3, #85	; 0x55
33d1dddc:	e1c230b0 	strh	r3, [r2]
			*addr = CMD_ERASE_CONFIRM;
33d1dde0:	e1c700b0 	strh	r0, [r7]

			/* wait until flash is ready */
			chip = 0;

			do {
				result = *addr;
33d1dde4:	e1d730b0 	ldrh	r3, [r7]
33d1dde8:	e1a05003 	mov	r5, r3

				/* check timeout */
				if (get_timer_masked () >
33d1ddec:	ebff8be2 	bl	33d00d7c <get_timer_masked>
33d1ddf0:	e59f30b4 	ldr	r3, [pc, #180]	; 33d1deac <flash_erase+0x200>
33d1ddf4:	e1500003 	cmp	r0, r3
33d1ddf8:	8affffdb 	bhi	33d1dd6c <flash_erase+0xc0>
					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
					chip = TMO;
					break;
				}

				if (!chip
33d1ddfc:	e3560000 	cmp	r6, #0	; 0x0
33d1de00:	1a000005 	bne	33d1de1c <flash_erase+0x170>
33d1de04:	e3150080 	tst	r5, #128	; 0x80
				    && (result & 0xFFFF) & BIT_ERASE_DONE)
					chip = READY;
33d1de08:	12866001 	addne	r6, r6, #1	; 0x1
33d1de0c:	1a000002 	bne	33d1de1c <flash_erase+0x170>

				if (!chip
33d1de10:	e3150020 	tst	r5, #32	; 0x20
33d1de14:	0afffff2 	beq	33d1dde4 <flash_erase+0x138>
				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
					chip = ERR;
33d1de18:	e3a06002 	mov	r6, #2	; 0x2

			} while (!chip);

			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
33d1de1c:	e59f307c 	ldr	r3, [pc, #124]	; 33d1dea0 <flash_erase+0x1f4>
33d1de20:	e3a010f0 	mov	r1, #240	; 0xf0

			if (chip == ERR) {
33d1de24:	e3560002 	cmp	r6, #2	; 0x2
				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
					chip = ERR;

			} while (!chip);

			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
33d1de28:	e1c310b0 	strh	r1, [r3]

			if (chip == ERR) {
33d1de2c:	0affffc3 	beq	33d1dd40 <flash_erase+0x94>
				rc = ERR_PROG_ERROR;
				goto outahere;
			}
			if (chip == TMO) {
33d1de30:	e3560004 	cmp	r6, #4	; 0x4
33d1de34:	0affffc3 	beq	33d1dd48 <flash_erase+0x9c>
				rc = ERR_TIMOUT;
				goto outahere;
			}

			printf ("ok.\n");
33d1de38:	e59f0070 	ldr	r0, [pc, #112]	; 33d1deb0 <flash_erase+0x204>
33d1de3c:	ea000000 	b	33d1de44 <flash_erase+0x198>
		} else {	/* it was protected */

			printf ("protected!\n");
33d1de40:	e59f006c 	ldr	r0, [pc, #108]	; 33d1deb4 <flash_erase+0x208>
33d1de44:	ebffe45f 	bl	33d16fc8 <printf>
	cflag = icache_status ();
	icache_disable ();
	iflag = disable_interrupts ();

	/* Start erase on unprotected sectors */
	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
33d1de48:	e2844001 	add	r4, r4, #1	; 0x1
33d1de4c:	e154000a 	cmp	r4, sl
33d1de50:	ca000002 	bgt	33d1de60 <flash_erase+0x1b4>
33d1de54:	ebffe474 	bl	33d1702c <ctrlc>
33d1de58:	e3500000 	cmp	r0, #0	; 0x0
33d1de5c:	0affffc7 	beq	33d1dd80 <flash_erase+0xd4>

			printf ("protected!\n");
		}
	}

	if (ctrlc ())
33d1de60:	ebffe471 	bl	33d1702c <ctrlc>
33d1de64:	e3500000 	cmp	r0, #0	; 0x0
		printf ("User Interrupt!\n");
33d1de68:	159f0048 	ldrne	r0, [pc, #72]	; 33d1deb8 <flash_erase+0x20c>
33d1de6c:	1bffe455 	blne	33d16fc8 <printf>

      outahere:
	/* allow flash to settle - wait 10 ms */
	udelay_masked (10000);
33d1de70:	e59f0044 	ldr	r0, [pc, #68]	; 33d1debc <flash_erase+0x210>
33d1de74:	ebff8bfb 	bl	33d00e68 <udelay_masked>

	if (iflag)
33d1de78:	e59d2004 	ldr	r2, [sp, #4]
33d1de7c:	e3520000 	cmp	r2, #0	; 0x0
		enable_interrupts ();
33d1de80:	1bff8af0 	blne	33d00a48 <enable_interrupts>

	if (cflag)
33d1de84:	e59d3000 	ldr	r3, [sp]
33d1de88:	e3530000 	cmp	r3, #0	; 0x0
		icache_enable ();
33d1de8c:	1b0000e6 	blne	33d1e22c <icache_enable>

	return rc;
33d1de90:	e1a0000b 	mov	r0, fp
}
33d1de94:	e28dd008 	add	sp, sp, #8	; 0x8
33d1de98:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1de9c:	0000ffff 	.word	0x0000ffff
33d1dea0:	00000aaa 	.word	0x00000aaa
33d1dea4:	33d2d19c 	.word	0x33d2d19c
33d1dea8:	00000554 	.word	0x00000554
33d1deac:	00773594 	.word	0x00773594
33d1deb0:	33d2d1b4 	.word	0x33d2d1b4
33d1deb4:	33d2d1bc 	.word	0x33d2d1bc
33d1deb8:	33d2d1c8 	.word	0x33d2d1c8
33d1debc:	00002710 	.word	0x00002710

33d1dec0 <write_hword>:
/*-----------------------------------------------------------------------
 * Copy memory to flash
 */

volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
{
33d1dec0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int chip;

	/*
	 * Check if Flash is (sufficiently) erased
	 */
	result = *addr;
33d1dec4:	e1d130b0 	ldrh	r3, [r1]
/*-----------------------------------------------------------------------
 * Copy memory to flash
 */

volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
{
33d1dec8:	e1a02802 	lsl	r2, r2, #16

	/*
	 * Check if Flash is (sufficiently) erased
	 */
	result = *addr;
	if ((result & data) != data)
33d1decc:	e0033822 	and	r3, r3, r2, lsr #16
33d1ded0:	e1a07822 	lsr	r7, r2, #16
33d1ded4:	e1530007 	cmp	r3, r7
/*-----------------------------------------------------------------------
 * Copy memory to flash
 */

volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
{
33d1ded8:	e1a04001 	mov	r4, r1
	vu_short *addr = (vu_short *) dest;
	ushort result;
	int rc = ERR_OK;
33d1dedc:	e3a0a000 	mov	sl, #0	; 0x0
	/*
	 * Check if Flash is (sufficiently) erased
	 */
	result = *addr;
	if ((result & data) != data)
		return ERR_NOT_ERASED;
33d1dee0:	13a00002 	movne	r0, #2	; 0x2

	/*
	 * Check if Flash is (sufficiently) erased
	 */
	result = *addr;
	if ((result & data) != data)
33d1dee4:	18bd8ef0 	popne	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1dee8:	ea000001 	b	33d1def4 <write_hword+0x34>
	do {
		result = *addr;

		/* check timeout */
		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
			chip = ERR | TMO;
33d1deec:	e3a05006 	mov	r5, #6	; 0x6
			break;
33d1def0:	ea000025 	b	33d1df8c <write_hword+0xcc>
	 * here. Remember that our exception vectors are
	 * at address 0 in the flash, and we don't want a
	 * (ticker) exception to happen while the flash
	 * chip is in programming mode.
	 */
	cflag = icache_status ();
33d1def4:	eb0000da 	bl	33d1e264 <icache_status>
33d1def8:	e1a0b000 	mov	fp, r0
	icache_disable ();
33d1defc:	eb0000d1 	bl	33d1e248 <icache_disable>
	iflag = disable_interrupts ();
33d1df00:	ebff8ad4 	bl	33d00a58 <disable_interrupts>

	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
33d1df04:	e59f20b8 	ldr	r2, [pc, #184]	; 33d1dfc4 <write_hword+0x104>
33d1df08:	e3a010aa 	mov	r1, #170	; 0xaa
	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
33d1df0c:	e59f30b4 	ldr	r3, [pc, #180]	; 33d1dfc8 <write_hword+0x108>
	 */
	cflag = icache_status ();
	icache_disable ();
	iflag = disable_interrupts ();

	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
33d1df10:	e1c210b0 	strh	r1, [r2]
	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
33d1df14:	e3a01055 	mov	r1, #85	; 0x55
33d1df18:	e1c310b0 	strh	r1, [r3]
	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
33d1df1c:	e3a03020 	mov	r3, #32	; 0x20
	*addr = CMD_PROGRAM;
33d1df20:	e3a010a0 	mov	r1, #160	; 0xa0
	icache_disable ();
	iflag = disable_interrupts ();

	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
33d1df24:	e1c230b0 	strh	r3, [r2]
	*addr = CMD_PROGRAM;
33d1df28:	e1c410b0 	strh	r1, [r4]
	*addr = data;
33d1df2c:	e1c470b0 	strh	r7, [r4]
	 * (ticker) exception to happen while the flash
	 * chip is in programming mode.
	 */
	cflag = icache_status ();
	icache_disable ();
	iflag = disable_interrupts ();
33d1df30:	e1a09000 	mov	r9, r0
	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
	*addr = CMD_PROGRAM;
	*addr = data;

	/* arm simple, non interrupt dependent timer */
	reset_timer_masked ();
33d1df34:	ebff8b83 	bl	33d00d48 <reset_timer_masked>

	/* wait until flash is ready */
	chip = 0;
33d1df38:	e1a0500a 	mov	r5, sl
	do {
		result = *addr;
33d1df3c:	e1d430b0 	ldrh	r3, [r4]
33d1df40:	e1a06003 	mov	r6, r3

		/* check timeout */
		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
33d1df44:	ebff8b8c 	bl	33d00d7c <get_timer_masked>
33d1df48:	e59f307c 	ldr	r3, [pc, #124]	; 33d1dfcc <write_hword+0x10c>
33d1df4c:	e1500003 	cmp	r0, r3
			chip = ERR | TMO;
			break;
		}
		if (!chip && ((result & 0x80) == (data & 0x80)))
33d1df50:	e2062080 	and	r2, r6, #128	; 0x80
33d1df54:	e2071080 	and	r1, r7, #128	; 0x80
	chip = 0;
	do {
		result = *addr;

		/* check timeout */
		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
33d1df58:	8affffe3 	bhi	33d1deec <write_hword+0x2c>
			chip = ERR | TMO;
			break;
		}
		if (!chip && ((result & 0x80) == (data & 0x80)))
33d1df5c:	e3550000 	cmp	r5, #0	; 0x0
33d1df60:	1a000009 	bne	33d1df8c <write_hword+0xcc>
33d1df64:	e1520001 	cmp	r2, r1
			chip = READY;
33d1df68:	02855001 	addeq	r5, r5, #1	; 0x1
33d1df6c:	0a000006 	beq	33d1df8c <write_hword+0xcc>

		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
33d1df70:	e3160020 	tst	r6, #32	; 0x20
33d1df74:	0afffff0 	beq	33d1df3c <write_hword+0x7c>
			result = *addr;
33d1df78:	e1d430b0 	ldrh	r3, [r4]

			if ((result & 0x80) == (data & 0x80))
33d1df7c:	e2033080 	and	r3, r3, #128	; 0x80
				chip = READY;
33d1df80:	e1530001 	cmp	r3, r1
33d1df84:	13a05002 	movne	r5, #2	; 0x2
33d1df88:	03a05001 	moveq	r5, #1	; 0x1
				chip = ERR;
		}

	} while (!chip);

	*addr = CMD_READ_ARRAY;
33d1df8c:	e3a030f0 	mov	r3, #240	; 0xf0

	if (chip == ERR || *addr != data)
33d1df90:	e3550002 	cmp	r5, #2	; 0x2
				chip = ERR;
		}

	} while (!chip);

	*addr = CMD_READ_ARRAY;
33d1df94:	e1c430b0 	strh	r3, [r4]

	if (chip == ERR || *addr != data)
33d1df98:	0a000002 	beq	33d1dfa8 <write_hword+0xe8>
33d1df9c:	e1d430b0 	ldrh	r3, [r4]
33d1dfa0:	e1530007 	cmp	r3, r7
33d1dfa4:	0a000000 	beq	33d1dfac <write_hword+0xec>
		rc = ERR_PROG_ERROR;
33d1dfa8:	e3a0a080 	mov	sl, #128	; 0x80

	if (iflag)
33d1dfac:	e3590000 	cmp	r9, #0	; 0x0
		enable_interrupts ();
33d1dfb0:	1bff8aa4 	blne	33d00a48 <enable_interrupts>

	if (cflag)
33d1dfb4:	e35b0000 	cmp	fp, #0	; 0x0
		icache_enable ();
33d1dfb8:	1b00009b 	blne	33d1e22c <icache_enable>

	return rc;
33d1dfbc:	e1a0000a 	mov	r0, sl
}
33d1dfc0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1dfc4:	00000aaa 	.word	0x00000aaa
33d1dfc8:	00000554 	.word	0x00000554
33d1dfcc:	00773594 	.word	0x00773594

33d1dfd0 <write_buff>:
/*-----------------------------------------------------------------------
 * Copy memory to flash.
 */

int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
{
33d1dfd0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	wp = (addr & ~1);	/* get lower word aligned address */

	/*
	 * handle unaligned start bytes
	 */
	if ((l = addr - wp) != 0) {
33d1dfd4:	e212e001 	ands	lr, r2, #1	; 0x1
/*-----------------------------------------------------------------------
 * Copy memory to flash.
 */

int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
{
33d1dfd8:	e1a07000 	mov	r7, r0
33d1dfdc:	e1a06001 	mov	r6, r1
33d1dfe0:	e1a04003 	mov	r4, r3
	ulong cp, wp;
	int l;
	int i, rc;
	ushort data;

	wp = (addr & ~1);	/* get lower word aligned address */
33d1dfe4:	e3c25001 	bic	r5, r2, #1	; 0x1

	/*
	 * handle unaligned start bytes
	 */
	if ((l = addr - wp) != 0) {
33d1dfe8:	0a00002f 	beq	33d1e0ac <write_buff+0xdc>
		data = 0;
33d1dfec:	e3a0c000 	mov	ip, #0	; 0x0
		for (i = 0, cp = wp; i < l; ++i, ++cp) {
33d1dff0:	e15c000e 	cmp	ip, lr
33d1dff4:	e1a0100c 	mov	r1, ip
33d1dff8:	e1a00005 	mov	r0, r5
33d1dffc:	aa000005 	bge	33d1e018 <write_buff+0x48>
			data = (data >> 8) | (*(uchar *) cp << 8);
33d1e000:	e4d03001 	ldrb	r3, [r0], #1
	/*
	 * handle unaligned start bytes
	 */
	if ((l = addr - wp) != 0) {
		data = 0;
		for (i = 0, cp = wp; i < l; ++i, ++cp) {
33d1e004:	e2811001 	add	r1, r1, #1	; 0x1
			data = (data >> 8) | (*(uchar *) cp << 8);
33d1e008:	e1a03403 	lsl	r3, r3, #8
	/*
	 * handle unaligned start bytes
	 */
	if ((l = addr - wp) != 0) {
		data = 0;
		for (i = 0, cp = wp; i < l; ++i, ++cp) {
33d1e00c:	e151000e 	cmp	r1, lr
			data = (data >> 8) | (*(uchar *) cp << 8);
33d1e010:	e183c42c 	orr	ip, r3, ip, lsr #8
33d1e014:	eafffff8 	b	33d1dffc <write_buff+0x2c>
		}
		for (; i < 2 && cnt > 0; ++i) {
33d1e018:	e3510001 	cmp	r1, #1	; 0x1
33d1e01c:	c3a03000 	movgt	r3, #0	; 0x0
33d1e020:	d3a03001 	movle	r3, #1	; 0x1
33d1e024:	e3540000 	cmp	r4, #0	; 0x0
33d1e028:	03a03000 	moveq	r3, #0	; 0x0
33d1e02c:	e3530000 	cmp	r3, #0	; 0x0
33d1e030:	0a00000c 	beq	33d1e068 <write_buff+0x98>
33d1e034:	e2544001 	subs	r4, r4, #1	; 0x1
			data = (data >> 8) | (*src++ << 8);
33d1e038:	e4d62001 	ldrb	r2, [r6], #1
	if ((l = addr - wp) != 0) {
		data = 0;
		for (i = 0, cp = wp; i < l; ++i, ++cp) {
			data = (data >> 8) | (*(uchar *) cp << 8);
		}
		for (; i < 2 && cnt > 0; ++i) {
33d1e03c:	03a03000 	moveq	r3, #0	; 0x0
33d1e040:	13a03001 	movne	r3, #1	; 0x1
33d1e044:	e2811001 	add	r1, r1, #1	; 0x1
33d1e048:	e3510001 	cmp	r1, #1	; 0x1
33d1e04c:	c3a03000 	movgt	r3, #0	; 0x0
33d1e050:	d2033001 	andle	r3, r3, #1	; 0x1
			data = (data >> 8) | (*src++ << 8);
33d1e054:	e1a02402 	lsl	r2, r2, #8
	if ((l = addr - wp) != 0) {
		data = 0;
		for (i = 0, cp = wp; i < l; ++i, ++cp) {
			data = (data >> 8) | (*(uchar *) cp << 8);
		}
		for (; i < 2 && cnt > 0; ++i) {
33d1e058:	e3530000 	cmp	r3, #0	; 0x0
			data = (data >> 8) | (*src++ << 8);
33d1e05c:	e182c42c 	orr	ip, r2, ip, lsr #8
			--cnt;
			++cp;
33d1e060:	e2800001 	add	r0, r0, #1	; 0x1
33d1e064:	eafffff1 	b	33d1e030 <write_buff+0x60>
		}
		for (; cnt == 0 && i < 2; ++i, ++cp) {
33d1e068:	e3510001 	cmp	r1, #1	; 0x1
33d1e06c:	d3540000 	cmple	r4, #0	; 0x0
33d1e070:	1a000006 	bne	33d1e090 <write_buff+0xc0>
			data = (data >> 8) | (*(uchar *) cp << 8);
33d1e074:	e4d03001 	ldrb	r3, [r0], #1
		for (; i < 2 && cnt > 0; ++i) {
			data = (data >> 8) | (*src++ << 8);
			--cnt;
			++cp;
		}
		for (; cnt == 0 && i < 2; ++i, ++cp) {
33d1e078:	e2811001 	add	r1, r1, #1	; 0x1
			data = (data >> 8) | (*(uchar *) cp << 8);
33d1e07c:	e1a03403 	lsl	r3, r3, #8
		for (; i < 2 && cnt > 0; ++i) {
			data = (data >> 8) | (*src++ << 8);
			--cnt;
			++cp;
		}
		for (; cnt == 0 && i < 2; ++i, ++cp) {
33d1e080:	e3510001 	cmp	r1, #1	; 0x1
33d1e084:	d3540000 	cmple	r4, #0	; 0x0
			data = (data >> 8) | (*(uchar *) cp << 8);
33d1e088:	e183c42c 	orr	ip, r3, ip, lsr #8
33d1e08c:	eafffff7 	b	33d1e070 <write_buff+0xa0>
		}

		if ((rc = write_hword (info, wp, data)) != 0) {
33d1e090:	e1a0200c 	mov	r2, ip
33d1e094:	e1a00007 	mov	r0, r7
33d1e098:	e1a01005 	mov	r1, r5
33d1e09c:	ebffff87 	bl	33d1dec0 <write_hword>
33d1e0a0:	e3500000 	cmp	r0, #0	; 0x0
33d1e0a4:	18bd80f0 	popne	{r4, r5, r6, r7, pc}
			return (rc);
		}
		wp += 2;
33d1e0a8:	e2855002 	add	r5, r5, #2	; 0x2
		if ((rc = write_hword (info, wp, data)) != 0) {
			return (rc);
		}
		src += 2;
		wp += 2;
		cnt -= 2;
33d1e0ac:	e3540001 	cmp	r4, #1	; 0x1
33d1e0b0:	9a000009 	bls	33d1e0dc <write_buff+0x10c>

	/*
	 * handle word aligned part
	 */
	while (cnt >= 2) {
		data = *((vu_short *) src);
33d1e0b4:	e1d620b0 	ldrh	r2, [r6]
		if ((rc = write_hword (info, wp, data)) != 0) {
33d1e0b8:	e1a01005 	mov	r1, r5
33d1e0bc:	e1a00007 	mov	r0, r7
33d1e0c0:	ebffff7e 	bl	33d1dec0 <write_hword>
33d1e0c4:	e3500000 	cmp	r0, #0	; 0x0
			return (rc);
		}
		src += 2;
		wp += 2;
		cnt -= 2;
33d1e0c8:	e2444002 	sub	r4, r4, #2	; 0x2
	while (cnt >= 2) {
		data = *((vu_short *) src);
		if ((rc = write_hword (info, wp, data)) != 0) {
			return (rc);
		}
		src += 2;
33d1e0cc:	e2866002 	add	r6, r6, #2	; 0x2
		wp += 2;
33d1e0d0:	e2855002 	add	r5, r5, #2	; 0x2
	/*
	 * handle word aligned part
	 */
	while (cnt >= 2) {
		data = *((vu_short *) src);
		if ((rc = write_hword (info, wp, data)) != 0) {
33d1e0d4:	18bd80f0 	popne	{r4, r5, r6, r7, pc}
33d1e0d8:	eafffff3 	b	33d1e0ac <write_buff+0xdc>
		src += 2;
		wp += 2;
		cnt -= 2;
	}

	if (cnt == 0) {
33d1e0dc:	e3540000 	cmp	r4, #0	; 0x0
		return ERR_OK;
33d1e0e0:	01a00004 	moveq	r0, r4
		src += 2;
		wp += 2;
		cnt -= 2;
	}

	if (cnt == 0) {
33d1e0e4:	08bd80f0 	popeq	{r4, r5, r6, r7, pc}
	}

	/*
	 * handle unaligned tail bytes
	 */
	data = 0;
33d1e0e8:	e3a0c000 	mov	ip, #0	; 0x0
	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
33d1e0ec:	e1a0100c 	mov	r1, ip
33d1e0f0:	e1a00005 	mov	r0, r5
33d1e0f4:	e2544001 	subs	r4, r4, #1	; 0x1
33d1e0f8:	03a03000 	moveq	r3, #0	; 0x0
33d1e0fc:	13a03001 	movne	r3, #1	; 0x1
33d1e100:	e2811001 	add	r1, r1, #1	; 0x1
		data = (data >> 8) | (*src++ << 8);
33d1e104:	e4d62001 	ldrb	r2, [r6], #1

	/*
	 * handle unaligned tail bytes
	 */
	data = 0;
	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
33d1e108:	e3510001 	cmp	r1, #1	; 0x1
33d1e10c:	c3a03000 	movgt	r3, #0	; 0x0
33d1e110:	d2033001 	andle	r3, r3, #1	; 0x1
		data = (data >> 8) | (*src++ << 8);
33d1e114:	e1a02402 	lsl	r2, r2, #8

	/*
	 * handle unaligned tail bytes
	 */
	data = 0;
	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
33d1e118:	e3530000 	cmp	r3, #0	; 0x0
		data = (data >> 8) | (*src++ << 8);
33d1e11c:	e182c42c 	orr	ip, r2, ip, lsr #8

	/*
	 * handle unaligned tail bytes
	 */
	data = 0;
	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
33d1e120:	e2800001 	add	r0, r0, #1	; 0x1
33d1e124:	1afffff2 	bne	33d1e0f4 <write_buff+0x124>
		data = (data >> 8) | (*src++ << 8);
		--cnt;
	}
	for (; i < 2; ++i, ++cp) {
33d1e128:	e3510001 	cmp	r1, #1	; 0x1
33d1e12c:	ca000005 	bgt	33d1e148 <write_buff+0x178>
		data = (data >> 8) | (*(uchar *) cp << 8);
33d1e130:	e4d03001 	ldrb	r3, [r0], #1
	data = 0;
	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
		data = (data >> 8) | (*src++ << 8);
		--cnt;
	}
	for (; i < 2; ++i, ++cp) {
33d1e134:	e2811001 	add	r1, r1, #1	; 0x1
		data = (data >> 8) | (*(uchar *) cp << 8);
33d1e138:	e1a03403 	lsl	r3, r3, #8
	data = 0;
	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
		data = (data >> 8) | (*src++ << 8);
		--cnt;
	}
	for (; i < 2; ++i, ++cp) {
33d1e13c:	e3510001 	cmp	r1, #1	; 0x1
		data = (data >> 8) | (*(uchar *) cp << 8);
33d1e140:	e183c42c 	orr	ip, r3, ip, lsr #8
33d1e144:	eafffff8 	b	33d1e12c <write_buff+0x15c>
	}

	return write_hword (info, wp, data);
33d1e148:	e1a00007 	mov	r0, r7
33d1e14c:	e1a01005 	mov	r1, r5
33d1e150:	e1a0200c 	mov	r2, ip
}
33d1e154:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
	}
	for (; i < 2; ++i, ++cp) {
		data = (data >> 8) | (*(uchar *) cp << 8);
	}

	return write_hword (info, wp, data);
33d1e158:	eaffff58 	b	33d1dec0 <write_hword>

33d1e15c <read_p15_c1>:

#ifdef MMU_DEBUG
	printf ("p15/c1 is = %08lx\n", value);
#endif
	return value;
}
33d1e15c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
33d1e160:	e1a0f00e 	mov	pc, lr

33d1e164 <write_p15_c1>:
static void write_p15_c1 (unsigned long value)
{
#ifdef MMU_DEBUG
	printf ("write %08lx to p15/c1\n", value);
#endif
	__asm__ __volatile__(
33d1e164:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
		"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
		:
		: "r" (value)
		: "memory");

	read_p15_c1 ();
33d1e168:	eafffffb 	b	33d1e15c <read_p15_c1>

33d1e16c <cp_delay>:
}

static void cp_delay (void)
{
33d1e16c:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++);
33d1e170:	e3a03000 	mov	r3, #0	; 0x0
33d1e174:	e58d3000 	str	r3, [sp]
33d1e178:	e59d3000 	ldr	r3, [sp]
33d1e17c:	e3530063 	cmp	r3, #99	; 0x63
33d1e180:	d59d3000 	ldrle	r3, [sp]
33d1e184:	d2833001 	addle	r3, r3, #1	; 0x1
33d1e188:	dafffff9 	ble	33d1e174 <cp_delay+0x8>
33d1e18c:	e28dd004 	add	sp, sp, #4	; 0x4
33d1e190:	e1a0f00e 	mov	pc, lr

33d1e194 <cpu_init>:
{
	/*
	 * setup up stacks if necessary
	 */
#ifdef CONFIG_USE_IRQ
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
33d1e194:	e59f303c 	ldr	r3, [pc, #60]	; 33d1e1d8 <cpu_init+0x44>
33d1e198:	e5933000 	ldr	r3, [r3]
33d1e19c:	e2433701 	sub	r3, r3, #262144	; 0x40000
33d1e1a0:	e2433084 	sub	r3, r3, #132	; 0x84
	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
33d1e1a4:	e59f2030 	ldr	r2, [pc, #48]	; 33d1e1dc <cpu_init+0x48>
33d1e1a8:	e2431a01 	sub	r1, r3, #4096	; 0x1000
    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
33d1e1ac:	e243ca22 	sub	ip, r3, #139264	; 0x22000
	/*
	 * setup up stacks if necessary
	 */
#ifdef CONFIG_USE_IRQ
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
33d1e1b0:	e5821000 	str	r1, [r2]
    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
33d1e1b4:	e59f2024 	ldr	r2, [pc, #36]	; 33d1e1e0 <cpu_init+0x4c>
33d1e1b8:	e28c020d 	add	r0, ip, #-805306368	; 0xd0000000
33d1e1bc:	e5820000 	str	r0, [r2]
{
	/*
	 * setup up stacks if necessary
	 */
#ifdef CONFIG_USE_IRQ
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
33d1e1c0:	e59f201c 	ldr	r2, [pc, #28]	; 33d1e1e4 <cpu_init+0x50>
33d1e1c4:	e5823000 	str	r3, [r2]
	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
33d1e1c8:	e59f3018 	ldr	r3, [pc, #24]	; 33d1e1e8 <cpu_init+0x54>
#else    
    FREE_RAM_END = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4 - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
#endif
	return 0;
}
33d1e1cc:	e3a00000 	mov	r0, #0	; 0x0
	 * setup up stacks if necessary
	 */
#ifdef CONFIG_USE_IRQ
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
33d1e1d0:	e583c000 	str	ip, [r3]
#else    
    FREE_RAM_END = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4 - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
#endif
	return 0;
}
33d1e1d4:	e1a0f00e 	mov	pc, lr
33d1e1d8:	33d00044 	.word	0x33d00044
33d1e1dc:	33d0005c 	.word	0x33d0005c
33d1e1e0:	33d00054 	.word	0x33d00054
33d1e1e4:	33d00058 	.word	0x33d00058
33d1e1e8:	33d00050 	.word	0x33d00050

33d1e1ec <cleanup_before_linux>:

int cleanup_before_linux (void)
{
33d1e1ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	 * we turn off caches etc ...
	 */

	unsigned long i;

	disable_interrupts ();
33d1e1f0:	ebff8a18 	bl	33d00a58 <disable_interrupts>

	/* turn off I/D-cache */
	asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (i));
33d1e1f4:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
	i &= ~(C1_DC | C1_IC);
33d1e1f8:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
33d1e1fc:	e3c33004 	bic	r3, r3, #4	; 0x4
	asm ("mcr p15, 0, %0, c1, c0, 0": :"r" (i));
33d1e200:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}

	/* flush I/D-cache */
	i = 0;
33d1e204:	e3a03000 	mov	r3, #0	; 0x0
	asm ("mcr p15, 0, %0, c7, c7, 0": :"r" (i));
33d1e208:	ee073f17 	mcr	15, 0, r3, cr7, cr7, {0}

	return (0);
}
33d1e20c:	e3a00000 	mov	r0, #0	; 0x0
33d1e210:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1e214 <do_reset>:

int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
33d1e214:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	disable_interrupts ();
33d1e218:	ebff8a0e 	bl	33d00a58 <disable_interrupts>
	reset_cpu (0);
33d1e21c:	e3a00000 	mov	r0, #0	; 0x0
33d1e220:	ebff8b37 	bl	33d00f04 <reset_cpu>
	/*NOTREACHED*/
	return (0);
}
33d1e224:	e3a00000 	mov	r0, #0	; 0x0
33d1e228:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1e22c <icache_enable>:

void icache_enable (void)
{
33d1e22c:	e92d4010 	push	{r4, lr}
	ulong reg;

	reg = read_p15_c1 ();		/* get control reg. */
33d1e230:	ebffffc9 	bl	33d1e15c <read_p15_c1>
33d1e234:	e1a04000 	mov	r4, r0
	cp_delay ();
33d1e238:	ebffffcb 	bl	33d1e16c <cp_delay>
	write_p15_c1 (reg | C1_IC);
33d1e23c:	e3840a01 	orr	r0, r4, #4096	; 0x1000
33d1e240:	e8bd4010 	pop	{r4, lr}
33d1e244:	eaffffc6 	b	33d1e164 <write_p15_c1>

33d1e248 <icache_disable>:
}

void icache_disable (void)
{
33d1e248:	e92d4010 	push	{r4, lr}
	ulong reg;

	reg = read_p15_c1 ();
33d1e24c:	ebffffc2 	bl	33d1e15c <read_p15_c1>
33d1e250:	e1a04000 	mov	r4, r0
	cp_delay ();
33d1e254:	ebffffc4 	bl	33d1e16c <cp_delay>
	write_p15_c1 (reg & ~C1_IC);
33d1e258:	e3c40a01 	bic	r0, r4, #4096	; 0x1000
33d1e25c:	e8bd4010 	pop	{r4, lr}
33d1e260:	eaffffbf 	b	33d1e164 <write_p15_c1>

33d1e264 <icache_status>:
}

int icache_status (void)
{
33d1e264:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return (read_p15_c1 () & C1_IC) != 0;
33d1e268:	ebffffbb 	bl	33d1e15c <read_p15_c1>
33d1e26c:	e1a00620 	lsr	r0, r0, #12
}
33d1e270:	e2000001 	and	r0, r0, #1	; 0x1
33d1e274:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1e278 <dcache_enable>:

#ifdef USE_920T_MMU
/* It makes no sense to use the dcache if the MMU is not enabled */
void dcache_enable (void)
{
33d1e278:	e92d4010 	push	{r4, lr}
	ulong reg;

	reg = read_p15_c1 ();
33d1e27c:	ebffffb6 	bl	33d1e15c <read_p15_c1>
33d1e280:	e1a04000 	mov	r4, r0
	cp_delay ();
33d1e284:	ebffffb8 	bl	33d1e16c <cp_delay>
	write_p15_c1 (reg | C1_DC);
33d1e288:	e3840004 	orr	r0, r4, #4	; 0x4
33d1e28c:	e8bd4010 	pop	{r4, lr}
33d1e290:	eaffffb3 	b	33d1e164 <write_p15_c1>

33d1e294 <dcache_disable>:
}

void dcache_disable (void)
{
33d1e294:	e92d4010 	push	{r4, lr}
	ulong reg;

	reg = read_p15_c1 ();
33d1e298:	ebffffaf 	bl	33d1e15c <read_p15_c1>
33d1e29c:	e1a04000 	mov	r4, r0
	cp_delay ();
33d1e2a0:	ebffffb1 	bl	33d1e16c <cp_delay>
	reg &= ~C1_DC;
	write_p15_c1 (reg);
33d1e2a4:	e3c40004 	bic	r0, r4, #4	; 0x4
33d1e2a8:	e8bd4010 	pop	{r4, lr}
33d1e2ac:	eaffffac 	b	33d1e164 <write_p15_c1>

33d1e2b0 <dcache_status>:
}

int dcache_status (void)
{
33d1e2b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return (read_p15_c1 () & C1_DC) != 0;
33d1e2b4:	ebffffa8 	bl	33d1e15c <read_p15_c1>
33d1e2b8:	e1a00120 	lsr	r0, r0, #2
}
33d1e2bc:	e2000001 	and	r0, r0, #1	; 0x1
33d1e2c0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1e2c4 <serial_setbrg>:
#else
#error "Bad: you didn't configure serial ..."
#endif

void serial_setbrg (void)
{
33d1e2c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR);
	int i;
	unsigned int reg = 0;

	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
	reg = get_PCLK() / (16 * gd->baudrate) - 1;
33d1e2c8:	ebff8c15 	bl	33d01324 <get_PCLK>
33d1e2cc:	e5981008 	ldr	r1, [r8, #8]
33d1e2d0:	e1a01201 	lsl	r1, r1, #4
33d1e2d4:	ebff8c41 	bl	33d013e0 <__udivsi3>
{
    return (S3C2440_NAND * const)S3C2410_NAND_BASE;
}
static inline S3C24X0_UART * const S3C24X0_GetBase_UART(S3C24X0_UARTS_NR nr)
{
    return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
33d1e2d8:	e3a02205 	mov	r2, #1342177280	; 0x50000000

	/* FIFO enable, Tx/Rx FIFO clear */
	uart->UFCON = 0x07;
33d1e2dc:	e3a03007 	mov	r3, #7	; 0x7
33d1e2e0:	e5823008 	str	r3, [r2, #8]
	uart->UMCON = 0x0;
33d1e2e4:	e2433007 	sub	r3, r3, #7	; 0x7
33d1e2e8:	e582300c 	str	r3, [r2, #12]
	/* Normal,No parity,1 stop,8 bit */
	uart->ULCON = 0x3;
33d1e2ec:	e2833003 	add	r3, r3, #3	; 0x3
33d1e2f0:	e5823000 	str	r3, [r2]
	/*
	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
	 * normal,interrupt or polling
	 */
	uart->UCON = 0x245;
33d1e2f4:	e59f3018 	ldr	r3, [pc, #24]	; 33d1e314 <serial_setbrg+0x50>
	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR);
	int i;
	unsigned int reg = 0;

	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
	reg = get_PCLK() / (16 * gd->baudrate) - 1;
33d1e2f8:	e2400001 	sub	r0, r0, #1	; 0x1
	uart->ULCON = 0x3;
	/*
	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
	 * normal,interrupt or polling
	 */
	uart->UCON = 0x245;
33d1e2fc:	e5823004 	str	r3, [r2, #4]
	uart->UBRDIV = reg;
33d1e300:	e5820028 	str	r0, [r2, #40]
33d1e304:	e3a03063 	mov	r3, #99	; 0x63
33d1e308:	e2533001 	subs	r3, r3, #1	; 0x1
33d1e30c:	5afffffd 	bpl	33d1e308 <serial_setbrg+0x44>

#ifdef CONFIG_HWFLOW
	uart->UMCON = 0x1; /* RTS up */
#endif
	for (i = 0; i < 100; i++);
33d1e310:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1e314:	00000245 	.word	0x00000245

33d1e318 <serial_init>:
 * Initialise the serial port with the given baudrate. The settings
 * are always 8 data bits, no parity, 1 stop bit, no start bits.
 *
 */
int serial_init (void)
{
33d1e318:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	serial_setbrg ();
33d1e31c:	ebffffe8 	bl	33d1e2c4 <serial_setbrg>

	return (0);
}
33d1e320:	e3a00000 	mov	r0, #0	; 0x0
33d1e324:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1e328 <serial_getc>:
33d1e328:	e3a02205 	mov	r2, #1342177280	; 0x50000000
int serial_getc (void)
{
	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR);

	/* wait for character to arrive */
	while (!(uart->UTRSTAT & 0x1));
33d1e32c:	e5923010 	ldr	r3, [r2, #16]
33d1e330:	e3130001 	tst	r3, #1	; 0x1
33d1e334:	0afffffc 	beq	33d1e32c <serial_getc+0x4>

	return uart->URXH & 0xff;
33d1e338:	e5d20024 	ldrb	r0, [r2, #36]
}
33d1e33c:	e1a0f00e 	mov	pc, lr

33d1e340 <serial_putc>:

/*
 * Output a single byte to the serial port.
 */
void serial_putc (const char c)
{
33d1e340:	e20000ff 	and	r0, r0, #255	; 0xff
33d1e344:	e3a02205 	mov	r2, #1342177280	; 0x50000000
	if (be_quiet)
		return;
#endif

	/* wait for room in the tx FIFO */
	while (!(uart->UTRSTAT & 0x2));
33d1e348:	e5923010 	ldr	r3, [r2, #16]
33d1e34c:	e3130002 	tst	r3, #2	; 0x2
33d1e350:	0afffffc 	beq	33d1e348 <serial_putc+0x8>
#endif

	uart->UTXH = c;

	/* If \n, also do \r */
	if (c == '\n')
33d1e354:	e350000a 	cmp	r0, #10	; 0xa
	/* Wait for CTS up */
	while(hwflow && !(uart->UMSTAT & 0x1))
		;
#endif

	uart->UTXH = c;
33d1e358:	e5c20020 	strb	r0, [r2, #32]

	/* If \n, also do \r */
	if (c == '\n')
33d1e35c:	11a0f00e 	movne	pc, lr
		serial_putc ('\r');
33d1e360:	e2800003 	add	r0, r0, #3	; 0x3
33d1e364:	eafffff5 	b	33d1e340 <serial_putc>

33d1e368 <serial_tstc>:
 */
int serial_tstc (void)
{
	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR);

	return uart->UTRSTAT & 0x1;
33d1e368:	e3a03205 	mov	r3, #1342177280	; 0x50000000
33d1e36c:	e5930010 	ldr	r0, [r3, #16]
}
33d1e370:	e2000001 	and	r0, r0, #1	; 0x1
33d1e374:	e1a0f00e 	mov	pc, lr

33d1e378 <serial_puts>:

void
serial_puts (const char *s)
{
33d1e378:	e92d4010 	push	{r4, lr}
33d1e37c:	e1a04000 	mov	r4, r0
	while (*s) {
		serial_putc (*s++);
33d1e380:	e5d00000 	ldrb	r0, [r0]
33d1e384:	e3500000 	cmp	r0, #0	; 0x0
33d1e388:	08bd8010 	popeq	{r4, pc}
33d1e38c:	ebffffeb 	bl	33d1e340 <serial_putc>
33d1e390:	e5f40001 	ldrb	r0, [r4, #1]!
33d1e394:	e3500000 	cmp	r0, #0	; 0x0
33d1e398:	1afffffb 	bne	33d1e38c <serial_puts+0x14>
33d1e39c:	e8bd8010 	pop	{r4, pc}

33d1e3a0 <do_getc>:
}

#if 1									//HJ_add_start
int getc_errno = 0;
__u8 do_getc(unsigned long timeout, int *statp)
{
33d1e3a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d1e3a4:	e3a0c205 	mov	ip, #1342177280	; 0x50000000
	while(!(uart->UTRSTAT & 0x1)) {

		if (do_timeout) {
			if (!timeout)
				break;
			timeout--;
33d1e3a8:	e59c3010 	ldr	r3, [ip, #16]
{
	__u8	c, rxstat;
	int	do_timeout = timeout != 0;
	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR);

	getc_errno = 0;	/* reste errno */
33d1e3ac:	e59fe074 	ldr	lr, [pc, #116]	; 33d1e428 <do_getc+0x88>
#if 1									//HJ_add_start
int getc_errno = 0;
__u8 do_getc(unsigned long timeout, int *statp)
{
	__u8	c, rxstat;
	int	do_timeout = timeout != 0;
33d1e3b0:	e2502000 	subs	r2, r0, #0	; 0x0
33d1e3b4:	13a02001 	movne	r2, #1	; 0x1
	while(!(uart->UTRSTAT & 0x1)) {

		if (do_timeout) {
			if (!timeout)
				break;
			timeout--;
33d1e3b8:	e3130001 	tst	r3, #1	; 0x1
{
	__u8	c, rxstat;
	int	do_timeout = timeout != 0;
	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR);

	getc_errno = 0;	/* reste errno */
33d1e3bc:	e3a03000 	mov	r3, #0	; 0x0
33d1e3c0:	e58e3000 	str	r3, [lr]
	while(!(uart->UTRSTAT & 0x1)) {

		if (do_timeout) {
			if (!timeout)
				break;
			timeout--;
33d1e3c4:	1a000007 	bne	33d1e3e8 <do_getc+0x48>

	getc_errno = 0;	/* reste errno */

	while(!(uart->UTRSTAT & 0x1)) {

		if (do_timeout) {
33d1e3c8:	e3520000 	cmp	r2, #0	; 0x0
33d1e3cc:	0a000002 	beq	33d1e3dc <do_getc+0x3c>
			if (!timeout)
33d1e3d0:	e3500000 	cmp	r0, #0	; 0x0
33d1e3d4:	0a000003 	beq	33d1e3e8 <do_getc+0x48>
				break;
			timeout--;
33d1e3d8:	e2400001 	sub	r0, r0, #1	; 0x1
33d1e3dc:	e59c3010 	ldr	r3, [ip, #16]
33d1e3e0:	e3130001 	tst	r3, #1	; 0x1
33d1e3e4:	eafffff6 	b	33d1e3c4 <do_getc+0x24>
		}

	}

	if (do_timeout && timeout == 0) {
33d1e3e8:	e3500000 	cmp	r0, #0	; 0x0
33d1e3ec:	13a03000 	movne	r3, #0	; 0x0
33d1e3f0:	02023001 	andeq	r3, r2, #1	; 0x1
33d1e3f4:	e3530000 	cmp	r3, #0	; 0x0
		c = 0;
33d1e3f8:	13a00000 	movne	r0, #0	; 0x0
		rxstat = -1;
33d1e3fc:	13a030ff 	movne	r3, #255	; 0xff
			timeout--;
		}

	}

	if (do_timeout && timeout == 0) {
33d1e400:	1a000004 	bne	33d1e418 <do_getc+0x78>
		c = 0;
		rxstat = -1;
	} else {
		c = (uart->URXH & 0xff);
33d1e404:	e5dc2024 	ldrb	r2, [ip, #36]
		rxstat = (uart->UERSTAT & 0xf);
33d1e408:	e59c3014 	ldr	r3, [ip, #20]
	}

	if (rxstat) {
33d1e40c:	e213300f 	ands	r3, r3, #15	; 0xf

	if (do_timeout && timeout == 0) {
		c = 0;
		rxstat = -1;
	} else {
		c = (uart->URXH & 0xff);
33d1e410:	e20200ff 	and	r0, r2, #255	; 0xff
		rxstat = (uart->UERSTAT & 0xf);
	}

	if (rxstat) {
33d1e414:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
		getc_errno = rxstat;
		if (statp)
33d1e418:	e3510000 	cmp	r1, #0	; 0x0
		c = (uart->URXH & 0xff);
		rxstat = (uart->UERSTAT & 0xf);
	}

	if (rxstat) {
		getc_errno = rxstat;
33d1e41c:	e58e3000 	str	r3, [lr]
		if (statp)
			*statp = rxstat;
33d1e420:	15813000 	strne	r3, [r1]
	}
	return (c);
}
33d1e424:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1e428:	33d625c0 	.word	0x33d625c0

33d1e42c <awaitkey2>:
 *   - Times out after delay iterations checking for presence of character
 *   - Sets *error_p to UART error bits or - on timeout
 *   - On timeout, sets *error_p to -1 and returns 0
 */
char awaitkey2(unsigned long delay, int* error_p)
{
33d1e42c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return (do_getc(delay, error_p));
33d1e430:	ebffffda 	bl	33d1e3a0 <do_getc>
33d1e434:	e20000ff 	and	r0, r0, #255	; 0xff
}
33d1e438:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d1e43c <s3c2410_nand_select_chip>:
/* select chip, for s3c2410 */
static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
{
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();

    if (chip == -1) {
33d1e43c:	e3710001 	cmn	r1, #1	; 0x1
{
    return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
}
static inline S3C2410_NAND * const S3C2410_GetBase_NAND(void)
{
    return (S3C2410_NAND * const)S3C2410_NAND_BASE;
33d1e440:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
        s3c2410nand->NFCONF |= S3C2410_NFCONF_nFCE;
33d1e444:	05923000 	ldreq	r3, [r2]
    } else {
        s3c2410nand->NFCONF &= ~S3C2410_NFCONF_nFCE;
33d1e448:	15923000 	ldrne	r3, [r2]
static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
{
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();

    if (chip == -1) {
        s3c2410nand->NFCONF |= S3C2410_NFCONF_nFCE;
33d1e44c:	03833b02 	orreq	r3, r3, #2048	; 0x800
    } else {
        s3c2410nand->NFCONF &= ~S3C2410_NFCONF_nFCE;
33d1e450:	13c33b02 	bicne	r3, r3, #2048	; 0x800
33d1e454:	e5823000 	str	r3, [r2]
33d1e458:	e1a0f00e 	mov	pc, lr

33d1e45c <s3c2410_nand_hwcontrol>:
static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
{
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
    struct nand_chip *chip = mtd->priv;

    switch (cmd) {
33d1e45c:	e2411001 	sub	r1, r1, #1	; 0x1
 *
*/
static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
{
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
    struct nand_chip *chip = mtd->priv;
33d1e460:	e590213c 	ldr	r2, [r0, #316]

    switch (cmd) {
33d1e464:	e3510004 	cmp	r1, #4	; 0x4
33d1e468:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
33d1e46c:	ea00000c 	b	33d1e4a4 <s3c2410_nand_hwcontrol+0x48>
33d1e470:	33d1e484 	.word	0x33d1e484
33d1e474:	33d1e484 	.word	0x33d1e484
33d1e478:	33d1e490 	.word	0x33d1e490
33d1e47c:	33d1e4a4 	.word	0x33d1e4a4
33d1e480:	33d1e498 	.word	0x33d1e498
    case NAND_CTL_SETNCE:
    case NAND_CTL_CLRNCE:
        printf("%s: called for NCE\n", __FUNCTION__);
33d1e484:	e59f0020 	ldr	r0, [pc, #32]	; 33d1e4ac <s3c2410_nand_hwcontrol+0x50>
33d1e488:	e59f1020 	ldr	r1, [pc, #32]	; 33d1e4b0 <s3c2410_nand_hwcontrol+0x54>
33d1e48c:	eaffe2cd 	b	33d16fc8 <printf>
        break;

    case NAND_CTL_SETCLE:
        chip->IO_ADDR_W = (void *)&s3c2410nand->NFCMD;
33d1e490:	e59f301c 	ldr	r3, [pc, #28]	; 33d1e4b4 <s3c2410_nand_hwcontrol+0x58>
33d1e494:	ea000000 	b	33d1e49c <s3c2410_nand_hwcontrol+0x40>
        break;

    case NAND_CTL_SETALE:
        chip->IO_ADDR_W = (void *)&s3c2410nand->NFADDR;
33d1e498:	e59f3018 	ldr	r3, [pc, #24]	; 33d1e4b8 <s3c2410_nand_hwcontrol+0x5c>
33d1e49c:	e5823004 	str	r3, [r2, #4]
        break;
33d1e4a0:	e1a0f00e 	mov	pc, lr

        /* NAND_CTL_CLRCLE: */
        /* NAND_CTL_CLRALE: */
    default:
        chip->IO_ADDR_W = (void *)&s3c2410nand->NFDATA;
33d1e4a4:	e59f3010 	ldr	r3, [pc, #16]	; 33d1e4bc <s3c2410_nand_hwcontrol+0x60>
33d1e4a8:	eafffffb 	b	33d1e49c <s3c2410_nand_hwcontrol+0x40>
33d1e4ac:	33d2d1dc 	.word	0x33d2d1dc
33d1e4b0:	33d24fdc 	.word	0x33d24fdc
33d1e4b4:	4e000004 	.word	0x4e000004
33d1e4b8:	4e000008 	.word	0x4e000008
33d1e4bc:	4e00000c 	.word	0x4e00000c

33d1e4c0 <s3c2410_nand_devready>:
 */
static int s3c2410_nand_devready(struct mtd_info *mtd)
{
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();

    return (s3c2410nand->NFSTAT & S3C2410_NFSTAT_READY);
33d1e4c0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d1e4c4:	e5930010 	ldr	r0, [r3, #16]
}
33d1e4c8:	e2000001 	and	r0, r0, #1	; 0x1
33d1e4cc:	e1a0f00e 	mov	pc, lr

33d1e4d0 <s3c2440_nand_select_chip>:
/* select chip, for s3c2440 */
static void s3c2440_nand_select_chip(struct mtd_info *mtd, int chip)
{
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    if (chip == -1) {
33d1e4d0:	e3710001 	cmn	r1, #1	; 0x1
}

/* for s3c2440, www.embedsky.net */
static inline S3C2440_NAND * const S3C2440_GetBase_NAND(void)
{
    return (S3C2440_NAND * const)S3C2410_NAND_BASE;
33d1e4d4:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
        s3c2440nand->NFCONT |= S3C2440_NFCONT_nFCE;
33d1e4d8:	05923004 	ldreq	r3, [r2, #4]
    } else {
        s3c2440nand->NFCONT &= ~S3C2440_NFCONT_nFCE;
33d1e4dc:	15923004 	ldrne	r3, [r2, #4]
static void s3c2440_nand_select_chip(struct mtd_info *mtd, int chip)
{
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    if (chip == -1) {
        s3c2440nand->NFCONT |= S3C2440_NFCONT_nFCE;
33d1e4e0:	03833002 	orreq	r3, r3, #2	; 0x2
    } else {
        s3c2440nand->NFCONT &= ~S3C2440_NFCONT_nFCE;
33d1e4e4:	13c33002 	bicne	r3, r3, #2	; 0x2
33d1e4e8:	e5823004 	str	r3, [r2, #4]
33d1e4ec:	e1a0f00e 	mov	pc, lr

33d1e4f0 <s3c2440_nand_hwcontrol>:
static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
{
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
    struct nand_chip *chip = mtd->priv;

    switch (cmd) {
33d1e4f0:	e2411001 	sub	r1, r1, #1	; 0x1

/* command and control functions */
static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
{
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
    struct nand_chip *chip = mtd->priv;
33d1e4f4:	e590213c 	ldr	r2, [r0, #316]

    switch (cmd) {
33d1e4f8:	e3510004 	cmp	r1, #4	; 0x4
33d1e4fc:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
33d1e500:	ea00000c 	b	33d1e538 <s3c2440_nand_hwcontrol+0x48>
33d1e504:	33d1e518 	.word	0x33d1e518
33d1e508:	33d1e518 	.word	0x33d1e518
33d1e50c:	33d1e524 	.word	0x33d1e524
33d1e510:	33d1e538 	.word	0x33d1e538
33d1e514:	33d1e52c 	.word	0x33d1e52c
    case NAND_CTL_SETNCE:
    case NAND_CTL_CLRNCE:
        printf("%s: called for NCE\n", __FUNCTION__);
33d1e518:	e59f0020 	ldr	r0, [pc, #32]	; 33d1e540 <s3c2440_nand_hwcontrol+0x50>
33d1e51c:	e59f1020 	ldr	r1, [pc, #32]	; 33d1e544 <s3c2440_nand_hwcontrol+0x54>
33d1e520:	eaffe2a8 	b	33d16fc8 <printf>
        break;

    case NAND_CTL_SETCLE:
        chip->IO_ADDR_W = (void *)&s3c2440nand->NFCMD;
33d1e524:	e59f301c 	ldr	r3, [pc, #28]	; 33d1e548 <s3c2440_nand_hwcontrol+0x58>
33d1e528:	ea000000 	b	33d1e530 <s3c2440_nand_hwcontrol+0x40>
        break;

    case NAND_CTL_SETALE:
        chip->IO_ADDR_W = (void *)&s3c2440nand->NFADDR;
33d1e52c:	e59f3018 	ldr	r3, [pc, #24]	; 33d1e54c <s3c2440_nand_hwcontrol+0x5c>
33d1e530:	e5823004 	str	r3, [r2, #4]
        break;
33d1e534:	e1a0f00e 	mov	pc, lr

        /* NAND_CTL_CLRCLE: */
        /* NAND_CTL_CLRALE: */
    default:
        chip->IO_ADDR_W = (void *)&s3c2440nand->NFDATA;
33d1e538:	e59f3010 	ldr	r3, [pc, #16]	; 33d1e550 <s3c2440_nand_hwcontrol+0x60>
33d1e53c:	eafffffb 	b	33d1e530 <s3c2440_nand_hwcontrol+0x40>
33d1e540:	33d2d1dc 	.word	0x33d2d1dc
33d1e544:	33d24ff4 	.word	0x33d24ff4
33d1e548:	4e000008 	.word	0x4e000008
33d1e54c:	4e00000c 	.word	0x4e00000c
33d1e550:	4e000010 	.word	0x4e000010

33d1e554 <s3c2440_nand_devready>:
 */
static int s3c2440_nand_devready(struct mtd_info *mtd)
{
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    return (s3c2440nand->NFSTAT & S3C2440_NFSTAT_READY);
33d1e554:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
33d1e558:	e5930020 	ldr	r0, [r3, #32]
}
33d1e55c:	e2000001 	and	r0, r0, #1	; 0x1
33d1e560:	e1a0f00e 	mov	pc, lr

33d1e564 <board_nand_init>:

#define TACLS   0
#define TWRPH0  4
#define TWRPH1  2

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
33d1e564:	e5983000 	ldr	r3, [r8]
33d1e568:	e5933014 	ldr	r3, [r3, #20]
33d1e56c:	e35300c1 	cmp	r3, #193	; 0xc1
        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
    }
    else
    {
        /* Set flash memory timing */
        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
33d1e570:	13a03e42 	movne	r3, #1056	; 0x420
{
    return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
}
static inline S3C2410_NAND * const S3C2410_GetBase_NAND(void)
{
    return (S3C2410_NAND * const)S3C2410_NAND_BASE;
33d1e574:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
#define TWRPH1  2

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
    {
        /* Enable NAND flash controller, Initialize ECC, enable chip select, Set flash memory timing */
        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
33d1e578:	059f3084 	ldreq	r3, [pc, #132]	; 33d1e604 <board_nand_init+0xa0>
    }
    else
    {
        /* Set flash memory timing */
        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
33d1e57c:	15823000 	strne	r3, [r2]
        /* Initialize ECC, enable chip select, NAND flash controller enable */
        s3c2440nand->NFCONT = (1<<4)|(0<<1)|(1<<0);
33d1e580:	13a03011 	movne	r3, #17	; 0x11
#define TWRPH1  2

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
    {
        /* Enable NAND flash controller, Initialize ECC, enable chip select, Set flash memory timing */
        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
33d1e584:	05823000 	streq	r3, [r2]
    else
    {
        /* Set flash memory timing */
        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
        /* Initialize ECC, enable chip select, NAND flash controller enable */
        s3c2440nand->NFCONT = (1<<4)|(0<<1)|(1<<0);
33d1e588:	15823004 	strne	r3, [r2, #4]
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    s3c24x0_nand_inithw();

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410) {
33d1e58c:	e5983000 	ldr	r3, [r8]
33d1e590:	e5933014 	ldr	r3, [r3, #20]
33d1e594:	e35300c1 	cmp	r3, #193	; 0xc1
        chip->hwcontrol    = s3c2410_nand_hwcontrol;
        chip->dev_ready    = s3c2410_nand_devready;
        chip->select_chip  = s3c2410_nand_select_chip;
        chip->options      = 0;
    } else {
        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
33d1e598:	e59f1068 	ldr	r1, [pc, #104]	; 33d1e608 <board_nand_init+0xa4>
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    s3c24x0_nand_inithw();

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410) {
        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
33d1e59c:	e59f2068 	ldr	r2, [pc, #104]	; 33d1e60c <board_nand_init+0xa8>
    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    s3c24x0_nand_inithw();

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410) {
33d1e5a0:	1a00000a 	bne	33d1e5d0 <board_nand_init+0x6c>
        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
        chip->IO_ADDR_W    = (void *)&s3c2410nand->NFDATA;
        chip->hwcontrol    = s3c2410_nand_hwcontrol;
33d1e5a4:	e59f3064 	ldr	r3, [pc, #100]	; 33d1e610 <board_nand_init+0xac>
33d1e5a8:	e5803030 	str	r3, [r0, #48]
        chip->dev_ready    = s3c2410_nand_devready;
33d1e5ac:	e59f3060 	ldr	r3, [pc, #96]	; 33d1e614 <board_nand_init+0xb0>
33d1e5b0:	e5803034 	str	r3, [r0, #52]
        chip->select_chip  = s3c2410_nand_select_chip;
33d1e5b4:	e59f305c 	ldr	r3, [pc, #92]	; 33d1e618 <board_nand_init+0xb4>
33d1e5b8:	e5803024 	str	r3, [r0, #36]
        chip->options      = 0;
33d1e5bc:	e3a03000 	mov	r3, #0	; 0x0

    s3c24x0_nand_inithw();

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410) {
        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
        chip->IO_ADDR_W    = (void *)&s3c2410nand->NFDATA;
33d1e5c0:	e5802004 	str	r2, [r0, #4]
        chip->hwcontrol    = s3c2410_nand_hwcontrol;
        chip->dev_ready    = s3c2410_nand_devready;
        chip->select_chip  = s3c2410_nand_select_chip;
        chip->options      = 0;
33d1e5c4:	e5803088 	str	r3, [r0, #136]
    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();

    s3c24x0_nand_inithw();

    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410) {
        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
33d1e5c8:	e5802000 	str	r2, [r0]
        chip->IO_ADDR_W    = (void *)&s3c2410nand->NFDATA;
        chip->hwcontrol    = s3c2410_nand_hwcontrol;
        chip->dev_ready    = s3c2410_nand_devready;
        chip->select_chip  = s3c2410_nand_select_chip;
        chip->options      = 0;
33d1e5cc:	ea000009 	b	33d1e5f8 <board_nand_init+0x94>
    } else {
        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
        chip->IO_ADDR_W    = (void *)&s3c2440nand->NFDATA;
        chip->hwcontrol    = s3c2440_nand_hwcontrol;
33d1e5d0:	e59f3044 	ldr	r3, [pc, #68]	; 33d1e61c <board_nand_init+0xb8>
33d1e5d4:	e5803030 	str	r3, [r0, #48]
        chip->dev_ready    = s3c2440_nand_devready;
33d1e5d8:	e59f3040 	ldr	r3, [pc, #64]	; 33d1e620 <board_nand_init+0xbc>
33d1e5dc:	e5803034 	str	r3, [r0, #52]
        chip->select_chip  = s3c2440_nand_select_chip;
33d1e5e0:	e59f303c 	ldr	r3, [pc, #60]	; 33d1e624 <board_nand_init+0xc0>
33d1e5e4:	e5803024 	str	r3, [r0, #36]
        chip->options      = 0;
33d1e5e8:	e3a03000 	mov	r3, #0	; 0x0
        chip->dev_ready    = s3c2410_nand_devready;
        chip->select_chip  = s3c2410_nand_select_chip;
        chip->options      = 0;
    } else {
        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
        chip->IO_ADDR_W    = (void *)&s3c2440nand->NFDATA;
33d1e5ec:	e5801004 	str	r1, [r0, #4]
        chip->hwcontrol    = s3c2440_nand_hwcontrol;
        chip->dev_ready    = s3c2440_nand_devready;
        chip->select_chip  = s3c2440_nand_select_chip;
        chip->options      = 0;
33d1e5f0:	e5803088 	str	r3, [r0, #136]
        chip->hwcontrol    = s3c2410_nand_hwcontrol;
        chip->dev_ready    = s3c2410_nand_devready;
        chip->select_chip  = s3c2410_nand_select_chip;
        chip->options      = 0;
    } else {
        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
33d1e5f4:	e5801000 	str	r1, [r0]
        chip->dev_ready    = s3c2440_nand_devready;
        chip->select_chip  = s3c2440_nand_select_chip;
        chip->options      = 0;
    }

    chip->eccmode       = NAND_ECC_SOFT;
33d1e5f8:	e3a03001 	mov	r3, #1	; 0x1
33d1e5fc:	e5803054 	str	r3, [r0, #84]
33d1e600:	e1a0f00e 	mov	pc, lr
33d1e604:	00009842 	.word	0x00009842
33d1e608:	4e000010 	.word	0x4e000010
33d1e60c:	4e00000c 	.word	0x4e00000c
33d1e610:	33d1e45c 	.word	0x33d1e45c
33d1e614:	33d1e4c0 	.word	0x33d1e4c0
33d1e618:	33d1e43c 	.word	0x33d1e43c
33d1e61c:	33d1e4f0 	.word	0x33d1e4f0
33d1e620:	33d1e554 	.word	0x33d1e554
33d1e624:	33d1e4d0 	.word	0x33d1e4d0

33d1e628 <__ashldi3>:
#endif

.globl __ashldi3
__ashldi3:

	subs	r3, r2, #32
33d1e628:	e2523020 	subs	r3, r2, #32	; 0x20
	rsb	ip, r2, #32
33d1e62c:	e262c020 	rsb	ip, r2, #32	; 0x20
	movmi	ah, ah, lsl r2
33d1e630:	41a01211 	lslmi	r1, r1, r2
	movpl	ah, al, lsl r3
33d1e634:	51a01310 	lslpl	r1, r0, r3
	orrmi	ah, ah, al, lsr ip
33d1e638:	41811c30 	orrmi	r1, r1, r0, lsr ip
	mov	al, al, lsl r2
33d1e63c:	e1a00210 	lsl	r0, r0, r2
	mov	pc, lr
33d1e640:	e1a0f00e 	mov	pc, lr

33d1e644 <__ashrdi3>:
#endif

.globl __ashrdi3
__ashrdi3:

	subs	r3, r2, #32
33d1e644:	e2523020 	subs	r3, r2, #32	; 0x20
	rsb	ip, r2, #32
33d1e648:	e262c020 	rsb	ip, r2, #32	; 0x20
	movmi	al, al, lsr r2
33d1e64c:	41a00230 	lsrmi	r0, r0, r2
	movpl	al, ah, asr r3
33d1e650:	51a00351 	asrpl	r0, r1, r3
	orrmi	al, al, ah, lsl ip
33d1e654:	41800c11 	orrmi	r0, r0, r1, lsl ip
	mov	ah, ah, asr r2
33d1e658:	e1a01251 	asr	r1, r1, r2
	mov	pc, lr
33d1e65c:	e1a0f00e 	mov	pc, lr

33d1e660 <__divsi3>:
	movhs	\order, #16
	movlo	\order, #0

	cmp	\divisor, #(1 << 8)
	movhs	\divisor, \divisor, lsr #8
	addhs	\order, \order, #8
33d1e660:	e3510000 	cmp	r1, #0	; 0x0

33d1e664:	e020c001 	eor	ip, r0, r1
	cmp	\divisor, #(1 << 4)
33d1e668:	0a000042 	beq	33d1e778 <Ldiv0>
	movhs	\divisor, \divisor, lsr #4
33d1e66c:	42611000 	rsbmi	r1, r1, #0	; 0x0
	addhs	\order, \order, #4
33d1e670:	e2512001 	subs	r2, r1, #1	; 0x1

33d1e674:	0a000027 	beq	33d1e718 <__divsi3+0xb8>
	cmp	\divisor, #(1 << 2)
33d1e678:	e1b03000 	movs	r3, r0
	addhi	\order, \order, #3
33d1e67c:	42603000 	rsbmi	r3, r0, #0	; 0x0
	addls	\order, \order, \divisor, lsr #1
33d1e680:	e1530001 	cmp	r3, r1

33d1e684:	9a000026 	bls	33d1e724 <__divsi3+0xc4>
#endif
33d1e688:	e1110002 	tst	r1, r2

33d1e68c:	0a000028 	beq	33d1e734 <__divsi3+0xd4>
	mov	\curbit, #1
	mov	\divisor, \divisor, lsl \result
	mov	\curbit, \curbit, lsl \result
	mov	\result, #0

#else
33d1e690:	e311020e 	tst	r1, #-536870912	; 0xe0000000
33d1e694:	01a01181 	lsleq	r1, r1, #3
33d1e698:	03a02008 	moveq	r2, #8	; 0x8
33d1e69c:	13a02001 	movne	r2, #1	; 0x1
33d1e6a0:	e3510201 	cmp	r1, #268435456	; 0x10000000
33d1e6a4:	31510003 	cmpcc	r1, r3
33d1e6a8:	31a01201 	lslcc	r1, r1, #4
33d1e6ac:	31a02202 	lslcc	r2, r2, #4
33d1e6b0:	3afffffa 	bcc	33d1e6a0 <__divsi3+0x40>
33d1e6b4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
33d1e6b8:	31510003 	cmpcc	r1, r3
33d1e6bc:	31a01081 	lslcc	r1, r1, #1
33d1e6c0:	31a02082 	lslcc	r2, r2, #1
33d1e6c4:	3afffffa 	bcc	33d1e6b4 <__divsi3+0x54>
33d1e6c8:	e3a00000 	mov	r0, #0	; 0x0
33d1e6cc:	e1530001 	cmp	r3, r1
33d1e6d0:	20433001 	subcs	r3, r3, r1
33d1e6d4:	21800002 	orrcs	r0, r0, r2
33d1e6d8:	e15300a1 	cmp	r3, r1, lsr #1
33d1e6dc:	204330a1 	subcs	r3, r3, r1, lsr #1
33d1e6e0:	218000a2 	orrcs	r0, r0, r2, lsr #1
33d1e6e4:	e1530121 	cmp	r3, r1, lsr #2
33d1e6e8:	20433121 	subcs	r3, r3, r1, lsr #2
33d1e6ec:	21800122 	orrcs	r0, r0, r2, lsr #2
33d1e6f0:	e15301a1 	cmp	r3, r1, lsr #3
33d1e6f4:	204331a1 	subcs	r3, r3, r1, lsr #3
33d1e6f8:	218001a2 	orrcs	r0, r0, r2, lsr #3
33d1e6fc:	e3530000 	cmp	r3, #0	; 0x0
33d1e700:	11b02222 	lsrsne	r2, r2, #4
33d1e704:	11a01221 	lsrne	r1, r1, #4
33d1e708:	1affffef 	bne	33d1e6cc <__divsi3+0x6c>
#endif

.endm

	.align	5
.globl __divsi3
33d1e70c:	e35c0000 	cmp	ip, #0	; 0x0
__divsi3:
33d1e710:	42600000 	rsbmi	r0, r0, #0	; 0x0
	cmp	r1, #0
33d1e714:	e1a0f00e 	mov	pc, lr
	eor	ip, r0, r1			@ save the sign of the result.
	beq	Ldiv0
33d1e718:	e13c0000 	teq	ip, r0
	rsbmi	r1, r1, #0			@ loops below use unsigned.
33d1e71c:	42600000 	rsbmi	r0, r0, #0	; 0x0
	subs	r2, r1, #1			@ division by 1 or -1 ?
33d1e720:	e1a0f00e 	mov	pc, lr
	beq	10f
	movs	r3, r0
33d1e724:	33a00000 	movcc	r0, #0	; 0x0
	rsbmi	r3, r0, #0			@ positive dividend value
33d1e728:	01a00fcc 	asreq	r0, ip, #31
	cmp	r3, r1
33d1e72c:	03800001 	orreq	r0, r0, #1	; 0x1
	bls	11f
33d1e730:	e1a0f00e 	mov	pc, lr
#if __LINUX_ARM_ARCH__ >= 5

	clz	\order, \divisor
	rsb	\order, \order, #31

#else
33d1e734:	e3510801 	cmp	r1, #65536	; 0x10000
33d1e738:	21a01821 	lsrcs	r1, r1, #16
33d1e73c:	23a02010 	movcs	r2, #16	; 0x10
33d1e740:	33a02000 	movcc	r2, #0	; 0x0
33d1e744:	e3510c01 	cmp	r1, #256	; 0x100
33d1e748:	21a01421 	lsrcs	r1, r1, #8
33d1e74c:	22822008 	addcs	r2, r2, #8	; 0x8
33d1e750:	e3510010 	cmp	r1, #16	; 0x10
33d1e754:	21a01221 	lsrcs	r1, r1, #4
33d1e758:	22822004 	addcs	r2, r2, #4	; 0x4
33d1e75c:	e3510004 	cmp	r1, #4	; 0x4
33d1e760:	82822003 	addhi	r2, r2, #3	; 0x3
33d1e764:	908220a1 	addls	r2, r2, r1, lsr #1
	cmp	r3, r1
	bls	11f
	tst	r1, r2				@ divisor is power of 2 ?
	beq	12f

	ARM_DIV_BODY r3, r1, r0, r2
33d1e768:	e35c0000 	cmp	ip, #0	; 0x0

33d1e76c:	e1a00233 	lsr	r0, r3, r2
	cmp	ip, #0
33d1e770:	42600000 	rsbmi	r0, r0, #0	; 0x0
	rsbmi	r0, r0, #0
33d1e774:	e1a0f00e 	mov	pc, lr

33d1e778 <Ldiv0>:
	mov	pc, lr

10:	teq	ip, r0				@ same sign ?
	rsbmi	r0, r0, #0
33d1e778:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	mov	pc, lr
33d1e77c:	ebff8ce0 	bl	33d01b04 <__div0>

33d1e780:	e3a00000 	mov	r0, #0	; 0x0
11:	movlo	r0, #0
33d1e784:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1e788:	e1a00000 	nop			(mov r0,r0)
33d1e78c:	e1a00000 	nop			(mov r0,r0)
33d1e790:	e1a00000 	nop			(mov r0,r0)
33d1e794:	e1a00000 	nop			(mov r0,r0)
33d1e798:	e1a00000 	nop			(mov r0,r0)
33d1e79c:	e1a00000 	nop			(mov r0,r0)

33d1e7a0 <__modsi3>:
	subhs	\dividend, \dividend, \divisor
	mov	\divisor,  \divisor,  lsr #1
3:	cmp	\dividend, \divisor
	subhs	\dividend, \dividend, \divisor
	mov	\divisor,  \divisor,  lsr #1
4:	cmp	\dividend, \divisor
33d1e7a0:	e3510000 	cmp	r1, #0	; 0x0
	subhs	\dividend, \dividend, \divisor
33d1e7a4:	0a000032 	beq	33d1e874 <Ldiv0>
5:
33d1e7a8:	42611000 	rsbmi	r1, r1, #0	; 0x0
.endm
33d1e7ac:	e1b0c000 	movs	ip, r0

33d1e7b0:	42600000 	rsbmi	r0, r0, #0	; 0x0
	.align	5
33d1e7b4:	e2512001 	subs	r2, r1, #1	; 0x1
.globl __modsi3
33d1e7b8:	11500001 	cmpne	r0, r1
__modsi3:
33d1e7bc:	03a00000 	moveq	r0, #0	; 0x0
	cmp	r1, #0
33d1e7c0:	81110002 	tsthi	r1, r2
	beq	Ldiv0
33d1e7c4:	00000002 	andeq	r0, r0, r2
	rsbmi	r1, r1, #0			@ loops below use unsigned.
33d1e7c8:	9a000026 	bls	33d1e868 <__modsi3+0xc8>
	clz	\order, \divisor
	clz	\spare, \dividend
	sub	\order, \order, \spare
	mov	\divisor, \divisor, lsl \order

#else
33d1e7cc:	e3a02000 	mov	r2, #0	; 0x0
33d1e7d0:	e3510201 	cmp	r1, #268435456	; 0x10000000
33d1e7d4:	31510000 	cmpcc	r1, r0
33d1e7d8:	31a01201 	lslcc	r1, r1, #4
33d1e7dc:	32822004 	addcc	r2, r2, #4	; 0x4
33d1e7e0:	3afffffa 	bcc	33d1e7d0 <__modsi3+0x30>
33d1e7e4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
33d1e7e8:	31510000 	cmpcc	r1, r0
33d1e7ec:	31a01081 	lslcc	r1, r1, #1
33d1e7f0:	32822001 	addcc	r2, r2, #1	; 0x1
33d1e7f4:	3afffffa 	bcc	33d1e7e4 <__modsi3+0x44>
33d1e7f8:	e2522003 	subs	r2, r2, #3	; 0x3
33d1e7fc:	ba00000e 	blt	33d1e83c <__modsi3+0x9c>
33d1e800:	e1500001 	cmp	r0, r1
33d1e804:	20400001 	subcs	r0, r0, r1
33d1e808:	e15000a1 	cmp	r0, r1, lsr #1
33d1e80c:	204000a1 	subcs	r0, r0, r1, lsr #1
33d1e810:	e1500121 	cmp	r0, r1, lsr #2
33d1e814:	20400121 	subcs	r0, r0, r1, lsr #2
33d1e818:	e15001a1 	cmp	r0, r1, lsr #3
33d1e81c:	204001a1 	subcs	r0, r0, r1, lsr #3
33d1e820:	e3500001 	cmp	r0, #1	; 0x1
33d1e824:	e1a01221 	lsr	r1, r1, #4
33d1e828:	a2522004 	subsge	r2, r2, #4	; 0x4
33d1e82c:	aafffff3 	bge	33d1e800 <__modsi3+0x60>
33d1e830:	e3120003 	tst	r2, #3	; 0x3
33d1e834:	13300000 	teqne	r0, #0	; 0x0
33d1e838:	0a00000a 	beq	33d1e868 <__modsi3+0xc8>
33d1e83c:	e3720002 	cmn	r2, #2	; 0x2
33d1e840:	ba000006 	blt	33d1e860 <__modsi3+0xc0>
33d1e844:	0a000002 	beq	33d1e854 <__modsi3+0xb4>
33d1e848:	e1500001 	cmp	r0, r1
33d1e84c:	20400001 	subcs	r0, r0, r1
33d1e850:	e1a010a1 	lsr	r1, r1, #1
33d1e854:	e1500001 	cmp	r0, r1
33d1e858:	20400001 	subcs	r0, r0, r1
33d1e85c:	e1a010a1 	lsr	r1, r1, #1
33d1e860:	e1500001 	cmp	r0, r1
33d1e864:	20400001 	subcs	r0, r0, r1
	beq	Ldiv0
	rsbmi	r1, r1, #0			@ loops below use unsigned.
	movs	ip, r0				@ preserve sign of dividend
	rsbmi	r0, r0, #0			@ if negative make positive
	subs	r2, r1, #1			@ compare divisor with 1
	cmpne	r0, r1				@ compare dividend with divisor
33d1e868:	e35c0000 	cmp	ip, #0	; 0x0
	moveq	r0, #0
33d1e86c:	42600000 	rsbmi	r0, r0, #0	; 0x0
	tsthi	r1, r2				@ see if divisor is power of 2
33d1e870:	e1a0f00e 	mov	pc, lr

33d1e874 <Ldiv0>:
	andeq	r0, r0, r2
	bls	10f

	ARM_MOD_BODY r0, r1, r2, r3

33d1e874:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
10:	cmp	ip, #0
33d1e878:	ebff8ca1 	bl	33d01b04 <__div0>
	rsbmi	r0, r0, #0
33d1e87c:	e3a00000 	mov	r0, #0	; 0x0
	mov	pc, lr
33d1e880:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1e884:	e1a00000 	nop			(mov r0,r0)
33d1e888:	e1a00000 	nop			(mov r0,r0)
33d1e88c:	e1a00000 	nop			(mov r0,r0)
33d1e890:	e1a00000 	nop			(mov r0,r0)
33d1e894:	e1a00000 	nop			(mov r0,r0)
33d1e898:	e1a00000 	nop			(mov r0,r0)
33d1e89c:	e1a00000 	nop			(mov r0,r0)

33d1e8a0 <__umodsi3>:
	.text
	.globl	 __umodsi3
	.type  __umodsi3       ,function
	.align 0
 __umodsi3      :
	cmp	divisor, #0
33d1e8a0:	e3510000 	cmp	r1, #0	; 0x0
	beq	Ldiv0
33d1e8a4:	0a000026 	beq	33d1e944 <Ldiv0>
	mov	curbit, #1
33d1e8a8:	e3a03001 	mov	r3, #1	; 0x1
	cmp	dividend, divisor
33d1e8ac:	e1500001 	cmp	r0, r1
	movcc  	pc, lr
33d1e8b0:	31a0f00e 	movcc	pc, lr

33d1e8b4 <Loop1>:
Loop1:
	@ Unless the divisor is very big, shift it up in multiples of
	@ four bits, since this is the amount of unwinding in the main
	@ division loop.  Continue shifting until the divisor is
	@ larger than the dividend.
	cmp	divisor, #0x10000000
33d1e8b4:	e3510201 	cmp	r1, #268435456	; 0x10000000
	cmpcc	divisor, dividend
33d1e8b8:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #4
33d1e8bc:	31a01201 	lslcc	r1, r1, #4
	movcc	curbit, curbit, lsl #4
33d1e8c0:	31a03203 	lslcc	r3, r3, #4
	bcc	Loop1
33d1e8c4:	3afffffa 	bcc	33d1e8b4 <Loop1>

33d1e8c8 <Lbignum>:
Lbignum:
	@ For very big divisors, we must shift it a bit at a time, or
	@ we will be in danger of overflowing.
	cmp	divisor, #0x80000000
33d1e8c8:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
	cmpcc	divisor, dividend
33d1e8cc:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #1
33d1e8d0:	31a01081 	lslcc	r1, r1, #1
	movcc	curbit, curbit, lsl #1
33d1e8d4:	31a03083 	lslcc	r3, r3, #1
	bcc	Lbignum
33d1e8d8:	3afffffa 	bcc	33d1e8c8 <Lbignum>

33d1e8dc <Loop3>:
Loop3:
	@ Test for possible subtractions.  On the final pass, this may
	@ subtract too much from the dividend, so keep track of which
	@ subtractions are done, we can fix them up afterwards...
	mov	overdone, #0
33d1e8dc:	e3a02000 	mov	r2, #0	; 0x0
	cmp	dividend, divisor
33d1e8e0:	e1500001 	cmp	r0, r1
	subcs	dividend, dividend, divisor
33d1e8e4:	20400001 	subcs	r0, r0, r1
	cmp	dividend, divisor, lsr #1
33d1e8e8:	e15000a1 	cmp	r0, r1, lsr #1
	subcs	dividend, dividend, divisor, lsr #1
33d1e8ec:	204000a1 	subcs	r0, r0, r1, lsr #1
	orrcs	overdone, overdone, curbit, ror #1
33d1e8f0:	218220e3 	orrcs	r2, r2, r3, ror #1
	cmp	dividend, divisor, lsr #2
33d1e8f4:	e1500121 	cmp	r0, r1, lsr #2
	subcs	dividend, dividend, divisor, lsr #2
33d1e8f8:	20400121 	subcs	r0, r0, r1, lsr #2
	orrcs	overdone, overdone, curbit, ror #2
33d1e8fc:	21822163 	orrcs	r2, r2, r3, ror #2
	cmp	dividend, divisor, lsr #3
33d1e900:	e15001a1 	cmp	r0, r1, lsr #3
	subcs	dividend, dividend, divisor, lsr #3
33d1e904:	204001a1 	subcs	r0, r0, r1, lsr #3
	orrcs	overdone, overdone, curbit, ror #3
33d1e908:	218221e3 	orrcs	r2, r2, r3, ror #3
	mov	ip, curbit
33d1e90c:	e1a0c003 	mov	ip, r3
	cmp	dividend, #0			@ Early termination?
33d1e910:	e3500000 	cmp	r0, #0	; 0x0
	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
33d1e914:	11b03223 	lsrsne	r3, r3, #4
	movne	divisor, divisor, lsr #4
33d1e918:	11a01221 	lsrne	r1, r1, #4
	bne	Loop3
33d1e91c:	1affffee 	bne	33d1e8dc <Loop3>
	@ the top three bits of "overdone".  Exactly which were not needed
	@ are governed by the position of the bit, stored in ip.
	@ If we terminated early, because dividend became zero,
	@ then none of the below will match, since the bit in ip will not be
	@ in the bottom nibble.
	ands	overdone, overdone, #0xe0000000
33d1e920:	e212220e 	ands	r2, r2, #-536870912	; 0xe0000000
	moveq  	pc, lr				@ No fixups needed
33d1e924:	01a0f00e 	moveq	pc, lr
	tst	overdone, ip, ror #3
33d1e928:	e11201ec 	tst	r2, ip, ror #3
	addne	dividend, dividend, divisor, lsr #3
33d1e92c:	108001a1 	addne	r0, r0, r1, lsr #3
	tst	overdone, ip, ror #2
33d1e930:	e112016c 	tst	r2, ip, ror #2
	addne	dividend, dividend, divisor, lsr #2
33d1e934:	10800121 	addne	r0, r0, r1, lsr #2
	tst	overdone, ip, ror #1
33d1e938:	e11200ec 	tst	r2, ip, ror #1
	addne	dividend, dividend, divisor, lsr #1
33d1e93c:	108000a1 	addne	r0, r0, r1, lsr #1
	mov 	pc, lr
33d1e940:	e1a0f00e 	mov	pc, lr

33d1e944 <Ldiv0>:
Ldiv0:
	str	lr, [sp, #-4]!
33d1e944:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	bl	 __div0       (PLT)
33d1e948:	ebff8c6d 	bl	33d01b04 <__div0>
	mov	r0, #0			@ about as wrong as it could be
33d1e94c:	e3a00000 	mov	r0, #0	; 0x0
	ldmia	sp!, {pc}
33d1e950:	e8bd8000 	pop	{pc}

33d1e954 <do_bootm_linux>:
extern image_header_t header;	/* from cmd_bootm.c */


void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
		     ulong addr, ulong *len_ptr, int verify)
{
33d1e954:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d1e958:	e24dd014 	sub	sp, sp, #20	; 0x14
33d1e95c:	e58d0010 	str	r0, [sp, #16]
33d1e960:	e58d100c 	str	r1, [sp, #12]
33d1e964:	e1a09003 	mov	r9, r3
	ulong len = 0, checksum;
	ulong initrd_start, initrd_end;
	ulong data;
	void (*theKernel)(int zero, int arch, uint params);
	image_header_t *hdr = &header;
	bd_t *bd = gd->bd;
33d1e968:	e5983000 	ldr	r3, [r8]

#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv ("bootargs");
33d1e96c:	e59f0358 	ldr	r0, [pc, #856]	; 33d1eccc <do_bootm_linux+0x378>
extern image_header_t header;	/* from cmd_bootm.c */


void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
		     ulong addr, ulong *len_ptr, int verify)
{
33d1e970:	e1a0b002 	mov	fp, r2
	ulong len = 0, checksum;
	ulong initrd_start, initrd_end;
	ulong data;
	void (*theKernel)(int zero, int arch, uint params);
	image_header_t *hdr = &header;
	bd_t *bd = gd->bd;
33d1e974:	e58d3004 	str	r3, [sp, #4]
extern image_header_t header;	/* from cmd_bootm.c */


void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
		     ulong addr, ulong *len_ptr, int verify)
{
33d1e978:	e59d5038 	ldr	r5, [sp, #56]
	void (*theKernel)(int zero, int arch, uint params);
	image_header_t *hdr = &header;
	bd_t *bd = gd->bd;

#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv ("bootargs");
33d1e97c:	ebffdbb3 	bl	33d15850 <getenv>
{
	ulong len = 0, checksum;
	ulong initrd_start, initrd_end;
	ulong data;
	void (*theKernel)(int zero, int arch, uint params);
	image_header_t *hdr = &header;
33d1e980:	e59f7348 	ldr	r7, [pc, #840]	; 33d1ecd0 <do_bootm_linux+0x37c>
33d1e984:	e5973014 	ldr	r3, [r7, #20]
	return __arch__swab32(x);
33d1e988:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d1e98c:	e1a02402 	lsl	r2, r2, #8
33d1e990:	e1822c03 	orr	r2, r2, r3, lsl #24
33d1e994:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d1e998:	e1822421 	orr	r2, r2, r1, lsr #8
33d1e99c:	e1823c23 	orr	r3, r2, r3, lsr #24
	theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);

	/*
	 * Check if there is an initrd image
	 */
	if (argc >= 3) {
33d1e9a0:	e35b0002 	cmp	fp, #2	; 0x2
	void (*theKernel)(int zero, int arch, uint params);
	image_header_t *hdr = &header;
	bd_t *bd = gd->bd;

#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv ("bootargs");
33d1e9a4:	e58d0000 	str	r0, [sp]
33d1e9a8:	e58d3008 	str	r3, [sp, #8]


void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
		     ulong addr, ulong *len_ptr, int verify)
{
	ulong len = 0, checksum;
33d1e9ac:	e3a04000 	mov	r4, #0	; 0x0
	theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);

	/*
	 * Check if there is an initrd image
	 */
	if (argc >= 3) {
33d1e9b0:	da000065 	ble	33d1eb4c <do_bootm_linux+0x1f8>
		SHOW_BOOT_PROGRESS (9);

		addr = simple_strtoul (argv[2], NULL, 16);
33d1e9b4:	e3a02010 	mov	r2, #16	; 0x10
33d1e9b8:	e1a01004 	mov	r1, r4
33d1e9bc:	e5990008 	ldr	r0, [r9, #8]
33d1e9c0:	ebffeee5 	bl	33d1a55c <simple_strtoul>

		printf ("## Loading Ramdisk Image at %08lx ...\n", addr);
33d1e9c4:	e1a01000 	mov	r1, r0
	 * Check if there is an initrd image
	 */
	if (argc >= 3) {
		SHOW_BOOT_PROGRESS (9);

		addr = simple_strtoul (argv[2], NULL, 16);
33d1e9c8:	e1a06000 	mov	r6, r0

		printf ("## Loading Ramdisk Image at %08lx ...\n", addr);
33d1e9cc:	e59f0300 	ldr	r0, [pc, #768]	; 33d1ecd4 <do_bootm_linux+0x380>
33d1e9d0:	ebffe17c 	bl	33d16fc8 <printf>
		if (addr_dataflash (addr)) {
			read_dataflash (addr, sizeof (image_header_t),
					(char *) &header);
		} else
#endif
			memcpy (&header, (char *) addr,
33d1e9d4:	e1a01006 	mov	r1, r6
33d1e9d8:	e3a02040 	mov	r2, #64	; 0x40
33d1e9dc:	e1a00007 	mov	r0, r7
33d1e9e0:	ebffee7f 	bl	33d1a3e4 <memcpy>
33d1e9e4:	e5971000 	ldr	r1, [r7]
33d1e9e8:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d1e9ec:	e1a03403 	lsl	r3, r3, #8
33d1e9f0:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d1e9f4:	e1833c01 	orr	r3, r3, r1, lsl #24
33d1e9f8:	e1833422 	orr	r3, r3, r2, lsr #8
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d1e9fc:	e59f22d4 	ldr	r2, [pc, #724]	; 33d1ecd8 <do_bootm_linux+0x384>
	return __arch__swab32(x);
33d1ea00:	e1833c21 	orr	r3, r3, r1, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d1ea04:	e1530002 	cmp	r3, r2
33d1ea08:	0a000006 	beq	33d1ea28 <do_bootm_linux+0xd4>
				sizeof (image_header_t));

		if (ntohl (hdr->ih_magic) != IH_MAGIC) {
			printf ("Bad Magic Number\n");
33d1ea0c:	e59f02c8 	ldr	r0, [pc, #712]	; 33d1ecdc <do_bootm_linux+0x388>
33d1ea10:	ebffe16c 	bl	33d16fc8 <printf>
			SHOW_BOOT_PROGRESS (-10);
			do_reset (cmdtp, flag, argc, argv);
33d1ea14:	e59d0010 	ldr	r0, [sp, #16]
33d1ea18:	e59d100c 	ldr	r1, [sp, #12]
33d1ea1c:	e1a0200b 	mov	r2, fp
33d1ea20:	e1a03009 	mov	r3, r9
33d1ea24:	ebfffdfa 	bl	33d1e214 <do_reset>
33d1ea28:	e5973004 	ldr	r3, [r7, #4]
	return __arch__swab32(x);
33d1ea2c:	e2034cff 	and	r4, r3, #65280	; 0xff00
33d1ea30:	e1a04404 	lsl	r4, r4, #8
33d1ea34:	e20328ff 	and	r2, r3, #16711680	; 0xff0000
33d1ea38:	e1844c03 	orr	r4, r4, r3, lsl #24
		}

		data = (ulong) & header;
		len = sizeof (image_header_t);

		checksum = ntohl (hdr->ih_hcrc);
33d1ea3c:	e3a0a000 	mov	sl, #0	; 0x0
33d1ea40:	e1844422 	orr	r4, r4, r2, lsr #8
		hdr->ih_hcrc = 0;

		if (crc32 (0, (unsigned char *) data, len) != checksum) {
33d1ea44:	e1a0000a 	mov	r0, sl
33d1ea48:	e1a01007 	mov	r1, r7
33d1ea4c:	e3a02040 	mov	r2, #64	; 0x40
33d1ea50:	e1844c23 	orr	r4, r4, r3, lsr #24

		data = (ulong) & header;
		len = sizeof (image_header_t);

		checksum = ntohl (hdr->ih_hcrc);
		hdr->ih_hcrc = 0;
33d1ea54:	e587a004 	str	sl, [r7, #4]

		if (crc32 (0, (unsigned char *) data, len) != checksum) {
33d1ea58:	ebffecae 	bl	33d19d18 <crc32>
33d1ea5c:	e1500004 	cmp	r0, r4
			printf ("Bad Magic Number\n");
			SHOW_BOOT_PROGRESS (-10);
			do_reset (cmdtp, flag, argc, argv);
		}

		data = (ulong) & header;
33d1ea60:	e1a05007 	mov	r5, r7
		len = sizeof (image_header_t);

		checksum = ntohl (hdr->ih_hcrc);
		hdr->ih_hcrc = 0;

		if (crc32 (0, (unsigned char *) data, len) != checksum) {
33d1ea64:	0a000006 	beq	33d1ea84 <do_bootm_linux+0x130>
			printf ("Bad Header Checksum\n");
33d1ea68:	e59f0270 	ldr	r0, [pc, #624]	; 33d1ece0 <do_bootm_linux+0x38c>
33d1ea6c:	ebffe155 	bl	33d16fc8 <printf>
			SHOW_BOOT_PROGRESS (-11);
			do_reset (cmdtp, flag, argc, argv);
33d1ea70:	e59d0010 	ldr	r0, [sp, #16]
33d1ea74:	e59d100c 	ldr	r1, [sp, #12]
33d1ea78:	e1a0200b 	mov	r2, fp
33d1ea7c:	e1a03009 	mov	r3, r9
33d1ea80:	ebfffde3 	bl	33d1e214 <do_reset>
		}

		SHOW_BOOT_PROGRESS (10);

		print_image_hdr (hdr);
33d1ea84:	e1a00005 	mov	r0, r5
33d1ea88:	ebffbaed 	bl	33d0d644 <print_image_hdr>
33d1ea8c:	e597100c 	ldr	r1, [r7, #12]
33d1ea90:	e2013cff 	and	r3, r1, #65280	; 0xff00
33d1ea94:	e1a03403 	lsl	r3, r3, #8
33d1ea98:	e20128ff 	and	r2, r1, #16711680	; 0xff0000
33d1ea9c:	e1833c01 	orr	r3, r3, r1, lsl #24
33d1eaa0:	e1833422 	orr	r3, r3, r2, lsr #8
			read_dataflash (data, len, (char *) CFG_LOAD_ADDR);
			data = CFG_LOAD_ADDR;
		}
#endif

		if (verify) {
33d1eaa4:	e59d203c 	ldr	r2, [sp, #60]
33d1eaa8:	e3520000 	cmp	r2, #0	; 0x0
33d1eaac:	e1834c21 	orr	r4, r3, r1, lsr #24

		SHOW_BOOT_PROGRESS (10);

		print_image_hdr (hdr);

		data = addr + sizeof (image_header_t);
33d1eab0:	e2865040 	add	r5, r6, #64	; 0x40
			read_dataflash (data, len, (char *) CFG_LOAD_ADDR);
			data = CFG_LOAD_ADDR;
		}
#endif

		if (verify) {
33d1eab4:	0a000017 	beq	33d1eb18 <do_bootm_linux+0x1c4>
			ulong csum = 0;

			printf ("   Verifying Checksum ... ");
33d1eab8:	e59f0224 	ldr	r0, [pc, #548]	; 33d1ece4 <do_bootm_linux+0x390>
33d1eabc:	ebffe141 	bl	33d16fc8 <printf>
			csum = crc32 (0, (unsigned char *) data, len);
33d1eac0:	e1a01005 	mov	r1, r5
33d1eac4:	e1a02004 	mov	r2, r4
33d1eac8:	e1a0000a 	mov	r0, sl
33d1eacc:	ebffec91 	bl	33d19d18 <crc32>
33d1ead0:	e5973018 	ldr	r3, [r7, #24]
33d1ead4:	e2032cff 	and	r2, r3, #65280	; 0xff00
33d1ead8:	e1a02402 	lsl	r2, r2, #8
33d1eadc:	e1822c03 	orr	r2, r2, r3, lsl #24
33d1eae0:	e20318ff 	and	r1, r3, #16711680	; 0xff0000
33d1eae4:	e1822421 	orr	r2, r2, r1, lsr #8
33d1eae8:	e1822c23 	orr	r2, r2, r3, lsr #24
{
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
33d1eaec:	e1500002 	cmp	r0, r2
33d1eaf0:	0a000006 	beq	33d1eb10 <do_bootm_linux+0x1bc>
			if (csum != ntohl (hdr->ih_dcrc)) {
				printf ("Bad Data CRC\n");
33d1eaf4:	e59f01ec 	ldr	r0, [pc, #492]	; 33d1ece8 <do_bootm_linux+0x394>
33d1eaf8:	ebffe132 	bl	33d16fc8 <printf>
				SHOW_BOOT_PROGRESS (-12);
				do_reset (cmdtp, flag, argc, argv);
33d1eafc:	e59d0010 	ldr	r0, [sp, #16]
33d1eb00:	e59d100c 	ldr	r1, [sp, #12]
33d1eb04:	e1a0200b 	mov	r2, fp
33d1eb08:	e1a03009 	mov	r3, r9
33d1eb0c:	ebfffdc0 	bl	33d1e214 <do_reset>
			}
			printf ("OK\n");
33d1eb10:	e59f01d4 	ldr	r0, [pc, #468]	; 33d1ecec <do_bootm_linux+0x398>
33d1eb14:	ebffe12b 	bl	33d16fc8 <printf>
		}

		SHOW_BOOT_PROGRESS (11);

		if ((hdr->ih_os != IH_OS_LINUX) ||
33d1eb18:	e597301c 	ldr	r3, [r7, #28]
33d1eb1c:	e59f21cc 	ldr	r2, [pc, #460]	; 33d1ecf0 <do_bootm_linux+0x39c>
33d1eb20:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
33d1eb24:	e1530002 	cmp	r3, r2
33d1eb28:	0a000012 	beq	33d1eb78 <do_bootm_linux+0x224>
		    (hdr->ih_arch != IH_CPU_ARM) ||
		    (hdr->ih_type != IH_TYPE_RAMDISK)) {
			printf ("No Linux ARM Ramdisk Image\n");
33d1eb2c:	e59f01c0 	ldr	r0, [pc, #448]	; 33d1ecf4 <do_bootm_linux+0x3a0>
33d1eb30:	ebffe124 	bl	33d16fc8 <printf>
			SHOW_BOOT_PROGRESS (-13);
			do_reset (cmdtp, flag, argc, argv);
33d1eb34:	e59d0010 	ldr	r0, [sp, #16]
33d1eb38:	e59d100c 	ldr	r1, [sp, #12]
33d1eb3c:	e1a0200b 	mov	r2, fp
33d1eb40:	e1a03009 	mov	r3, r9
33d1eb44:	ebfffdb2 	bl	33d1e214 <do_reset>
33d1eb48:	ea00000a 	b	33d1eb78 <do_bootm_linux+0x224>
#endif /* CONFIG_B2 || CONFIG_EVB4510 */

		/*
		 * Now check if we have a multifile image
		 */
	} else if ((hdr->ih_type == IH_TYPE_MULTI) && (len_ptr[1])) {
33d1eb4c:	e5d7301e 	ldrb	r3, [r7, #30]
33d1eb50:	e3530004 	cmp	r3, #4	; 0x4
33d1eb54:	1a000007 	bne	33d1eb78 <do_bootm_linux+0x224>
33d1eb58:	e5953004 	ldr	r3, [r5, #4]
33d1eb5c:	e3530000 	cmp	r3, #0	; 0x0
33d1eb60:	0a000004 	beq	33d1eb78 <do_bootm_linux+0x224>
		SHOW_BOOT_PROGRESS (13);

		/* skip kernel length and terminator */
		data = (ulong) (&len_ptr[2]);
		/* skip any additional image length fields */
		for (i = 1; len_ptr[i]; ++i)
33d1eb64:	e3a02001 	mov	r2, #1	; 0x1
33d1eb68:	e2822001 	add	r2, r2, #1	; 0x1
33d1eb6c:	e7953102 	ldr	r3, [r5, r2, lsl #2]
33d1eb70:	e3530000 	cmp	r3, #0	; 0x0
33d1eb74:	1afffffb 	bne	33d1eb68 <do_bootm_linux+0x214>
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *) bd->bi_boot_params;
33d1eb78:	e59d3004 	ldr	r3, [sp, #4]
33d1eb7c:	e59f0174 	ldr	r0, [pc, #372]	; 33d1ecf8 <do_bootm_linux+0x3a4>
33d1eb80:	e5932018 	ldr	r2, [r3, #24]

	params->hdr.tag = ATAG_CORE;
33d1eb84:	e59f3170 	ldr	r3, [pc, #368]	; 33d1ecfc <do_bootm_linux+0x3a8>
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *) bd->bi_boot_params;
33d1eb88:	e5802000 	str	r2, [r0]

	params->hdr.tag = ATAG_CORE;
33d1eb8c:	e5823004 	str	r3, [r2, #4]
	params->hdr.size = tag_size (tag_core);
33d1eb90:	e5902000 	ldr	r2, [r0]
33d1eb94:	e3a03005 	mov	r3, #5	; 0x5
33d1eb98:	e5823000 	str	r3, [r2]

	params->u.core.flags = 0;
33d1eb9c:	e5903000 	ldr	r3, [r0]
33d1eba0:	e3a01000 	mov	r1, #0	; 0x0
33d1eba4:	e5831008 	str	r1, [r3, #8]
	params->u.core.pagesize = 0;
33d1eba8:	e5903000 	ldr	r3, [r0]
33d1ebac:	e583100c 	str	r1, [r3, #12]
	params->u.core.rootdev = 0;
33d1ebb0:	e5903000 	ldr	r3, [r0]
33d1ebb4:	e5831010 	str	r1, [r3, #16]
33d1ebb8:	ea00000b 	b	33d1ebec <do_bootm_linux+0x298>
static void setup_memory_tags (bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
33d1ebbc:	e5902000 	ldr	r2, [r0]
33d1ebc0:	e59f3138 	ldr	r3, [pc, #312]	; 33d1ed00 <do_bootm_linux+0x3ac>
33d1ebc4:	e5823004 	str	r3, [r2, #4]
		params->hdr.size = tag_size (tag_mem32);
33d1ebc8:	e5902000 	ldr	r2, [r0]
33d1ebcc:	e3a03004 	mov	r3, #4	; 0x4
33d1ebd0:	e5823000 	str	r3, [r2]

		params->u.mem.start = bd->bi_dram[i].start;
33d1ebd4:	e5902000 	ldr	r2, [r0]
33d1ebd8:	e59c301c 	ldr	r3, [ip, #28]
33d1ebdc:	e582300c 	str	r3, [r2, #12]
		params->u.mem.size = bd->bi_dram[i].size;
33d1ebe0:	e59c2020 	ldr	r2, [ip, #32]
33d1ebe4:	e5903000 	ldr	r3, [r0]
33d1ebe8:	e5832008 	str	r2, [r3, #8]

		params = tag_next (params);
33d1ebec:	e5903000 	ldr	r3, [r0]
33d1ebf0:	e5932000 	ldr	r2, [r3]
33d1ebf4:	e0833102 	add	r3, r3, r2, lsl #2
33d1ebf8:	e5803000 	str	r3, [r0]

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
33d1ebfc:	e59d3004 	ldr	r3, [sp, #4]
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags (bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
33d1ec00:	e3510000 	cmp	r1, #0	; 0x0
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
33d1ec04:	e083c181 	add	ip, r3, r1, lsl #3
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags (bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
33d1ec08:	e2811001 	add	r1, r1, #1	; 0x1
33d1ec0c:	daffffea 	ble	33d1ebbc <do_bootm_linux+0x268>

static void setup_commandline_tag (bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
33d1ec10:	e59d3000 	ldr	r3, [sp]
33d1ec14:	e3530000 	cmp	r3, #0	; 0x0
33d1ec18:	0a000019 	beq	33d1ec84 <do_bootm_linux+0x330>
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
33d1ec1c:	e1a06003 	mov	r6, r3
33d1ec20:	e5d33000 	ldrb	r3, [r3]
33d1ec24:	e3530020 	cmp	r3, #32	; 0x20
33d1ec28:	05f63001 	ldrbeq	r3, [r6, #1]!
33d1ec2c:	0afffffc 	beq	33d1ec24 <do_bootm_linux+0x2d0>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
33d1ec30:	e5d63000 	ldrb	r3, [r6]
33d1ec34:	e3530000 	cmp	r3, #0	; 0x0
33d1ec38:	0a000011 	beq	33d1ec84 <do_bootm_linux+0x330>
		return;

	params->hdr.tag = ATAG_CMDLINE;
33d1ec3c:	e59f40b4 	ldr	r4, [pc, #180]	; 33d1ecf8 <do_bootm_linux+0x3a4>
33d1ec40:	e59f30bc 	ldr	r3, [pc, #188]	; 33d1ed04 <do_bootm_linux+0x3b0>
33d1ec44:	e5942000 	ldr	r2, [r4]
33d1ec48:	e5823004 	str	r3, [r2, #4]
	params->hdr.size =
33d1ec4c:	e1a00006 	mov	r0, r6
33d1ec50:	e5945000 	ldr	r5, [r4]
33d1ec54:	ebffed2d 	bl	33d1a110 <strlen>
33d1ec58:	e280000d 	add	r0, r0, #13	; 0xd
33d1ec5c:	e1a00120 	lsr	r0, r0, #2
33d1ec60:	e5850000 	str	r0, [r5]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
33d1ec64:	e5940000 	ldr	r0, [r4]
33d1ec68:	e1a01006 	mov	r1, r6
33d1ec6c:	e2800008 	add	r0, r0, #8	; 0x8
33d1ec70:	ebffecd1 	bl	33d19fbc <strcpy>

	params = tag_next (params);
33d1ec74:	e5943000 	ldr	r3, [r4]
33d1ec78:	e5932000 	ldr	r2, [r3]
33d1ec7c:	e0833102 	add	r3, r3, r2, lsl #2
33d1ec80:	e5843000 	str	r3, [r4]
#endif  /* CONFIG_REVISION_TAG */


static void setup_end_tag (bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
33d1ec84:	e59f206c 	ldr	r2, [pc, #108]	; 33d1ecf8 <do_bootm_linux+0x3a4>
33d1ec88:	e5923000 	ldr	r3, [r2]
33d1ec8c:	e3a04000 	mov	r4, #0	; 0x0
33d1ec90:	e5834004 	str	r4, [r3, #4]
	params->hdr.size = 0;
33d1ec94:	e5923000 	ldr	r3, [r2]
#endif
	setup_end_tag (bd);
#endif

	/* we assume that the kernel is in place */
	printf ("\nStarting kernel ...\n\n");
33d1ec98:	e59f0068 	ldr	r0, [pc, #104]	; 33d1ed08 <do_bootm_linux+0x3b4>


static void setup_end_tag (bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
	params->hdr.size = 0;
33d1ec9c:	e5834000 	str	r4, [r3]
#endif
	setup_end_tag (bd);
#endif

	/* we assume that the kernel is in place */
	printf ("\nStarting kernel ...\n\n");
33d1eca0:	ebffe0c8 	bl	33d16fc8 <printf>
		extern void udc_disconnect (void);
                //udc_disconnect (); // cancled by www.embedsky.net
	}
#endif

	cleanup_before_linux ();
33d1eca4:	ebfffd50 	bl	33d1e1ec <cleanup_before_linux>

	theKernel (0, bd->bi_arch_number, bd->bi_boot_params);
33d1eca8:	e59d3004 	ldr	r3, [sp, #4]
33d1ecac:	e1a00004 	mov	r0, r4
33d1ecb0:	e2831014 	add	r1, r3, #20	; 0x14
33d1ecb4:	e8910006 	ldm	r1, {r1, r2}
33d1ecb8:	e59d3008 	ldr	r3, [sp, #8]
33d1ecbc:	e1a0e00f 	mov	lr, pc
33d1ecc0:	e1a0f003 	mov	pc, r3
33d1ecc4:	e28dd014 	add	sp, sp, #20	; 0x14
33d1ecc8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1eccc:	33d255f4 	.word	0x33d255f4
33d1ecd0:	33d60888 	.word	0x33d60888
33d1ecd4:	33d2d1f0 	.word	0x33d2d1f0
33d1ecd8:	27051956 	.word	0x27051956
33d1ecdc:	33d27a80 	.word	0x33d27a80
33d1ece0:	33d27a94 	.word	0x33d27a94
33d1ece4:	33d279a4 	.word	0x33d279a4
33d1ece8:	33d27aac 	.word	0x33d27aac
33d1ecec:	33d279d4 	.word	0x33d279d4
33d1ecf0:	00030205 	.word	0x00030205
33d1ecf4:	33d2d218 	.word	0x33d2d218
33d1ecf8:	33d625c4 	.word	0x33d625c4
33d1ecfc:	54410001 	.word	0x54410001
33d1ed00:	54410002 	.word	0x54410002
33d1ed04:	54410009 	.word	0x54410009
33d1ed08:	33d2d234 	.word	0x33d2d234

33d1ed0c <flush_cache>:
#ifdef CONFIG_OMAP2420
	void arm1136_cache_flush(void);

	arm1136_cache_flush();
#endif
	return;
33d1ed0c:	e1a0f00e 	mov	pc, lr

33d1ed10 <cramfs_read_super>:
 * device address space offset, so we need to shift it by a device start address. */
extern flash_info_t flash_info[];
#define PART_OFFSET(x)	(x->offset + flash_info[x->dev->id->num].start[0])

static int cramfs_read_super (struct part_info *info)
{
33d1ed10:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	unsigned long root_offset;

	/* Read the first block and get the superblock from it */
	memcpy (&super, (void *) PART_OFFSET(info), sizeof (super));
33d1ed14:	e5903020 	ldr	r3, [r0, #32]
33d1ed18:	e5933008 	ldr	r3, [r3, #8]
33d1ed1c:	e5d33009 	ldrb	r3, [r3, #9]
33d1ed20:	e59f70fc 	ldr	r7, [pc, #252]	; 33d1ee24 <cramfs_read_super+0x114>
33d1ed24:	e0833083 	add	r3, r3, r3, lsl #1
33d1ed28:	e0833183 	add	r3, r3, r3, lsl #3
33d1ed2c:	e0873103 	add	r3, r7, r3, lsl #2
33d1ed30:	e593300c 	ldr	r3, [r3, #12]
33d1ed34:	e5901014 	ldr	r1, [r0, #20]
33d1ed38:	e59f50e8 	ldr	r5, [pc, #232]	; 33d1ee28 <cramfs_read_super+0x118>
33d1ed3c:	e0811003 	add	r1, r1, r3
 * device address space offset, so we need to shift it by a device start address. */
extern flash_info_t flash_info[];
#define PART_OFFSET(x)	(x->offset + flash_info[x->dev->id->num].start[0])

static int cramfs_read_super (struct part_info *info)
{
33d1ed40:	e1a04000 	mov	r4, r0
	unsigned long root_offset;

	/* Read the first block and get the superblock from it */
	memcpy (&super, (void *) PART_OFFSET(info), sizeof (super));
33d1ed44:	e3a0204c 	mov	r2, #76	; 0x4c
33d1ed48:	e1a00005 	mov	r0, r5
33d1ed4c:	ebffeda4 	bl	33d1a3e4 <memcpy>

	/* Do sanity checks on the superblock */
	if (super.magic != CRAMFS_32 (CRAMFS_MAGIC)) {
33d1ed50:	e59f60d4 	ldr	r6, [pc, #212]	; 33d1ee2c <cramfs_read_super+0x11c>
33d1ed54:	e5953000 	ldr	r3, [r5]
33d1ed58:	e1530006 	cmp	r3, r6
33d1ed5c:	0a000010 	beq	33d1eda4 <cramfs_read_super+0x94>
		/* check at 512 byte offset */
		memcpy (&super, (void *) PART_OFFSET(info) + 512, sizeof (super));
33d1ed60:	e5943020 	ldr	r3, [r4, #32]
33d1ed64:	e5933008 	ldr	r3, [r3, #8]
33d1ed68:	e5d33009 	ldrb	r3, [r3, #9]
33d1ed6c:	e0833083 	add	r3, r3, r3, lsl #1
33d1ed70:	e0833183 	add	r3, r3, r3, lsl #3
33d1ed74:	e0873103 	add	r3, r7, r3, lsl #2
33d1ed78:	e593300c 	ldr	r3, [r3, #12]
33d1ed7c:	e5941014 	ldr	r1, [r4, #20]
33d1ed80:	e0811003 	add	r1, r1, r3
33d1ed84:	e2811c02 	add	r1, r1, #512	; 0x200
33d1ed88:	e1a00005 	mov	r0, r5
33d1ed8c:	e3a0204c 	mov	r2, #76	; 0x4c
33d1ed90:	ebffed93 	bl	33d1a3e4 <memcpy>
		if (super.magic != CRAMFS_32 (CRAMFS_MAGIC)) {
33d1ed94:	e5953000 	ldr	r3, [r5]
33d1ed98:	e1530006 	cmp	r3, r6
			printf ("cramfs: wrong magic\n");
33d1ed9c:	159f008c 	ldrne	r0, [pc, #140]	; 33d1ee30 <cramfs_read_super+0x120>

	/* Do sanity checks on the superblock */
	if (super.magic != CRAMFS_32 (CRAMFS_MAGIC)) {
		/* check at 512 byte offset */
		memcpy (&super, (void *) PART_OFFSET(info) + 512, sizeof (super));
		if (super.magic != CRAMFS_32 (CRAMFS_MAGIC)) {
33d1eda0:	1a000006 	bne	33d1edc0 <cramfs_read_super+0xb0>
			return -1;
		}
	}

	/* flags is reused several times, so swab it once */
	super.flags = CRAMFS_32 (super.flags);
33d1eda4:	e5952008 	ldr	r2, [r5, #8]
	super.size = CRAMFS_32 (super.size);

	/* get feature flags first */
	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {
33d1eda8:	e3c23e7f 	bic	r3, r2, #2032	; 0x7f0
33d1edac:	e3c3300f 	bic	r3, r3, #15	; 0xf
33d1edb0:	e3530000 	cmp	r3, #0	; 0x0
			return -1;
		}
	}

	/* flags is reused several times, so swab it once */
	super.flags = CRAMFS_32 (super.flags);
33d1edb4:	e59f106c 	ldr	r1, [pc, #108]	; 33d1ee28 <cramfs_read_super+0x118>
	super.size = CRAMFS_32 (super.size);

	/* get feature flags first */
	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {
33d1edb8:	0a000003 	beq	33d1edcc <cramfs_read_super+0xbc>
		printf ("cramfs: unsupported filesystem features\n");
33d1edbc:	e59f0070 	ldr	r0, [pc, #112]	; 33d1ee34 <cramfs_read_super+0x124>
33d1edc0:	ebffe080 	bl	33d16fc8 <printf>
		return -1;
33d1edc4:	e3e00000 	mvn	r0, #0	; 0x0
33d1edc8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	}

	/* Check that the root inode is in a sane state */
	if (!S_ISDIR (CRAMFS_16 (super.root.mode))) {
33d1edcc:	e1d134b0 	ldrh	r3, [r1, #64]
33d1edd0:	e2033a0f 	and	r3, r3, #61440	; 0xf000
33d1edd4:	e3530901 	cmp	r3, #16384	; 0x4000
		printf ("cramfs: root is not a directory\n");
33d1edd8:	159f0058 	ldrne	r0, [pc, #88]	; 33d1ee38 <cramfs_read_super+0x128>
		printf ("cramfs: unsupported filesystem features\n");
		return -1;
	}

	/* Check that the root inode is in a sane state */
	if (!S_ISDIR (CRAMFS_16 (super.root.mode))) {
33d1eddc:	1afffff7 	bne	33d1edc0 <cramfs_read_super+0xb0>
		printf ("cramfs: root is not a directory\n");
		return -1;
	}
	root_offset = CRAMFS_GET_OFFSET (&(super.root)) << 2;
33d1ede0:	e5913048 	ldr	r3, [r1, #72]
33d1ede4:	e1a03323 	lsr	r3, r3, #6
	if (root_offset == 0) {
33d1ede8:	e1b01103 	lsls	r1, r3, #2
33d1edec:	1a000002 	bne	33d1edfc <cramfs_read_super+0xec>
		printf ("cramfs: empty filesystem");
33d1edf0:	e59f0044 	ldr	r0, [pc, #68]	; 33d1ee3c <cramfs_read_super+0x12c>
33d1edf4:	ebffe073 	bl	33d16fc8 <printf>
33d1edf8:	ea000007 	b	33d1ee1c <cramfs_read_super+0x10c>
	} else if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&
33d1edfc:	e3120b01 	tst	r2, #1024	; 0x400
33d1ee00:	1a000005 	bne	33d1ee1c <cramfs_read_super+0x10c>
33d1ee04:	e351004c 	cmp	r1, #76	; 0x4c
33d1ee08:	13510f93 	cmpne	r1, #588	; 0x24c
33d1ee0c:	0a000002 	beq	33d1ee1c <cramfs_read_super+0x10c>
		   ((root_offset != sizeof (struct cramfs_super)) &&
		    (root_offset != 512 + sizeof (struct cramfs_super)))) {
		printf ("cramfs: bad root offset %lu\n", root_offset);
33d1ee10:	e59f0028 	ldr	r0, [pc, #40]	; 33d1ee40 <cramfs_read_super+0x130>
33d1ee14:	ebffe06b 	bl	33d16fc8 <printf>
33d1ee18:	eaffffe9 	b	33d1edc4 <cramfs_read_super+0xb4>
		return -1;
	}

	return 0;
33d1ee1c:	e3a00000 	mov	r0, #0	; 0x0
}
33d1ee20:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d1ee24:	33d62554 	.word	0x33d62554
33d1ee28:	33d625c8 	.word	0x33d625c8
33d1ee2c:	28cd3d45 	.word	0x28cd3d45
33d1ee30:	33d2d24c 	.word	0x33d2d24c
33d1ee34:	33d2d264 	.word	0x33d2d264
33d1ee38:	33d2d290 	.word	0x33d2d290
33d1ee3c:	33d2d2b4 	.word	0x33d2d2b4
33d1ee40:	33d2d2d0 	.word	0x33d2d2d0

33d1ee44 <cramfs_resolve>:

static unsigned long cramfs_resolve (unsigned long begin, unsigned long offset,
				     unsigned long size, int raw,
				     char *filename)
{
33d1ee44:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d1ee48:	e24dd010 	sub	sp, sp, #16	; 0x10
33d1ee4c:	e59dc030 	ldr	ip, [sp, #48]
33d1ee50:	e58d000c 	str	r0, [sp, #12]
33d1ee54:	e58dc004 	str	ip, [sp, #4]
33d1ee58:	e58d3008 	str	r3, [sp, #8]
33d1ee5c:	e1a09001 	mov	r9, r1
33d1ee60:	e1a07002 	mov	r7, r2
	unsigned long inodeoffset = 0, nextoffset;
33d1ee64:	e3a06000 	mov	r6, #0	; 0x0
					CRAMFS_16 (inode->mode));
				return 0;
			}
		}

		inodeoffset = nextoffset;
33d1ee68:	e1560007 	cmp	r6, r7
33d1ee6c:	2a000037 	bcs	33d1ef50 <cramfs_resolve+0x10c>
	while (inodeoffset < size) {
		struct cramfs_inode *inode;
		char *name;
		int namelen;

		inode = (struct cramfs_inode *) (begin + offset +
33d1ee70:	e59d200c 	ldr	r2, [sp, #12]
33d1ee74:	e0823009 	add	r3, r2, r9
33d1ee78:	e0835006 	add	r5, r3, r6
		/*
		 * Namelengths on disk are shifted by two
		 * and the name padded out to 4-byte boundaries
		 * with zeroes.
		 */
		namelen = CRAMFS_GET_NAMELEN (inode) << 2;
33d1ee7c:	e5d53008 	ldrb	r3, [r5, #8]
33d1ee80:	e203303f 	and	r3, r3, #63	; 0x3f
33d1ee84:	e1a04103 	lsl	r4, r3, #2
		name = (char *) inode + sizeof (struct cramfs_inode);

		nextoffset =
33d1ee88:	e0863004 	add	r3, r6, r4
33d1ee8c:	e283b00c 	add	fp, r3, #12	; 0xc
		 * Namelengths on disk are shifted by two
		 * and the name padded out to 4-byte boundaries
		 * with zeroes.
		 */
		namelen = CRAMFS_GET_NAMELEN (inode) << 2;
		name = (char *) inode + sizeof (struct cramfs_inode);
33d1ee90:	e285a00c 	add	sl, r5, #12	; 0xc

		nextoffset =
			inodeoffset + sizeof (struct cramfs_inode) + namelen;

		for (;;) {
			if (!namelen)
33d1ee94:	e3540000 	cmp	r4, #0	; 0x0
				return -1;
			if (name[namelen - 1])
33d1ee98:	e08a3004 	add	r3, sl, r4
		nextoffset =
			inodeoffset + sizeof (struct cramfs_inode) + namelen;

		for (;;) {
			if (!namelen)
				return -1;
33d1ee9c:	03e00000 	mvneq	r0, #0	; 0x0
33d1eea0:	0a00002d 	beq	33d1ef5c <cramfs_resolve+0x118>
			if (name[namelen - 1])
33d1eea4:	e5533001 	ldrb	r3, [r3, #-1]
33d1eea8:	e3530000 	cmp	r3, #0	; 0x0
				break;
			namelen--;
33d1eeac:	02444001 	subeq	r4, r4, #1	; 0x1
		name = (char *) inode + sizeof (struct cramfs_inode);

		nextoffset =
			inodeoffset + sizeof (struct cramfs_inode) + namelen;

		for (;;) {
33d1eeb0:	0afffff7 	beq	33d1ee94 <cramfs_resolve+0x50>
			if (name[namelen - 1])
				break;
			namelen--;
		}

		if (!strncmp (filename, name, namelen)) {
33d1eeb4:	e59d0004 	ldr	r0, [sp, #4]
33d1eeb8:	e1a0100a 	mov	r1, sl
33d1eebc:	e1a02004 	mov	r2, r4
33d1eec0:	ebffec74 	bl	33d1a098 <strncmp>
33d1eec4:	e3500000 	cmp	r0, #0	; 0x0
33d1eec8:	1a00001e 	bne	33d1ef48 <cramfs_resolve+0x104>
			char *p = strtok (NULL, "/");
33d1eecc:	e59f1090 	ldr	r1, [pc, #144]	; 33d1ef64 <cramfs_resolve+0x120>
33d1eed0:	ebffece9 	bl	33d1a27c <strtok>

			if (raw && (p == NULL || *p == '\0'))
33d1eed4:	e59d3008 	ldr	r3, [sp, #8]
33d1eed8:	e3530000 	cmp	r3, #0	; 0x0
33d1eedc:	0a000004 	beq	33d1eef4 <cramfs_resolve+0xb0>
33d1eee0:	e3500000 	cmp	r0, #0	; 0x0
33d1eee4:	0a00000e 	beq	33d1ef24 <cramfs_resolve+0xe0>
33d1eee8:	e5d03000 	ldrb	r3, [r0]
33d1eeec:	e3530000 	cmp	r3, #0	; 0x0
33d1eef0:	0a00000b 	beq	33d1ef24 <cramfs_resolve+0xe0>
				return offset + inodeoffset;

			if (S_ISDIR (CRAMFS_16 (inode->mode))) {
33d1eef4:	e1d5c0b0 	ldrh	ip, [r5]
33d1eef8:	e20c3a0f 	and	r3, ip, #61440	; 0xf000
33d1eefc:	e3530901 	cmp	r3, #16384	; 0x4000
33d1ef00:	1a000005 	bne	33d1ef1c <cramfs_resolve+0xd8>
				return cramfs_resolve (begin,
33d1ef04:	e995000c 	ldmib	r5, {r2, r3}
33d1ef08:	e1a03323 	lsr	r3, r3, #6
33d1ef0c:	e1a09103 	lsl	r9, r3, #2
33d1ef10:	e3c274ff 	bic	r7, r2, #-16777216	; 0xff000000
33d1ef14:	e58d0004 	str	r0, [sp, #4]
33d1ef18:	eaffffd1 	b	33d1ee64 <cramfs_resolve+0x20>
						       CRAMFS_GET_OFFSET
						       (inode) << 2,
						       CRAMFS_24 (inode->
								  size), raw,
						       p);
			} else if (S_ISREG (CRAMFS_16 (inode->mode))) {
33d1ef1c:	e3530902 	cmp	r3, #32768	; 0x8000
33d1ef20:	1a000001 	bne	33d1ef2c <cramfs_resolve+0xe8>
				return offset + inodeoffset;
33d1ef24:	e0890006 	add	r0, r9, r6
33d1ef28:	ea00000b 	b	33d1ef5c <cramfs_resolve+0x118>
			} else {
				printf ("%*.*s: unsupported file type (%x)\n",
33d1ef2c:	e1a01004 	mov	r1, r4
33d1ef30:	e1a0300a 	mov	r3, sl
33d1ef34:	e59f002c 	ldr	r0, [pc, #44]	; 33d1ef68 <cramfs_resolve+0x124>
33d1ef38:	e1a02004 	mov	r2, r4
33d1ef3c:	e58dc000 	str	ip, [sp]
33d1ef40:	ebffe020 	bl	33d16fc8 <printf>
33d1ef44:	ea000003 	b	33d1ef58 <cramfs_resolve+0x114>
					CRAMFS_16 (inode->mode));
				return 0;
			}
		}

		inodeoffset = nextoffset;
33d1ef48:	e1a0600b 	mov	r6, fp
33d1ef4c:	eaffffc5 	b	33d1ee68 <cramfs_resolve+0x24>
	}

	printf ("can't find corresponding entry\n");
33d1ef50:	e59f0014 	ldr	r0, [pc, #20]	; 33d1ef6c <cramfs_resolve+0x128>
33d1ef54:	ebffe01b 	bl	33d16fc8 <printf>
	return 0;
33d1ef58:	e3a00000 	mov	r0, #0	; 0x0
}
33d1ef5c:	e28dd010 	add	sp, sp, #16	; 0x10
33d1ef60:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1ef64:	33d298a8 	.word	0x33d298a8
33d1ef68:	33d2d2f0 	.word	0x33d2d2f0
33d1ef6c:	33d2d314 	.word	0x33d2d314

33d1ef70 <cramfs_uncompress>:

static int cramfs_uncompress (unsigned long begin, unsigned long offset,
			      unsigned long loadoffset)
{
33d1ef70:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct cramfs_inode *inode = (struct cramfs_inode *) (begin + offset);
33d1ef74:	e0806001 	add	r6, r0, r1
	unsigned long *block_ptrs = (unsigned long *)
		(begin + (CRAMFS_GET_OFFSET (inode) << 2));
	unsigned long curr_block = (CRAMFS_GET_OFFSET (inode) +
33d1ef78:	e5963004 	ldr	r3, [r6, #4]

static int cramfs_uncompress (unsigned long begin, unsigned long offset,
			      unsigned long loadoffset)
{
	struct cramfs_inode *inode = (struct cramfs_inode *) (begin + offset);
	unsigned long *block_ptrs = (unsigned long *)
33d1ef7c:	e5961008 	ldr	r1, [r6, #8]
		(begin + (CRAMFS_GET_OFFSET (inode) << 2));
	unsigned long curr_block = (CRAMFS_GET_OFFSET (inode) +
33d1ef80:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
33d1ef84:	e2833eff 	add	r3, r3, #4080	; 0xff0

static int cramfs_uncompress (unsigned long begin, unsigned long offset,
			      unsigned long loadoffset)
{
	struct cramfs_inode *inode = (struct cramfs_inode *) (begin + offset);
	unsigned long *block_ptrs = (unsigned long *)
33d1ef88:	e1a01321 	lsr	r1, r1, #6
		(begin + (CRAMFS_GET_OFFSET (inode) << 2));
	unsigned long curr_block = (CRAMFS_GET_OFFSET (inode) +
33d1ef8c:	e283300f 	add	r3, r3, #15	; 0xf
33d1ef90:	e0813623 	add	r3, r1, r3, lsr #12
33d1ef94:	e1a04103 	lsl	r4, r3, #2
	return 0;
}

static int cramfs_uncompress (unsigned long begin, unsigned long offset,
			      unsigned long loadoffset)
{
33d1ef98:	e1a09000 	mov	r9, r0
33d1ef9c:	e1a07002 	mov	r7, r2
	struct cramfs_inode *inode = (struct cramfs_inode *) (begin + offset);
	unsigned long *block_ptrs = (unsigned long *)
33d1efa0:	e080b101 	add	fp, r0, r1, lsl #2
				    (((CRAMFS_24 (inode->size)) +
				      4095) >> 12)) << 2;
	int size, total_size = 0;
	int i;

	cramfs_uncompress_init ();
33d1efa4:	eb000168 	bl	33d1f54c <cramfs_uncompress_init>

	for (i = 0; i < ((CRAMFS_24 (inode->size) + 4095) >> 12); i++) {
33d1efa8:	e5963004 	ldr	r3, [r6, #4]
33d1efac:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
33d1efb0:	e2833eff 	add	r3, r3, #4080	; 0xff0
	unsigned long *block_ptrs = (unsigned long *)
		(begin + (CRAMFS_GET_OFFSET (inode) << 2));
	unsigned long curr_block = (CRAMFS_GET_OFFSET (inode) +
				    (((CRAMFS_24 (inode->size)) +
				      4095) >> 12)) << 2;
	int size, total_size = 0;
33d1efb4:	e3a0a000 	mov	sl, #0	; 0x0
	int i;

	cramfs_uncompress_init ();

	for (i = 0; i < ((CRAMFS_24 (inode->size) + 4095) >> 12); i++) {
33d1efb8:	e283300f 	add	r3, r3, #15	; 0xf
33d1efbc:	e15a0623 	cmp	sl, r3, lsr #12
33d1efc0:	e1a0500a 	mov	r5, sl
33d1efc4:	aa000010 	bge	33d1f00c <cramfs_uncompress+0x9c>
		size = cramfs_uncompress_block ((void *) loadoffset,
33d1efc8:	e79b2105 	ldr	r2, [fp, r5, lsl #2]
33d1efcc:	e1a00007 	mov	r0, r7
33d1efd0:	e0642002 	rsb	r2, r4, r2
33d1efd4:	e0891004 	add	r1, r9, r4
33d1efd8:	eb000148 	bl	33d1f500 <cramfs_uncompress_block>
						(void *) (begin + curr_block),
						(CRAMFS_32 (block_ptrs[i]) -
						 curr_block));
		if (size < 0)
33d1efdc:	e3500000 	cmp	r0, #0	; 0x0
			return size;
		loadoffset += size;
		total_size += size;
33d1efe0:	e08aa000 	add	sl, sl, r0
						(void *) (begin + curr_block),
						(CRAMFS_32 (block_ptrs[i]) -
						 curr_block));
		if (size < 0)
			return size;
		loadoffset += size;
33d1efe4:	e0877000 	add	r7, r7, r0
	for (i = 0; i < ((CRAMFS_24 (inode->size) + 4095) >> 12); i++) {
		size = cramfs_uncompress_block ((void *) loadoffset,
						(void *) (begin + curr_block),
						(CRAMFS_32 (block_ptrs[i]) -
						 curr_block));
		if (size < 0)
33d1efe8:	b8bd8ef0 	poplt	{r4, r5, r6, r7, r9, sl, fp, pc}
	int size, total_size = 0;
	int i;

	cramfs_uncompress_init ();

	for (i = 0; i < ((CRAMFS_24 (inode->size) + 4095) >> 12); i++) {
33d1efec:	e5963004 	ldr	r3, [r6, #4]
33d1eff0:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
33d1eff4:	e2833eff 	add	r3, r3, #4080	; 0xff0
33d1eff8:	e283300f 	add	r3, r3, #15	; 0xf
						 curr_block));
		if (size < 0)
			return size;
		loadoffset += size;
		total_size += size;
		curr_block = CRAMFS_32 (block_ptrs[i]);
33d1effc:	e79b4105 	ldr	r4, [fp, r5, lsl #2]
	int size, total_size = 0;
	int i;

	cramfs_uncompress_init ();

	for (i = 0; i < ((CRAMFS_24 (inode->size) + 4095) >> 12); i++) {
33d1f000:	e2855001 	add	r5, r5, #1	; 0x1
33d1f004:	e1550623 	cmp	r5, r3, lsr #12
33d1f008:	eaffffed 	b	33d1efc4 <cramfs_uncompress+0x54>
		loadoffset += size;
		total_size += size;
		curr_block = CRAMFS_32 (block_ptrs[i]);
	}

	cramfs_uncompress_exit ();
33d1f00c:	eb000166 	bl	33d1f5ac <cramfs_uncompress_exit>
	return total_size;
33d1f010:	e1a0000a 	mov	r0, sl
}
33d1f014:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d1f018 <cramfs_load>:

int cramfs_load (char *loadoffset, struct part_info *info, char *filename)
{
33d1f018:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
33d1f01c:	e1a07000 	mov	r7, r0
33d1f020:	e24dd004 	sub	sp, sp, #4	; 0x4
	unsigned long offset;

	if (cramfs_read_super (info))
33d1f024:	e1a00001 	mov	r0, r1
	cramfs_uncompress_exit ();
	return total_size;
}

int cramfs_load (char *loadoffset, struct part_info *info, char *filename)
{
33d1f028:	e1a05001 	mov	r5, r1
33d1f02c:	e1a04002 	mov	r4, r2
	unsigned long offset;

	if (cramfs_read_super (info))
33d1f030:	ebffff36 	bl	33d1ed10 <cramfs_read_super>
33d1f034:	e2506000 	subs	r6, r0, #0	; 0x0
		return -1;

	offset = cramfs_resolve (PART_OFFSET(info),
33d1f038:	e59fa0a8 	ldr	sl, [pc, #168]	; 33d1f0e8 <cramfs_load+0xd0>
33d1f03c:	e59f10a8 	ldr	r1, [pc, #168]	; 33d1f0ec <cramfs_load+0xd4>
33d1f040:	e1a00004 	mov	r0, r4
int cramfs_load (char *loadoffset, struct part_info *info, char *filename)
{
	unsigned long offset;

	if (cramfs_read_super (info))
		return -1;
33d1f044:	e3e03000 	mvn	r3, #0	; 0x0

int cramfs_load (char *loadoffset, struct part_info *info, char *filename)
{
	unsigned long offset;

	if (cramfs_read_super (info))
33d1f048:	1a000023 	bne	33d1f0dc <cramfs_load+0xc4>
		return -1;

	offset = cramfs_resolve (PART_OFFSET(info),
33d1f04c:	ebffec8a 	bl	33d1a27c <strtok>
33d1f050:	e5953020 	ldr	r3, [r5, #32]
33d1f054:	e5933008 	ldr	r3, [r3, #8]
33d1f058:	e5d33009 	ldrb	r3, [r3, #9]
33d1f05c:	e59f208c 	ldr	r2, [pc, #140]	; 33d1f0f0 <cramfs_load+0xd8>
33d1f060:	e0833083 	add	r3, r3, r3, lsl #1
33d1f064:	e0833183 	add	r3, r3, r3, lsl #3
33d1f068:	e5921008 	ldr	r1, [r2, #8]
33d1f06c:	e08a3103 	add	r3, sl, r3, lsl #2
33d1f070:	e593c00c 	ldr	ip, [r3, #12]
33d1f074:	e5922004 	ldr	r2, [r2, #4]
33d1f078:	e5953014 	ldr	r3, [r5, #20]
33d1f07c:	e1a01321 	lsr	r1, r1, #6
33d1f080:	e58d0000 	str	r0, [sp]
33d1f084:	e1a01101 	lsl	r1, r1, #2
33d1f088:	e083000c 	add	r0, r3, ip
33d1f08c:	e3c224ff 	bic	r2, r2, #-16777216	; 0xff000000
33d1f090:	e1a03006 	mov	r3, r6
33d1f094:	ebffff6a 	bl	33d1ee44 <cramfs_resolve>
				 CRAMFS_GET_OFFSET (&(super.root)) << 2,
				 CRAMFS_24 (super.root.size), 0,
				 strtok (filename, "/"));

	if (offset <= 0)
33d1f098:	e3500000 	cmp	r0, #0	; 0x0
		return offset;

	return cramfs_uncompress (PART_OFFSET(info), offset,
33d1f09c:	e1a02007 	mov	r2, r7
33d1f0a0:	e1a01000 	mov	r1, r0
				 CRAMFS_GET_OFFSET (&(super.root)) << 2,
				 CRAMFS_24 (super.root.size), 0,
				 strtok (filename, "/"));

	if (offset <= 0)
		return offset;
33d1f0a4:	e1a03000 	mov	r3, r0
	offset = cramfs_resolve (PART_OFFSET(info),
				 CRAMFS_GET_OFFSET (&(super.root)) << 2,
				 CRAMFS_24 (super.root.size), 0,
				 strtok (filename, "/"));

	if (offset <= 0)
33d1f0a8:	0a00000b 	beq	33d1f0dc <cramfs_load+0xc4>
		return offset;

	return cramfs_uncompress (PART_OFFSET(info), offset,
33d1f0ac:	e5953020 	ldr	r3, [r5, #32]
33d1f0b0:	e5933008 	ldr	r3, [r3, #8]
33d1f0b4:	e5d33009 	ldrb	r3, [r3, #9]
33d1f0b8:	e0833083 	add	r3, r3, r3, lsl #1
33d1f0bc:	e0833183 	add	r3, r3, r3, lsl #3
33d1f0c0:	e08a3103 	add	r3, sl, r3, lsl #2
33d1f0c4:	e595c014 	ldr	ip, [r5, #20]
33d1f0c8:	e593000c 	ldr	r0, [r3, #12]
33d1f0cc:	e08c0000 	add	r0, ip, r0
				  (unsigned long) loadoffset);
}
33d1f0d0:	e28dd004 	add	sp, sp, #4	; 0x4
33d1f0d4:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
				 strtok (filename, "/"));

	if (offset <= 0)
		return offset;

	return cramfs_uncompress (PART_OFFSET(info), offset,
33d1f0d8:	eaffffa4 	b	33d1ef70 <cramfs_uncompress>
				  (unsigned long) loadoffset);
}
33d1f0dc:	e1a00003 	mov	r0, r3
33d1f0e0:	e28dd004 	add	sp, sp, #4	; 0x4
33d1f0e4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d1f0e8:	33d62554 	.word	0x33d62554
33d1f0ec:	33d298a8 	.word	0x33d298a8
33d1f0f0:	33d62608 	.word	0x33d62608

33d1f0f4 <cramfs_list_inode>:

static int cramfs_list_inode (struct part_info *info, unsigned long offset)
{
33d1f0f4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct cramfs_inode *inode = (struct cramfs_inode *)
33d1f0f8:	e5903020 	ldr	r3, [r0, #32]
33d1f0fc:	e5933008 	ldr	r3, [r3, #8]
33d1f100:	e5d33009 	ldrb	r3, [r3, #9]
33d1f104:	e59fb12c 	ldr	fp, [pc, #300]	; 33d1f238 <cramfs_list_inode+0x144>
33d1f108:	e0833083 	add	r3, r3, r3, lsl #1
33d1f10c:	e0833183 	add	r3, r3, r3, lsl #3
33d1f110:	e08b3103 	add	r3, fp, r3, lsl #2
33d1f114:	e593200c 	ldr	r2, [r3, #12]
33d1f118:	e5903014 	ldr	r3, [r0, #20]
33d1f11c:	e0833002 	add	r3, r3, r2
33d1f120:	e0835001 	add	r5, r3, r1
	/*
	 * Namelengths on disk are shifted by two
	 * and the name padded out to 4-byte boundaries
	 * with zeroes.
	 */
	namelen = CRAMFS_GET_NAMELEN (inode) << 2;
33d1f124:	e5d53008 	ldrb	r3, [r5, #8]
33d1f128:	e203303f 	and	r3, r3, #63	; 0x3f
33d1f12c:	e1a04103 	lsl	r4, r3, #2
	return cramfs_uncompress (PART_OFFSET(info), offset,
				  (unsigned long) loadoffset);
}

static int cramfs_list_inode (struct part_info *info, unsigned long offset)
{
33d1f130:	e24dd01c 	sub	sp, sp, #28	; 0x1c
33d1f134:	e1a06000 	mov	r6, r0
33d1f138:	e1a0a001 	mov	sl, r1
	 * Namelengths on disk are shifted by two
	 * and the name padded out to 4-byte boundaries
	 * with zeroes.
	 */
	namelen = CRAMFS_GET_NAMELEN (inode) << 2;
	name = (char *) inode + sizeof (struct cramfs_inode);
33d1f13c:	e285700c 	add	r7, r5, #12	; 0xc
	nextoff = namelen;
33d1f140:	e1a09004 	mov	r9, r4

	for (;;) {
		if (!namelen)
33d1f144:	e3540000 	cmp	r4, #0	; 0x0
			return namelen;
		if (name[namelen - 1])
33d1f148:	e0873004 	add	r3, r7, r4
	namelen = CRAMFS_GET_NAMELEN (inode) << 2;
	name = (char *) inode + sizeof (struct cramfs_inode);
	nextoff = namelen;

	for (;;) {
		if (!namelen)
33d1f14c:	0a000032 	beq	33d1f21c <cramfs_list_inode+0x128>
			return namelen;
		if (name[namelen - 1])
33d1f150:	e5533001 	ldrb	r3, [r3, #-1]
33d1f154:	e3530000 	cmp	r3, #0	; 0x0
			break;
		namelen--;
33d1f158:	02444001 	subeq	r4, r4, #1	; 0x1
	 */
	namelen = CRAMFS_GET_NAMELEN (inode) << 2;
	name = (char *) inode + sizeof (struct cramfs_inode);
	nextoff = namelen;

	for (;;) {
33d1f15c:	0afffff8 	beq	33d1f144 <cramfs_list_inode+0x50>
		if (name[namelen - 1])
			break;
		namelen--;
	}

	printf (" %s %8d %*.*s", mkmodestr (CRAMFS_16 (inode->mode), str),
33d1f160:	e28d1008 	add	r1, sp, #8	; 0x8
33d1f164:	e1d500b0 	ldrh	r0, [r5]
33d1f168:	eb00033c 	bl	33d1fe60 <mkmodestr>
33d1f16c:	e5952004 	ldr	r2, [r5, #4]
33d1f170:	e1a01000 	mov	r1, r0
33d1f174:	e1a03004 	mov	r3, r4
33d1f178:	e3c224ff 	bic	r2, r2, #-16777216	; 0xff000000
33d1f17c:	e59f00b8 	ldr	r0, [pc, #184]	; 33d1f23c <cramfs_list_inode+0x148>
33d1f180:	e88d0090 	stm	sp, {r4, r7}
33d1f184:	ebffdf8f 	bl	33d16fc8 <printf>
		CRAMFS_24 (inode->size), namelen, namelen, name);

	if ((CRAMFS_16 (inode->mode) & S_IFMT) == S_IFLNK) {
33d1f188:	e1d530b0 	ldrh	r3, [r5]
33d1f18c:	e2033a0f 	and	r3, r3, #61440	; 0xf000
33d1f190:	e3530a0a 	cmp	r3, #40960	; 0xa000
33d1f194:	1a000022 	bne	33d1f224 <cramfs_list_inode+0x130>
		/* symbolic link.
		 * Unpack the link target, trusting in the inode's size field.
		 */
		unsigned long size = CRAMFS_24 (inode->size);
33d1f198:	e5953004 	ldr	r3, [r5, #4]
33d1f19c:	e3c354ff 	bic	r5, r3, #-16777216	; 0xff000000
		char *link = malloc (size);
33d1f1a0:	e1a00005 	mov	r0, r5
33d1f1a4:	ebffe12f 	bl	33d17668 <malloc>

		if (link != NULL && cramfs_uncompress (PART_OFFSET(info), offset,
33d1f1a8:	e2504000 	subs	r4, r0, #0	; 0x0
33d1f1ac:	0a000013 	beq	33d1f200 <cramfs_list_inode+0x10c>
33d1f1b0:	e5963020 	ldr	r3, [r6, #32]
33d1f1b4:	e5933008 	ldr	r3, [r3, #8]
33d1f1b8:	e5d33009 	ldrb	r3, [r3, #9]
33d1f1bc:	e0833083 	add	r3, r3, r3, lsl #1
33d1f1c0:	e0833183 	add	r3, r3, r3, lsl #3
33d1f1c4:	e08b3103 	add	r3, fp, r3, lsl #2
33d1f1c8:	e5962014 	ldr	r2, [r6, #20]
33d1f1cc:	e593000c 	ldr	r0, [r3, #12]
33d1f1d0:	e1a0100a 	mov	r1, sl
33d1f1d4:	e0820000 	add	r0, r2, r0
33d1f1d8:	e1a02004 	mov	r2, r4
33d1f1dc:	ebffff63 	bl	33d1ef70 <cramfs_uncompress>
33d1f1e0:	e1500005 	cmp	r0, r5
33d1f1e4:	1a000005 	bne	33d1f200 <cramfs_list_inode+0x10c>
						       (unsigned long) link)
		    == size)
			printf (" -> %*.*s\n", (int) size, (int) size, link);
33d1f1e8:	e1a01000 	mov	r1, r0
33d1f1ec:	e1a02001 	mov	r2, r1
33d1f1f0:	e59f0048 	ldr	r0, [pc, #72]	; 33d1f240 <cramfs_list_inode+0x14c>
33d1f1f4:	e1a03004 	mov	r3, r4
33d1f1f8:	ebffdf72 	bl	33d16fc8 <printf>
33d1f1fc:	ea000001 	b	33d1f208 <cramfs_list_inode+0x114>
		else
			printf (" [Error reading link]\n");
33d1f200:	e59f003c 	ldr	r0, [pc, #60]	; 33d1f244 <cramfs_list_inode+0x150>
33d1f204:	ebffdf6f 	bl	33d16fc8 <printf>
		if (link)
33d1f208:	e3540000 	cmp	r4, #0	; 0x0
33d1f20c:	0a000006 	beq	33d1f22c <cramfs_list_inode+0x138>
			free (link);
33d1f210:	e1a00004 	mov	r0, r4
33d1f214:	ebffe08e 	bl	33d17454 <free>
33d1f218:	ea000003 	b	33d1f22c <cramfs_list_inode+0x138>
	name = (char *) inode + sizeof (struct cramfs_inode);
	nextoff = namelen;

	for (;;) {
		if (!namelen)
			return namelen;
33d1f21c:	e1a00004 	mov	r0, r4
33d1f220:	ea000002 	b	33d1f230 <cramfs_list_inode+0x13c>
		else
			printf (" [Error reading link]\n");
		if (link)
			free (link);
	} else
		printf ("\n");
33d1f224:	e59f001c 	ldr	r0, [pc, #28]	; 33d1f248 <cramfs_list_inode+0x154>
33d1f228:	ebffdf66 	bl	33d16fc8 <printf>

	return nextoff;
33d1f22c:	e1a00009 	mov	r0, r9
}
33d1f230:	e28dd01c 	add	sp, sp, #28	; 0x1c
33d1f234:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1f238:	33d62554 	.word	0x33d62554
33d1f23c:	33d2d334 	.word	0x33d2d334
33d1f240:	33d2d344 	.word	0x33d2d344
33d1f244:	33d2d350 	.word	0x33d2d350
33d1f248:	33d2bd80 	.word	0x33d2bd80

33d1f24c <cramfs_ls>:

int cramfs_ls (struct part_info *info, char *filename)
{
33d1f24c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
33d1f250:	e24dd004 	sub	sp, sp, #4	; 0x4
33d1f254:	e1a04001 	mov	r4, r1
33d1f258:	e1a06000 	mov	r6, r0
	struct cramfs_inode *inode;
	unsigned long inodeoffset = 0, nextoffset;
	unsigned long offset, size;

	if (cramfs_read_super (info))
33d1f25c:	ebfffeab 	bl	33d1ed10 <cramfs_read_super>
33d1f260:	e3500000 	cmp	r0, #0	; 0x0
}

int cramfs_ls (struct part_info *info, char *filename)
{
	struct cramfs_inode *inode;
	unsigned long inodeoffset = 0, nextoffset;
33d1f264:	e3a07000 	mov	r7, #0	; 0x0
	unsigned long offset, size;

	if (cramfs_read_super (info))
		return -1;
33d1f268:	13e00000 	mvnne	r0, #0	; 0x0
{
	struct cramfs_inode *inode;
	unsigned long inodeoffset = 0, nextoffset;
	unsigned long offset, size;

	if (cramfs_read_super (info))
33d1f26c:	1a00004b 	bne	33d1f3a0 <cramfs_ls+0x154>
		return -1;

	if (strlen (filename) == 0 || !strcmp (filename, "/")) {
33d1f270:	e1a00004 	mov	r0, r4
33d1f274:	ebffeba5 	bl	33d1a110 <strlen>
33d1f278:	e3500000 	cmp	r0, #0	; 0x0
33d1f27c:	0a000004 	beq	33d1f294 <cramfs_ls+0x48>
33d1f280:	e1a00004 	mov	r0, r4
33d1f284:	e59f111c 	ldr	r1, [pc, #284]	; 33d1f3a8 <cramfs_ls+0x15c>
33d1f288:	ebffeb76 	bl	33d1a068 <strcmp>
33d1f28c:	e3500000 	cmp	r0, #0	; 0x0
33d1f290:	1a000006 	bne	33d1f2b0 <cramfs_ls+0x64>
		/* Root directory. Use root inode in super block */
		offset = CRAMFS_GET_OFFSET (&(super.root)) << 2;
33d1f294:	e59f3110 	ldr	r3, [pc, #272]	; 33d1f3ac <cramfs_ls+0x160>
33d1f298:	e5932008 	ldr	r2, [r3, #8]
		size = CRAMFS_24 (super.root.size);
33d1f29c:	e5933004 	ldr	r3, [r3, #4]
	if (cramfs_read_super (info))
		return -1;

	if (strlen (filename) == 0 || !strcmp (filename, "/")) {
		/* Root directory. Use root inode in super block */
		offset = CRAMFS_GET_OFFSET (&(super.root)) << 2;
33d1f2a0:	e1a02322 	lsr	r2, r2, #6
33d1f2a4:	e1a05102 	lsl	r5, r2, #2
		size = CRAMFS_24 (super.root.size);
33d1f2a8:	e3c344ff 	bic	r4, r3, #-16777216	; 0xff000000
33d1f2ac:	ea000031 	b	33d1f378 <cramfs_ls+0x12c>
	} else {
		/* Resolve the path */
		offset = cramfs_resolve (PART_OFFSET(info),
33d1f2b0:	e1a00004 	mov	r0, r4
33d1f2b4:	e59f10ec 	ldr	r1, [pc, #236]	; 33d1f3a8 <cramfs_ls+0x15c>
33d1f2b8:	ebffebef 	bl	33d1a27c <strtok>
33d1f2bc:	e5963020 	ldr	r3, [r6, #32]
33d1f2c0:	e5933008 	ldr	r3, [r3, #8]
33d1f2c4:	e5d33009 	ldrb	r3, [r3, #9]
33d1f2c8:	e59f20dc 	ldr	r2, [pc, #220]	; 33d1f3ac <cramfs_ls+0x160>
33d1f2cc:	e0833083 	add	r3, r3, r3, lsl #1
33d1f2d0:	e59f40d8 	ldr	r4, [pc, #216]	; 33d1f3b0 <cramfs_ls+0x164>
33d1f2d4:	e0833183 	add	r3, r3, r3, lsl #3
33d1f2d8:	e5921008 	ldr	r1, [r2, #8]
33d1f2dc:	e0843103 	add	r3, r4, r3, lsl #2
33d1f2e0:	e593c00c 	ldr	ip, [r3, #12]
33d1f2e4:	e5922004 	ldr	r2, [r2, #4]
33d1f2e8:	e5963014 	ldr	r3, [r6, #20]
33d1f2ec:	e1a01321 	lsr	r1, r1, #6
33d1f2f0:	e58d0000 	str	r0, [sp]
33d1f2f4:	e1a01101 	lsl	r1, r1, #2
33d1f2f8:	e083000c 	add	r0, r3, ip
33d1f2fc:	e3c224ff 	bic	r2, r2, #-16777216	; 0xff000000
33d1f300:	e3a03001 	mov	r3, #1	; 0x1
33d1f304:	ebfffece 	bl	33d1ee44 <cramfs_resolve>
					 CRAMFS_GET_OFFSET (&(super.root)) <<
					 2, CRAMFS_24 (super.root.size), 1,
					 strtok (filename, "/"));

		if (offset <= 0)
33d1f308:	e2505000 	subs	r5, r0, #0	; 0x0
			return offset;
33d1f30c:	01a00007 	moveq	r0, r7
		offset = cramfs_resolve (PART_OFFSET(info),
					 CRAMFS_GET_OFFSET (&(super.root)) <<
					 2, CRAMFS_24 (super.root.size), 1,
					 strtok (filename, "/"));

		if (offset <= 0)
33d1f310:	0a000022 	beq	33d1f3a0 <cramfs_ls+0x154>
			return offset;

		/* Resolving was successful. Examine the inode */
		inode = (struct cramfs_inode *) (PART_OFFSET(info) + offset);
33d1f314:	e5963020 	ldr	r3, [r6, #32]
33d1f318:	e5933008 	ldr	r3, [r3, #8]
33d1f31c:	e5d33009 	ldrb	r3, [r3, #9]
33d1f320:	e0833083 	add	r3, r3, r3, lsl #1
33d1f324:	e0833183 	add	r3, r3, r3, lsl #3
33d1f328:	e0843103 	add	r3, r4, r3, lsl #2
33d1f32c:	e593300c 	ldr	r3, [r3, #12]
33d1f330:	e5962014 	ldr	r2, [r6, #20]
33d1f334:	e0822003 	add	r2, r2, r3
		if (!S_ISDIR (CRAMFS_16 (inode->mode))) {
33d1f338:	e19230b5 	ldrh	r3, [r2, r5]
33d1f33c:	e2033a0f 	and	r3, r3, #61440	; 0xf000
33d1f340:	e3530901 	cmp	r3, #16384	; 0x4000

		if (offset <= 0)
			return offset;

		/* Resolving was successful. Examine the inode */
		inode = (struct cramfs_inode *) (PART_OFFSET(info) + offset);
33d1f344:	e0822005 	add	r2, r2, r5
		if (!S_ISDIR (CRAMFS_16 (inode->mode))) {
33d1f348:	0a000006 	beq	33d1f368 <cramfs_ls+0x11c>
			/* It's not a directory - list it, and that's that */
			return (cramfs_list_inode (info, offset) > 0);
33d1f34c:	e1a00006 	mov	r0, r6
33d1f350:	e1a01005 	mov	r1, r5
33d1f354:	ebffff66 	bl	33d1f0f4 <cramfs_list_inode>
33d1f358:	e3500000 	cmp	r0, #0	; 0x0
33d1f35c:	d3a00000 	movle	r0, #0	; 0x0
33d1f360:	c3a00001 	movgt	r0, #1	; 0x1
33d1f364:	ea00000d 	b	33d1f3a0 <cramfs_ls+0x154>
		}

		/* It's a directory. List files within */
		offset = CRAMFS_GET_OFFSET (inode) << 2;
33d1f368:	e992000c 	ldmib	r2, {r2, r3}
33d1f36c:	e1a03323 	lsr	r3, r3, #6
33d1f370:	e1a05103 	lsl	r5, r3, #2
		size = CRAMFS_24 (inode->size);
33d1f374:	e3c244ff 	bic	r4, r2, #-16777216	; 0xff000000
						 inodeoffset);

		nextoffset = cramfs_list_inode (info, offset + inodeoffset);
		if (nextoffset == 0)
			break;
		inodeoffset += sizeof (struct cramfs_inode) + nextoffset;
33d1f378:	e1570004 	cmp	r7, r4
33d1f37c:	2a000006 	bcs	33d1f39c <cramfs_ls+0x150>
	/* List the given directory */
	while (inodeoffset < size) {
		inode = (struct cramfs_inode *) (PART_OFFSET(info) + offset +
						 inodeoffset);

		nextoffset = cramfs_list_inode (info, offset + inodeoffset);
33d1f380:	e0851007 	add	r1, r5, r7
33d1f384:	e1a00006 	mov	r0, r6
33d1f388:	ebffff59 	bl	33d1f0f4 <cramfs_list_inode>
		if (nextoffset == 0)
33d1f38c:	e3500000 	cmp	r0, #0	; 0x0
			break;
		inodeoffset += sizeof (struct cramfs_inode) + nextoffset;
33d1f390:	e0870000 	add	r0, r7, r0
33d1f394:	e280700c 	add	r7, r0, #12	; 0xc
	while (inodeoffset < size) {
		inode = (struct cramfs_inode *) (PART_OFFSET(info) + offset +
						 inodeoffset);

		nextoffset = cramfs_list_inode (info, offset + inodeoffset);
		if (nextoffset == 0)
33d1f398:	1afffff6 	bne	33d1f378 <cramfs_ls+0x12c>
			break;
		inodeoffset += sizeof (struct cramfs_inode) + nextoffset;
	}

	return 1;
33d1f39c:	e3a00001 	mov	r0, #1	; 0x1
}
33d1f3a0:	e28dd004 	add	sp, sp, #4	; 0x4
33d1f3a4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d1f3a8:	33d298a8 	.word	0x33d298a8
33d1f3ac:	33d62608 	.word	0x33d62608
33d1f3b0:	33d62554 	.word	0x33d62554

33d1f3b4 <cramfs_info>:

int cramfs_info (struct part_info *info)
{
33d1f3b4:	e92d4010 	push	{r4, lr}
	if (cramfs_read_super (info))
33d1f3b8:	ebfffe54 	bl	33d1ed10 <cramfs_read_super>
33d1f3bc:	e3500000 	cmp	r0, #0	; 0x0
		return 0;
33d1f3c0:	13a00000 	movne	r0, #0	; 0x0
	return 1;
}

int cramfs_info (struct part_info *info)
{
	if (cramfs_read_super (info))
33d1f3c4:	18bd8010 	popne	{r4, pc}
		return 0;

	printf ("size: 0x%x (%u)\n", super.size, super.size);
33d1f3c8:	e59f4084 	ldr	r4, [pc, #132]	; 33d1f454 <cramfs_info+0xa0>
33d1f3cc:	e5941004 	ldr	r1, [r4, #4]
33d1f3d0:	e59f0080 	ldr	r0, [pc, #128]	; 33d1f458 <cramfs_info+0xa4>
33d1f3d4:	e1a02001 	mov	r2, r1
33d1f3d8:	ebffdefa 	bl	33d16fc8 <printf>

	if (super.flags != 0) {
33d1f3dc:	e5943008 	ldr	r3, [r4, #8]
33d1f3e0:	e3530000 	cmp	r3, #0	; 0x0
33d1f3e4:	0a000011 	beq	33d1f430 <cramfs_info+0x7c>
		printf ("flags:\n");
33d1f3e8:	e59f006c 	ldr	r0, [pc, #108]	; 33d1f45c <cramfs_info+0xa8>
33d1f3ec:	ebffdef5 	bl	33d16fc8 <printf>
		if (super.flags & CRAMFS_FLAG_FSID_VERSION_2)
33d1f3f0:	e5943008 	ldr	r3, [r4, #8]
33d1f3f4:	e3130001 	tst	r3, #1	; 0x1
			printf ("\tFSID version 2\n");
33d1f3f8:	159f0060 	ldrne	r0, [pc, #96]	; 33d1f460 <cramfs_info+0xac>
33d1f3fc:	1bffdef1 	blne	33d16fc8 <printf>
		if (super.flags & CRAMFS_FLAG_SORTED_DIRS)
33d1f400:	e5943008 	ldr	r3, [r4, #8]
33d1f404:	e3130002 	tst	r3, #2	; 0x2
			printf ("\tsorted dirs\n");
33d1f408:	159f0054 	ldrne	r0, [pc, #84]	; 33d1f464 <cramfs_info+0xb0>
33d1f40c:	1bffdeed 	blne	33d16fc8 <printf>
		if (super.flags & CRAMFS_FLAG_HOLES)
33d1f410:	e5943008 	ldr	r3, [r4, #8]
33d1f414:	e3130c01 	tst	r3, #256	; 0x100
			printf ("\tholes\n");
33d1f418:	159f0048 	ldrne	r0, [pc, #72]	; 33d1f468 <cramfs_info+0xb4>
33d1f41c:	1bffdee9 	blne	33d16fc8 <printf>
		if (super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET)
33d1f420:	e5943008 	ldr	r3, [r4, #8]
33d1f424:	e3130b01 	tst	r3, #1024	; 0x400
			printf ("\tshifted root offset\n");
33d1f428:	159f003c 	ldrne	r0, [pc, #60]	; 33d1f46c <cramfs_info+0xb8>
33d1f42c:	1bffdee5 	blne	33d16fc8 <printf>
	}

	printf ("fsid:\n\tcrc: 0x%x\n\tedition: 0x%x\n",
33d1f430:	e2841020 	add	r1, r4, #32	; 0x20
33d1f434:	e8910006 	ldm	r1, {r1, r2}
33d1f438:	e59f0030 	ldr	r0, [pc, #48]	; 33d1f470 <cramfs_info+0xbc>
33d1f43c:	ebffdee1 	bl	33d16fc8 <printf>
		super.fsid.crc, super.fsid.edition);
	printf ("name: %16s\n", super.name);
33d1f440:	e59f002c 	ldr	r0, [pc, #44]	; 33d1f474 <cramfs_info+0xc0>
33d1f444:	e59f102c 	ldr	r1, [pc, #44]	; 33d1f478 <cramfs_info+0xc4>
33d1f448:	ebffdede 	bl	33d16fc8 <printf>

	return 1;
33d1f44c:	e3a00001 	mov	r0, #1	; 0x1
}
33d1f450:	e8bd8010 	pop	{r4, pc}
33d1f454:	33d625c8 	.word	0x33d625c8
33d1f458:	33d2d368 	.word	0x33d2d368
33d1f45c:	33d2d37c 	.word	0x33d2d37c
33d1f460:	33d2d384 	.word	0x33d2d384
33d1f464:	33d2d398 	.word	0x33d2d398
33d1f468:	33d2d3a8 	.word	0x33d2d3a8
33d1f46c:	33d2d3b0 	.word	0x33d2d3b0
33d1f470:	33d2d3c8 	.word	0x33d2d3c8
33d1f474:	33d2d3ec 	.word	0x33d2d3ec
33d1f478:	33d625f8 	.word	0x33d625f8

33d1f47c <cramfs_check>:

int cramfs_check (struct part_info *info)
{
33d1f47c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct cramfs_super *sb;

	if (info->dev->id->type != MTD_DEV_TYPE_NOR)
33d1f480:	e5903020 	ldr	r3, [r0, #32]
33d1f484:	e5932008 	ldr	r2, [r3, #8]
33d1f488:	e5d23008 	ldrb	r3, [r2, #8]
33d1f48c:	e3530001 	cmp	r3, #1	; 0x1
		return 0;

	sb = (struct cramfs_super *) PART_OFFSET(info);
	if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC)) {
33d1f490:	e59fe048 	ldr	lr, [pc, #72]	; 33d1f4e0 <cramfs_check+0x64>
int cramfs_check (struct part_info *info)
{
	struct cramfs_super *sb;

	if (info->dev->id->type != MTD_DEV_TYPE_NOR)
		return 0;
33d1f494:	e3a0c000 	mov	ip, #0	; 0x0

int cramfs_check (struct part_info *info)
{
	struct cramfs_super *sb;

	if (info->dev->id->type != MTD_DEV_TYPE_NOR)
33d1f498:	1a00000e 	bne	33d1f4d8 <cramfs_check+0x5c>
		return 0;

	sb = (struct cramfs_super *) PART_OFFSET(info);
33d1f49c:	e5d23009 	ldrb	r3, [r2, #9]
33d1f4a0:	e59f203c 	ldr	r2, [pc, #60]	; 33d1f4e4 <cramfs_check+0x68>
33d1f4a4:	e0833083 	add	r3, r3, r3, lsl #1
33d1f4a8:	e0833183 	add	r3, r3, r3, lsl #3
33d1f4ac:	e0822103 	add	r2, r2, r3, lsl #2
33d1f4b0:	e5901014 	ldr	r1, [r0, #20]
33d1f4b4:	e592200c 	ldr	r2, [r2, #12]
	if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC)) {
33d1f4b8:	e7913002 	ldr	r3, [r1, r2]
33d1f4bc:	e153000e 	cmp	r3, lr
		/* check at 512 byte offset */
		sb = (struct cramfs_super *) (PART_OFFSET(info) + 512);
		if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC))
			return 0;
	}
	return 1;
33d1f4c0:	e3a0c001 	mov	ip, #1	; 0x1
	struct cramfs_super *sb;

	if (info->dev->id->type != MTD_DEV_TYPE_NOR)
		return 0;

	sb = (struct cramfs_super *) PART_OFFSET(info);
33d1f4c4:	e0810002 	add	r0, r1, r2
	if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC)) {
33d1f4c8:	0a000002 	beq	33d1f4d8 <cramfs_check+0x5c>
		/* check at 512 byte offset */
		sb = (struct cramfs_super *) (PART_OFFSET(info) + 512);
		if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC))
33d1f4cc:	e5903200 	ldr	r3, [r0, #512]
33d1f4d0:	e153000e 	cmp	r3, lr
			return 0;
33d1f4d4:	124cc001 	subne	ip, ip, #1	; 0x1
	}
	return 1;
}
33d1f4d8:	e1a0000c 	mov	r0, ip
33d1f4dc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1f4e0:	28cd3d45 	.word	0x28cd3d45
33d1f4e4:	33d62554 	.word	0x33d62554

33d1f4e8 <zalloc>:

static void *zalloc (void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
33d1f4e8:	e0000291 	mul	r0, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
33d1f4ec:	e280000f 	add	r0, r0, #15	; 0xf

	p = malloc (size);
33d1f4f0:	e3c0000f 	bic	r0, r0, #15	; 0xf
33d1f4f4:	eaffe05b 	b	33d17668 <malloc>

33d1f4f8 <zfree>:
	return (p);
}

static void zfree (void *x, void *addr, unsigned nb)
{
	free (addr);
33d1f4f8:	e1a00001 	mov	r0, r1
33d1f4fc:	eaffdfd4 	b	33d17454 <free>

33d1f500 <cramfs_uncompress_block>:
}

/* Returns length of decompressed data. */
int cramfs_uncompress_block (void *dst, void *src, int srclen)
{
33d1f500:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int err;

	inflateReset (&stream);
33d1f504:	e59f703c 	ldr	r7, [pc, #60]	; 33d1f548 <cramfs_uncompress_block+0x48>
	free (addr);
}

/* Returns length of decompressed data. */
int cramfs_uncompress_block (void *dst, void *src, int srclen)
{
33d1f508:	e1a06000 	mov	r6, r0
	int err;

	inflateReset (&stream);
33d1f50c:	e1a00007 	mov	r0, r7
	free (addr);
}

/* Returns length of decompressed data. */
int cramfs_uncompress_block (void *dst, void *src, int srclen)
{
33d1f510:	e1a04001 	mov	r4, r1
33d1f514:	e1a05002 	mov	r5, r2
	int err;

	inflateReset (&stream);
33d1f518:	ebffee83 	bl	33d1af2c <inflateReset>

	stream.next_in = src;
	stream.avail_in = srclen;

	stream.next_out = dst;
	stream.avail_out = 4096 * 2;
33d1f51c:	e3a03a02 	mov	r3, #8192	; 0x2000

	err = inflate (&stream, Z_FINISH);
33d1f520:	e1a00007 	mov	r0, r7
33d1f524:	e3a01004 	mov	r1, #4	; 0x4
{
	int err;

	inflateReset (&stream);

	stream.next_in = src;
33d1f528:	e8870030 	stm	r7, {r4, r5}
	stream.avail_in = srclen;

	stream.next_out = dst;
33d1f52c:	e587600c 	str	r6, [r7, #12]
	stream.avail_out = 4096 * 2;
33d1f530:	e5873010 	str	r3, [r7, #16]

	err = inflate (&stream, Z_FINISH);
33d1f534:	ebfff17b 	bl	33d1bb28 <inflate>

	if (err != Z_STREAM_END)
33d1f538:	e3500001 	cmp	r0, #1	; 0x1
		goto err;
	return stream.total_out;
33d1f53c:	05970014 	ldreq	r0, [r7, #20]

      err:
	/*printf ("Error %d while decompressing!\n", err); */
	/*printf ("%p(%d)->%p\n", src, srclen, dst); */
	return -1;
33d1f540:	13e00000 	mvnne	r0, #0	; 0x0
}
33d1f544:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d1f548:	33d62614 	.word	0x33d62614

33d1f54c <cramfs_uncompress_init>:

int cramfs_uncompress_init (void)
{
	int err;

	stream.zalloc = zalloc;
33d1f54c:	e59f2048 	ldr	r2, [pc, #72]	; 33d1f59c <cramfs_uncompress_init+0x50>
33d1f550:	e59f3048 	ldr	r3, [pc, #72]	; 33d1f5a0 <cramfs_uncompress_init+0x54>
	/*printf ("%p(%d)->%p\n", src, srclen, dst); */
	return -1;
}

int cramfs_uncompress_init (void)
{
33d1f554:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int err;

	stream.zalloc = zalloc;
33d1f558:	e5823020 	str	r3, [r2, #32]
	stream.zfree = zfree;
33d1f55c:	e59f3040 	ldr	r3, [pc, #64]	; 33d1f5a4 <cramfs_uncompress_init+0x58>
	stream.next_in = 0;
33d1f560:	e3a01000 	mov	r1, #0	; 0x0
int cramfs_uncompress_init (void)
{
	int err;

	stream.zalloc = zalloc;
	stream.zfree = zfree;
33d1f564:	e5823024 	str	r3, [r2, #36]
	stream.avail_in = 0;

#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
	stream.outcb = (cb_func) WATCHDOG_RESET;
#else
	stream.outcb = Z_NULL;
33d1f568:	e5821030 	str	r1, [r2, #48]
{
	int err;

	stream.zalloc = zalloc;
	stream.zfree = zfree;
	stream.next_in = 0;
33d1f56c:	e5821000 	str	r1, [r2]
	stream.avail_in = 0;
33d1f570:	e5821004 	str	r1, [r2, #4]
	stream.outcb = (cb_func) WATCHDOG_RESET;
#else
	stream.outcb = Z_NULL;
#endif /* CONFIG_HW_WATCHDOG */

	err = inflateInit (&stream);
33d1f574:	e1a00002 	mov	r0, r2
33d1f578:	ebffef20 	bl	33d1b200 <inflateInit>
	if (err != Z_OK) {
33d1f57c:	e2503000 	subs	r3, r0, #0	; 0x0
		printf ("Error: inflateInit2() returned %d\n", err);
33d1f580:	e1a01003 	mov	r1, r3
33d1f584:	e59f001c 	ldr	r0, [pc, #28]	; 33d1f5a8 <cramfs_uncompress_init+0x5c>
		return -1;
	}

	return 0;
33d1f588:	01a00003 	moveq	r0, r3
#else
	stream.outcb = Z_NULL;
#endif /* CONFIG_HW_WATCHDOG */

	err = inflateInit (&stream);
	if (err != Z_OK) {
33d1f58c:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
		printf ("Error: inflateInit2() returned %d\n", err);
33d1f590:	ebffde8c 	bl	33d16fc8 <printf>
		return -1;
33d1f594:	e3e00000 	mvn	r0, #0	; 0x0
33d1f598:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1f59c:	33d62614 	.word	0x33d62614
33d1f5a0:	33d1f4e8 	.word	0x33d1f4e8
33d1f5a4:	33d1f4f8 	.word	0x33d1f4f8
33d1f5a8:	33d27a1c 	.word	0x33d27a1c

33d1f5ac <cramfs_uncompress_exit>:

	return 0;
}

int cramfs_uncompress_exit (void)
{
33d1f5ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	inflateEnd (&stream);
33d1f5b0:	e59f0008 	ldr	r0, [pc, #8]	; 33d1f5c0 <cramfs_uncompress_exit+0x14>
33d1f5b4:	ebffee34 	bl	33d1ae8c <inflateEnd>
	return 0;
}
33d1f5b8:	e3a00000 	mov	r0, #0	; 0x0
33d1f5bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
33d1f5c0:	33d62614 	.word	0x33d62614

33d1f5c4 <get_fl_mem_nand>:
	}
	return bytes_read;
}

static void *get_fl_mem_nand(u32 off, u32 size, void *ext_buf)
{
33d1f5c4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u_char *buf = ext_buf ? (u_char*)ext_buf : (u_char*)malloc(size);
33d1f5c8:	e3520000 	cmp	r2, #0	; 0x0
	}
	return bytes_read;
}

static void *get_fl_mem_nand(u32 off, u32 size, void *ext_buf)
{
33d1f5cc:	e24dd018 	sub	sp, sp, #24	; 0x18
33d1f5d0:	e1a04002 	mov	r4, r2
33d1f5d4:	e58d0010 	str	r0, [sp, #16]
33d1f5d8:	e1a07001 	mov	r7, r1
	u_char *buf = ext_buf ? (u_char*)ext_buf : (u_char*)malloc(size);
33d1f5dc:	e58d200c 	str	r2, [sp, #12]
33d1f5e0:	1a00000b 	bne	33d1f614 <get_fl_mem_nand+0x50>
33d1f5e4:	e1a00001 	mov	r0, r1
33d1f5e8:	ebffe01e 	bl	33d17668 <malloc>

	if (NULL == buf) {
33d1f5ec:	e2504000 	subs	r4, r0, #0	; 0x0
33d1f5f0:	1a000007 	bne	33d1f614 <get_fl_mem_nand+0x50>
		printf("get_fl_mem_nand: can't alloc %d bytes\n", size);
33d1f5f4:	e1a01007 	mov	r1, r7
33d1f5f8:	e59f0168 	ldr	r0, [pc, #360]	; 33d1f768 <get_fl_mem_nand+0x1a4>
33d1f5fc:	ebffde71 	bl	33d16fc8 <printf>
33d1f600:	ea000055 	b	33d1f75c <get_fl_mem_nand+0x198>
			if (!nand_cache) {
				/* This memory never gets freed but 'cause
				   it's a bootloader, nobody cares */
				nand_cache = malloc(NAND_CACHE_SIZE);
				if (!nand_cache) {
					printf("read_nand_cached: can't alloc cache size %d bytes\n",
33d1f604:	e59f0160 	ldr	r0, [pc, #352]	; 33d1f76c <get_fl_mem_nand+0x1a8>
33d1f608:	e3a01a02 	mov	r1, #8192	; 0x2000
33d1f60c:	ebffde6d 	bl	33d16fc8 <printf>
33d1f610:	ea00004b 	b	33d1f744 <get_fl_mem_nand+0x180>
static u8* nand_cache = NULL;
static u32 nand_cache_off = (u32)-1;

static int read_nand_cached(u32 off, u32 size, u_char *buf)
{
	struct mtdids *id = current_part->dev->id;
33d1f614:	e59f3154 	ldr	r3, [pc, #340]	; 33d1f770 <get_fl_mem_nand+0x1ac>
33d1f618:	e5933000 	ldr	r3, [r3]
33d1f61c:	e5933020 	ldr	r3, [r3, #32]
33d1f620:	e5933008 	ldr	r3, [r3, #8]
	u32 bytes_read = 0;
33d1f624:	e3a06000 	mov	r6, #0	; 0x0
static u8* nand_cache = NULL;
static u32 nand_cache_off = (u32)-1;

static int read_nand_cached(u32 off, u32 size, u_char *buf)
{
	struct mtdids *id = current_part->dev->id;
33d1f628:	e58d3008 	str	r3, [sp, #8]
		if (cpy_bytes > size - bytes_read)
			cpy_bytes = size - bytes_read;
		memcpy(buf + bytes_read,
		       nand_cache + off + bytes_read - nand_cache_off,
		       cpy_bytes);
		bytes_read += cpy_bytes;
33d1f62c:	e1560007 	cmp	r6, r7
33d1f630:	2a000041 	bcs	33d1f73c <get_fl_mem_nand+0x178>
	ulong retlen;
#endif
	int cpy_bytes;

	while (bytes_read < size) {
		if ((off + bytes_read < nand_cache_off) ||
33d1f634:	e59f9138 	ldr	r9, [pc, #312]	; 33d1f774 <get_fl_mem_nand+0x1b0>
33d1f638:	e59d2010 	ldr	r2, [sp, #16]
33d1f63c:	e5993000 	ldr	r3, [r9]
33d1f640:	e0825006 	add	r5, r2, r6
				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
						nand_cache_off, NAND_CACHE_SIZE);
				return -1;
			}
#else
			retlen = NAND_CACHE_SIZE;
33d1f644:	e3a0ba02 	mov	fp, #8192	; 0x2000
	int cpy_bytes;

	while (bytes_read < size) {
		if ((off + bytes_read < nand_cache_off) ||
		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
			nand_cache_off = (off + bytes_read) & NAND_PAGE_MASK;
33d1f648:	e3c52f7f 	bic	r2, r5, #508	; 0x1fc
	ulong retlen;
#endif
	int cpy_bytes;

	while (bytes_read < size) {
		if ((off + bytes_read < nand_cache_off) ||
33d1f64c:	e1550003 	cmp	r5, r3
		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
			nand_cache_off = (off + bytes_read) & NAND_PAGE_MASK;
			if (!nand_cache) {
33d1f650:	e59fa120 	ldr	sl, [pc, #288]	; 33d1f778 <get_fl_mem_nand+0x1b4>
	ulong retlen;
#endif
	int cpy_bytes;

	while (bytes_read < size) {
		if ((off + bytes_read < nand_cache_off) ||
33d1f654:	e083100b 	add	r1, r3, fp
		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
			nand_cache_off = (off + bytes_read) & NAND_PAGE_MASK;
33d1f658:	e3c22003 	bic	r2, r2, #3	; 0x3
	ulong retlen;
#endif
	int cpy_bytes;

	while (bytes_read < size) {
		if ((off + bytes_read < nand_cache_off) ||
33d1f65c:	3a000001 	bcc	33d1f668 <get_fl_mem_nand+0xa4>
33d1f660:	e1550001 	cmp	r5, r1
33d1f664:	3a000022 	bcc	33d1f6f4 <get_fl_mem_nand+0x130>
		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
			nand_cache_off = (off + bytes_read) & NAND_PAGE_MASK;
			if (!nand_cache) {
33d1f668:	e59a3000 	ldr	r3, [sl]
33d1f66c:	e3530000 	cmp	r3, #0	; 0x0
				/* This memory never gets freed but 'cause
				   it's a bootloader, nobody cares */
				nand_cache = malloc(NAND_CACHE_SIZE);
33d1f670:	e3a00a02 	mov	r0, #8192	; 0x2000
	int cpy_bytes;

	while (bytes_read < size) {
		if ((off + bytes_read < nand_cache_off) ||
		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
			nand_cache_off = (off + bytes_read) & NAND_PAGE_MASK;
33d1f674:	e5892000 	str	r2, [r9]
			if (!nand_cache) {
33d1f678:	1a000003 	bne	33d1f68c <get_fl_mem_nand+0xc8>
				/* This memory never gets freed but 'cause
				   it's a bootloader, nobody cares */
				nand_cache = malloc(NAND_CACHE_SIZE);
33d1f67c:	ebffdff9 	bl	33d17668 <malloc>
				if (!nand_cache) {
33d1f680:	e3500000 	cmp	r0, #0	; 0x0
		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
			nand_cache_off = (off + bytes_read) & NAND_PAGE_MASK;
			if (!nand_cache) {
				/* This memory never gets freed but 'cause
				   it's a bootloader, nobody cares */
				nand_cache = malloc(NAND_CACHE_SIZE);
33d1f684:	e58a0000 	str	r0, [sl]
				if (!nand_cache) {
33d1f688:	0affffdd 	beq	33d1f604 <get_fl_mem_nand+0x40>
				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
						nand_cache_off, NAND_CACHE_SIZE);
				return -1;
			}
#else
			retlen = NAND_CACHE_SIZE;
33d1f68c:	e28d0018 	add	r0, sp, #24	; 0x18
33d1f690:	e520b004 	str	fp, [r0, #-4]!

extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
33d1f694:	e59d2008 	ldr	r2, [sp, #8]
33d1f698:	e5d23009 	ldrb	r3, [r2, #9]
33d1f69c:	e59fc0d8 	ldr	ip, [pc, #216]	; 33d1f77c <get_fl_mem_nand+0x1b8>
33d1f6a0:	e0832103 	add	r2, r3, r3, lsl #2
33d1f6a4:	e0833182 	add	r3, r3, r2, lsl #3
33d1f6a8:	e5991000 	ldr	r1, [r9]
33d1f6ac:	e59a2000 	ldr	r2, [sl]
33d1f6b0:	e08cc183 	add	ip, ip, r3, lsl #3
	return info->read(info, ofs, *len, (size_t *)len, buf);
33d1f6b4:	e88d0005 	stm	sp, {r0, r2}
33d1f6b8:	e1a0300b 	mov	r3, fp
33d1f6bc:	e3a02000 	mov	r2, #0	; 0x0
33d1f6c0:	e1a0000c 	mov	r0, ip
33d1f6c4:	e1a0e00f 	mov	lr, pc
33d1f6c8:	e59cf10c 	ldr	pc, [ip, #268]

extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
{
33d1f6cc:	e3500000 	cmp	r0, #0	; 0x0
33d1f6d0:	1a000002 	bne	33d1f6e0 <get_fl_mem_nand+0x11c>
33d1f6d4:	e59d3014 	ldr	r3, [sp, #20]
33d1f6d8:	e3530a02 	cmp	r3, #8192	; 0x2000
33d1f6dc:	0a000004 	beq	33d1f6f4 <get_fl_mem_nand+0x130>
			if (nand_read(&nand_info[id->num], nand_cache_off,
						&retlen, nand_cache) != 0 ||
					retlen != NAND_CACHE_SIZE) {
				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
33d1f6e0:	e5991000 	ldr	r1, [r9]
33d1f6e4:	e1a0200b 	mov	r2, fp
33d1f6e8:	e59f0090 	ldr	r0, [pc, #144]	; 33d1f780 <get_fl_mem_nand+0x1bc>
33d1f6ec:	ebffde35 	bl	33d16fc8 <printf>
33d1f6f0:	ea000013 	b	33d1f744 <get_fl_mem_nand+0x180>
						nand_cache_off, NAND_CACHE_SIZE);
				return -1;
			}
#endif
		}
		cpy_bytes = nand_cache_off + NAND_CACHE_SIZE - (off + bytes_read);
33d1f6f4:	e59f3078 	ldr	r3, [pc, #120]	; 33d1f774 <get_fl_mem_nand+0x1b0>
33d1f6f8:	e5930000 	ldr	r0, [r3]
		if (cpy_bytes > size - bytes_read)
			cpy_bytes = size - bytes_read;
		memcpy(buf + bytes_read,
33d1f6fc:	e59f3074 	ldr	r3, [pc, #116]	; 33d1f778 <get_fl_mem_nand+0x1b4>
33d1f700:	e5931000 	ldr	r1, [r3]
33d1f704:	e59d3010 	ldr	r3, [sp, #16]
						nand_cache_off, NAND_CACHE_SIZE);
				return -1;
			}
#endif
		}
		cpy_bytes = nand_cache_off + NAND_CACHE_SIZE - (off + bytes_read);
33d1f708:	e0652000 	rsb	r2, r5, r0
		if (cpy_bytes > size - bytes_read)
			cpy_bytes = size - bytes_read;
		memcpy(buf + bytes_read,
33d1f70c:	e0811003 	add	r1, r1, r3
33d1f710:	e0811006 	add	r1, r1, r6
				return -1;
			}
#endif
		}
		cpy_bytes = nand_cache_off + NAND_CACHE_SIZE - (off + bytes_read);
		if (cpy_bytes > size - bytes_read)
33d1f714:	e0663007 	rsb	r3, r6, r7
						nand_cache_off, NAND_CACHE_SIZE);
				return -1;
			}
#endif
		}
		cpy_bytes = nand_cache_off + NAND_CACHE_SIZE - (off + bytes_read);
33d1f718:	e2822a02 	add	r2, r2, #8192	; 0x2000
		if (cpy_bytes > size - bytes_read)
			cpy_bytes = size - bytes_read;
33d1f71c:	e1520003 	cmp	r2, r3
33d1f720:	21a02003 	movcs	r2, r3
		memcpy(buf + bytes_read,
33d1f724:	e0601001 	rsb	r1, r0, r1
33d1f728:	e0840006 	add	r0, r4, r6
		       nand_cache + off + bytes_read - nand_cache_off,
		       cpy_bytes);
		bytes_read += cpy_bytes;
33d1f72c:	e0866002 	add	r6, r6, r2
#endif
		}
		cpy_bytes = nand_cache_off + NAND_CACHE_SIZE - (off + bytes_read);
		if (cpy_bytes > size - bytes_read)
			cpy_bytes = size - bytes_read;
		memcpy(buf + bytes_read,
33d1f730:	ebffeb2b 	bl	33d1a3e4 <memcpy>
		       nand_cache + off + bytes_read - nand_cache_off,
		       cpy_bytes);
		bytes_read += cpy_bytes;
33d1f734:	e1560007 	cmp	r6, r7
33d1f738:	eaffffbc 	b	33d1f630 <get_fl_mem_nand+0x6c>

static u8* nand_cache = NULL;
static u32 nand_cache_off = (u32)-1;

static int read_nand_cached(u32 off, u32 size, u_char *buf)
{
33d1f73c:	e3560000 	cmp	r6, #0	; 0x0
33d1f740:	aa000005 	bge	33d1f75c <get_fl_mem_nand+0x198>
	if (NULL == buf) {
		printf("get_fl_mem_nand: can't alloc %d bytes\n", size);
		return NULL;
	}
	if (read_nand_cached(off, size, buf) < 0) {
		if (!ext_buf)
33d1f744:	e59d200c 	ldr	r2, [sp, #12]
33d1f748:	e3520000 	cmp	r2, #0	; 0x0
			free(buf);
33d1f74c:	01a00004 	moveq	r0, r4
33d1f750:	0bffdf3f 	bleq	33d17454 <free>
		return NULL;
33d1f754:	e3a00000 	mov	r0, #0	; 0x0
33d1f758:	ea000000 	b	33d1f760 <get_fl_mem_nand+0x19c>
	}

	return buf;
33d1f75c:	e1a00004 	mov	r0, r4
}
33d1f760:	e28dd018 	add	sp, sp, #24	; 0x18
33d1f764:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1f768:	33d2d438 	.word	0x33d2d438
33d1f76c:	33d2d460 	.word	0x33d2d460
33d1f770:	33d6264c 	.word	0x33d6264c
33d1f774:	33d3693c 	.word	0x33d3693c
33d1f778:	33d62648 	.word	0x33d62648
33d1f77c:	33d39920 	.word	0x33d39920
33d1f780:	33d2d494 	.word	0x33d2d494

33d1f784 <get_node_mem_nand>:

static void *get_node_mem_nand(u32 off)
{
33d1f784:	e92d4030 	push	{r4, r5, lr}
33d1f788:	e24dd010 	sub	sp, sp, #16	; 0x10
	struct jffs2_unknown_node node;
	void *ret = NULL;

	if (NULL == get_fl_mem_nand(off, sizeof(node), &node))
33d1f78c:	e3a0100c 	mov	r1, #12	; 0xc
33d1f790:	e28d2004 	add	r2, sp, #4	; 0x4

	return buf;
}

static void *get_node_mem_nand(u32 off)
{
33d1f794:	e1a05000 	mov	r5, r0
	struct jffs2_unknown_node node;
	void *ret = NULL;

	if (NULL == get_fl_mem_nand(off, sizeof(node), &node))
33d1f798:	ebffff89 	bl	33d1f5c4 <get_fl_mem_nand>
}

static void *get_node_mem_nand(u32 off)
{
	struct jffs2_unknown_node node;
	void *ret = NULL;
33d1f79c:	e3a04000 	mov	r4, #0	; 0x0

	if (NULL == get_fl_mem_nand(off, sizeof(node), &node))
33d1f7a0:	e3500000 	cmp	r0, #0	; 0x0
		return NULL;
33d1f7a4:	e1a00004 	mov	r0, r4
static void *get_node_mem_nand(u32 off)
{
	struct jffs2_unknown_node node;
	void *ret = NULL;

	if (NULL == get_fl_mem_nand(off, sizeof(node), &node))
33d1f7a8:	0a000010 	beq	33d1f7f0 <get_node_mem_nand+0x6c>
		return NULL;

	if (!(ret = get_fl_mem_nand(off, node.magic ==
33d1f7ac:	e1dd20b4 	ldrh	r2, [sp, #4]
33d1f7b0:	e59f3040 	ldr	r3, [pc, #64]	; 33d1f7f8 <get_node_mem_nand+0x74>
33d1f7b4:	e1520003 	cmp	r2, r3
33d1f7b8:	059d1008 	ldreq	r1, [sp, #8]
33d1f7bc:	13a0100c 	movne	r1, #12	; 0xc
33d1f7c0:	e3a02000 	mov	r2, #0	; 0x0
33d1f7c4:	e1a00005 	mov	r0, r5
33d1f7c8:	ebffff7d 	bl	33d1f5c4 <get_fl_mem_nand>
33d1f7cc:	e2504000 	subs	r4, r0, #0	; 0x0
			       JFFS2_MAGIC_BITMASK ? node.totlen : sizeof(node),
			       NULL))) {
		printf("off = %#x magic %#x type %#x node.totlen = %d\n",
33d1f7d0:	e1a01005 	mov	r1, r5
33d1f7d4:	e59f0020 	ldr	r0, [pc, #32]	; 33d1f7fc <get_node_mem_nand+0x78>
33d1f7d8:	059dc008 	ldreq	ip, [sp, #8]
33d1f7dc:	01dd20b4 	ldrheq	r2, [sp, #4]
33d1f7e0:	01dd30b6 	ldrheq	r3, [sp, #6]
33d1f7e4:	058dc000 	streq	ip, [sp]
33d1f7e8:	0bffddf6 	bleq	33d16fc8 <printf>
		       off, node.magic, node.nodetype, node.totlen);
	}
	return ret;
33d1f7ec:	e1a00004 	mov	r0, r4
}
33d1f7f0:	e28dd010 	add	sp, sp, #16	; 0x10
33d1f7f4:	e8bd8030 	pop	{r4, r5, pc}
33d1f7f8:	00001985 	.word	0x00001985
33d1f7fc:	33d2d4d0 	.word	0x33d2d4d0

33d1f800 <put_fl_mem_nand>:

static void put_fl_mem_nand(void *buf)
{
	free(buf);
33d1f800:	eaffdf13 	b	33d17454 <free>

33d1f804 <free_nodes>:
};


static void
free_nodes(struct b_list *list)
{
33d1f804:	e92d4030 	push	{r4, r5, lr}
	while (list->listMemBase != NULL) {
		struct mem_block *next = list->listMemBase->next;
		free( list->listMemBase );
		list->listMemBase = next;
33d1f808:	e590300c 	ldr	r3, [r0, #12]
33d1f80c:	e3530000 	cmp	r3, #0	; 0x0
};


static void
free_nodes(struct b_list *list)
{
33d1f810:	e1a05000 	mov	r5, r0
	while (list->listMemBase != NULL) {
		struct mem_block *next = list->listMemBase->next;
		free( list->listMemBase );
		list->listMemBase = next;
33d1f814:	08bd8030 	popeq	{r4, r5, pc}

static void
free_nodes(struct b_list *list)
{
	while (list->listMemBase != NULL) {
		struct mem_block *next = list->listMemBase->next;
33d1f818:	e595000c 	ldr	r0, [r5, #12]
33d1f81c:	e5904004 	ldr	r4, [r0, #4]
		free( list->listMemBase );
33d1f820:	ebffdf0b 	bl	33d17454 <free>
		list->listMemBase = next;
33d1f824:	e3540000 	cmp	r4, #0	; 0x0
33d1f828:	e585400c 	str	r4, [r5, #12]
33d1f82c:	1afffff9 	bne	33d1f818 <free_nodes+0x14>
33d1f830:	e8bd8030 	pop	{r4, r5, pc}

33d1f834 <insert_node>:
	return b;
}

static struct b_node *
insert_node(struct b_list *list, u32 offset)
{
33d1f834:	e92d40f0 	push	{r4, r5, r6, r7, lr}
{
	u32 index = 0;
	struct mem_block *memBase;
	struct b_node *b;

	memBase = list->listMemBase;
33d1f838:	e590400c 	ldr	r4, [r0, #12]
	if (memBase != NULL)
33d1f83c:	e3540000 	cmp	r4, #0	; 0x0
}

static struct b_node *
add_node(struct b_list *list)
{
	u32 index = 0;
33d1f840:	e3a02000 	mov	r2, #0	; 0x0
	struct mem_block *memBase;
	struct b_node *b;

	memBase = list->listMemBase;
	if (memBase != NULL)
		index = memBase->index;
33d1f844:	15942000 	ldrne	r2, [r4]
#if 0
	putLabeledWord("add_node: index = ", index);
	putLabeledWord("add_node: memBase = ", list->listMemBase);
#endif

	if (memBase == NULL || index >= NODE_CHUNK) {
33d1f848:	13a03000 	movne	r3, #0	; 0x0
33d1f84c:	03a03001 	moveq	r3, #1	; 0x1
33d1f850:	e3520b01 	cmp	r2, #1024	; 0x400
33d1f854:	23833001 	orrcs	r3, r3, #1	; 0x1
33d1f858:	e3530000 	cmp	r3, #0	; 0x0
	return b;
}

static struct b_node *
insert_node(struct b_list *list, u32 offset)
{
33d1f85c:	e1a05000 	mov	r5, r0
33d1f860:	e1a07001 	mov	r7, r1
#if 0
	putLabeledWord("add_node: index = ", index);
	putLabeledWord("add_node: memBase = ", list->listMemBase);
#endif

	if (memBase == NULL || index >= NODE_CHUNK) {
33d1f864:	0a00000b 	beq	33d1f898 <insert_node+0x64>
		/* we need more space before we continue */
		memBase = mmalloc(sizeof(struct mem_block));
33d1f868:	e59f008c 	ldr	r0, [pc, #140]	; 33d1f8fc <insert_node+0xc8>
33d1f86c:	ebffdf7d 	bl	33d17668 <malloc>
		if (memBase == NULL) {
33d1f870:	e2504000 	subs	r4, r0, #0	; 0x0
			putstr("add_node: malloc failed\n");
			return NULL;
		}
		memBase->next = list->listMemBase;
33d1f874:	1595300c 	ldrne	r3, [r5, #12]
		index = 0;
33d1f878:	13a02000 	movne	r2, #0	; 0x0
		memBase = mmalloc(sizeof(struct mem_block));
		if (memBase == NULL) {
			putstr("add_node: malloc failed\n");
			return NULL;
		}
		memBase->next = list->listMemBase;
33d1f87c:	15843004 	strne	r3, [r4, #4]
#endif

	if (memBase == NULL || index >= NODE_CHUNK) {
		/* we need more space before we continue */
		memBase = mmalloc(sizeof(struct mem_block));
		if (memBase == NULL) {
33d1f880:	1a000004 	bne	33d1f898 <insert_node+0x64>
			putstr("add_node: malloc failed\n");
33d1f884:	e59f0074 	ldr	r0, [pc, #116]	; 33d1f900 <insert_node+0xcc>
33d1f888:	e59f1074 	ldr	r1, [pc, #116]	; 33d1f904 <insert_node+0xd0>
33d1f88c:	ebffddcd 	bl	33d16fc8 <printf>
33d1f890:	e1a06004 	mov	r6, r4
33d1f894:	ea000008 	b	33d1f8bc <insert_node+0x88>
		putLabeledWord("add_node: alloced a new membase at ", *memBase);
#endif

	}
	/* now we have room to add it. */
	b = &memBase->nodes[index];
33d1f898:	e0841182 	add	r1, r4, r2, lsl #3
	index ++;
33d1f89c:	e2822001 	add	r2, r2, #1	; 0x1

	memBase->index = index;
33d1f8a0:	e5842000 	str	r2, [r4]
	list->listMemBase = memBase;
	list->listCount++;
33d1f8a4:	e5953008 	ldr	r3, [r5, #8]
	}
}

static struct b_node *
add_node(struct b_list *list)
{
33d1f8a8:	e2916008 	adds	r6, r1, #8	; 0x8
	b = &memBase->nodes[index];
	index ++;

	memBase->index = index;
	list->listMemBase = memBase;
	list->listCount++;
33d1f8ac:	e2833001 	add	r3, r3, #1	; 0x1
	/* now we have room to add it. */
	b = &memBase->nodes[index];
	index ++;

	memBase->index = index;
	list->listMemBase = memBase;
33d1f8b0:	e585400c 	str	r4, [r5, #12]
	list->listCount++;
33d1f8b4:	e5853008 	str	r3, [r5, #8]
	}
}

static struct b_node *
add_node(struct b_list *list)
{
33d1f8b8:	1a000004 	bne	33d1f8d0 <insert_node+0x9c>
#ifdef CFG_JFFS2_SORT_FRAGMENTS
	struct b_node *b, *prev;
#endif

	if (!(new = add_node(list))) {
		putstr("add_node failed!\r\n");
33d1f8bc:	e59f003c 	ldr	r0, [pc, #60]	; 33d1f900 <insert_node+0xcc>
33d1f8c0:	e59f1040 	ldr	r1, [pc, #64]	; 33d1f908 <insert_node+0xd4>
33d1f8c4:	ebffddbf 	bl	33d16fc8 <printf>
		return NULL;
33d1f8c8:	e1a00006 	mov	r0, r6
33d1f8cc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
		else
			list->listHead = new;
	} else
#endif
	{
		new->next = (struct b_node *) NULL;
33d1f8d0:	e3a03000 	mov	r3, #0	; 0x0
33d1f8d4:	e5863004 	str	r3, [r6, #4]

	if (!(new = add_node(list))) {
		putstr("add_node failed!\r\n");
		return NULL;
	}
	new->offset = offset;
33d1f8d8:	e5817008 	str	r7, [r1, #8]
			list->listHead = new;
	} else
#endif
	{
		new->next = (struct b_node *) NULL;
		if (list->listTail != NULL) {
33d1f8dc:	e5953000 	ldr	r3, [r5]
		} else {
			list->listTail = list->listHead = new;
		}
	}

	return new;
33d1f8e0:	e1a00006 	mov	r0, r6
			list->listHead = new;
	} else
#endif
	{
		new->next = (struct b_node *) NULL;
		if (list->listTail != NULL) {
33d1f8e4:	e3530000 	cmp	r3, #0	; 0x0
			list->listTail->next = new;
33d1f8e8:	15836004 	strne	r6, [r3, #4]
			list->listTail = new;
		} else {
			list->listTail = list->listHead = new;
33d1f8ec:	05856000 	streq	r6, [r5]
#endif
	{
		new->next = (struct b_node *) NULL;
		if (list->listTail != NULL) {
			list->listTail->next = new;
			list->listTail = new;
33d1f8f0:	15856000 	strne	r6, [r5]
		} else {
			list->listTail = list->listHead = new;
33d1f8f4:	05856004 	streq	r6, [r5, #4]
		}
	}

	return new;
}
33d1f8f8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d1f8fc:	00002008 	.word	0x00002008
33d1f900:	33d2c2fc 	.word	0x33d2c2fc
33d1f904:	33d2d500 	.word	0x33d2d500
33d1f908:	33d2d51c 	.word	0x33d2d51c

33d1f90c <jffs2_free_cache>:
	return (u32)offset - part->offset;
}

void
jffs2_free_cache(struct part_info *part)
{
33d1f90c:	e92d4010 	push	{r4, lr}
	struct b_lists *pL;

	if (part->jffs2_priv != NULL) {
33d1f910:	e5904018 	ldr	r4, [r0, #24]
33d1f914:	e3540000 	cmp	r4, #0	; 0x0
		pL = (struct b_lists *)part->jffs2_priv;
		free_nodes(&pL->frag);
33d1f918:	e2840010 	add	r0, r4, #16	; 0x10
void
jffs2_free_cache(struct part_info *part)
{
	struct b_lists *pL;

	if (part->jffs2_priv != NULL) {
33d1f91c:	08bd8010 	popeq	{r4, pc}
		pL = (struct b_lists *)part->jffs2_priv;
		free_nodes(&pL->frag);
33d1f920:	ebffffb7 	bl	33d1f804 <free_nodes>
		free_nodes(&pL->dir);
33d1f924:	e1a00004 	mov	r0, r4
33d1f928:	ebffffb5 	bl	33d1f804 <free_nodes>
		free(pL);
33d1f92c:	e1a00004 	mov	r0, r4
	}
}
33d1f930:	e8bd4010 	pop	{r4, lr}

	if (part->jffs2_priv != NULL) {
		pL = (struct b_lists *)part->jffs2_priv;
		free_nodes(&pL->frag);
		free_nodes(&pL->dir);
		free(pL);
33d1f934:	eaffdec6 	b	33d17454 <free>

33d1f938 <jffs2_1pass_read_inode>:
}

/* find the inode from the slashless name given a parent */
static long
jffs2_1pass_read_inode(struct b_lists *pL, u32 inode, char *dest)
{
33d1f938:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct b_node *b;
	struct jffs2_raw_inode *jNode;
	u32 totalSize = 0;
33d1f93c:	e3a09000 	mov	r9, #0	; 0x0
		}
		put_fl_mem(jNode);
	}
#endif

	for (b = pL->frag.listHead; b != NULL; b = b->next) {
33d1f940:	e5907014 	ldr	r7, [r0, #20]
}

/* find the inode from the slashless name given a parent */
static long
jffs2_1pass_read_inode(struct b_lists *pL, u32 inode, char *dest)
{
33d1f944:	e24dd008 	sub	sp, sp, #8	; 0x8
33d1f948:	e58d1004 	str	r1, [sp, #4]
	struct b_node *b;
	struct jffs2_raw_inode *jNode;
	u32 totalSize = 0;
	u32 latestVersion = 0;
33d1f94c:	e58d9000 	str	r9, [sp]
		}
		put_fl_mem(jNode);
	}
#endif

	for (b = pL->frag.listHead; b != NULL; b = b->next) {
33d1f950:	e3570000 	cmp	r7, #0	; 0x0
}

/* find the inode from the slashless name given a parent */
static long
jffs2_1pass_read_inode(struct b_lists *pL, u32 inode, char *dest)
{
33d1f954:	e1a0b002 	mov	fp, r2
		}
		put_fl_mem(jNode);
	}
#endif

	for (b = pL->frag.listHead; b != NULL; b = b->next) {
33d1f958:	0a0000b8 	beq	33d1fc40 <jffs2_1pass_read_inode+0x308>
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d1f95c:	e59fa2e8 	ldr	sl, [pc, #744]	; 33d1fc4c <jffs2_1pass_read_inode+0x314>
33d1f960:	e59a3000 	ldr	r3, [sl]
33d1f964:	e5933020 	ldr	r3, [r3, #32]
33d1f968:	e5932008 	ldr	r2, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d1f96c:	e5d23008 	ldrb	r3, [r2, #8]
33d1f970:	e3530001 	cmp	r3, #1	; 0x1
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d1f974:	e5974000 	ldr	r4, [r7]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d1f978:	1a000007 	bne	33d1f99c <jffs2_1pass_read_inode+0x64>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d1f97c:	e5d23009 	ldrb	r3, [r2, #9]
33d1f980:	e59f22c8 	ldr	r2, [pc, #712]	; 33d1fc50 <jffs2_1pass_read_inode+0x318>
33d1f984:	e0833083 	add	r3, r3, r3, lsl #1
33d1f988:	e0833183 	add	r3, r3, r3, lsl #3
33d1f98c:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d1f990:	e592300c 	ldr	r3, [r2, #12]
33d1f994:	e0844003 	add	r4, r4, r3
static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d1f998:	ea000007 	b	33d1f9bc <jffs2_1pass_read_inode+0x84>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d1f99c:	e3530002 	cmp	r3, #2	; 0x2
33d1f9a0:	1a000003 	bne	33d1f9b4 <jffs2_1pass_read_inode+0x7c>
33d1f9a4:	e1a00004 	mov	r0, r4
33d1f9a8:	ebffff75 	bl	33d1f784 <get_node_mem_nand>
33d1f9ac:	e1a04000 	mov	r4, r0
33d1f9b0:	ea000001 	b	33d1f9bc <jffs2_1pass_read_inode+0x84>
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d1f9b4:	e59f0298 	ldr	r0, [pc, #664]	; 33d1fc54 <jffs2_1pass_read_inode+0x31c>
33d1f9b8:	ebffdd82 	bl	33d16fc8 <printf>
	}
#endif

	for (b = pL->frag.listHead; b != NULL; b = b->next) {
		jNode = (struct jffs2_raw_inode *) get_node_mem(b->offset);
		if ((inode == jNode->ino)) {
33d1f9bc:	e5d4200d 	ldrb	r2, [r4, #13]
33d1f9c0:	e5d4300c 	ldrb	r3, [r4, #12]
33d1f9c4:	e5d4100e 	ldrb	r1, [r4, #14]
33d1f9c8:	e1833402 	orr	r3, r3, r2, lsl #8
33d1f9cc:	e5d4200f 	ldrb	r2, [r4, #15]
33d1f9d0:	e1833801 	orr	r3, r3, r1, lsl #16
33d1f9d4:	e1833c02 	orr	r3, r3, r2, lsl #24
33d1f9d8:	e59d2004 	ldr	r2, [sp, #4]
33d1f9dc:	e1520003 	cmp	r2, r3
33d1f9e0:	1a00008c 	bne	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
			putLabeledWord("read_inode: flags = ", jNode->flags);
#endif

#ifndef CFG_JFFS2_SORT_FRAGMENTS
			/* get actual file length from the newest node */
			if (jNode->version >= latestVersion) {
33d1f9e4:	e5d42011 	ldrb	r2, [r4, #17]
33d1f9e8:	e5d43010 	ldrb	r3, [r4, #16]
33d1f9ec:	e5d41012 	ldrb	r1, [r4, #18]
33d1f9f0:	e1833402 	orr	r3, r3, r2, lsl #8
33d1f9f4:	e5d42013 	ldrb	r2, [r4, #19]
33d1f9f8:	e1833801 	orr	r3, r3, r1, lsl #16
33d1f9fc:	e1830c02 	orr	r0, r3, r2, lsl #24
33d1fa00:	e59d3000 	ldr	r3, [sp]
33d1fa04:	e1500003 	cmp	r0, r3
33d1fa08:	3a000007 	bcc	33d1fa2c <jffs2_1pass_read_inode+0xf4>
				totalSize = jNode->isize;
33d1fa0c:	e5d4201d 	ldrb	r2, [r4, #29]
33d1fa10:	e5d4301c 	ldrb	r3, [r4, #28]
33d1fa14:	e5d4101e 	ldrb	r1, [r4, #30]
33d1fa18:	e1833402 	orr	r3, r3, r2, lsl #8
33d1fa1c:	e5d4201f 	ldrb	r2, [r4, #31]
33d1fa20:	e1833801 	orr	r3, r3, r1, lsl #16
				latestVersion = jNode->version;
33d1fa24:	e58d0000 	str	r0, [sp]
#endif

#ifndef CFG_JFFS2_SORT_FRAGMENTS
			/* get actual file length from the newest node */
			if (jNode->version >= latestVersion) {
				totalSize = jNode->isize;
33d1fa28:	e1839c02 	orr	r9, r3, r2, lsl #24
				latestVersion = jNode->version;
			}
#endif

			if(dest) {
33d1fa2c:	e35b0000 	cmp	fp, #0	; 0x0
33d1fa30:	0a000078 	beq	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
				src = ((uchar *) jNode) + sizeof(struct jffs2_raw_inode);
				/* ignore data behind latest known EOF */
				if (jNode->offset > totalSize) {
33d1fa34:	e5d4202d 	ldrb	r2, [r4, #45]
33d1fa38:	e5d4302c 	ldrb	r3, [r4, #44]
33d1fa3c:	e5d4102e 	ldrb	r1, [r4, #46]
33d1fa40:	e1833402 	orr	r3, r3, r2, lsl #8
33d1fa44:	e5d4202f 	ldrb	r2, [r4, #47]
33d1fa48:	e1833801 	orr	r3, r3, r1, lsl #16
33d1fa4c:	e1830c02 	orr	r0, r3, r2, lsl #24
33d1fa50:	e1500009 	cmp	r0, r9
				latestVersion = jNode->version;
			}
#endif

			if(dest) {
				src = ((uchar *) jNode) + sizeof(struct jffs2_raw_inode);
33d1fa54:	e2846044 	add	r6, r4, #68	; 0x44
				/* ignore data behind latest known EOF */
				if (jNode->offset > totalSize) {
33d1fa58:	8a00006e 	bhi	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
				lDest = (uchar *) (dest + jNode->offset);
#if 0
				putLabeledWord("read_inode: src = ", src);
				putLabeledWord("read_inode: dest = ", lDest);
#endif
				switch (jNode->compr) {
33d1fa5c:	e5d42038 	ldrb	r2, [r4, #56]
				if (jNode->offset > totalSize) {
					put_fl_mem(jNode);
					continue;
				}

				lDest = (uchar *) (dest + jNode->offset);
33d1fa60:	e08b5000 	add	r5, fp, r0
#if 0
				putLabeledWord("read_inode: src = ", src);
				putLabeledWord("read_inode: dest = ", lDest);
#endif
				switch (jNode->compr) {
33d1fa64:	e3520006 	cmp	r2, #6	; 0x6
33d1fa68:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
33d1fa6c:	ea00005d 	b	33d1fbe8 <jffs2_1pass_read_inode+0x2b0>
33d1fa70:	33d1fa8c 	.word	0x33d1fa8c
33d1fa74:	33d1fab8 	.word	0x33d1fab8
33d1fa78:	33d1fb10 	.word	0x33d1fb10
33d1fa7c:	33d1fbe8 	.word	0x33d1fbe8
33d1fa80:	33d1fbe8 	.word	0x33d1fbe8
33d1fa84:	33d1fb58 	.word	0x33d1fb58
33d1fa88:	33d1fba0 	.word	0x33d1fba0
				case JFFS2_COMPR_NONE:
					ret = (unsigned long) ldr_memcpy(lDest, src, jNode->dsize);
33d1fa8c:	e5d43035 	ldrb	r3, [r4, #53]
33d1fa90:	e5d42034 	ldrb	r2, [r4, #52]
33d1fa94:	e5d41036 	ldrb	r1, [r4, #54]
33d1fa98:	e1822403 	orr	r2, r2, r3, lsl #8
33d1fa9c:	e5d43037 	ldrb	r3, [r4, #55]
33d1faa0:	e1822801 	orr	r2, r2, r1, lsl #16
33d1faa4:	e1822c03 	orr	r2, r2, r3, lsl #24
33d1faa8:	e1a00005 	mov	r0, r5
33d1faac:	e1a01006 	mov	r1, r6
33d1fab0:	ebffea4b 	bl	33d1a3e4 <memcpy>
					break;
33d1fab4:	ea000057 	b	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
				case JFFS2_COMPR_ZERO:
					ret = 0;
					for (i = 0; i < jNode->dsize; i++)
33d1fab8:	e5d42035 	ldrb	r2, [r4, #53]
33d1fabc:	e5d43034 	ldrb	r3, [r4, #52]
33d1fac0:	e5d41036 	ldrb	r1, [r4, #54]
33d1fac4:	e1833402 	orr	r3, r3, r2, lsl #8
33d1fac8:	e5d42037 	ldrb	r2, [r4, #55]
33d1facc:	e1833801 	orr	r3, r3, r1, lsl #16
33d1fad0:	e1932c02 	orrs	r2, r3, r2, lsl #24
33d1fad4:	e3a00000 	mov	r0, #0	; 0x0
33d1fad8:	0a00004e 	beq	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
						*(lDest++) = 0;
33d1fadc:	e3a03000 	mov	r3, #0	; 0x0
33d1fae0:	e4c53001 	strb	r3, [r5], #1
				case JFFS2_COMPR_NONE:
					ret = (unsigned long) ldr_memcpy(lDest, src, jNode->dsize);
					break;
				case JFFS2_COMPR_ZERO:
					ret = 0;
					for (i = 0; i < jNode->dsize; i++)
33d1fae4:	e5d42035 	ldrb	r2, [r4, #53]
33d1fae8:	e5d43034 	ldrb	r3, [r4, #52]
33d1faec:	e5d41036 	ldrb	r1, [r4, #54]
33d1faf0:	e1833402 	orr	r3, r3, r2, lsl #8
33d1faf4:	e5d42037 	ldrb	r2, [r4, #55]
33d1faf8:	e1833801 	orr	r3, r3, r1, lsl #16
33d1fafc:	e1833c02 	orr	r3, r3, r2, lsl #24
33d1fb00:	e2800001 	add	r0, r0, #1	; 0x1
33d1fb04:	e1500003 	cmp	r0, r3
33d1fb08:	3afffff3 	bcc	33d1fadc <jffs2_1pass_read_inode+0x1a4>
						*(lDest++) = 0;
					break;
33d1fb0c:	ea000041 	b	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
				case JFFS2_COMPR_RTIME:
					ret = 0;
					rtime_decompress(src, lDest, jNode->csize, jNode->dsize);
33d1fb10:	e5d40031 	ldrb	r0, [r4, #49]
33d1fb14:	e5d41035 	ldrb	r1, [r4, #53]
33d1fb18:	e5d42030 	ldrb	r2, [r4, #48]
33d1fb1c:	e5d43034 	ldrb	r3, [r4, #52]
33d1fb20:	e5d4c032 	ldrb	ip, [r4, #50]
33d1fb24:	e5d4e036 	ldrb	lr, [r4, #54]
33d1fb28:	e1822400 	orr	r2, r2, r0, lsl #8
33d1fb2c:	e1833401 	orr	r3, r3, r1, lsl #8
33d1fb30:	e5d40037 	ldrb	r0, [r4, #55]
33d1fb34:	e5d41033 	ldrb	r1, [r4, #51]
33d1fb38:	e182280c 	orr	r2, r2, ip, lsl #16
33d1fb3c:	e183380e 	orr	r3, r3, lr, lsl #16
33d1fb40:	e1822c01 	orr	r2, r2, r1, lsl #24
33d1fb44:	e1833c00 	orr	r3, r3, r0, lsl #24
33d1fb48:	e1a01005 	mov	r1, r5
33d1fb4c:	e1a00006 	mov	r0, r6
33d1fb50:	eb000674 	bl	33d21528 <rtime_decompress>
					break;
33d1fb54:	ea00002f 	b	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
				case JFFS2_COMPR_DYNRUBIN:
					/* this is slow but it works */
					ret = 0;
					dynrubin_decompress(src, lDest, jNode->csize, jNode->dsize);
33d1fb58:	e5d40031 	ldrb	r0, [r4, #49]
33d1fb5c:	e5d41035 	ldrb	r1, [r4, #53]
33d1fb60:	e5d42030 	ldrb	r2, [r4, #48]
33d1fb64:	e5d43034 	ldrb	r3, [r4, #52]
33d1fb68:	e5d4c032 	ldrb	ip, [r4, #50]
33d1fb6c:	e5d4e036 	ldrb	lr, [r4, #54]
33d1fb70:	e1822400 	orr	r2, r2, r0, lsl #8
33d1fb74:	e1833401 	orr	r3, r3, r1, lsl #8
33d1fb78:	e5d40037 	ldrb	r0, [r4, #55]
33d1fb7c:	e5d41033 	ldrb	r1, [r4, #51]
33d1fb80:	e182280c 	orr	r2, r2, ip, lsl #16
33d1fb84:	e183380e 	orr	r3, r3, lr, lsl #16
33d1fb88:	e1822c01 	orr	r2, r2, r1, lsl #24
33d1fb8c:	e1833c00 	orr	r3, r3, r0, lsl #24
33d1fb90:	e1a01005 	mov	r1, r5
33d1fb94:	e1a00006 	mov	r0, r6
33d1fb98:	eb0006ce 	bl	33d216d8 <dynrubin_decompress>
					break;
33d1fb9c:	ea00001d 	b	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
				case JFFS2_COMPR_ZLIB:
					ret = zlib_decompress(src, lDest, jNode->csize, jNode->dsize);
33d1fba0:	e5d40031 	ldrb	r0, [r4, #49]
33d1fba4:	e5d41035 	ldrb	r1, [r4, #53]
33d1fba8:	e5d42030 	ldrb	r2, [r4, #48]
33d1fbac:	e5d43034 	ldrb	r3, [r4, #52]
33d1fbb0:	e5d4c032 	ldrb	ip, [r4, #50]
33d1fbb4:	e5d4e036 	ldrb	lr, [r4, #54]
33d1fbb8:	e1822400 	orr	r2, r2, r0, lsl #8
33d1fbbc:	e1833401 	orr	r3, r3, r1, lsl #8
33d1fbc0:	e5d40037 	ldrb	r0, [r4, #55]
33d1fbc4:	e5d41033 	ldrb	r1, [r4, #51]
33d1fbc8:	e182280c 	orr	r2, r2, ip, lsl #16
33d1fbcc:	e183380e 	orr	r3, r3, lr, lsl #16
33d1fbd0:	e1822c01 	orr	r2, r2, r1, lsl #24
33d1fbd4:	e1833c00 	orr	r3, r3, r0, lsl #24
33d1fbd8:	e1a01005 	mov	r1, r5
33d1fbdc:	e1a00006 	mov	r0, r6
33d1fbe0:	eb0006ce 	bl	33d21720 <zlib_decompress>
					break;
33d1fbe4:	ea00000b 	b	33d1fc18 <jffs2_1pass_read_inode+0x2e0>
					ret = lzari_decompress(src, lDest, jNode->csize, jNode->dsize);
					break;
#endif
				default:
					/* unknown */
					putLabeledWord("UNKOWN COMPRESSION METHOD = ", jNode->compr);
33d1fbe8:	e59f0068 	ldr	r0, [pc, #104]	; 33d1fc58 <jffs2_1pass_read_inode+0x320>
33d1fbec:	e59f1068 	ldr	r1, [pc, #104]	; 33d1fc5c <jffs2_1pass_read_inode+0x324>
33d1fbf0:	ebffdcf4 	bl	33d16fc8 <printf>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d1fbf4:	e59a3000 	ldr	r3, [sl]
33d1fbf8:	e5933020 	ldr	r3, [r3, #32]
33d1fbfc:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d1fc00:	e5d33008 	ldrb	r3, [r3, #8]
33d1fc04:	e3530002 	cmp	r3, #2	; 0x2
33d1fc08:	01a00004 	moveq	r0, r4
33d1fc0c:	0bfffefb 	bleq	33d1f800 <put_fl_mem_nand>
#endif
				default:
					/* unknown */
					putLabeledWord("UNKOWN COMPRESSION METHOD = ", jNode->compr);
					put_fl_mem(jNode);
					return -1;
33d1fc10:	e3e00000 	mvn	r0, #0	; 0x0
33d1fc14:	ea00000a 	b	33d1fc44 <jffs2_1pass_read_inode+0x30c>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d1fc18:	e59a3000 	ldr	r3, [sl]
33d1fc1c:	e5933020 	ldr	r3, [r3, #32]
33d1fc20:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d1fc24:	e5d33008 	ldrb	r3, [r3, #8]
33d1fc28:	e3530002 	cmp	r3, #2	; 0x2
33d1fc2c:	01a00004 	moveq	r0, r4
33d1fc30:	0bfffef2 	bleq	33d1f800 <put_fl_mem_nand>
		}
		put_fl_mem(jNode);
	}
#endif

	for (b = pL->frag.listHead; b != NULL; b = b->next) {
33d1fc34:	e5977004 	ldr	r7, [r7, #4]
33d1fc38:	e3570000 	cmp	r7, #0	; 0x0
33d1fc3c:	eaffff45 	b	33d1f958 <jffs2_1pass_read_inode+0x20>
	}

#if 0
	putLabeledWord("read_inode: returning = ", totalSize);
#endif
	return totalSize;
33d1fc40:	e1a00009 	mov	r0, r9
}
33d1fc44:	e28dd008 	add	sp, sp, #8	; 0x8
33d1fc48:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1fc4c:	33d6264c 	.word	0x33d6264c
33d1fc50:	33d62554 	.word	0x33d62554
33d1fc54:	33d2d530 	.word	0x33d2d530
33d1fc58:	33d2d568 	.word	0x33d2d568
33d1fc5c:	33d2d574 	.word	0x33d2d574

33d1fc60 <jffs2_1pass_find_inode>:

/* find the inode from the slashless name given a parent */
static u32
jffs2_1pass_find_inode(struct b_lists * pL, const char *name, u32 pino)
{
33d1fc60:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d1fc64:	e1a04000 	mov	r4, r0
33d1fc68:	e24dd008 	sub	sp, sp, #8	; 0x8
	u32 counter;
	u32 version = 0;
	u32 inode = 0;

	/* name is assumed slash free */
	len = strlen(name);
33d1fc6c:	e1a00001 	mov	r0, r1
}

/* find the inode from the slashless name given a parent */
static u32
jffs2_1pass_find_inode(struct b_lists * pL, const char *name, u32 pino)
{
33d1fc70:	e58d1004 	str	r1, [sp, #4]
33d1fc74:	e58d2000 	str	r2, [sp]
	u32 counter;
	u32 version = 0;
	u32 inode = 0;

	/* name is assumed slash free */
	len = strlen(name);
33d1fc78:	ebffe924 	bl	33d1a110 <strlen>

	counter = 0;
	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next, counter++) {
33d1fc7c:	e5946004 	ldr	r6, [r4, #4]
{
	struct b_node *b;
	struct jffs2_raw_dirent *jDir;
	int len;
	u32 counter;
	u32 version = 0;
33d1fc80:	e3a07000 	mov	r7, #0	; 0x0
	u32 inode = 0;

	/* name is assumed slash free */
	len = strlen(name);
33d1fc84:	e1a0b000 	mov	fp, r0

	counter = 0;
	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next, counter++) {
33d1fc88:	e3560000 	cmp	r6, #0	; 0x0
	struct b_node *b;
	struct jffs2_raw_dirent *jDir;
	int len;
	u32 counter;
	u32 version = 0;
	u32 inode = 0;
33d1fc8c:	e1a09007 	mov	r9, r7
	/* name is assumed slash free */
	len = strlen(name);

	counter = 0;
	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next, counter++) {
33d1fc90:	0a000067 	beq	33d1fe34 <jffs2_1pass_find_inode+0x1d4>
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d1fc94:	e59fa1a4 	ldr	sl, [pc, #420]	; 33d1fe40 <jffs2_1pass_find_inode+0x1e0>
33d1fc98:	e59a3000 	ldr	r3, [sl]
33d1fc9c:	e5933020 	ldr	r3, [r3, #32]
33d1fca0:	e5932008 	ldr	r2, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d1fca4:	e5d23008 	ldrb	r3, [r2, #8]
33d1fca8:	e3530001 	cmp	r3, #1	; 0x1
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d1fcac:	e5964000 	ldr	r4, [r6]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d1fcb0:	1a000007 	bne	33d1fcd4 <jffs2_1pass_find_inode+0x74>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d1fcb4:	e5d23009 	ldrb	r3, [r2, #9]
33d1fcb8:	e59f2184 	ldr	r2, [pc, #388]	; 33d1fe44 <jffs2_1pass_find_inode+0x1e4>
33d1fcbc:	e0833083 	add	r3, r3, r3, lsl #1
33d1fcc0:	e0833183 	add	r3, r3, r3, lsl #3
33d1fcc4:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d1fcc8:	e592300c 	ldr	r3, [r2, #12]
33d1fccc:	e0844003 	add	r4, r4, r3
static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d1fcd0:	ea000007 	b	33d1fcf4 <jffs2_1pass_find_inode+0x94>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d1fcd4:	e3530002 	cmp	r3, #2	; 0x2
33d1fcd8:	1a000003 	bne	33d1fcec <jffs2_1pass_find_inode+0x8c>
33d1fcdc:	e1a00004 	mov	r0, r4
33d1fce0:	ebfffea7 	bl	33d1f784 <get_node_mem_nand>
33d1fce4:	e1a04000 	mov	r4, r0
33d1fce8:	ea000001 	b	33d1fcf4 <jffs2_1pass_find_inode+0x94>
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d1fcec:	e59f0154 	ldr	r0, [pc, #340]	; 33d1fe48 <jffs2_1pass_find_inode+0x1e8>
33d1fcf0:	ebffdcb4 	bl	33d16fc8 <printf>

	counter = 0;
	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next, counter++) {
		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
		if ((pino == jDir->pino) && (len == jDir->nsize) &&
33d1fcf4:	e5d4200d 	ldrb	r2, [r4, #13]
33d1fcf8:	e5d4300c 	ldrb	r3, [r4, #12]
33d1fcfc:	e5d4100e 	ldrb	r1, [r4, #14]
33d1fd00:	e1833402 	orr	r3, r3, r2, lsl #8
33d1fd04:	e5d4200f 	ldrb	r2, [r4, #15]
33d1fd08:	e1833801 	orr	r3, r3, r1, lsl #16
33d1fd0c:	e1833c02 	orr	r3, r3, r2, lsl #24
33d1fd10:	e59d2000 	ldr	r2, [sp]
33d1fd14:	e1520003 	cmp	r2, r3
33d1fd18:	1a00003b 	bne	33d1fe0c <jffs2_1pass_find_inode+0x1ac>
33d1fd1c:	e5d4301c 	ldrb	r3, [r4, #28]
33d1fd20:	e15b0003 	cmp	fp, r3
33d1fd24:	1a000038 	bne	33d1fe0c <jffs2_1pass_find_inode+0x1ac>
33d1fd28:	e5d42015 	ldrb	r2, [r4, #21]
33d1fd2c:	e5d43014 	ldrb	r3, [r4, #20]
33d1fd30:	e5d41016 	ldrb	r1, [r4, #22]
33d1fd34:	e1833402 	orr	r3, r3, r2, lsl #8
33d1fd38:	e5d42017 	ldrb	r2, [r4, #23]
33d1fd3c:	e1833801 	orr	r3, r3, r1, lsl #16
33d1fd40:	e1932c02 	orrs	r2, r3, r2, lsl #24
33d1fd44:	0a000030 	beq	33d1fe0c <jffs2_1pass_find_inode+0x1ac>
33d1fd48:	e2845028 	add	r5, r4, #40	; 0x28
33d1fd4c:	e1a00005 	mov	r0, r5
33d1fd50:	e59d1004 	ldr	r1, [sp, #4]
33d1fd54:	e1a0200b 	mov	r2, fp
33d1fd58:	ebffe8ce 	bl	33d1a098 <strncmp>
33d1fd5c:	e3500000 	cmp	r0, #0	; 0x0
33d1fd60:	1a000029 	bne	33d1fe0c <jffs2_1pass_find_inode+0x1ac>
		    (jDir->ino) &&	/* 0 for unlink */
		    (!strncmp((char *)jDir->name, name, len))) {	/* a match */
			if (jDir->version < version) {
33d1fd64:	e5d42011 	ldrb	r2, [r4, #17]
33d1fd68:	e5d43010 	ldrb	r3, [r4, #16]
33d1fd6c:	e5d41012 	ldrb	r1, [r4, #18]
33d1fd70:	e1833402 	orr	r3, r3, r2, lsl #8
33d1fd74:	e5d42013 	ldrb	r2, [r4, #19]
33d1fd78:	e1833801 	orr	r3, r3, r1, lsl #16
33d1fd7c:	e1833c02 	orr	r3, r3, r2, lsl #24
33d1fd80:	e1530009 	cmp	r3, r9
33d1fd84:	3a000020 	bcc	33d1fe0c <jffs2_1pass_find_inode+0x1ac>
				put_fl_mem(jDir);
				continue;
			}

			if (jDir->version == version && inode != 0) {
33d1fd88:	13a03000 	movne	r3, #0	; 0x0
33d1fd8c:	03a03001 	moveq	r3, #1	; 0x1
33d1fd90:	e3570000 	cmp	r7, #0	; 0x0
33d1fd94:	03a03000 	moveq	r3, #0	; 0x0
33d1fd98:	12033001 	andne	r3, r3, #1	; 0x1
33d1fd9c:	e3530000 	cmp	r3, #0	; 0x0
33d1fda0:	0a00000b 	beq	33d1fdd4 <jffs2_1pass_find_inode+0x174>
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
33d1fda4:	e59f00a0 	ldr	r0, [pc, #160]	; 33d1fe4c <jffs2_1pass_find_inode+0x1ec>
33d1fda8:	e59f10a0 	ldr	r1, [pc, #160]	; 33d1fe50 <jffs2_1pass_find_inode+0x1f0>
33d1fdac:	ebffdc85 	bl	33d16fc8 <printf>
				putnstr(jDir->name, jDir->nsize);
33d1fdb0:	e5d4101c 	ldrb	r1, [r4, #28]
33d1fdb4:	e59f0098 	ldr	r0, [pc, #152]	; 33d1fe54 <jffs2_1pass_find_inode+0x1f4>
33d1fdb8:	e1a02001 	mov	r2, r1
33d1fdbc:	e1a03005 	mov	r3, r5
33d1fdc0:	ebffdc80 	bl	33d16fc8 <printf>
				putLabeledWord(" has dup version =", version);
33d1fdc4:	e1a02009 	mov	r2, r9
33d1fdc8:	e59f0088 	ldr	r0, [pc, #136]	; 33d1fe58 <jffs2_1pass_find_inode+0x1f8>
33d1fdcc:	e59f1088 	ldr	r1, [pc, #136]	; 33d1fe5c <jffs2_1pass_find_inode+0x1fc>
33d1fdd0:	ebffdc7c 	bl	33d16fc8 <printf>
			}
			inode = jDir->ino;
33d1fdd4:	e5d40015 	ldrb	r0, [r4, #21]
			version = jDir->version;
33d1fdd8:	e5d41011 	ldrb	r1, [r4, #17]
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
				putnstr(jDir->name, jDir->nsize);
				putLabeledWord(" has dup version =", version);
			}
			inode = jDir->ino;
33d1fddc:	e5d42014 	ldrb	r2, [r4, #20]
			version = jDir->version;
33d1fde0:	e5d43010 	ldrb	r3, [r4, #16]
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
				putnstr(jDir->name, jDir->nsize);
				putLabeledWord(" has dup version =", version);
			}
			inode = jDir->ino;
33d1fde4:	e5d4c016 	ldrb	ip, [r4, #22]
			version = jDir->version;
33d1fde8:	e5d4e012 	ldrb	lr, [r4, #18]
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
				putnstr(jDir->name, jDir->nsize);
				putLabeledWord(" has dup version =", version);
			}
			inode = jDir->ino;
33d1fdec:	e1822400 	orr	r2, r2, r0, lsl #8
			version = jDir->version;
33d1fdf0:	e1833401 	orr	r3, r3, r1, lsl #8
33d1fdf4:	e5d40013 	ldrb	r0, [r4, #19]
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
				putnstr(jDir->name, jDir->nsize);
				putLabeledWord(" has dup version =", version);
			}
			inode = jDir->ino;
33d1fdf8:	e5d41017 	ldrb	r1, [r4, #23]
33d1fdfc:	e182280c 	orr	r2, r2, ip, lsl #16
			version = jDir->version;
33d1fe00:	e183380e 	orr	r3, r3, lr, lsl #16
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
				putnstr(jDir->name, jDir->nsize);
				putLabeledWord(" has dup version =", version);
			}
			inode = jDir->ino;
33d1fe04:	e1827c01 	orr	r7, r2, r1, lsl #24
			version = jDir->version;
33d1fe08:	e1839c00 	orr	r9, r3, r0, lsl #24
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d1fe0c:	e59a3000 	ldr	r3, [sl]
33d1fe10:	e5933020 	ldr	r3, [r3, #32]
33d1fe14:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d1fe18:	e5d33008 	ldrb	r3, [r3, #8]
33d1fe1c:	e3530002 	cmp	r3, #2	; 0x2
33d1fe20:	01a00004 	moveq	r0, r4
33d1fe24:	0bfffe75 	bleq	33d1f800 <put_fl_mem_nand>
	/* name is assumed slash free */
	len = strlen(name);

	counter = 0;
	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next, counter++) {
33d1fe28:	e5966004 	ldr	r6, [r6, #4]
33d1fe2c:	e3560000 	cmp	r6, #0	; 0x0
33d1fe30:	eaffff96 	b	33d1fc90 <jffs2_1pass_find_inode+0x30>
		putLabeledWord("counter = ", counter);
#endif
		put_fl_mem(jDir);
	}
	return inode;
}
33d1fe34:	e1a00007 	mov	r0, r7
33d1fe38:	e28dd008 	add	sp, sp, #8	; 0x8
33d1fe3c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d1fe40:	33d6264c 	.word	0x33d6264c
33d1fe44:	33d62554 	.word	0x33d62554
33d1fe48:	33d2d530 	.word	0x33d2d530
33d1fe4c:	33d2c2fc 	.word	0x33d2c2fc
33d1fe50:	33d2d594 	.word	0x33d2d594
33d1fe54:	33d2d33c 	.word	0x33d2d33c
33d1fe58:	33d2d568 	.word	0x33d2d568
33d1fe5c:	33d2d5a4 	.word	0x33d2d5a4

33d1fe60 <mkmodestr>:
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1fe60:	e2003a0f 	and	r3, r0, #61440	; 0xf000
33d1fe64:	e3530a06 	cmp	r3, #24576	; 0x6000
	}
	return inode;
}

char *mkmodestr(unsigned long mode, char *str)
{
33d1fe68:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
		case S_IFDIR:    str[0] = 'd'; break;
		case S_IFBLK:    str[0] = 'b'; break;
33d1fe6c:	03a03062 	moveq	r3, #98	; 0x62
	}
	return inode;
}

char *mkmodestr(unsigned long mode, char *str)
{
33d1fe70:	e1a05000 	mov	r5, r0
33d1fe74:	e1a04001 	mov	r4, r1
	static const char *l = "xwr";
	int mask = 1, i;
33d1fe78:	e3a07001 	mov	r7, #1	; 0x1
	char c;

	switch (mode & S_IFMT) {
33d1fe7c:	0a000018 	beq	33d1fee4 <mkmodestr+0x84>
33d1fe80:	8a00000b 	bhi	33d1feb4 <mkmodestr+0x54>
33d1fe84:	e3530a02 	cmp	r3, #8192	; 0x2000
		case S_IFDIR:    str[0] = 'd'; break;
		case S_IFBLK:    str[0] = 'b'; break;
		case S_IFCHR:    str[0] = 'c'; break;
33d1fe88:	03a03063 	moveq	r3, #99	; 0x63
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1fe8c:	0a000014 	beq	33d1fee4 <mkmodestr+0x84>
33d1fe90:	8a000003 	bhi	33d1fea4 <mkmodestr+0x44>
33d1fe94:	e3530a01 	cmp	r3, #4096	; 0x1000
		case S_IFDIR:    str[0] = 'd'; break;
		case S_IFBLK:    str[0] = 'b'; break;
		case S_IFCHR:    str[0] = 'c'; break;
		case S_IFIFO:    str[0] = 'f'; break;
33d1fe98:	03a03066 	moveq	r3, #102	; 0x66
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1fe9c:	0a000010 	beq	33d1fee4 <mkmodestr+0x84>
33d1fea0:	ea00000e 	b	33d1fee0 <mkmodestr+0x80>
33d1fea4:	e3530901 	cmp	r3, #16384	; 0x4000
		case S_IFDIR:    str[0] = 'd'; break;
33d1fea8:	03a03064 	moveq	r3, #100	; 0x64
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1feac:	0a00000c 	beq	33d1fee4 <mkmodestr+0x84>
33d1feb0:	ea00000a 	b	33d1fee0 <mkmodestr+0x80>
33d1feb4:	e3530a0a 	cmp	r3, #40960	; 0xa000
		case S_IFDIR:    str[0] = 'd'; break;
		case S_IFBLK:    str[0] = 'b'; break;
		case S_IFCHR:    str[0] = 'c'; break;
		case S_IFIFO:    str[0] = 'f'; break;
		case S_IFLNK:    str[0] = 'l'; break;
33d1feb8:	03a0306c 	moveq	r3, #108	; 0x6c
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1febc:	0a000008 	beq	33d1fee4 <mkmodestr+0x84>
33d1fec0:	8a000003 	bhi	33d1fed4 <mkmodestr+0x74>
33d1fec4:	e3530902 	cmp	r3, #32768	; 0x8000
		case S_IFBLK:    str[0] = 'b'; break;
		case S_IFCHR:    str[0] = 'c'; break;
		case S_IFIFO:    str[0] = 'f'; break;
		case S_IFLNK:    str[0] = 'l'; break;
		case S_IFSOCK:   str[0] = 's'; break;
		case S_IFREG:    str[0] = '-'; break;
33d1fec8:	03a0302d 	moveq	r3, #45	; 0x2d
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1fecc:	0a000004 	beq	33d1fee4 <mkmodestr+0x84>
33d1fed0:	ea000002 	b	33d1fee0 <mkmodestr+0x80>
33d1fed4:	e3530903 	cmp	r3, #49152	; 0xc000
		case S_IFDIR:    str[0] = 'd'; break;
		case S_IFBLK:    str[0] = 'b'; break;
		case S_IFCHR:    str[0] = 'c'; break;
		case S_IFIFO:    str[0] = 'f'; break;
		case S_IFLNK:    str[0] = 'l'; break;
		case S_IFSOCK:   str[0] = 's'; break;
33d1fed8:	03a03073 	moveq	r3, #115	; 0x73
{
	static const char *l = "xwr";
	int mask = 1, i;
	char c;

	switch (mode & S_IFMT) {
33d1fedc:	0a000000 	beq	33d1fee4 <mkmodestr+0x84>
		case S_IFCHR:    str[0] = 'c'; break;
		case S_IFIFO:    str[0] = 'f'; break;
		case S_IFLNK:    str[0] = 'l'; break;
		case S_IFSOCK:   str[0] = 's'; break;
		case S_IFREG:    str[0] = '-'; break;
		default:         str[0] = '?';
33d1fee0:	e3a0303f 	mov	r3, #63	; 0x3f
33d1fee4:	e5c43000 	strb	r3, [r4]
	}

	for(i = 0; i < 9; i++) {
33d1fee8:	e3a06000 	mov	r6, #0	; 0x0
		c = l[i%3];
33d1feec:	e1a00006 	mov	r0, r6
33d1fef0:	e3a01003 	mov	r1, #3	; 0x3
33d1fef4:	ebfffa29 	bl	33d1e7a0 <__modsi3>
33d1fef8:	e59f307c 	ldr	r3, [pc, #124]	; 33d1ff7c <mkmodestr+0x11c>
33d1fefc:	e5933000 	ldr	r3, [r3]
		str[9-i] = (mode & mask)?c:'-';
33d1ff00:	e1150007 	tst	r5, r7
		case S_IFREG:    str[0] = '-'; break;
		default:         str[0] = '?';
	}

	for(i = 0; i < 9; i++) {
		c = l[i%3];
33d1ff04:	e7d33000 	ldrb	r3, [r3, r0]
		str[9-i] = (mode & mask)?c:'-';
33d1ff08:	e0662004 	rsb	r2, r6, r4
		case S_IFSOCK:   str[0] = 's'; break;
		case S_IFREG:    str[0] = '-'; break;
		default:         str[0] = '?';
	}

	for(i = 0; i < 9; i++) {
33d1ff0c:	e2866001 	add	r6, r6, #1	; 0x1
		c = l[i%3];
		str[9-i] = (mode & mask)?c:'-';
33d1ff10:	03a0302d 	moveq	r3, #45	; 0x2d
		case S_IFSOCK:   str[0] = 's'; break;
		case S_IFREG:    str[0] = '-'; break;
		default:         str[0] = '?';
	}

	for(i = 0; i < 9; i++) {
33d1ff14:	e3560008 	cmp	r6, #8	; 0x8
		c = l[i%3];
		str[9-i] = (mode & mask)?c:'-';
33d1ff18:	e5c23009 	strb	r3, [r2, #9]
		mask = mask<<1;
33d1ff1c:	e1a07087 	lsl	r7, r7, #1
		case S_IFSOCK:   str[0] = 's'; break;
		case S_IFREG:    str[0] = '-'; break;
		default:         str[0] = '?';
	}

	for(i = 0; i < 9; i++) {
33d1ff20:	dafffff1 	ble	33d1feec <mkmodestr+0x8c>
		c = l[i%3];
		str[9-i] = (mode & mask)?c:'-';
		mask = mask<<1;
	}

	if(mode & S_ISUID) str[3] = (mode & S_IXUSR)?'s':'S';
33d1ff24:	e3150b02 	tst	r5, #2048	; 0x800
33d1ff28:	0a000003 	beq	33d1ff3c <mkmodestr+0xdc>
33d1ff2c:	e3150040 	tst	r5, #64	; 0x40
33d1ff30:	13a03073 	movne	r3, #115	; 0x73
33d1ff34:	03a03053 	moveq	r3, #83	; 0x53
33d1ff38:	e5c43003 	strb	r3, [r4, #3]
	if(mode & S_ISGID) str[6] = (mode & S_IXGRP)?'s':'S';
33d1ff3c:	e3150b01 	tst	r5, #1024	; 0x400
33d1ff40:	0a000003 	beq	33d1ff54 <mkmodestr+0xf4>
33d1ff44:	e3150008 	tst	r5, #8	; 0x8
33d1ff48:	13a03073 	movne	r3, #115	; 0x73
33d1ff4c:	03a03053 	moveq	r3, #83	; 0x53
33d1ff50:	e5c43006 	strb	r3, [r4, #6]
	if(mode & S_ISVTX) str[9] = (mode & S_IXOTH)?'t':'T';
33d1ff54:	e3150c02 	tst	r5, #512	; 0x200
33d1ff58:	0a000003 	beq	33d1ff6c <mkmodestr+0x10c>
33d1ff5c:	e3150001 	tst	r5, #1	; 0x1
33d1ff60:	13a03074 	movne	r3, #116	; 0x74
33d1ff64:	03a03054 	moveq	r3, #84	; 0x54
33d1ff68:	e5c43009 	strb	r3, [r4, #9]
	str[10] = '\0';
33d1ff6c:	e3a03000 	mov	r3, #0	; 0x0
	return str;
}
33d1ff70:	e1a00004 	mov	r0, r4
	}

	if(mode & S_ISUID) str[3] = (mode & S_IXUSR)?'s':'S';
	if(mode & S_ISGID) str[6] = (mode & S_IXGRP)?'s':'S';
	if(mode & S_ISVTX) str[9] = (mode & S_IXOTH)?'t':'T';
	str[10] = '\0';
33d1ff74:	e5c4300a 	strb	r3, [r4, #10]
	return str;
}
33d1ff78:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d1ff7c:	33d36940 	.word	0x33d36940

33d1ff80 <jffs2_1pass_search_inode>:
	return pino;
}

static u32
jffs2_1pass_search_inode(struct b_lists * pL, const char *fname, u32 pino)
{
33d1ff80:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	char *c;

	/* discard any leading slash */
	i = 0;
	while (fname[i] == '/')
		i++;
33d1ff84:	e5d13000 	ldrb	r3, [r1]
	return pino;
}

static u32
jffs2_1pass_search_inode(struct b_lists * pL, const char *fname, u32 pino)
{
33d1ff88:	e24ddf81 	sub	sp, sp, #516	; 0x204
33d1ff8c:	e58d0000 	str	r0, [sp]
	char *c;

	/* discard any leading slash */
	i = 0;
	while (fname[i] == '/')
		i++;
33d1ff90:	e353002f 	cmp	r3, #47	; 0x2f
	return pino;
}

static u32
jffs2_1pass_search_inode(struct b_lists * pL, const char *fname, u32 pino)
{
33d1ff94:	e1a05002 	mov	r5, r2
	char tmp[256];
	char working_tmp[256];
	char *c;

	/* discard any leading slash */
	i = 0;
33d1ff98:	e3a04000 	mov	r4, #0	; 0x0
	while (fname[i] == '/')
		i++;
33d1ff9c:	1a000003 	bne	33d1ffb0 <jffs2_1pass_search_inode+0x30>
33d1ffa0:	e2844001 	add	r4, r4, #1	; 0x1
33d1ffa4:	e7d13004 	ldrb	r3, [r1, r4]
33d1ffa8:	e353002f 	cmp	r3, #47	; 0x2f
33d1ffac:	eafffffa 	b	33d1ff9c <jffs2_1pass_search_inode+0x1c>
	strcpy(tmp, &fname[i]);
33d1ffb0:	e28daf41 	add	sl, sp, #260	; 0x104
33d1ffb4:	e0811004 	add	r1, r1, r4
33d1ffb8:	e1a0000a 	mov	r0, sl
33d1ffbc:	ebffe7fe 	bl	33d19fbc <strcpy>

	while ((c = (char *) strchr(tmp, '/')))	/* we are still dired searching */
33d1ffc0:	ea000021 	b	33d2004c <jffs2_1pass_search_inode+0xcc>
	{
		strncpy(working_tmp, tmp, c - tmp);
33d1ffc4:	e06a4006 	rsb	r4, sl, r6
33d1ffc8:	e28d9004 	add	r9, sp, #4	; 0x4
33d1ffcc:	e1a02004 	mov	r2, r4
33d1ffd0:	e1a00009 	mov	r0, r9
33d1ffd4:	e1a0100a 	mov	r1, sl
33d1ffd8:	ebffe7fe 	bl	33d19fd8 <strncpy>
		working_tmp[c - tmp] = '\0';
33d1ffdc:	e28d2f81 	add	r2, sp, #516	; 0x204
33d1ffe0:	e0823004 	add	r3, r2, r4
33d1ffe4:	e2433c02 	sub	r3, r3, #512	; 0x200
33d1ffe8:	e3a02000 	mov	r2, #0	; 0x0
33d1ffec:	e5c32000 	strb	r2, [r3]
		putstr("\r\n");
		putstr("search_inode: c = ");
		putstr(c);
		putstr("\r\n");
#endif
		for (i = 0; i < strlen(c) - 1; i++)
33d1fff0:	e1a04002 	mov	r4, r2
33d1fff4:	e1a0b00a 	mov	fp, sl
33d1fff8:	e28d7f81 	add	r7, sp, #516	; 0x204
33d1fffc:	ea000002 	b	33d2000c <jffs2_1pass_search_inode+0x8c>
			tmp[i] = c[i + 1];
33d20000:	e5d33001 	ldrb	r3, [r3, #1]
33d20004:	e4cb3001 	strb	r3, [fp], #1
33d20008:	e2877001 	add	r7, r7, #1	; 0x1
		putstr("\r\n");
		putstr("search_inode: c = ");
		putstr(c);
		putstr("\r\n");
#endif
		for (i = 0; i < strlen(c) - 1; i++)
33d2000c:	e1a00006 	mov	r0, r6
33d20010:	ebffe83e 	bl	33d1a110 <strlen>
33d20014:	e2400001 	sub	r0, r0, #1	; 0x1
33d20018:	e1540000 	cmp	r4, r0
			tmp[i] = c[i + 1];
33d2001c:	e0863004 	add	r3, r6, r4
		putstr("\r\n");
		putstr("search_inode: c = ");
		putstr(c);
		putstr("\r\n");
#endif
		for (i = 0; i < strlen(c) - 1; i++)
33d20020:	e2844001 	add	r4, r4, #1	; 0x1
33d20024:	3afffff5 	bcc	33d20000 <jffs2_1pass_search_inode+0x80>
			tmp[i] = c[i + 1];
		tmp[i] = '\0';
33d20028:	e247cc01 	sub	ip, r7, #256	; 0x100
33d2002c:	e3a03000 	mov	r3, #0	; 0x0
		putstr("search_inode: post tmp = ");
		putstr(tmp);
		putstr("\r\n");
#endif

		if (!(pino = jffs2_1pass_find_inode(pL, working_tmp, pino))) {
33d20030:	e1a02005 	mov	r2, r5
33d20034:	e59d0000 	ldr	r0, [sp]
33d20038:	e1a01009 	mov	r1, r9
		putstr(c);
		putstr("\r\n");
#endif
		for (i = 0; i < strlen(c) - 1; i++)
			tmp[i] = c[i + 1];
		tmp[i] = '\0';
33d2003c:	e5cc3000 	strb	r3, [ip]
		putstr("search_inode: post tmp = ");
		putstr(tmp);
		putstr("\r\n");
#endif

		if (!(pino = jffs2_1pass_find_inode(pL, working_tmp, pino))) {
33d20040:	ebffff06 	bl	33d1fc60 <jffs2_1pass_find_inode>
33d20044:	e2505000 	subs	r5, r0, #0	; 0x0
33d20048:	0a00000f 	beq	33d2008c <jffs2_1pass_search_inode+0x10c>
			putstr("find_inode failed for name=");
			putstr(working_tmp);
			putstr("\r\n");
			return 0;
33d2004c:	e1a0000a 	mov	r0, sl
33d20050:	e3a0102f 	mov	r1, #47	; 0x2f
33d20054:	ebffe821 	bl	33d1a0e0 <strchr>
33d20058:	e2506000 	subs	r6, r0, #0	; 0x0
33d2005c:	1affffd8 	bne	33d1ffc4 <jffs2_1pass_search_inode+0x44>
		}
	}
	/* this is for the bare filename, directories have already been mapped */
	if (!(pino = jffs2_1pass_find_inode(pL, tmp, pino))) {
33d20060:	e1a02005 	mov	r2, r5
33d20064:	e59d0000 	ldr	r0, [sp]
33d20068:	e1a0100a 	mov	r1, sl
33d2006c:	ebfffefb 	bl	33d1fc60 <jffs2_1pass_find_inode>
33d20070:	e2505000 	subs	r5, r0, #0	; 0x0
33d20074:	1a00000d 	bne	33d200b0 <jffs2_1pass_search_inode+0x130>
		putstr("find_inode failed for name=");
33d20078:	e59f103c 	ldr	r1, [pc, #60]	; 33d200bc <jffs2_1pass_search_inode+0x13c>
33d2007c:	e59f003c 	ldr	r0, [pc, #60]	; 33d200c0 <jffs2_1pass_search_inode+0x140>
33d20080:	ebffdbd0 	bl	33d16fc8 <printf>
		putstr(tmp);
33d20084:	e1a0100a 	mov	r1, sl
33d20088:	ea000003 	b	33d2009c <jffs2_1pass_search_inode+0x11c>
		putstr(tmp);
		putstr("\r\n");
#endif

		if (!(pino = jffs2_1pass_find_inode(pL, working_tmp, pino))) {
			putstr("find_inode failed for name=");
33d2008c:	e59f1028 	ldr	r1, [pc, #40]	; 33d200bc <jffs2_1pass_search_inode+0x13c>
33d20090:	e59f0028 	ldr	r0, [pc, #40]	; 33d200c0 <jffs2_1pass_search_inode+0x140>
33d20094:	ebffdbcb 	bl	33d16fc8 <printf>
			putstr(working_tmp);
33d20098:	e1a01009 	mov	r1, r9
33d2009c:	e59f001c 	ldr	r0, [pc, #28]	; 33d200c0 <jffs2_1pass_search_inode+0x140>
33d200a0:	ebffdbc8 	bl	33d16fc8 <printf>
			putstr("\r\n");
33d200a4:	e59f0014 	ldr	r0, [pc, #20]	; 33d200c0 <jffs2_1pass_search_inode+0x140>
33d200a8:	e59f1014 	ldr	r1, [pc, #20]	; 33d200c4 <jffs2_1pass_search_inode+0x144>
33d200ac:	ebffdbc5 	bl	33d16fc8 <printf>
		putstr("find_inode failed for name=");
		putstr(tmp);
		putstr("\r\n");
		return 0;
	}
	return pino;
33d200b0:	e1a00005 	mov	r0, r5

}
33d200b4:	e28ddf81 	add	sp, sp, #516	; 0x204
33d200b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d200bc:	33d2d5bc 	.word	0x33d2d5bc
33d200c0:	33d2c2fc 	.word	0x33d2c2fc
33d200c4:	33d2bbb8 	.word	0x33d2bbb8

33d200c8 <jffs2_1pass_rescan_needed>:

}

unsigned char
jffs2_1pass_rescan_needed(struct part_info *part)
{
33d200c8:	e92d4030 	push	{r4, r5, lr}
	struct b_node *b;
	struct jffs2_unknown_node onode;
	struct jffs2_unknown_node *node;
	struct b_lists *pL = (struct b_lists *)part->jffs2_priv;
33d200cc:	e5902018 	ldr	r2, [r0, #24]

	if (part->jffs2_priv == 0){
33d200d0:	e3520000 	cmp	r2, #0	; 0x0

}

unsigned char
jffs2_1pass_rescan_needed(struct part_info *part)
{
33d200d4:	e24dd00c 	sub	sp, sp, #12	; 0xc
	struct b_node *b;
	struct jffs2_unknown_node onode;
	struct jffs2_unknown_node *node;
	struct b_lists *pL = (struct b_lists *)part->jffs2_priv;

	if (part->jffs2_priv == 0){
33d200d8:	0a000003 	beq	33d200ec <jffs2_1pass_rescan_needed+0x24>
		DEBUGF ("rescan: First time in use\n");
		return 1;
	}

	/* if we have no list, we need to rescan */
	if (pL->frag.listCount == 0) {
33d200dc:	e5923018 	ldr	r3, [r2, #24]
33d200e0:	e3530000 	cmp	r3, #0	; 0x0
		DEBUGF ("rescan: fraglist zero\n");
		return 1;
	}

	/* but suppose someone reflashed a partition at the same offset... */
	b = pL->dir.listHead;
33d200e4:	15925004 	ldrne	r5, [r2, #4]
		DEBUGF ("rescan: First time in use\n");
		return 1;
	}

	/* if we have no list, we need to rescan */
	if (pL->frag.listCount == 0) {
33d200e8:	1a000001 	bne	33d200f4 <jffs2_1pass_rescan_needed+0x2c>
		node = (struct jffs2_unknown_node *) get_fl_mem(b->offset,
			sizeof(onode), &onode);
		if (node->nodetype != JFFS2_NODETYPE_DIRENT) {
			DEBUGF ("rescan: fs changed beneath me? (%lx)\n",
					(unsigned long) b->offset);
			return 1;
33d200ec:	e3a00001 	mov	r0, #1	; 0x1
33d200f0:	ea000024 	b	33d20188 <jffs2_1pass_rescan_needed+0xc0>
		}
		b = b->next;
33d200f4:	e3550000 	cmp	r5, #0	; 0x0
33d200f8:	0a000021 	beq	33d20184 <jffs2_1pass_rescan_needed+0xbc>
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;
33d200fc:	e59f308c 	ldr	r3, [pc, #140]	; 33d20190 <jffs2_1pass_rescan_needed+0xc8>
33d20100:	e5933000 	ldr	r3, [r3]
33d20104:	e5933020 	ldr	r3, [r3, #32]
33d20108:	e5933008 	ldr	r3, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2010c:	e5d3c008 	ldrb	ip, [r3, #8]
33d20110:	e35c0001 	cmp	ip, #1	; 0x1
/*
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
33d20114:	e5954000 	ldr	r4, [r5]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20118:	1a000007 	bne	33d2013c <jffs2_1pass_rescan_needed+0x74>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d2011c:	e5d33009 	ldrb	r3, [r3, #9]
33d20120:	e59f206c 	ldr	r2, [pc, #108]	; 33d20194 <jffs2_1pass_rescan_needed+0xcc>
33d20124:	e0833083 	add	r3, r3, r3, lsl #1
33d20128:	e0833183 	add	r3, r3, r3, lsl #3
33d2012c:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d20130:	e592300c 	ldr	r3, [r2, #12]
33d20134:	e0840003 	add	r0, r4, r3
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20138:	ea000009 	b	33d20164 <jffs2_1pass_rescan_needed+0x9c>
		return get_fl_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d2013c:	e35c0002 	cmp	ip, #2	; 0x2
33d20140:	e1a00004 	mov	r0, r4
33d20144:	e1a0200d 	mov	r2, sp
33d20148:	e3a0100c 	mov	r1, #12	; 0xc
33d2014c:	1a000001 	bne	33d20158 <jffs2_1pass_rescan_needed+0x90>
33d20150:	ebfffd1b 	bl	33d1f5c4 <get_fl_mem_nand>
33d20154:	ea000002 	b	33d20164 <jffs2_1pass_rescan_needed+0x9c>
		return get_fl_mem_nand(off, size, ext_buf);
#endif

	printf("get_fl_mem: unknown device type, using raw offset!\n");
33d20158:	e59f0038 	ldr	r0, [pc, #56]	; 33d20198 <jffs2_1pass_rescan_needed+0xd0>
33d2015c:	ebffdb99 	bl	33d16fc8 <printf>
33d20160:	e1a00004 	mov	r0, r4
	/* but suppose someone reflashed a partition at the same offset... */
	b = pL->dir.listHead;
	while (b) {
		node = (struct jffs2_unknown_node *) get_fl_mem(b->offset,
			sizeof(onode), &onode);
		if (node->nodetype != JFFS2_NODETYPE_DIRENT) {
33d20164:	e5d03003 	ldrb	r3, [r0, #3]
33d20168:	e5d02002 	ldrb	r2, [r0, #2]
33d2016c:	e1822403 	orr	r2, r2, r3, lsl #8
33d20170:	e59f3024 	ldr	r3, [pc, #36]	; 33d2019c <jffs2_1pass_rescan_needed+0xd4>
33d20174:	e1520003 	cmp	r2, r3
33d20178:	1affffdb 	bne	33d200ec <jffs2_1pass_rescan_needed+0x24>
			DEBUGF ("rescan: fs changed beneath me? (%lx)\n",
					(unsigned long) b->offset);
			return 1;
		}
		b = b->next;
33d2017c:	e5955004 	ldr	r5, [r5, #4]
33d20180:	eaffffdb 	b	33d200f4 <jffs2_1pass_rescan_needed+0x2c>
	}
	return 0;
33d20184:	e3a00000 	mov	r0, #0	; 0x0
}
33d20188:	e28dd00c 	add	sp, sp, #12	; 0xc
33d2018c:	e8bd8030 	pop	{r4, r5, pc}
33d20190:	33d6264c 	.word	0x33d6264c
33d20194:	33d62554 	.word	0x33d62554
33d20198:	33d2d5d8 	.word	0x33d2d5d8
33d2019c:	0000e001 	.word	0x0000e001

33d201a0 <jffs2_get_list>:
}


static struct b_lists *
jffs2_get_list(struct part_info * part, const char *who)
{
33d201a0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	/* copy requested part_info struct pointer to global location */
	current_part = part;
33d201a4:	e59f34f0 	ldr	r3, [pc, #1264]	; 33d2069c <jffs2_get_list+0x4fc>
}


static struct b_lists *
jffs2_get_list(struct part_info * part, const char *who)
{
33d201a8:	e24dd014 	sub	sp, sp, #20	; 0x14
	/* copy requested part_info struct pointer to global location */
	current_part = part;
33d201ac:	e5830000 	str	r0, [r3]
}


static struct b_lists *
jffs2_get_list(struct part_info * part, const char *who)
{
33d201b0:	e1a06000 	mov	r6, r0
33d201b4:	e58d100c 	str	r1, [sp, #12]
	/* copy requested part_info struct pointer to global location */
	current_part = part;

	if (jffs2_1pass_rescan_needed(part)) {
33d201b8:	ebffffc2 	bl	33d200c8 <jffs2_1pass_rescan_needed>
33d201bc:	e31000ff 	tst	r0, #255	; 0xff
33d201c0:	0a000132 	beq	33d20690 <jffs2_get_list+0x4f0>
jffs2_1pass_build_lists(struct part_info * part)
{
	struct b_lists *pL;
	struct jffs2_unknown_node *node;
	u32 offset, oldoffset = 0;
	u32 max = part->size - sizeof(struct jffs2_raw_inode);
33d201c4:	e5963010 	ldr	r3, [r6, #16]
static u32
jffs_init_1pass_list(struct part_info *part)
{
	struct b_lists *pL;

	jffs2_free_cache(part);
33d201c8:	e1a00006 	mov	r0, r6
jffs2_1pass_build_lists(struct part_info * part)
{
	struct b_lists *pL;
	struct jffs2_unknown_node *node;
	u32 offset, oldoffset = 0;
	u32 max = part->size - sizeof(struct jffs2_raw_inode);
33d201cc:	e2433044 	sub	r3, r3, #68	; 0x44
33d201d0:	e58d3004 	str	r3, [sp, #4]
static u32
jffs_init_1pass_list(struct part_info *part)
{
	struct b_lists *pL;

	jffs2_free_cache(part);
33d201d4:	ebfffdcc 	bl	33d1f90c <jffs2_free_cache>

	if (NULL != (part->jffs2_priv = malloc(sizeof(struct b_lists)))) {
33d201d8:	e3a00020 	mov	r0, #32	; 0x20
33d201dc:	ebffdd21 	bl	33d17668 <malloc>
static u32
jffs2_1pass_build_lists(struct part_info * part)
{
	struct b_lists *pL;
	struct jffs2_unknown_node *node;
	u32 offset, oldoffset = 0;
33d201e0:	e3a09000 	mov	r9, #0	; 0x0
{
	struct b_lists *pL;

	jffs2_free_cache(part);

	if (NULL != (part->jffs2_priv = malloc(sizeof(struct b_lists)))) {
33d201e4:	e1500009 	cmp	r0, r9
33d201e8:	e5860018 	str	r0, [r6, #24]
	struct b_lists *pL;
	struct jffs2_unknown_node *node;
	u32 offset, oldoffset = 0;
	u32 max = part->size - sizeof(struct jffs2_raw_inode);
	u32 counter = 0;
	u32 counter4 = 0;
33d201ec:	e1a04009 	mov	r4, r9
{
	struct b_lists *pL;
	struct jffs2_unknown_node *node;
	u32 offset, oldoffset = 0;
	u32 max = part->size - sizeof(struct jffs2_raw_inode);
	u32 counter = 0;
33d201f0:	e1a0b009 	mov	fp, r9
	u32 counter4 = 0;
	u32 counterF = 0;
	u32 counterN = 0;
33d201f4:	e58d9000 	str	r9, [sp]
	jffs2_free_cache(part);

	if (NULL != (part->jffs2_priv = malloc(sizeof(struct b_lists)))) {
		pL = (struct b_lists *)part->jffs2_priv;

		memset(pL, 0, sizeof(*pL));
33d201f8:	11a01009 	movne	r1, r9
33d201fc:	13a02020 	movne	r2, #32	; 0x20
33d20200:	1bffe863 	blne	33d1a394 <memset>
	/* only about 5 %.  not enough to inconvenience people for. */
	/* lcd_off(); */

	/* if we are building a list we need to refresh the cache. */
	jffs_init_1pass_list(part);
	pL = (struct b_lists *)part->jffs2_priv;
33d20204:	e5963018 	ldr	r3, [r6, #24]
	offset = 0;
	puts ("Scanning JFFS2 FS:   ");
33d20208:	e59f0490 	ldr	r0, [pc, #1168]	; 33d206a0 <jffs2_get_list+0x500>
	/* lcd_off(); */

	/* if we are building a list we need to refresh the cache. */
	jffs_init_1pass_list(part);
	pL = (struct b_lists *)part->jffs2_priv;
	offset = 0;
33d2020c:	e1a07004 	mov	r7, r4
	/* only about 5 %.  not enough to inconvenience people for. */
	/* lcd_off(); */

	/* if we are building a list we need to refresh the cache. */
	jffs_init_1pass_list(part);
	pL = (struct b_lists *)part->jffs2_priv;
33d20210:	e58d3008 	str	r3, [sp, #8]
	offset = 0;
	puts ("Scanning JFFS2 FS:   ");
33d20214:	ebffdb64 	bl	33d16fac <puts>
static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;

	if (id->type == MTD_DEV_TYPE_NAND)
33d20218:	e59d3004 	ldr	r3, [sp, #4]
33d2021c:	e1570003 	cmp	r7, r3
33d20220:	2a000111 	bcs	33d2066c <jffs2_get_list+0x4cc>
	offset = 0;
	puts ("Scanning JFFS2 FS:   ");

	/* start at the beginning of the partition */
	while (offset < max) {
	    	if ((oldoffset >> SPIN_BLKSIZE) != (offset >> SPIN_BLKSIZE)) {
33d20224:	e1a03927 	lsr	r3, r7, #18
33d20228:	e1530929 	cmp	r3, r9, lsr #18
33d2022c:	0a000006 	beq	33d2024c <jffs2_get_list+0xac>
			printf("\b\b%c ", spinner[counter++ % sizeof(spinner)]);
33d20230:	e59f346c 	ldr	r3, [pc, #1132]	; 33d206a4 <jffs2_get_list+0x504>
33d20234:	e20b2003 	and	r2, fp, #3	; 0x3
33d20238:	e7d31002 	ldrb	r1, [r3, r2]
33d2023c:	e59f0464 	ldr	r0, [pc, #1124]	; 33d206a8 <jffs2_get_list+0x508>
33d20240:	ebffdb60 	bl	33d16fc8 <printf>
33d20244:	e28bb001 	add	fp, fp, #1	; 0x1
			oldoffset = offset;
33d20248:	e1a09007 	mov	r9, r7
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d2024c:	e59fa448 	ldr	sl, [pc, #1096]	; 33d2069c <jffs2_get_list+0x4fc>
33d20250:	e59a3000 	ldr	r3, [sl]
33d20254:	e5933020 	ldr	r3, [r3, #32]
33d20258:	e5931008 	ldr	r1, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2025c:	e5d12008 	ldrb	r2, [r1, #8]
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d20260:	e5963014 	ldr	r3, [r6, #20]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20264:	e3520001 	cmp	r2, #1	; 0x1
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d20268:	e0834007 	add	r4, r3, r7
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2026c:	1a000007 	bne	33d20290 <jffs2_get_list+0xf0>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d20270:	e5d13009 	ldrb	r3, [r1, #9]
33d20274:	e59f2430 	ldr	r2, [pc, #1072]	; 33d206ac <jffs2_get_list+0x50c>
33d20278:	e0833083 	add	r3, r3, r3, lsl #1
33d2027c:	e0833183 	add	r3, r3, r3, lsl #3
33d20280:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d20284:	e592300c 	ldr	r3, [r2, #12]
33d20288:	e0845003 	add	r5, r4, r3
static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2028c:	ea000008 	b	33d202b4 <jffs2_get_list+0x114>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20290:	e3520002 	cmp	r2, #2	; 0x2
33d20294:	1a000003 	bne	33d202a8 <jffs2_get_list+0x108>
33d20298:	e1a00004 	mov	r0, r4
33d2029c:	ebfffd38 	bl	33d1f784 <get_node_mem_nand>
33d202a0:	e1a05000 	mov	r5, r0
33d202a4:	ea000002 	b	33d202b4 <jffs2_get_list+0x114>
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d202a8:	e59f0400 	ldr	r0, [pc, #1024]	; 33d206b0 <jffs2_get_list+0x510>
33d202ac:	ebffdb45 	bl	33d16fc8 <printf>
33d202b0:	e1a05004 	mov	r5, r4
			printf("\b\b%c ", spinner[counter++ % sizeof(spinner)]);
			oldoffset = offset;
		}

		node = (struct jffs2_unknown_node *) get_node_mem((u32)part->offset + offset);
		if (node->magic == JFFS2_MAGIC_BITMASK && hdr_crc(node)) {
33d202b4:	e5d52001 	ldrb	r2, [r5, #1]
33d202b8:	e5d53000 	ldrb	r3, [r5]
33d202bc:	e1833402 	orr	r3, r3, r2, lsl #8
33d202c0:	e59f23ec 	ldr	r2, [pc, #1004]	; 33d206b4 <jffs2_get_list+0x514>
33d202c4:	e1530002 	cmp	r3, r2
33d202c8:	1a0000a5 	bne	33d20564 <jffs2_get_list+0x3c4>

static inline int
hdr_crc(struct jffs2_unknown_node *node)
{
#if 1
	u32 crc = crc32_no_comp(0, (unsigned char *)node, sizeof(struct jffs2_unknown_node) - 4);
33d202cc:	e1a01005 	mov	r1, r5
33d202d0:	e3a02008 	mov	r2, #8	; 0x8
33d202d4:	e3a00000 	mov	r0, #0	; 0x0
33d202d8:	ebffe6cd 	bl	33d19e14 <crc32_no_comp>
	/* what's the semantics of this? why is this here? */
	u32 crc = crc32_no_comp(~0, (unsigned char *)node, sizeof(struct jffs2_unknown_node) - 4);

	crc ^= ~0;
#endif
	if (node->hdr_crc != crc) {
33d202dc:	e5d52009 	ldrb	r2, [r5, #9]
33d202e0:	e5d53008 	ldrb	r3, [r5, #8]
33d202e4:	e5d5100a 	ldrb	r1, [r5, #10]
33d202e8:	e1833402 	orr	r3, r3, r2, lsl #8
33d202ec:	e5d5200b 	ldrb	r2, [r5, #11]
33d202f0:	e1833801 	orr	r3, r3, r1, lsl #16
33d202f4:	e1833c02 	orr	r3, r3, r2, lsl #24
33d202f8:	e1530000 	cmp	r3, r0
33d202fc:	1a000098 	bne	33d20564 <jffs2_get_list+0x3c4>
			/* if its a fragment add it */
			if (node->nodetype == JFFS2_NODETYPE_INODE &&
33d20300:	e5d52003 	ldrb	r2, [r5, #3]
33d20304:	e5d53002 	ldrb	r3, [r5, #2]
33d20308:	e1833402 	orr	r3, r3, r2, lsl #8
33d2030c:	e59f23a4 	ldr	r2, [pc, #932]	; 33d206b8 <jffs2_get_list+0x518>
33d20310:	e1530002 	cmp	r3, r2
33d20314:	1a000027 	bne	33d203b8 <jffs2_get_list+0x218>
}

static inline int
inode_crc(struct jffs2_raw_inode *node)
{
	if (node->node_crc != crc32_no_comp(0, (unsigned char *)node, sizeof(struct jffs2_raw_inode) - 8)) {
33d20318:	e5d53041 	ldrb	r3, [r5, #65]
33d2031c:	e5d54040 	ldrb	r4, [r5, #64]
33d20320:	e5d52042 	ldrb	r2, [r5, #66]
33d20324:	e1844403 	orr	r4, r4, r3, lsl #8
33d20328:	e5d53043 	ldrb	r3, [r5, #67]
33d2032c:	e1844802 	orr	r4, r4, r2, lsl #16
33d20330:	e3a00000 	mov	r0, #0	; 0x0
33d20334:	e1a01005 	mov	r1, r5
33d20338:	e3a0203c 	mov	r2, #60	; 0x3c
33d2033c:	e1844c03 	orr	r4, r4, r3, lsl #24
33d20340:	ebffe6b3 	bl	33d19e14 <crc32_no_comp>
33d20344:	e1540000 	cmp	r4, r0
33d20348:	1a00001a 	bne	33d203b8 <jffs2_get_list+0x218>
}

static inline int
data_crc(struct jffs2_raw_inode *node)
{
	if (node->data_crc != crc32_no_comp(0, (unsigned char *)
33d2034c:	e5d53031 	ldrb	r3, [r5, #49]
33d20350:	e5d52030 	ldrb	r2, [r5, #48]
33d20354:	e5d5103d 	ldrb	r1, [r5, #61]
33d20358:	e5d50032 	ldrb	r0, [r5, #50]
33d2035c:	e5d5403c 	ldrb	r4, [r5, #60]
33d20360:	e1822403 	orr	r2, r2, r3, lsl #8
33d20364:	e5d5c033 	ldrb	ip, [r5, #51]
33d20368:	e5d5303e 	ldrb	r3, [r5, #62]
33d2036c:	e1844401 	orr	r4, r4, r1, lsl #8
33d20370:	e1822800 	orr	r2, r2, r0, lsl #16
33d20374:	e5d5e03f 	ldrb	lr, [r5, #63]
33d20378:	e1844803 	orr	r4, r4, r3, lsl #16
33d2037c:	e1822c0c 	orr	r2, r2, ip, lsl #24
33d20380:	e3a00000 	mov	r0, #0	; 0x0
33d20384:	e2851044 	add	r1, r5, #68	; 0x44
33d20388:	e1844c0e 	orr	r4, r4, lr, lsl #24
33d2038c:	ebffe6a0 	bl	33d19e14 <crc32_no_comp>
33d20390:	e1540000 	cmp	r4, r0
33d20394:	1a000007 	bne	33d203b8 <jffs2_get_list+0x218>
				    inode_crc((struct jffs2_raw_inode *) node) &&
				    data_crc((struct jffs2_raw_inode *) node)) {
				if (insert_node(&pL->frag, (u32) part->offset +
33d20398:	e5961014 	ldr	r1, [r6, #20]
33d2039c:	e59d3008 	ldr	r3, [sp, #8]
33d203a0:	e0811007 	add	r1, r1, r7
33d203a4:	e2830010 	add	r0, r3, #16	; 0x10
33d203a8:	ebfffd21 	bl	33d1f834 <insert_node>
33d203ac:	e2504000 	subs	r4, r0, #0	; 0x0
33d203b0:	1a000060 	bne	33d20538 <jffs2_get_list+0x398>
33d203b4:	ea00002b 	b	33d20468 <jffs2_get_list+0x2c8>
						offset) == NULL) {
					put_fl_mem(node);
					return 0;
				}
			} else if (node->nodetype == JFFS2_NODETYPE_DIRENT &&
33d203b8:	e5d52003 	ldrb	r2, [r5, #3]
33d203bc:	e5d53002 	ldrb	r3, [r5, #2]
33d203c0:	e1833402 	orr	r3, r3, r2, lsl #8
33d203c4:	e59f22f0 	ldr	r2, [pc, #752]	; 33d206bc <jffs2_get_list+0x51c>
33d203c8:	e1530002 	cmp	r3, r2
33d203cc:	1a000032 	bne	33d2049c <jffs2_get_list+0x2fc>
}

static inline int
dirent_crc(struct jffs2_raw_dirent *node)
{
	if (node->node_crc != crc32_no_comp(0, (unsigned char *)node, sizeof(struct jffs2_raw_dirent) - 8)) {
33d203d0:	e5d53021 	ldrb	r3, [r5, #33]
33d203d4:	e5d54020 	ldrb	r4, [r5, #32]
33d203d8:	e5d52022 	ldrb	r2, [r5, #34]
33d203dc:	e1844403 	orr	r4, r4, r3, lsl #8
33d203e0:	e5d53023 	ldrb	r3, [r5, #35]
33d203e4:	e1844802 	orr	r4, r4, r2, lsl #16
33d203e8:	e3a00000 	mov	r0, #0	; 0x0
33d203ec:	e1a01005 	mov	r1, r5
33d203f0:	e3a02020 	mov	r2, #32	; 0x20
33d203f4:	e1844c03 	orr	r4, r4, r3, lsl #24
33d203f8:	ebffe685 	bl	33d19e14 <crc32_no_comp>
33d203fc:	e1540000 	cmp	r4, r0
33d20400:	1a000025 	bne	33d2049c <jffs2_get_list+0x2fc>
}

static inline int
dirent_name_crc(struct jffs2_raw_dirent *node)
{
	if (node->name_crc != crc32_no_comp(0, (unsigned char *)&(node->name), node->nsize)) {
33d20404:	e5d53025 	ldrb	r3, [r5, #37]
33d20408:	e5d54024 	ldrb	r4, [r5, #36]
33d2040c:	e5d52026 	ldrb	r2, [r5, #38]
33d20410:	e1844403 	orr	r4, r4, r3, lsl #8
33d20414:	e5d53027 	ldrb	r3, [r5, #39]
33d20418:	e1844802 	orr	r4, r4, r2, lsl #16
33d2041c:	e3a00000 	mov	r0, #0	; 0x0
33d20420:	e2851028 	add	r1, r5, #40	; 0x28
33d20424:	e5d5201c 	ldrb	r2, [r5, #28]
33d20428:	e1844c03 	orr	r4, r4, r3, lsl #24
33d2042c:	ebffe678 	bl	33d19e14 <crc32_no_comp>
33d20430:	e1540000 	cmp	r4, r0
33d20434:	1a000018 	bne	33d2049c <jffs2_get_list+0x2fc>
				   dirent_crc((struct jffs2_raw_dirent *) node)  &&
				   dirent_name_crc((struct jffs2_raw_dirent *) node)) {
				if (! (counterN%100))
33d20438:	e59d0000 	ldr	r0, [sp]
33d2043c:	e3a01064 	mov	r1, #100	; 0x64
33d20440:	ebfff916 	bl	33d1e8a0 <__umodsi3>
33d20444:	e3500000 	cmp	r0, #0	; 0x0
					puts ("\b\b.  ");
33d20448:	059f0270 	ldreq	r0, [pc, #624]	; 33d206c0 <jffs2_get_list+0x520>
33d2044c:	0bffdad6 	bleq	33d16fac <puts>
				if (insert_node(&pL->dir, (u32) part->offset +
33d20450:	e5961014 	ldr	r1, [r6, #20]
33d20454:	e59d0008 	ldr	r0, [sp, #8]
33d20458:	e0811007 	add	r1, r1, r7
33d2045c:	ebfffcf4 	bl	33d1f834 <insert_node>
33d20460:	e2504000 	subs	r4, r0, #0	; 0x0
33d20464:	1a000008 	bne	33d2048c <jffs2_get_list+0x2ec>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d20468:	e59a3000 	ldr	r3, [sl]
33d2046c:	e5933020 	ldr	r3, [r3, #32]
33d20470:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d20474:	e5d33008 	ldrb	r3, [r3, #8]
33d20478:	e3530002 	cmp	r3, #2	; 0x2
33d2047c:	1a00007e 	bne	33d2067c <jffs2_get_list+0x4dc>
33d20480:	e1a00005 	mov	r0, r5
33d20484:	ebfffcdd 	bl	33d1f800 <put_fl_mem_nand>
				   dirent_name_crc((struct jffs2_raw_dirent *) node)) {
				if (! (counterN%100))
					puts ("\b\b.  ");
				if (insert_node(&pL->dir, (u32) part->offset +
						offset) == NULL) {
					put_fl_mem(node);
33d20488:	ea00007b 	b	33d2067c <jffs2_get_list+0x4dc>
					return 0;
				}
				counterN++;
33d2048c:	e59d3000 	ldr	r3, [sp]
33d20490:	e2833001 	add	r3, r3, #1	; 0x1
33d20494:	e58d3000 	str	r3, [sp]
33d20498:	ea000026 	b	33d20538 <jffs2_get_list+0x398>
			} else if (node->nodetype == JFFS2_NODETYPE_CLEANMARKER) {
33d2049c:	e5d53002 	ldrb	r3, [r5, #2]
33d204a0:	e5d52003 	ldrb	r2, [r5, #3]
33d204a4:	e1831402 	orr	r1, r3, r2, lsl #8
33d204a8:	e59f3214 	ldr	r3, [pc, #532]	; 33d206c4 <jffs2_get_list+0x524>
33d204ac:	e1510003 	cmp	r1, r3
33d204b0:	1a00000a 	bne	33d204e0 <jffs2_get_list+0x340>
				if (node->totlen != sizeof(struct jffs2_unknown_node))
33d204b4:	e5d52005 	ldrb	r2, [r5, #5]
33d204b8:	e5d53004 	ldrb	r3, [r5, #4]
33d204bc:	e5d51006 	ldrb	r1, [r5, #6]
33d204c0:	e1833402 	orr	r3, r3, r2, lsl #8
33d204c4:	e5d52007 	ldrb	r2, [r5, #7]
33d204c8:	e1833801 	orr	r3, r3, r1, lsl #16
33d204cc:	e1831c02 	orr	r1, r3, r2, lsl #24
33d204d0:	e351000c 	cmp	r1, #12	; 0xc
					printf("OOPS Cleanmarker has bad size "
33d204d4:	159f01ec 	ldrne	r0, [pc, #492]	; 33d206c8 <jffs2_get_list+0x528>
					put_fl_mem(node);
					return 0;
				}
				counterN++;
			} else if (node->nodetype == JFFS2_NODETYPE_CLEANMARKER) {
				if (node->totlen != sizeof(struct jffs2_unknown_node))
33d204d8:	1a00000d 	bne	33d20514 <jffs2_get_list+0x374>
33d204dc:	ea000015 	b	33d20538 <jffs2_get_list+0x398>
					printf("OOPS Cleanmarker has bad size "
						"%d != %d\n", node->totlen,
						sizeof(struct jffs2_unknown_node));
			} else if (node->nodetype == JFFS2_NODETYPE_PADDING) {
33d204e0:	e59f31e4 	ldr	r3, [pc, #484]	; 33d206cc <jffs2_get_list+0x52c>
33d204e4:	e1510003 	cmp	r1, r3
33d204e8:	e5d52004 	ldrb	r2, [r5, #4]
33d204ec:	e5d53005 	ldrb	r3, [r5, #5]
33d204f0:	e5d50006 	ldrb	r0, [r5, #6]
33d204f4:	e5d5c007 	ldrb	ip, [r5, #7]
33d204f8:	1a000008 	bne	33d20520 <jffs2_get_list+0x380>
				if (node->totlen < sizeof(struct jffs2_unknown_node))
33d204fc:	e1823403 	orr	r3, r2, r3, lsl #8
33d20500:	e1833800 	orr	r3, r3, r0, lsl #16
33d20504:	e1831c0c 	orr	r1, r3, ip, lsl #24
33d20508:	e351000b 	cmp	r1, #11	; 0xb
33d2050c:	8a000009 	bhi	33d20538 <jffs2_get_list+0x398>
					printf("OOPS Padding has bad size "
33d20510:	e59f01b8 	ldr	r0, [pc, #440]	; 33d206d0 <jffs2_get_list+0x530>
33d20514:	e3a0200c 	mov	r2, #12	; 0xc
33d20518:	ebffdaaa 	bl	33d16fc8 <printf>
33d2051c:	ea000005 	b	33d20538 <jffs2_get_list+0x398>
						"%d < %d\n", node->totlen,
						sizeof(struct jffs2_unknown_node));
			} else {
				printf("Unknown node type: %x len %d "
33d20520:	e1822403 	orr	r2, r2, r3, lsl #8
33d20524:	e1822800 	orr	r2, r2, r0, lsl #16
33d20528:	e1822c0c 	orr	r2, r2, ip, lsl #24
33d2052c:	e59f01a0 	ldr	r0, [pc, #416]	; 33d206d4 <jffs2_get_list+0x534>
33d20530:	e1a03007 	mov	r3, r7
33d20534:	ebffdaa3 	bl	33d16fc8 <printf>
					"offset 0x%x\n", node->nodetype,
					node->totlen, offset);
			}
			offset += ((node->totlen + 3) & ~3);
33d20538:	e5d52005 	ldrb	r2, [r5, #5]
33d2053c:	e5d53004 	ldrb	r3, [r5, #4]
33d20540:	e5d51006 	ldrb	r1, [r5, #6]
33d20544:	e1833402 	orr	r3, r3, r2, lsl #8
33d20548:	e5d52007 	ldrb	r2, [r5, #7]
33d2054c:	e1833801 	orr	r3, r3, r1, lsl #16
33d20550:	e1833c02 	orr	r3, r3, r2, lsl #24
33d20554:	e2833003 	add	r3, r3, #3	; 0x3
33d20558:	e3c33003 	bic	r3, r3, #3	; 0x3
33d2055c:	e0877003 	add	r7, r7, r3
			counterF++;
33d20560:	ea000037 	b	33d20644 <jffs2_get_list+0x4a4>
		} else if (node->magic == JFFS2_EMPTY_BITMASK &&
33d20564:	e5d53000 	ldrb	r3, [r5]
33d20568:	e5d52001 	ldrb	r2, [r5, #1]
33d2056c:	e1831402 	orr	r1, r3, r2, lsl #8
33d20570:	e59f3160 	ldr	r3, [pc, #352]	; 33d206d8 <jffs2_get_list+0x538>
33d20574:	e1510003 	cmp	r1, r3
33d20578:	1a000030 	bne	33d20640 <jffs2_get_list+0x4a0>
33d2057c:	e5d52003 	ldrb	r2, [r5, #3]
33d20580:	e5d53002 	ldrb	r3, [r5, #2]
33d20584:	e1833402 	orr	r3, r3, r2, lsl #8
33d20588:	e1530001 	cmp	r3, r1
#endif

static u32
jffs2_scan_empty(u32 start_offset, struct part_info *part)
{
	char *max = (char *)(part->offset + part->size - sizeof(struct jffs2_raw_inode));
33d2058c:	02863014 	addeq	r3, r6, #20	; 0x14
33d20590:	0813000c 	ldmdaeq	r3, {r2, r3}
33d20594:	00832002 	addeq	r2, r3, r2
33d20598:	05963014 	ldreq	r3, [r6, #20]
	char *offset = (char *)(part->offset + start_offset);
33d2059c:	00834007 	addeq	r4, r3, r7
#endif

static u32
jffs2_scan_empty(u32 start_offset, struct part_info *part)
{
	char *max = (char *)(part->offset + part->size - sizeof(struct jffs2_raw_inode));
33d205a0:	02427044 	subeq	r7, r2, #68	; 0x44
					"offset 0x%x\n", node->nodetype,
					node->totlen, offset);
			}
			offset += ((node->totlen + 3) & ~3);
			counterF++;
		} else if (node->magic == JFFS2_EMPTY_BITMASK &&
33d205a4:	0a000005 	beq	33d205c0 <jffs2_get_list+0x420>
33d205a8:	ea000024 	b	33d20640 <jffs2_get_list+0x4a0>
	char *offset = (char *)(part->offset + start_offset);
	u32 off;

	while (offset < max &&
	       *(u32*)get_fl_mem((u32)offset, sizeof(u32), &off) == 0xFFFFFFFF) {
		offset += sizeof(u32);
33d205ac:	e2844004 	add	r4, r4, #4	; 0x4
		/* return if spinning is due */
		if (((u32)offset & ((1 << SPIN_BLKSIZE)-1)) == 0) break;
33d205b0:	e3c434ff 	bic	r3, r4, #-16777216	; 0xff000000
33d205b4:	e3c3373f 	bic	r3, r3, #16515072	; 0xfc0000
33d205b8:	e3530000 	cmp	r3, #0	; 0x0
33d205bc:	0a00001c 	beq	33d20634 <jffs2_get_list+0x494>
33d205c0:	e1540007 	cmp	r4, r7
33d205c4:	2a00001a 	bcs	33d20634 <jffs2_get_list+0x494>
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;
33d205c8:	e59a3000 	ldr	r3, [sl]
33d205cc:	e5933020 	ldr	r3, [r3, #32]
33d205d0:	e5933008 	ldr	r3, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d205d4:	e5d3c008 	ldrb	ip, [r3, #8]
33d205d8:	e35c0001 	cmp	ip, #1	; 0x1
33d205dc:	1a000007 	bne	33d20600 <jffs2_get_list+0x460>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d205e0:	e5d33009 	ldrb	r3, [r3, #9]
33d205e4:	e59f20c0 	ldr	r2, [pc, #192]	; 33d206ac <jffs2_get_list+0x50c>
33d205e8:	e0833083 	add	r3, r3, r3, lsl #1
33d205ec:	e0833183 	add	r3, r3, r3, lsl #3
33d205f0:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d205f4:	e592300c 	ldr	r3, [r2, #12]
33d205f8:	e0840003 	add	r0, r4, r3
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d205fc:	ea000009 	b	33d20628 <jffs2_get_list+0x488>
		return get_fl_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20600:	e35c0002 	cmp	ip, #2	; 0x2
33d20604:	e28d2010 	add	r2, sp, #16	; 0x10
33d20608:	e1a00004 	mov	r0, r4
33d2060c:	e3a01004 	mov	r1, #4	; 0x4
33d20610:	1a000001 	bne	33d2061c <jffs2_get_list+0x47c>
33d20614:	ebfffbea 	bl	33d1f5c4 <get_fl_mem_nand>
33d20618:	ea000002 	b	33d20628 <jffs2_get_list+0x488>
		return get_fl_mem_nand(off, size, ext_buf);
#endif

	printf("get_fl_mem: unknown device type, using raw offset!\n");
33d2061c:	e59f00b8 	ldr	r0, [pc, #184]	; 33d206dc <jffs2_get_list+0x53c>
33d20620:	ebffda68 	bl	33d16fc8 <printf>
33d20624:	e1a00004 	mov	r0, r4
/*
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
33d20628:	e5903000 	ldr	r3, [r0]
33d2062c:	e3730001 	cmn	r3, #1	; 0x1
33d20630:	0affffdd 	beq	33d205ac <jffs2_get_list+0x40c>
	while (offset < max &&
	       *(u32*)get_fl_mem((u32)offset, sizeof(u32), &off) == 0xFFFFFFFF) {
		offset += sizeof(u32);
		/* return if spinning is due */
		if (((u32)offset & ((1 << SPIN_BLKSIZE)-1)) == 0) break;
	}
33d20634:	e5963014 	ldr	r3, [r6, #20]
33d20638:	e0637004 	rsb	r7, r3, r4
}
#endif

static u32
jffs2_scan_empty(u32 start_offset, struct part_info *part)
{
33d2063c:	ea000000 	b	33d20644 <jffs2_get_list+0x4a4>
			counterF++;
		} else if (node->magic == JFFS2_EMPTY_BITMASK &&
			   node->nodetype == JFFS2_EMPTY_BITMASK) {
			offset = jffs2_scan_empty(offset, part);
		} else {	/* if we know nothing, we just step and look. */
			offset += 4;
33d20640:	e2877004 	add	r7, r7, #4	; 0x4
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d20644:	e59f3050 	ldr	r3, [pc, #80]	; 33d2069c <jffs2_get_list+0x4fc>
33d20648:	e5933000 	ldr	r3, [r3]
33d2064c:	e5933020 	ldr	r3, [r3, #32]
33d20650:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d20654:	e5d33008 	ldrb	r3, [r3, #8]
33d20658:	e3530002 	cmp	r3, #2	; 0x2
33d2065c:	1afffeed 	bne	33d20218 <jffs2_get_list+0x78>
33d20660:	e1a00005 	mov	r0, r5
33d20664:	ebfffc65 	bl	33d1f800 <put_fl_mem_nand>
33d20668:	eafffeea 	b	33d20218 <jffs2_get_list+0x78>
		}
/*             printf("unknown node magic %4.4x %4.4x @ %lx\n", node->magic, node->nodetype, (unsigned long)node); */
		put_fl_mem(node);
	}

	putstr("\b\b done.\r\n");		/* close off the dots */
33d2066c:	e59f006c 	ldr	r0, [pc, #108]	; 33d206e0 <jffs2_get_list+0x540>
33d20670:	e59f106c 	ldr	r1, [pc, #108]	; 33d206e4 <jffs2_get_list+0x544>
33d20674:	ebffda53 	bl	33d16fc8 <printf>
33d20678:	ea000004 	b	33d20690 <jffs2_get_list+0x4f0>
	/* copy requested part_info struct pointer to global location */
	current_part = part;

	if (jffs2_1pass_rescan_needed(part)) {
		if (!jffs2_1pass_build_lists(part)) {
			printf("%s: Failed to scan JFFSv2 file structure\n", who);
33d2067c:	e59f0064 	ldr	r0, [pc, #100]	; 33d206e8 <jffs2_get_list+0x548>
33d20680:	e59d100c 	ldr	r1, [sp, #12]
33d20684:	ebffda4f 	bl	33d16fc8 <printf>
			return NULL;
33d20688:	e1a00004 	mov	r0, r4
33d2068c:	ea000000 	b	33d20694 <jffs2_get_list+0x4f4>
		}
	}
	return (struct b_lists *)part->jffs2_priv;
33d20690:	e5960018 	ldr	r0, [r6, #24]
}
33d20694:	e28dd014 	add	sp, sp, #20	; 0x14
33d20698:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d2069c:	33d6264c 	.word	0x33d6264c
33d206a0:	33d2d60c 	.word	0x33d2d60c
33d206a4:	33d36938 	.word	0x33d36938
33d206a8:	33d2d624 	.word	0x33d2d624
33d206ac:	33d62554 	.word	0x33d62554
33d206b0:	33d2d530 	.word	0x33d2d530
33d206b4:	00001985 	.word	0x00001985
33d206b8:	0000e002 	.word	0x0000e002
33d206bc:	0000e001 	.word	0x0000e001
33d206c0:	33d2d62c 	.word	0x33d2d62c
33d206c4:	00002003 	.word	0x00002003
33d206c8:	33d2d634 	.word	0x33d2d634
33d206cc:	00002004 	.word	0x00002004
33d206d0:	33d2d65c 	.word	0x33d2d65c
33d206d4:	33d2d680 	.word	0x33d2d680
33d206d8:	0000ffff 	.word	0x0000ffff
33d206dc:	33d2d5d8 	.word	0x33d2d5d8
33d206e0:	33d2c2fc 	.word	0x33d2c2fc
33d206e4:	33d2d6ac 	.word	0x33d2d6ac
33d206e8:	33d2d6b8 	.word	0x33d2d6b8

33d206ec <jffs2_1pass_ls>:


/* Print directory / file contents */
u32
jffs2_1pass_ls(struct part_info * part, const char *fname)
{
33d206ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d206f0:	e24dde42 	sub	sp, sp, #1056	; 0x420
33d206f4:	e24dd008 	sub	sp, sp, #8	; 0x8
33d206f8:	e1a05001 	mov	r5, r1
	struct b_lists *pl;
	long ret = 1;
	u32 inode;

	if (! (pl = jffs2_get_list(part, "ls")))
33d206fc:	e59f1834 	ldr	r1, [pc, #2100]	; 33d20f38 <jffs2_1pass_ls+0x84c>
33d20700:	ebfffea6 	bl	33d201a0 <jffs2_get_list>
33d20704:	e3500000 	cmp	r0, #0	; 0x0
33d20708:	e58d0020 	str	r0, [sp, #32]
33d2070c:	0a000206 	beq	33d20f2c <jffs2_1pass_ls+0x840>
	char *c;

	/* discard any leading slash */
	i = 0;
	while (fname[i] == '/')
		i++;
33d20710:	e5d53000 	ldrb	r3, [r5]
	return jffs2_1pass_search_inode(pL, tmp, pino);
}

static u32
jffs2_1pass_search_list_inodes(struct b_lists * pL, const char *fname, u32 pino)
{
33d20714:	e3a00001 	mov	r0, #1	; 0x1
33d20718:	e58d001c 	str	r0, [sp, #28]
	char *c;

	/* discard any leading slash */
	i = 0;
	while (fname[i] == '/')
		i++;
33d2071c:	e353002f 	cmp	r3, #47	; 0x2f
	char tmp[256];
	char working_tmp[256];
	char *c;

	/* discard any leading slash */
	i = 0;
33d20720:	e3a04000 	mov	r4, #0	; 0x0
	while (fname[i] == '/')
		i++;
33d20724:	1a000003 	bne	33d20738 <jffs2_1pass_ls+0x4c>
33d20728:	e2844001 	add	r4, r4, #1	; 0x1
33d2072c:	e7d53004 	ldrb	r3, [r5, r4]
33d20730:	e353002f 	cmp	r3, #47	; 0x2f
33d20734:	eafffffa 	b	33d20724 <jffs2_1pass_ls+0x38>
	strcpy(tmp, &fname[i]);
33d20738:	e28d7fca 	add	r7, sp, #808	; 0x328
33d2073c:	e0851004 	add	r1, r5, r4
33d20740:	e1a00007 	mov	r0, r7
33d20744:	ebffe61c 	bl	33d19fbc <strcpy>
	working_tmp[0] = '\0';
33d20748:	e59f37ec 	ldr	r3, [pc, #2028]	; 33d20f3c <jffs2_1pass_ls+0x850>
33d2074c:	e28d1e42 	add	r1, sp, #1056	; 0x420
33d20750:	e3a02000 	mov	r2, #0	; 0x0
33d20754:	e2811008 	add	r1, r1, #8	; 0x8
33d20758:	e7c12003 	strb	r2, [r1, r3]
	while ((c = (char *) strchr(tmp, '/')))	/* we are still dired searching */
33d2075c:	ea00002a 	b	33d2080c <jffs2_1pass_ls+0x120>
	{
		strncpy(working_tmp, tmp, c - tmp);
33d20760:	e0674005 	rsb	r4, r7, r5
33d20764:	e28d9f8a 	add	r9, sp, #552	; 0x228
33d20768:	e1a02004 	mov	r2, r4
33d2076c:	e1a00009 	mov	r0, r9
33d20770:	e1a01007 	mov	r1, r7
33d20774:	ebffe617 	bl	33d19fd8 <strncpy>
		working_tmp[c - tmp] = '\0';
33d20778:	e28d2e42 	add	r2, sp, #1056	; 0x420
33d2077c:	e2822008 	add	r2, r2, #8	; 0x8
33d20780:	e0823004 	add	r3, r2, r4
33d20784:	e2433c02 	sub	r3, r3, #512	; 0x200
33d20788:	e3a02000 	mov	r2, #0	; 0x0
33d2078c:	e28d6e42 	add	r6, sp, #1056	; 0x420
33d20790:	e5c32000 	strb	r2, [r3]
		for (i = 0; i < strlen(c) - 1; i++)
33d20794:	e1a04002 	mov	r4, r2
33d20798:	e1a0a007 	mov	sl, r7
33d2079c:	e2866008 	add	r6, r6, #8	; 0x8
33d207a0:	ea000002 	b	33d207b0 <jffs2_1pass_ls+0xc4>
			tmp[i] = c[i + 1];
33d207a4:	e5d33001 	ldrb	r3, [r3, #1]
33d207a8:	e4ca3001 	strb	r3, [sl], #1
33d207ac:	e2866001 	add	r6, r6, #1	; 0x1
	working_tmp[0] = '\0';
	while ((c = (char *) strchr(tmp, '/')))	/* we are still dired searching */
	{
		strncpy(working_tmp, tmp, c - tmp);
		working_tmp[c - tmp] = '\0';
		for (i = 0; i < strlen(c) - 1; i++)
33d207b0:	e1a00005 	mov	r0, r5
33d207b4:	ebffe655 	bl	33d1a110 <strlen>
33d207b8:	e2400001 	sub	r0, r0, #1	; 0x1
33d207bc:	e1540000 	cmp	r4, r0
			tmp[i] = c[i + 1];
33d207c0:	e0853004 	add	r3, r5, r4
	working_tmp[0] = '\0';
	while ((c = (char *) strchr(tmp, '/')))	/* we are still dired searching */
	{
		strncpy(working_tmp, tmp, c - tmp);
		working_tmp[c - tmp] = '\0';
		for (i = 0; i < strlen(c) - 1; i++)
33d207c4:	e2844001 	add	r4, r4, #1	; 0x1
33d207c8:	3afffff5 	bcc	33d207a4 <jffs2_1pass_ls+0xb8>
			tmp[i] = c[i + 1];
		tmp[i] = '\0';
33d207cc:	e246cc01 	sub	ip, r6, #256	; 0x100
33d207d0:	e3a03000 	mov	r3, #0	; 0x0
		/* only a failure if we arent looking at top level */
		if (!(pino = jffs2_1pass_find_inode(pL, working_tmp, pino)) &&
33d207d4:	e59d201c 	ldr	r2, [sp, #28]
33d207d8:	e59d0020 	ldr	r0, [sp, #32]
33d207dc:	e1a01009 	mov	r1, r9
	{
		strncpy(working_tmp, tmp, c - tmp);
		working_tmp[c - tmp] = '\0';
		for (i = 0; i < strlen(c) - 1; i++)
			tmp[i] = c[i + 1];
		tmp[i] = '\0';
33d207e0:	e5cc3000 	strb	r3, [ip]
		/* only a failure if we arent looking at top level */
		if (!(pino = jffs2_1pass_find_inode(pL, working_tmp, pino)) &&
33d207e4:	ebfffd1d 	bl	33d1fc60 <jffs2_1pass_find_inode>
33d207e8:	e3500000 	cmp	r0, #0	; 0x0
33d207ec:	e58d001c 	str	r0, [sp, #28]
33d207f0:	1a000005 	bne	33d2080c <jffs2_1pass_ls+0x120>
33d207f4:	e59f3740 	ldr	r3, [pc, #1856]	; 33d20f3c <jffs2_1pass_ls+0x850>
33d207f8:	e28dce42 	add	ip, sp, #1056	; 0x420
33d207fc:	e28cc008 	add	ip, ip, #8	; 0x8
33d20800:	e7dc3003 	ldrb	r3, [ip, r3]
33d20804:	e3530000 	cmp	r3, #0	; 0x0
33d20808:	1a0001b9 	bne	33d20ef4 <jffs2_1pass_ls+0x808>
		    (working_tmp[0])) {
			putstr("find_inode failed for name=");
			putstr(working_tmp);
			putstr("\r\n");
33d2080c:	e1a00007 	mov	r0, r7
33d20810:	e3a0102f 	mov	r1, #47	; 0x2f
33d20814:	ebffe631 	bl	33d1a0e0 <strchr>
33d20818:	e2505000 	subs	r5, r0, #0	; 0x0
33d2081c:	1affffcf 	bne	33d20760 <jffs2_1pass_ls+0x74>
			return 0;
		}
	}

	if (tmp[0] && !(pino = jffs2_1pass_find_inode(pL, tmp, pino))) {
33d20820:	e28d0e42 	add	r0, sp, #1056	; 0x420
33d20824:	e3e030ff 	mvn	r3, #255	; 0xff
33d20828:	e2800008 	add	r0, r0, #8	; 0x8
33d2082c:	e7d03003 	ldrb	r3, [r0, r3]
33d20830:	e3530000 	cmp	r3, #0	; 0x0
33d20834:	0a00000b 	beq	33d20868 <jffs2_1pass_ls+0x17c>
33d20838:	e59d201c 	ldr	r2, [sp, #28]
33d2083c:	e59d0020 	ldr	r0, [sp, #32]
33d20840:	e1a01007 	mov	r1, r7
33d20844:	ebfffd05 	bl	33d1fc60 <jffs2_1pass_find_inode>
33d20848:	e3500000 	cmp	r0, #0	; 0x0
33d2084c:	e58d001c 	str	r0, [sp, #28]
33d20850:	1a000004 	bne	33d20868 <jffs2_1pass_ls+0x17c>
		putstr("find_inode failed for name=");
33d20854:	e59f16e4 	ldr	r1, [pc, #1764]	; 33d20f40 <jffs2_1pass_ls+0x854>
33d20858:	e59f06e4 	ldr	r0, [pc, #1764]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d2085c:	ebffd9d9 	bl	33d16fc8 <printf>
		putstr(tmp);
33d20860:	e1a01007 	mov	r1, r7
33d20864:	ea0001a6 	b	33d20f04 <jffs2_1pass_ls+0x818>
jffs2_1pass_list_inodes(struct b_lists * pL, u32 pino)
{
	struct b_node *b;
	struct jffs2_raw_dirent *jDir;

	for (b = pL->dir.listHead; b; b = b->next) {
33d20868:	e59d1020 	ldr	r1, [sp, #32]
33d2086c:	e5911004 	ldr	r1, [r1, #4]
33d20870:	e3510000 	cmp	r1, #0	; 0x0
33d20874:	e58d1018 	str	r1, [sp, #24]
33d20878:	0a000193 	beq	33d20ecc <jffs2_1pass_ls+0x7e0>
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d2087c:	e59f36c4 	ldr	r3, [pc, #1732]	; 33d20f48 <jffs2_1pass_ls+0x85c>
33d20880:	e5933000 	ldr	r3, [r3]
33d20884:	e5933020 	ldr	r3, [r3, #32]
33d20888:	e5932008 	ldr	r2, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2088c:	e5d23008 	ldrb	r3, [r2, #8]
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d20890:	e59dc018 	ldr	ip, [sp, #24]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20894:	e3530001 	cmp	r3, #1	; 0x1
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d20898:	e59c4000 	ldr	r4, [ip]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2089c:	1a000007 	bne	33d208c0 <jffs2_1pass_ls+0x1d4>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d208a0:	e5d23009 	ldrb	r3, [r2, #9]
33d208a4:	e59f26a0 	ldr	r2, [pc, #1696]	; 33d20f4c <jffs2_1pass_ls+0x860>
33d208a8:	e0833083 	add	r3, r3, r3, lsl #1
33d208ac:	e0833183 	add	r3, r3, r3, lsl #3
33d208b0:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d208b4:	e592300c 	ldr	r3, [r2, #12]
33d208b8:	e084b003 	add	fp, r4, r3
static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d208bc:	ea000008 	b	33d208e4 <jffs2_1pass_ls+0x1f8>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d208c0:	e3530002 	cmp	r3, #2	; 0x2
33d208c4:	1a000003 	bne	33d208d8 <jffs2_1pass_ls+0x1ec>
33d208c8:	e1a00004 	mov	r0, r4
33d208cc:	ebfffbac 	bl	33d1f784 <get_node_mem_nand>
33d208d0:	e1a0b000 	mov	fp, r0
33d208d4:	ea000002 	b	33d208e4 <jffs2_1pass_ls+0x1f8>
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d208d8:	e59f0670 	ldr	r0, [pc, #1648]	; 33d20f50 <jffs2_1pass_ls+0x864>
33d208dc:	ebffd9b9 	bl	33d16fc8 <printf>
33d208e0:	e1a0b004 	mov	fp, r4
	struct b_node *b;
	struct jffs2_raw_dirent *jDir;

	for (b = pL->dir.listHead; b; b = b->next) {
		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
		if ((pino == jDir->pino) && (jDir->ino)) { /* ino=0 -> unlink */
33d208e4:	e5db200d 	ldrb	r2, [fp, #13]
33d208e8:	e5db300c 	ldrb	r3, [fp, #12]
33d208ec:	e5db100e 	ldrb	r1, [fp, #14]
33d208f0:	e1833402 	orr	r3, r3, r2, lsl #8
33d208f4:	e5db200f 	ldrb	r2, [fp, #15]
33d208f8:	e1833801 	orr	r3, r3, r1, lsl #16
33d208fc:	e59d001c 	ldr	r0, [sp, #28]
33d20900:	e1833c02 	orr	r3, r3, r2, lsl #24
33d20904:	e1500003 	cmp	r0, r3
33d20908:	1a000165 	bne	33d20ea4 <jffs2_1pass_ls+0x7b8>
33d2090c:	e5db2015 	ldrb	r2, [fp, #21]
33d20910:	e5db3014 	ldrb	r3, [fp, #20]
33d20914:	e5db1016 	ldrb	r1, [fp, #22]
33d20918:	e1833402 	orr	r3, r3, r2, lsl #8
33d2091c:	e5db2017 	ldrb	r2, [fp, #23]
33d20920:	e1833801 	orr	r3, r3, r1, lsl #16
33d20924:	e1932c02 	orrs	r2, r3, r2, lsl #24
33d20928:	0a00015d 	beq	33d20ea4 <jffs2_1pass_ls+0x7b8>
			u32 i_version = 0;
			struct jffs2_raw_inode ojNode;
			struct jffs2_raw_inode *jNode, *i = NULL;
			struct b_node *b2 = pL->frag.listHead;
33d2092c:	e59d1020 	ldr	r1, [sp, #32]
	struct jffs2_raw_dirent *jDir;

	for (b = pL->dir.listHead; b; b = b->next) {
		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
		if ((pino == jDir->pino) && (jDir->ino)) { /* ino=0 -> unlink */
			u32 i_version = 0;
33d20930:	e3a02000 	mov	r2, #0	; 0x0
			struct jffs2_raw_inode ojNode;
			struct jffs2_raw_inode *jNode, *i = NULL;
			struct b_node *b2 = pL->frag.listHead;
33d20934:	e5915014 	ldr	r5, [r1, #20]
	struct jffs2_raw_dirent *jDir;

	for (b = pL->dir.listHead; b; b = b->next) {
		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
		if ((pino == jDir->pino) && (jDir->ino)) { /* ino=0 -> unlink */
			u32 i_version = 0;
33d20938:	e58d2014 	str	r2, [sp, #20]
					if (jDir->type == DT_LNK)
						i = get_node_mem(b2->offset);
					else
						i = get_fl_mem(b2->offset, sizeof(*i), NULL);
				}
				b2 = b2->next;
33d2093c:	e3550000 	cmp	r5, #0	; 0x0
33d20940:	0a000060 	beq	33d20ac8 <jffs2_1pass_ls+0x3dc>
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;
33d20944:	e59f65fc 	ldr	r6, [pc, #1532]	; 33d20f48 <jffs2_1pass_ls+0x85c>
33d20948:	e5963000 	ldr	r3, [r6]
33d2094c:	e5933020 	ldr	r3, [r3, #32]
33d20950:	e5932008 	ldr	r2, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20954:	e5d23008 	ldrb	r3, [r2, #8]
33d20958:	e3530001 	cmp	r3, #1	; 0x1
/*
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
33d2095c:	e5954000 	ldr	r4, [r5]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20960:	1a000007 	bne	33d20984 <jffs2_1pass_ls+0x298>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d20964:	e5d23009 	ldrb	r3, [r2, #9]
33d20968:	e59f25dc 	ldr	r2, [pc, #1500]	; 33d20f4c <jffs2_1pass_ls+0x860>
33d2096c:	e0833083 	add	r3, r3, r3, lsl #1
33d20970:	e0833183 	add	r3, r3, r3, lsl #3
33d20974:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d20978:	e592300c 	ldr	r3, [r2, #12]
33d2097c:	e0844003 	add	r4, r4, r3
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20980:	ea000009 	b	33d209ac <jffs2_1pass_ls+0x2c0>
		return get_fl_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20984:	e3530002 	cmp	r3, #2	; 0x2
33d20988:	1a000005 	bne	33d209a4 <jffs2_1pass_ls+0x2b8>
33d2098c:	e1a00004 	mov	r0, r4
33d20990:	e28d2f79 	add	r2, sp, #484	; 0x1e4
33d20994:	e3a01044 	mov	r1, #68	; 0x44
33d20998:	ebfffb09 	bl	33d1f5c4 <get_fl_mem_nand>
33d2099c:	e1a04000 	mov	r4, r0
33d209a0:	ea000001 	b	33d209ac <jffs2_1pass_ls+0x2c0>
		return get_fl_mem_nand(off, size, ext_buf);
#endif

	printf("get_fl_mem: unknown device type, using raw offset!\n");
33d209a4:	e59f05a8 	ldr	r0, [pc, #1448]	; 33d20f54 <jffs2_1pass_ls+0x868>
33d209a8:	ebffd986 	bl	33d16fc8 <printf>
			struct b_node *b2 = pL->frag.listHead;

			while (b2) {
				jNode = (struct jffs2_raw_inode *)
					get_fl_mem(b2->offset, sizeof(ojNode), &ojNode);
				if (jNode->ino == jDir->ino && jNode->version >= i_version) {
33d209ac:	e5d4000d 	ldrb	r0, [r4, #13]
33d209b0:	e5db1015 	ldrb	r1, [fp, #21]
33d209b4:	e5d4200c 	ldrb	r2, [r4, #12]
33d209b8:	e5db3014 	ldrb	r3, [fp, #20]
33d209bc:	e5d4c00e 	ldrb	ip, [r4, #14]
33d209c0:	e5dbe016 	ldrb	lr, [fp, #22]
33d209c4:	e1822400 	orr	r2, r2, r0, lsl #8
33d209c8:	e1833401 	orr	r3, r3, r1, lsl #8
33d209cc:	e5db0017 	ldrb	r0, [fp, #23]
33d209d0:	e5d4100f 	ldrb	r1, [r4, #15]
33d209d4:	e182280c 	orr	r2, r2, ip, lsl #16
33d209d8:	e183380e 	orr	r3, r3, lr, lsl #16
33d209dc:	e1822c01 	orr	r2, r2, r1, lsl #24
33d209e0:	e1833c00 	orr	r3, r3, r0, lsl #24
33d209e4:	e1520003 	cmp	r2, r3
33d209e8:	1a000033 	bne	33d20abc <jffs2_1pass_ls+0x3d0>
					if (i)
33d209ec:	e59d3014 	ldr	r3, [sp, #20]
33d209f0:	e3530000 	cmp	r3, #0	; 0x0
33d209f4:	0a000006 	beq	33d20a14 <jffs2_1pass_ls+0x328>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d209f8:	e5963000 	ldr	r3, [r6]
33d209fc:	e5933020 	ldr	r3, [r3, #32]
33d20a00:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d20a04:	e5d33008 	ldrb	r3, [r3, #8]
33d20a08:	e3530002 	cmp	r3, #2	; 0x2
33d20a0c:	059d0014 	ldreq	r0, [sp, #20]
33d20a10:	0bfffb7a 	bleq	33d1f800 <put_fl_mem_nand>
					get_fl_mem(b2->offset, sizeof(ojNode), &ojNode);
				if (jNode->ino == jDir->ino && jNode->version >= i_version) {
					if (i)
						put_fl_mem(i);

					if (jDir->type == DT_LNK)
33d20a14:	e5db301d 	ldrb	r3, [fp, #29]
33d20a18:	e353000a 	cmp	r3, #10	; 0xa
33d20a1c:	e5954000 	ldr	r4, [r5]
33d20a20:	e59f3520 	ldr	r3, [pc, #1312]	; 33d20f48 <jffs2_1pass_ls+0x85c>
33d20a24:	1a00000b 	bne	33d20a58 <jffs2_1pass_ls+0x36c>
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d20a28:	e5933000 	ldr	r3, [r3]
33d20a2c:	e5933020 	ldr	r3, [r3, #32]
33d20a30:	e5933008 	ldr	r3, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20a34:	e5d32008 	ldrb	r2, [r3, #8]
33d20a38:	e3520001 	cmp	r2, #1	; 0x1
33d20a3c:	0a00000b 	beq	33d20a70 <jffs2_1pass_ls+0x384>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20a40:	e3520002 	cmp	r2, #2	; 0x2
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d20a44:	159f0504 	ldrne	r0, [pc, #1284]	; 33d20f50 <jffs2_1pass_ls+0x864>
	if (id->type == MTD_DEV_TYPE_NOR)
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20a48:	1a000018 	bne	33d20ab0 <jffs2_1pass_ls+0x3c4>
33d20a4c:	e1a00004 	mov	r0, r4
33d20a50:	ebfffb4b 	bl	33d1f784 <get_node_mem_nand>
33d20a54:	ea000017 	b	33d20ab8 <jffs2_1pass_ls+0x3cc>
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;
33d20a58:	e5933000 	ldr	r3, [r3]
33d20a5c:	e5933020 	ldr	r3, [r3, #32]
33d20a60:	e5933008 	ldr	r3, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20a64:	e5d32008 	ldrb	r2, [r3, #8]
33d20a68:	e3520001 	cmp	r2, #1	; 0x1
33d20a6c:	1a000007 	bne	33d20a90 <jffs2_1pass_ls+0x3a4>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d20a70:	e5d33009 	ldrb	r3, [r3, #9]
33d20a74:	e59f24d0 	ldr	r2, [pc, #1232]	; 33d20f4c <jffs2_1pass_ls+0x860>
33d20a78:	e0833083 	add	r3, r3, r3, lsl #1
33d20a7c:	e0833183 	add	r3, r3, r3, lsl #3
33d20a80:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d20a84:	e592300c 	ldr	r3, [r2, #12]
33d20a88:	e0840003 	add	r0, r4, r3
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d20a8c:	ea000009 	b	33d20ab8 <jffs2_1pass_ls+0x3cc>
		return get_fl_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20a90:	e3520002 	cmp	r2, #2	; 0x2
		return get_fl_mem_nand(off, size, ext_buf);
#endif

	printf("get_fl_mem: unknown device type, using raw offset!\n");
33d20a94:	159f04b8 	ldrne	r0, [pc, #1208]	; 33d20f54 <jffs2_1pass_ls+0x868>
	if (id->type == MTD_DEV_TYPE_NOR)
		return get_fl_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d20a98:	1a000004 	bne	33d20ab0 <jffs2_1pass_ls+0x3c4>
33d20a9c:	e1a00004 	mov	r0, r4
33d20aa0:	e3a01044 	mov	r1, #68	; 0x44
33d20aa4:	e2422002 	sub	r2, r2, #2	; 0x2
33d20aa8:	ebfffac5 	bl	33d1f5c4 <get_fl_mem_nand>
33d20aac:	ea000001 	b	33d20ab8 <jffs2_1pass_ls+0x3cc>
		return get_fl_mem_nand(off, size, ext_buf);
#endif

	printf("get_fl_mem: unknown device type, using raw offset!\n");
33d20ab0:	ebffd944 	bl	33d16fc8 <printf>
33d20ab4:	e1a00004 	mov	r0, r4
/*
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
33d20ab8:	e58d0014 	str	r0, [sp, #20]
					if (jDir->type == DT_LNK)
						i = get_node_mem(b2->offset);
					else
						i = get_fl_mem(b2->offset, sizeof(*i), NULL);
				}
				b2 = b2->next;
33d20abc:	e5955004 	ldr	r5, [r5, #4]
33d20ac0:	e3550000 	cmp	r5, #0	; 0x0
33d20ac4:	eaffff9d 	b	33d20940 <jffs2_1pass_ls+0x254>
static inline u32 dump_inode(struct b_lists * pL, struct jffs2_raw_dirent *d, struct jffs2_raw_inode *i)
{
	char fname[256];
	struct stat st;

	if(!d || !i) return -1;
33d20ac8:	e59dc014 	ldr	ip, [sp, #20]
33d20acc:	e35c0000 	cmp	ip, #0	; 0x0
33d20ad0:	135b0000 	cmpne	fp, #0	; 0x0
33d20ad4:	13a04000 	movne	r4, #0	; 0x0
33d20ad8:	03a04001 	moveq	r4, #1	; 0x1
33d20adc:	0a0000e7 	beq	33d20e80 <jffs2_1pass_ls+0x794>

	strncpy(fname, (char *)d->name, d->nsize);
33d20ae0:	e28b1028 	add	r1, fp, #40	; 0x28
33d20ae4:	e5db201c 	ldrb	r2, [fp, #28]
33d20ae8:	e28d00e4 	add	r0, sp, #228	; 0xe4
33d20aec:	ebffe539 	bl	33d19fd8 <strncpy>
	fname[d->nsize] = '\0';
33d20af0:	e5db301c 	ldrb	r3, [fp, #28]
33d20af4:	e28d0e42 	add	r0, sp, #1056	; 0x420
33d20af8:	e2800008 	add	r0, r0, #8	; 0x8
33d20afc:	e0803003 	add	r3, r0, r3
33d20b00:	e2433fd1 	sub	r3, r3, #836	; 0x344

	memset(&st,0,sizeof(st));
33d20b04:	e1a01004 	mov	r1, r4
	struct stat st;

	if(!d || !i) return -1;

	strncpy(fname, (char *)d->name, d->nsize);
	fname[d->nsize] = '\0';
33d20b08:	e5c34000 	strb	r4, [r3]

	memset(&st,0,sizeof(st));
33d20b0c:	e3a02040 	mov	r2, #64	; 0x40
33d20b10:	e28d00a4 	add	r0, sp, #164	; 0xa4
33d20b14:	ebffe61e 	bl	33d1a394 <memset>

	st.st_mtime = i->mtime;
33d20b18:	e59d1014 	ldr	r1, [sp, #20]
33d20b1c:	e59dc014 	ldr	ip, [sp, #20]
33d20b20:	e5d12025 	ldrb	r2, [r1, #37]
33d20b24:	e5d13024 	ldrb	r3, [r1, #36]
33d20b28:	e5d11026 	ldrb	r1, [r1, #38]
33d20b2c:	e1833402 	orr	r3, r3, r2, lsl #8
33d20b30:	e5dc2027 	ldrb	r2, [ip, #39]
33d20b34:	e1833801 	orr	r3, r3, r1, lsl #16
33d20b38:	e1833c02 	orr	r3, r3, r2, lsl #24
33d20b3c:	e58d30cc 	str	r3, [sp, #204]
	st.st_mode = i->mode;
33d20b40:	e5dc2015 	ldrb	r2, [ip, #21]
33d20b44:	e5dc3014 	ldrb	r3, [ip, #20]
33d20b48:	e28d0e42 	add	r0, sp, #1056	; 0x420
33d20b4c:	e1833402 	orr	r3, r3, r2, lsl #8
33d20b50:	e59f2400 	ldr	r2, [pc, #1024]	; 33d20f58 <jffs2_1pass_ls+0x86c>
33d20b54:	e2800008 	add	r0, r0, #8	; 0x8
33d20b58:	e18030b2 	strh	r3, [r0, r2]
	st.st_ino = i->ino;
33d20b5c:	e5dc200d 	ldrb	r2, [ip, #13]
33d20b60:	e5dc300c 	ldrb	r3, [ip, #12]
33d20b64:	e5dc100e 	ldrb	r1, [ip, #14]
33d20b68:	e1833402 	orr	r3, r3, r2, lsl #8
33d20b6c:	e5dc200f 	ldrb	r2, [ip, #15]
33d20b70:	e1833801 	orr	r3, r3, r1, lsl #16
33d20b74:	e1833c02 	orr	r3, r3, r2, lsl #24
33d20b78:	e58d30a8 	str	r3, [sp, #168]

	/* neither dsize nor isize help us.. do it the long way */
	st.st_size = jffs2_1pass_read_inode(pL, i->ino, NULL);
33d20b7c:	e5dc300d 	ldrb	r3, [ip, #13]
33d20b80:	e5dc100c 	ldrb	r1, [ip, #12]
33d20b84:	e5dc200e 	ldrb	r2, [ip, #14]
33d20b88:	e1811403 	orr	r1, r1, r3, lsl #8
33d20b8c:	e5dc300f 	ldrb	r3, [ip, #15]
33d20b90:	e1811802 	orr	r1, r1, r2, lsl #16
33d20b94:	e1811c03 	orr	r1, r1, r3, lsl #24
33d20b98:	e1a02004 	mov	r2, r4
33d20b9c:	e59d0020 	ldr	r0, [sp, #32]
33d20ba0:	ebfffb64 	bl	33d1f938 <jffs2_1pass_read_inode>
static inline void dump_stat(struct stat *st, const char *name)
{
	char str[20];
	char s[64], *p;

	if (st->st_mtime == (time_t)(-1)) /* some ctimes really hate -1 */
33d20ba4:	e59d30cc 	ldr	r3, [sp, #204]
33d20ba8:	e3730001 	cmn	r3, #1	; 0x1
		st->st_mtime = 1;
33d20bac:	02833002 	addeq	r3, r3, #2	; 0x2
33d20bb0:	058d30cc 	streq	r3, [sp, #204]
    long days, rem;
    int y;
    int yleap;
    _CONST int *ip;

    days = ((long) *tim_p) / SECSPERDAY;
33d20bb4:	e59d40cc 	ldr	r4, [sp, #204]
	st.st_mtime = i->mtime;
	st.st_mode = i->mode;
	st.st_ino = i->ino;

	/* neither dsize nor isize help us.. do it the long way */
	st.st_size = jffs2_1pass_read_inode(pL, i->ino, NULL);
33d20bb8:	e58d00b8 	str	r0, [sp, #184]
33d20bbc:	e59f1398 	ldr	r1, [pc, #920]	; 33d20f5c <jffs2_1pass_ls+0x870>
33d20bc0:	e1a00004 	mov	r0, r4
33d20bc4:	ebfff6a5 	bl	33d1e660 <__divsi3>
    rem = ((long) *tim_p) % SECSPERDAY;
33d20bc8:	e59f138c 	ldr	r1, [pc, #908]	; 33d20f5c <jffs2_1pass_ls+0x870>
    long days, rem;
    int y;
    int yleap;
    _CONST int *ip;

    days = ((long) *tim_p) / SECSPERDAY;
33d20bcc:	e1a0a000 	mov	sl, r0
    rem = ((long) *tim_p) % SECSPERDAY;
33d20bd0:	e1a00004 	mov	r0, r4
33d20bd4:	ebfff6f1 	bl	33d1e7a0 <__modsi3>

static inline struct tm *
_DEFUN (localtime_r, (tim_p, res),
	_CONST time_t * tim_p _AND
	struct tm *res)
{
33d20bd8:	e28d9028 	add	r9, sp, #40	; 0x28
    days = ((long) *tim_p) / SECSPERDAY;
    rem = ((long) *tim_p) % SECSPERDAY;
    while (rem < 0)
    {
	rem += SECSPERDAY;
	--days;
33d20bdc:	e2504000 	subs	r4, r0, #0	; 0x0

static inline struct tm *
_DEFUN (localtime_r, (tim_p, res),
	_CONST time_t * tim_p _AND
	struct tm *res)
{
33d20be0:	e2499004 	sub	r9, r9, #4	; 0x4
    days = ((long) *tim_p) / SECSPERDAY;
    rem = ((long) *tim_p) % SECSPERDAY;
    while (rem < 0)
    {
	rem += SECSPERDAY;
	--days;
33d20be4:	aa000004 	bge	33d20bfc <jffs2_1pass_ls+0x510>

    days = ((long) *tim_p) / SECSPERDAY;
    rem = ((long) *tim_p) % SECSPERDAY;
    while (rem < 0)
    {
	rem += SECSPERDAY;
33d20be8:	e2844a15 	add	r4, r4, #86016	; 0x15000
33d20bec:	e2844d06 	add	r4, r4, #384	; 0x180
	--days;
33d20bf0:	e3540000 	cmp	r4, #0	; 0x0
33d20bf4:	e24aa001 	sub	sl, sl, #1	; 0x1
33d20bf8:	eafffff9 	b	33d20be4 <jffs2_1pass_ls+0x4f8>
    }
    while (rem >= SECSPERDAY)
    {
	rem -= SECSPERDAY;
	++days;
33d20bfc:	e59f335c 	ldr	r3, [pc, #860]	; 33d20f60 <jffs2_1pass_ls+0x874>
33d20c00:	e1540003 	cmp	r4, r3
33d20c04:	da000004 	ble	33d20c1c <jffs2_1pass_ls+0x530>
	rem += SECSPERDAY;
	--days;
    }
    while (rem >= SECSPERDAY)
    {
	rem -= SECSPERDAY;
33d20c08:	e2444a15 	sub	r4, r4, #86016	; 0x15000
33d20c0c:	e2444d06 	sub	r4, r4, #384	; 0x180
	++days;
33d20c10:	e1540003 	cmp	r4, r3
33d20c14:	e28aa001 	add	sl, sl, #1	; 0x1
33d20c18:	eafffff9 	b	33d20c04 <jffs2_1pass_ls+0x518>
    }

    /* compute hour, min, and sec */
    res->tm_hour = (int) (rem / SECSPERHOUR);
33d20c1c:	e1a00004 	mov	r0, r4
33d20c20:	e3a01ee1 	mov	r1, #3600	; 0xe10
33d20c24:	ebfff68d 	bl	33d1e660 <__divsi3>
    rem %= SECSPERHOUR;
33d20c28:	e3a01ee1 	mov	r1, #3600	; 0xe10
	rem -= SECSPERDAY;
	++days;
    }

    /* compute hour, min, and sec */
    res->tm_hour = (int) (rem / SECSPERHOUR);
33d20c2c:	e5890008 	str	r0, [r9, #8]
    rem %= SECSPERHOUR;
33d20c30:	e1a00004 	mov	r0, r4
33d20c34:	ebfff6d9 	bl	33d1e7a0 <__modsi3>
    res->tm_min = (int) (rem / SECSPERMIN);
33d20c38:	e3a0103c 	mov	r1, #60	; 0x3c
	++days;
    }

    /* compute hour, min, and sec */
    res->tm_hour = (int) (rem / SECSPERHOUR);
    rem %= SECSPERHOUR;
33d20c3c:	e1a04000 	mov	r4, r0
    res->tm_min = (int) (rem / SECSPERMIN);
33d20c40:	ebfff686 	bl	33d1e660 <__divsi3>
    res->tm_sec = (int) (rem % SECSPERMIN);
33d20c44:	e3a0103c 	mov	r1, #60	; 0x3c
    }

    /* compute hour, min, and sec */
    res->tm_hour = (int) (rem / SECSPERHOUR);
    rem %= SECSPERHOUR;
    res->tm_min = (int) (rem / SECSPERMIN);
33d20c48:	e5890004 	str	r0, [r9, #4]
    res->tm_sec = (int) (rem % SECSPERMIN);
33d20c4c:	e1a00004 	mov	r0, r4
33d20c50:	ebfff6d2 	bl	33d1e7a0 <__modsi3>

    /* compute day of week */
    if ((res->tm_wday = ((EPOCH_WDAY + days) % DAYSPERWEEK)) < 0)
33d20c54:	e3a01007 	mov	r1, #7	; 0x7

    /* compute hour, min, and sec */
    res->tm_hour = (int) (rem / SECSPERHOUR);
    rem %= SECSPERHOUR;
    res->tm_min = (int) (rem / SECSPERMIN);
    res->tm_sec = (int) (rem % SECSPERMIN);
33d20c58:	e5890000 	str	r0, [r9]

    /* compute day of week */
    if ((res->tm_wday = ((EPOCH_WDAY + days) % DAYSPERWEEK)) < 0)
33d20c5c:	e28a0004 	add	r0, sl, #4	; 0x4
33d20c60:	ebfff6ce 	bl	33d1e7a0 <__modsi3>
33d20c64:	e3500000 	cmp	r0, #0	; 0x0
	res->tm_wday += DAYSPERWEEK;
33d20c68:	b2803007 	addlt	r3, r0, #7	; 0x7
    rem %= SECSPERHOUR;
    res->tm_min = (int) (rem / SECSPERMIN);
    res->tm_sec = (int) (rem % SECSPERMIN);

    /* compute day of week */
    if ((res->tm_wday = ((EPOCH_WDAY + days) % DAYSPERWEEK)) < 0)
33d20c6c:	e5890018 	str	r0, [r9, #24]
	res->tm_wday += DAYSPERWEEK;
33d20c70:	b5893018 	strlt	r3, [r9, #24]

    /* compute year & day of year */
    y = EPOCH_YEAR;
    if (days >= 0)
33d20c74:	e35a0000 	cmp	sl, #0	; 0x0
    /* compute day of week */
    if ((res->tm_wday = ((EPOCH_WDAY + days) % DAYSPERWEEK)) < 0)
	res->tm_wday += DAYSPERWEEK;

    /* compute year & day of year */
    y = EPOCH_YEAR;
33d20c78:	e59f42e4 	ldr	r4, [pc, #740]	; 33d20f64 <jffs2_1pass_ls+0x878>
    if (days >= 0)
33d20c7c:	ba000014 	blt	33d20cd4 <jffs2_1pass_ls+0x5e8>
    {
	for (;;)
	{
	    yleap = isleap(y);
33d20c80:	e3140003 	tst	r4, #3	; 0x3
33d20c84:	e3a01064 	mov	r1, #100	; 0x64
33d20c88:	e1a00004 	mov	r0, r4
33d20c8c:	e3a05000 	mov	r5, #0	; 0x0
33d20c90:	1a000002 	bne	33d20ca0 <jffs2_1pass_ls+0x5b4>
33d20c94:	ebfff6c1 	bl	33d1e7a0 <__modsi3>
33d20c98:	e1500005 	cmp	r0, r5
33d20c9c:	1a000004 	bne	33d20cb4 <jffs2_1pass_ls+0x5c8>
33d20ca0:	e1a00004 	mov	r0, r4
33d20ca4:	e3a01e19 	mov	r1, #400	; 0x190
33d20ca8:	ebfff6bc 	bl	33d1e7a0 <__modsi3>
33d20cac:	e3500000 	cmp	r0, #0	; 0x0
33d20cb0:	1a000000 	bne	33d20cb8 <jffs2_1pass_ls+0x5cc>
33d20cb4:	e3a05001 	mov	r5, #1	; 0x1
	    if (days < year_lengths[yleap])
33d20cb8:	e59f32a8 	ldr	r3, [pc, #680]	; 33d20f68 <jffs2_1pass_ls+0x87c>
33d20cbc:	e7933105 	ldr	r3, [r3, r5, lsl #2]
33d20cc0:	e15a0003 	cmp	sl, r3
33d20cc4:	ba000015 	blt	33d20d20 <jffs2_1pass_ls+0x634>
		break;
	    y++;
	    days -= year_lengths[yleap];
33d20cc8:	e063a00a 	rsb	sl, r3, sl
	for (;;)
	{
	    yleap = isleap(y);
	    if (days < year_lengths[yleap])
		break;
	    y++;
33d20ccc:	e2844001 	add	r4, r4, #1	; 0x1

    /* compute year & day of year */
    y = EPOCH_YEAR;
    if (days >= 0)
    {
	for (;;)
33d20cd0:	eaffffea 	b	33d20c80 <jffs2_1pass_ls+0x594>
    }
    else
    {
	do
	{
	    --y;
33d20cd4:	e2444001 	sub	r4, r4, #1	; 0x1
	    yleap = isleap(y);
33d20cd8:	e3140003 	tst	r4, #3	; 0x3
33d20cdc:	e3a01064 	mov	r1, #100	; 0x64
33d20ce0:	e1a00004 	mov	r0, r4
33d20ce4:	e3a05000 	mov	r5, #0	; 0x0
33d20ce8:	1a000002 	bne	33d20cf8 <jffs2_1pass_ls+0x60c>
33d20cec:	ebfff6ab 	bl	33d1e7a0 <__modsi3>
33d20cf0:	e1500005 	cmp	r0, r5
33d20cf4:	1a000004 	bne	33d20d0c <jffs2_1pass_ls+0x620>
33d20cf8:	e1a00004 	mov	r0, r4
33d20cfc:	e3a01e19 	mov	r1, #400	; 0x190
33d20d00:	ebfff6a6 	bl	33d1e7a0 <__modsi3>
33d20d04:	e3500000 	cmp	r0, #0	; 0x0
33d20d08:	1a000000 	bne	33d20d10 <jffs2_1pass_ls+0x624>
33d20d0c:	e3a05001 	mov	r5, #1	; 0x1
	    days += year_lengths[yleap];
33d20d10:	e59f3250 	ldr	r3, [pc, #592]	; 33d20f68 <jffs2_1pass_ls+0x87c>
33d20d14:	e7933105 	ldr	r3, [r3, r5, lsl #2]
	} while (days < 0);
33d20d18:	e09aa003 	adds	sl, sl, r3
33d20d1c:	4affffec 	bmi	33d20cd4 <jffs2_1pass_ls+0x5e8>
    }

    res->tm_year = y - YEAR_BASE;
    res->tm_yday = days;
    ip = mon_lengths[yleap];
33d20d20:	e3550000 	cmp	r5, #0	; 0x0
33d20d24:	e59f0240 	ldr	r0, [pc, #576]	; 33d20f6c <jffs2_1pass_ls+0x880>
33d20d28:	13a01030 	movne	r1, #48	; 0x30
33d20d2c:	03a01000 	moveq	r1, #0	; 0x0
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d30:	e7912000 	ldr	r2, [r1, r0]
	    yleap = isleap(y);
	    days += year_lengths[yleap];
	} while (days < 0);
    }

    res->tm_year = y - YEAR_BASE;
33d20d34:	e2443e76 	sub	r3, r4, #1888	; 0x760
    res->tm_yday = days;
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d38:	e15a0002 	cmp	sl, r2
	    yleap = isleap(y);
	    days += year_lengths[yleap];
	} while (days < 0);
    }

    res->tm_year = y - YEAR_BASE;
33d20d3c:	e243300c 	sub	r3, r3, #12	; 0xc
    res->tm_yday = days;
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d40:	e3a02000 	mov	r2, #0	; 0x0
	    yleap = isleap(y);
	    days += year_lengths[yleap];
	} while (days < 0);
    }

    res->tm_year = y - YEAR_BASE;
33d20d44:	e5893014 	str	r3, [r9, #20]
    res->tm_yday = days;
33d20d48:	e589a01c 	str	sl, [r9, #28]
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d4c:	e5892010 	str	r2, [r9, #16]
	} while (days < 0);
    }

    res->tm_year = y - YEAR_BASE;
    res->tm_yday = days;
    ip = mon_lengths[yleap];
33d20d50:	e0811000 	add	r1, r1, r0
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d54:	ba000007 	blt	33d20d78 <jffs2_1pass_ls+0x68c>
33d20d58:	e1a00002 	mov	r0, r2
	days -= ip[res->tm_mon];
33d20d5c:	e7912100 	ldr	r2, [r1, r0, lsl #2]
    }

    res->tm_year = y - YEAR_BASE;
    res->tm_yday = days;
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d60:	e2800001 	add	r0, r0, #1	; 0x1
33d20d64:	e7913100 	ldr	r3, [r1, r0, lsl #2]
	days -= ip[res->tm_mon];
33d20d68:	e062a00a 	rsb	sl, r2, sl
    }

    res->tm_year = y - YEAR_BASE;
    res->tm_yday = days;
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
33d20d6c:	e15a0003 	cmp	sl, r3
33d20d70:	aafffff9 	bge	33d20d5c <jffs2_1pass_ls+0x670>
33d20d74:	e5890010 	str	r0, [r9, #16]
    static _CONST char mon_name[12][3] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    sprintf (result, "%.3s %.3s %.2d %.2d:%.2d:%.2d %d\n",
33d20d78:	e5993018 	ldr	r3, [r9, #24]
33d20d7c:	e599e014 	ldr	lr, [r9, #20]
33d20d80:	e59f21e8 	ldr	r2, [pc, #488]	; 33d20f70 <jffs2_1pass_ls+0x884>
33d20d84:	e5991010 	ldr	r1, [r9, #16]
33d20d88:	e0833083 	add	r3, r3, r3, lsl #1
33d20d8c:	e5995008 	ldr	r5, [r9, #8]
33d20d90:	e5996004 	ldr	r6, [r9, #4]
33d20d94:	e5997000 	ldr	r7, [r9]
33d20d98:	e0832002 	add	r2, r3, r2
33d20d9c:	e28eee76 	add	lr, lr, #1888	; 0x760
33d20da0:	e59f31cc 	ldr	r3, [pc, #460]	; 33d20f74 <jffs2_1pass_ls+0x888>
33d20da4:	e28ee00c 	add	lr, lr, #12	; 0xc
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
	days -= ip[res->tm_mon];
    res->tm_mday = days + 1;

    /* set daylight saving time flag */
    res->tm_isdst = -1;
33d20da8:	e3e0c000 	mvn	ip, #0	; 0x0
    static _CONST char mon_name[12][3] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    sprintf (result, "%.3s %.3s %.2d %.2d:%.2d:%.2d %d\n",
33d20dac:	e0811081 	add	r1, r1, r1, lsl #1
    res->tm_year = y - YEAR_BASE;
    res->tm_yday = days;
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
	days -= ip[res->tm_mon];
    res->tm_mday = days + 1;
33d20db0:	e28a4001 	add	r4, sl, #1	; 0x1
    static _CONST char mon_name[12][3] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    sprintf (result, "%.3s %.3s %.2d %.2d:%.2d:%.2d %d\n",
33d20db4:	e0813003 	add	r3, r1, r3
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
	days -= ip[res->tm_mon];
    res->tm_mday = days + 1;

    /* set daylight saving time flag */
    res->tm_isdst = -1;
33d20db8:	e589c020 	str	ip, [r9, #32]
    static _CONST char mon_name[12][3] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    sprintf (result, "%.3s %.3s %.2d %.2d:%.2d:%.2d %d\n",
33d20dbc:	e59f11b4 	ldr	r1, [pc, #436]	; 33d20f78 <jffs2_1pass_ls+0x88c>
33d20dc0:	e58de010 	str	lr, [sp, #16]
33d20dc4:	e88d00f0 	stm	sp, {r4, r5, r6, r7}
33d20dc8:	e28d0050 	add	r0, sp, #80	; 0x50
    res->tm_year = y - YEAR_BASE;
    res->tm_yday = days;
    ip = mon_lengths[yleap];
    for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
	days -= ip[res->tm_mon];
    res->tm_mday = days + 1;
33d20dcc:	e589400c 	str	r4, [r9, #12]
    static _CONST char mon_name[12][3] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    sprintf (result, "%.3s %.3s %.2d %.2d:%.2d:%.2d %d\n",
33d20dd0:	ebffe7c7 	bl	33d1acf4 <sprintf>
	if (st->st_mtime == (time_t)(-1)) /* some ctimes really hate -1 */
		st->st_mtime = 1;

	ctime_r((time_t *)&st->st_mtime, s/*,64*/); /* newlib ctime doesn't have buflen */

	if ((p = strchr(s,'\n')) != NULL) *p = '\0';
33d20dd4:	e3a0100a 	mov	r1, #10	; 0xa
33d20dd8:	e28d0050 	add	r0, sp, #80	; 0x50
33d20ddc:	ebffe4bf 	bl	33d1a0e0 <strchr>
33d20de0:	e3500000 	cmp	r0, #0	; 0x0
33d20de4:	13a03000 	movne	r3, #0	; 0x0
33d20de8:	15c03000 	strbne	r3, [r0]
	if ((p = strchr(s,'\r')) != NULL) *p = '\0';
33d20dec:	e3a0100d 	mov	r1, #13	; 0xd
33d20df0:	e28d0050 	add	r0, sp, #80	; 0x50
33d20df4:	ebffe4b9 	bl	33d1a0e0 <strchr>
33d20df8:	e3500000 	cmp	r0, #0	; 0x0
33d20dfc:	13a03000 	movne	r3, #0	; 0x0
33d20e00:	15c03000 	strbne	r3, [r0]
/*
	printf("%6lo %s %8ld %s %s\n", st->st_mode, mkmodestr(st->st_mode, str),
		st->st_size, s, name);
*/

	printf(" %s %8ld %s %s", mkmodestr(st->st_mode,str), st->st_size, s, name);
33d20e04:	e28d1090 	add	r1, sp, #144	; 0x90
33d20e08:	e1dd0abc 	ldrh	r0, [sp, #172]
33d20e0c:	ebfffc13 	bl	33d1fe60 <mkmodestr>
33d20e10:	e28d3050 	add	r3, sp, #80	; 0x50
33d20e14:	e1a01000 	mov	r1, r0
33d20e18:	e28dc0e4 	add	ip, sp, #228	; 0xe4
33d20e1c:	e59d20b8 	ldr	r2, [sp, #184]
33d20e20:	e59f0154 	ldr	r0, [pc, #340]	; 33d20f7c <jffs2_1pass_ls+0x890>
33d20e24:	e58dc000 	str	ip, [sp]
33d20e28:	ebffd866 	bl	33d16fc8 <printf>
	/* neither dsize nor isize help us.. do it the long way */
	st.st_size = jffs2_1pass_read_inode(pL, i->ino, NULL);

	dump_stat(&st, fname);

	if (d->type == DT_LNK) {
33d20e2c:	e5db301d 	ldrb	r3, [fp, #29]
33d20e30:	e353000a 	cmp	r3, #10	; 0xa
33d20e34:	1a00000e 	bne	33d20e74 <jffs2_1pass_ls+0x788>
		unsigned char *src = (unsigned char *) (&i[1]);
	        putstr(" -> ");
33d20e38:	e59f0104 	ldr	r0, [pc, #260]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20e3c:	e59f113c 	ldr	r1, [pc, #316]	; 33d20f80 <jffs2_1pass_ls+0x894>
33d20e40:	ebffd860 	bl	33d16fc8 <printf>
		putnstr(src, (int)i->dsize);
33d20e44:	e59d0014 	ldr	r0, [sp, #20]
33d20e48:	e5d03035 	ldrb	r3, [r0, #53]
33d20e4c:	e5d01034 	ldrb	r1, [r0, #52]
33d20e50:	e5d02036 	ldrb	r2, [r0, #54]
33d20e54:	e1811403 	orr	r1, r1, r3, lsl #8
33d20e58:	e5d03037 	ldrb	r3, [r0, #55]
33d20e5c:	e1811802 	orr	r1, r1, r2, lsl #16
33d20e60:	e1811c03 	orr	r1, r1, r3, lsl #24
33d20e64:	e1a02001 	mov	r2, r1
	st.st_size = jffs2_1pass_read_inode(pL, i->ino, NULL);

	dump_stat(&st, fname);

	if (d->type == DT_LNK) {
		unsigned char *src = (unsigned char *) (&i[1]);
33d20e68:	e2803044 	add	r3, r0, #68	; 0x44
	        putstr(" -> ");
		putnstr(src, (int)i->dsize);
33d20e6c:	e59f0110 	ldr	r0, [pc, #272]	; 33d20f84 <jffs2_1pass_ls+0x898>
33d20e70:	ebffd854 	bl	33d16fc8 <printf>
	}

	putstr("\r\n");
33d20e74:	e59f00c8 	ldr	r0, [pc, #200]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20e78:	e59f1108 	ldr	r1, [pc, #264]	; 33d20f88 <jffs2_1pass_ls+0x89c>
33d20e7c:	ebffd851 	bl	33d16fc8 <printf>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d20e80:	e59f30c0 	ldr	r3, [pc, #192]	; 33d20f48 <jffs2_1pass_ls+0x85c>
33d20e84:	e5933000 	ldr	r3, [r3]
33d20e88:	e5933020 	ldr	r3, [r3, #32]
33d20e8c:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d20e90:	e5d33008 	ldrb	r3, [r3, #8]
33d20e94:	e3530002 	cmp	r3, #2	; 0x2
33d20e98:	1a000009 	bne	33d20ec4 <jffs2_1pass_ls+0x7d8>
33d20e9c:	e59d0014 	ldr	r0, [sp, #20]
33d20ea0:	ebfffa56 	bl	33d1f800 <put_fl_mem_nand>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d20ea4:	e59f309c 	ldr	r3, [pc, #156]	; 33d20f48 <jffs2_1pass_ls+0x85c>
33d20ea8:	e5933000 	ldr	r3, [r3]
33d20eac:	e5933020 	ldr	r3, [r3, #32]
33d20eb0:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d20eb4:	e5d33008 	ldrb	r3, [r3, #8]
33d20eb8:	e3530002 	cmp	r3, #2	; 0x2
33d20ebc:	01a0000b 	moveq	r0, fp
33d20ec0:	0bfffa4e 	bleq	33d1f800 <put_fl_mem_nand>
jffs2_1pass_list_inodes(struct b_lists * pL, u32 pino)
{
	struct b_node *b;
	struct jffs2_raw_dirent *jDir;

	for (b = pL->dir.listHead; b; b = b->next) {
33d20ec4:	e59d1018 	ldr	r1, [sp, #24]
33d20ec8:	eafffe67 	b	33d2086c <jffs2_1pass_ls+0x180>
}

/* list inodes with the given pino */
static u32
jffs2_1pass_list_inodes(struct b_lists * pL, u32 pino)
{
33d20ecc:	e59d201c 	ldr	r2, [sp, #28]
33d20ed0:	e3520000 	cmp	r2, #0	; 0x0
#if 0
	putLabeledWord("found file at inode = ", inode);
	putLabeledWord("read_inode returns = ", ret);
#endif

	return ret;
33d20ed4:	13a00001 	movne	r0, #1	; 0x1
}

/* list inodes with the given pino */
static u32
jffs2_1pass_list_inodes(struct b_lists * pL, u32 pino)
{
33d20ed8:	1a000013 	bne	33d20f2c <jffs2_1pass_ls+0x840>
		putstr("\r\n");
		return 0;
	}
	/* this is for the bare filename, directories have already been mapped */
	if (!(pino = jffs2_1pass_list_inodes(pL, pino))) {
		putstr("find_inode failed for name=");
33d20edc:	e59f0060 	ldr	r0, [pc, #96]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20ee0:	e59f1058 	ldr	r1, [pc, #88]	; 33d20f40 <jffs2_1pass_ls+0x854>
33d20ee4:	ebffd837 	bl	33d16fc8 <printf>
		putstr(tmp);
33d20ee8:	e59f0054 	ldr	r0, [pc, #84]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20eec:	e28d1fca 	add	r1, sp, #808	; 0x328
33d20ef0:	ea000004 	b	33d20f08 <jffs2_1pass_ls+0x81c>
			tmp[i] = c[i + 1];
		tmp[i] = '\0';
		/* only a failure if we arent looking at top level */
		if (!(pino = jffs2_1pass_find_inode(pL, working_tmp, pino)) &&
		    (working_tmp[0])) {
			putstr("find_inode failed for name=");
33d20ef4:	e59f1044 	ldr	r1, [pc, #68]	; 33d20f40 <jffs2_1pass_ls+0x854>
33d20ef8:	e59f0044 	ldr	r0, [pc, #68]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20efc:	ebffd831 	bl	33d16fc8 <printf>
			putstr(working_tmp);
33d20f00:	e1a01009 	mov	r1, r9
33d20f04:	e59f0038 	ldr	r0, [pc, #56]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20f08:	ebffd82e 	bl	33d16fc8 <printf>
			putstr("\r\n");
33d20f0c:	e59f0030 	ldr	r0, [pc, #48]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20f10:	e59f1070 	ldr	r1, [pc, #112]	; 33d20f88 <jffs2_1pass_ls+0x89c>
33d20f14:	ebffd82b 	bl	33d16fc8 <printf>
33d20f18:	e59d401c 	ldr	r4, [sp, #28]

	if (! (pl = jffs2_get_list(part, "ls")))
		return 0;

	if (! (inode = jffs2_1pass_search_list_inodes(pl, fname, 1))) {
		putstr("ls: Failed to scan jffs2 file structure\r\n");
33d20f1c:	e59f0020 	ldr	r0, [pc, #32]	; 33d20f44 <jffs2_1pass_ls+0x858>
33d20f20:	e59f1064 	ldr	r1, [pc, #100]	; 33d20f8c <jffs2_1pass_ls+0x8a0>
33d20f24:	ebffd827 	bl	33d16fc8 <printf>
		return 0;
33d20f28:	e1a00004 	mov	r0, r4
	putLabeledWord("found file at inode = ", inode);
	putLabeledWord("read_inode returns = ", ret);
#endif

	return ret;
}
33d20f2c:	e28dd028 	add	sp, sp, #40	; 0x28
33d20f30:	e28ddb01 	add	sp, sp, #1024	; 0x400
33d20f34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d20f38:	33d29164 	.word	0x33d29164
33d20f3c:	fffffe00 	.word	0xfffffe00
33d20f40:	33d2d5bc 	.word	0x33d2d5bc
33d20f44:	33d2c2fc 	.word	0x33d2c2fc
33d20f48:	33d6264c 	.word	0x33d6264c
33d20f4c:	33d62554 	.word	0x33d62554
33d20f50:	33d2d530 	.word	0x33d2d530
33d20f54:	33d2d5d8 	.word	0x33d2d5d8
33d20f58:	fffffc84 	.word	0xfffffc84
33d20f5c:	00015180 	.word	0x00015180
33d20f60:	0001517f 	.word	0x0001517f
33d20f64:	000007b2 	.word	0x000007b2
33d20f68:	33d2506c 	.word	0x33d2506c
33d20f6c:	33d2500c 	.word	0x33d2500c
33d20f70:	33d25074 	.word	0x33d25074
33d20f74:	33d25089 	.word	0x33d25089
33d20f78:	33d2d6e4 	.word	0x33d2d6e4
33d20f7c:	33d2d708 	.word	0x33d2d708
33d20f80:	33d2d718 	.word	0x33d2d718
33d20f84:	33d2d33c 	.word	0x33d2d33c
33d20f88:	33d2bbb8 	.word	0x33d2bbb8
33d20f8c:	33d2d720 	.word	0x33d2d720

33d20f90 <jffs2_1pass_load>:


/* Load a file from flash into memory. fname can be a full path */
u32
jffs2_1pass_load(char *dest, struct part_info * part, const char *fname)
{
33d20f90:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d20f94:	e24ddf43 	sub	sp, sp, #268	; 0x10c
33d20f98:	e58d0008 	str	r0, [sp, #8]

	struct b_lists *pl;
	long ret = 1;
	u32 inode;

	if (! (pl  = jffs2_get_list(part, "load")))
33d20f9c:	e1a00001 	mov	r0, r1
33d20fa0:	e59f13a8 	ldr	r1, [pc, #936]	; 33d21350 <jffs2_1pass_load+0x3c0>


/* Load a file from flash into memory. fname can be a full path */
u32
jffs2_1pass_load(char *dest, struct part_info * part, const char *fname)
{
33d20fa4:	e1a04002 	mov	r4, r2

	struct b_lists *pl;
	long ret = 1;
	u32 inode;

	if (! (pl  = jffs2_get_list(part, "load")))
33d20fa8:	ebfffc7c 	bl	33d201a0 <jffs2_get_list>
33d20fac:	e2509000 	subs	r9, r0, #0	; 0x0
u32
jffs2_1pass_load(char *dest, struct part_info * part, const char *fname)
{

	struct b_lists *pl;
	long ret = 1;
33d20fb0:	e3a02001 	mov	r2, #1	; 0x1
	u32 inode;

	if (! (pl  = jffs2_get_list(part, "load")))
		return 0;
33d20fb4:	01a00009 	moveq	r0, r9

	struct b_lists *pl;
	long ret = 1;
	u32 inode;

	if (! (pl  = jffs2_get_list(part, "load")))
33d20fb8:	0a0000e2 	beq	33d21348 <jffs2_1pass_load+0x3b8>
		return 0;

	if (! (inode = jffs2_1pass_search_inode(pl, fname, 1))) {
33d20fbc:	e1a01004 	mov	r1, r4
33d20fc0:	ebfffbee 	bl	33d1ff80 <jffs2_1pass_search_inode>
33d20fc4:	e3500000 	cmp	r0, #0	; 0x0
33d20fc8:	e58d0004 	str	r0, [sp, #4]
33d20fcc:	1a000004 	bne	33d20fe4 <jffs2_1pass_load+0x54>
		putstr("load: Failed to find inode\r\n");
33d20fd0:	e59f037c 	ldr	r0, [pc, #892]	; 33d21354 <jffs2_1pass_load+0x3c4>
33d20fd4:	e59f137c 	ldr	r1, [pc, #892]	; 33d21358 <jffs2_1pass_load+0x3c8>
33d20fd8:	ebffd7fa 	bl	33d16fc8 <printf>
		return 0;
33d20fdc:	e59d0004 	ldr	r0, [sp, #4]
33d20fe0:	ea0000d8 	b	33d21348 <jffs2_1pass_load+0x3b8>
	u32 version = 0;
	u32 pino;
	unsigned char *src;

	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next) {
33d20fe4:	e599a004 	ldr	sl, [r9, #4]
{
	struct b_node *b;
	struct b_node *b2;
	struct jffs2_raw_dirent *jDir;
	struct jffs2_raw_inode *jNode;
	u8 jDirFoundType = 0;
33d20fe8:	e3a0b000 	mov	fp, #0	; 0x0
	u32 version = 0;
	u32 pino;
	unsigned char *src;

	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next) {
33d20fec:	e15a000b 	cmp	sl, fp
	struct b_node *b2;
	struct jffs2_raw_dirent *jDir;
	struct jffs2_raw_inode *jNode;
	u8 jDirFoundType = 0;
	u32 jDirFoundIno = 0;
	u32 jDirFoundPino = 0;
33d20ff0:	e58db000 	str	fp, [sp]
	struct b_node *b;
	struct b_node *b2;
	struct jffs2_raw_dirent *jDir;
	struct jffs2_raw_inode *jNode;
	u8 jDirFoundType = 0;
	u32 jDirFoundIno = 0;
33d20ff4:	e1a0500b 	mov	r5, fp
	u32 jDirFoundPino = 0;
	char tmp[256];
	u32 version = 0;
33d20ff8:	e1a0600b 	mov	r6, fp
	u32 pino;
	unsigned char *src;

	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next) {
33d20ffc:	0a000064 	beq	33d21194 <jffs2_1pass_load+0x204>
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d21000:	e59f1354 	ldr	r1, [pc, #852]	; 33d2135c <jffs2_1pass_load+0x3cc>
33d21004:	e5913000 	ldr	r3, [r1]
33d21008:	e5933020 	ldr	r3, [r3, #32]
33d2100c:	e5932008 	ldr	r2, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d21010:	e5d23008 	ldrb	r3, [r2, #8]
33d21014:	e3530001 	cmp	r3, #1	; 0x1
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d21018:	e59a4000 	ldr	r4, [sl]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2101c:	1a000007 	bne	33d21040 <jffs2_1pass_load+0xb0>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d21020:	e5d23009 	ldrb	r3, [r2, #9]
33d21024:	e59f2334 	ldr	r2, [pc, #820]	; 33d21360 <jffs2_1pass_load+0x3d0>
33d21028:	e0833083 	add	r3, r3, r3, lsl #1
33d2102c:	e0833183 	add	r3, r3, r3, lsl #3
33d21030:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d21034:	e592300c 	ldr	r3, [r2, #12]
33d21038:	e0847003 	add	r7, r4, r3
static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2103c:	ea000008 	b	33d21064 <jffs2_1pass_load+0xd4>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d21040:	e3530002 	cmp	r3, #2	; 0x2
33d21044:	1a000003 	bne	33d21058 <jffs2_1pass_load+0xc8>
33d21048:	e1a00004 	mov	r0, r4
33d2104c:	ebfff9cc 	bl	33d1f784 <get_node_mem_nand>
33d21050:	e1a07000 	mov	r7, r0
33d21054:	ea000002 	b	33d21064 <jffs2_1pass_load+0xd4>
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d21058:	e59f0304 	ldr	r0, [pc, #772]	; 33d21364 <jffs2_1pass_load+0x3d4>
33d2105c:	ebffd7d9 	bl	33d16fc8 <printf>
33d21060:	e1a07004 	mov	r7, r4
	unsigned char *src;

	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next) {
		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
		if (ino == jDir->ino) {
33d21064:	e5d72015 	ldrb	r2, [r7, #21]
33d21068:	e5d73014 	ldrb	r3, [r7, #20]
33d2106c:	e5d71016 	ldrb	r1, [r7, #22]
33d21070:	e1833402 	orr	r3, r3, r2, lsl #8
33d21074:	e5d72017 	ldrb	r2, [r7, #23]
33d21078:	e1833801 	orr	r3, r3, r1, lsl #16
33d2107c:	e1833c02 	orr	r3, r3, r2, lsl #24
33d21080:	e59d2004 	ldr	r2, [sp, #4]
33d21084:	e1520003 	cmp	r2, r3
33d21088:	1a000034 	bne	33d21160 <jffs2_1pass_load+0x1d0>
		    	if (jDir->version < version) {
33d2108c:	e5d72011 	ldrb	r2, [r7, #17]
33d21090:	e5d73010 	ldrb	r3, [r7, #16]
33d21094:	e5d71012 	ldrb	r1, [r7, #18]
33d21098:	e1833402 	orr	r3, r3, r2, lsl #8
33d2109c:	e5d72013 	ldrb	r2, [r7, #19]
33d210a0:	e1833801 	orr	r3, r3, r1, lsl #16
33d210a4:	e1833c02 	orr	r3, r3, r2, lsl #24
33d210a8:	e1530006 	cmp	r3, r6
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d210ac:	359f12a8 	ldrcc	r1, [pc, #680]	; 33d2135c <jffs2_1pass_load+0x3cc>
33d210b0:	35913000 	ldrcc	r3, [r1]

	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next) {
		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
		if (ino == jDir->ino) {
		    	if (jDir->version < version) {
33d210b4:	3a00002b 	bcc	33d21168 <jffs2_1pass_load+0x1d8>
				put_fl_mem(jDir);
				continue;
			}

			if (jDir->version == version && jDirFoundType) {
33d210b8:	13a03000 	movne	r3, #0	; 0x0
33d210bc:	03a03001 	moveq	r3, #1	; 0x1
33d210c0:	e3550000 	cmp	r5, #0	; 0x0
33d210c4:	03a03000 	moveq	r3, #0	; 0x0
33d210c8:	12033001 	andne	r3, r3, #1	; 0x1
33d210cc:	e3530000 	cmp	r3, #0	; 0x0
33d210d0:	0a00000b 	beq	33d21104 <jffs2_1pass_load+0x174>
			    	/* I'm pretty sure this isn't legal */
				putstr(" ** ERROR ** ");
33d210d4:	e59f0278 	ldr	r0, [pc, #632]	; 33d21354 <jffs2_1pass_load+0x3c4>
33d210d8:	e59f1288 	ldr	r1, [pc, #648]	; 33d21368 <jffs2_1pass_load+0x3d8>
33d210dc:	ebffd7b9 	bl	33d16fc8 <printf>
				putnstr(jDir->name, jDir->nsize);
33d210e0:	e5d7101c 	ldrb	r1, [r7, #28]
33d210e4:	e59f0280 	ldr	r0, [pc, #640]	; 33d2136c <jffs2_1pass_load+0x3dc>
33d210e8:	e1a02001 	mov	r2, r1
33d210ec:	e2873028 	add	r3, r7, #40	; 0x28
33d210f0:	ebffd7b4 	bl	33d16fc8 <printf>
				putLabeledWord(" has dup version (resolve) = ",
33d210f4:	e1a02006 	mov	r2, r6
33d210f8:	e59f0270 	ldr	r0, [pc, #624]	; 33d21370 <jffs2_1pass_load+0x3e0>
33d210fc:	e59f1270 	ldr	r1, [pc, #624]	; 33d21374 <jffs2_1pass_load+0x3e4>
33d21100:	ebffd7b0 	bl	33d16fc8 <printf>
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
			jDirFoundPino = jDir->pino;
33d21104:	e5d7c00d 	ldrb	ip, [r7, #13]
33d21108:	e5d7200c 	ldrb	r2, [r7, #12]
33d2110c:	e5d7500e 	ldrb	r5, [r7, #14]
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d21110:	e5d7e015 	ldrb	lr, [r7, #21]
			jDirFoundPino = jDir->pino;
			version = jDir->version;
33d21114:	e5d70011 	ldrb	r0, [r7, #17]
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d21118:	e5d71014 	ldrb	r1, [r7, #20]
			jDirFoundPino = jDir->pino;
			version = jDir->version;
33d2111c:	e5d73010 	ldrb	r3, [r7, #16]
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
			jDirFoundPino = jDir->pino;
33d21120:	e182240c 	orr	r2, r2, ip, lsl #8
33d21124:	e5d7c00f 	ldrb	ip, [r7, #15]
			version = jDir->version;
33d21128:	e5d76012 	ldrb	r6, [r7, #18]
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d2112c:	e5d74016 	ldrb	r4, [r7, #22]
			jDirFoundPino = jDir->pino;
33d21130:	e1822805 	orr	r2, r2, r5, lsl #16
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d21134:	e181140e 	orr	r1, r1, lr, lsl #8
			jDirFoundPino = jDir->pino;
			version = jDir->version;
33d21138:	e1833400 	orr	r3, r3, r0, lsl #8
33d2113c:	e5d7e013 	ldrb	lr, [r7, #19]
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d21140:	e5d70017 	ldrb	r0, [r7, #23]
			jDirFoundPino = jDir->pino;
33d21144:	e182cc0c 	orr	ip, r2, ip, lsl #24
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d21148:	e1811804 	orr	r1, r1, r4, lsl #16
			jDirFoundPino = jDir->pino;
			version = jDir->version;
33d2114c:	e1833806 	orr	r3, r3, r6, lsl #16
				putnstr(jDir->name, jDir->nsize);
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
33d21150:	e5d7501d 	ldrb	r5, [r7, #29]
			jDirFoundIno = jDir->ino;
			jDirFoundPino = jDir->pino;
33d21154:	e58dc000 	str	ip, [sp]
				putLabeledWord(" has dup version (resolve) = ",
					version);
			}

			jDirFoundType = jDir->type;
			jDirFoundIno = jDir->ino;
33d21158:	e181bc00 	orr	fp, r1, r0, lsl #24
			jDirFoundPino = jDir->pino;
			version = jDir->version;
33d2115c:	e1836c0e 	orr	r6, r3, lr, lsl #24
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d21160:	e59f21f4 	ldr	r2, [pc, #500]	; 33d2135c <jffs2_1pass_load+0x3cc>
33d21164:	e5923000 	ldr	r3, [r2]
33d21168:	e5933020 	ldr	r3, [r3, #32]
33d2116c:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d21170:	e5d33008 	ldrb	r3, [r3, #8]
33d21174:	e3530002 	cmp	r3, #2	; 0x2
33d21178:	01a00007 	moveq	r0, r7
33d2117c:	0bfff99f 	bleq	33d1f800 <put_fl_mem_nand>
	u32 version = 0;
	u32 pino;
	unsigned char *src;

	/* we need to search all and return the inode with the highest version */
	for(b = pL->dir.listHead; b; b = b->next) {
33d21180:	e59aa004 	ldr	sl, [sl, #4]
33d21184:	e35a0000 	cmp	sl, #0	; 0x0
33d21188:	1affff9c 	bne	33d21000 <jffs2_1pass_load+0x70>
			version = jDir->version;
		}
		put_fl_mem(jDir);
	}
	/* now we found the right entry again. (shoulda returned inode*) */
	if (jDirFoundType != DT_LNK)
33d2118c:	e355000a 	cmp	r5, #10	; 0xa
33d21190:	0a000001 	beq	33d2119c <jffs2_1pass_load+0x20c>
33d21194:	e1a0400b 	mov	r4, fp
33d21198:	ea000058 	b	33d21300 <jffs2_1pass_load+0x370>
		return jDirFoundIno;

	/* it's a soft link so we follow it again. */
	b2 = pL->frag.listHead;
33d2119c:	e5995014 	ldr	r5, [r9, #20]
static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;

	if (id->type == MTD_DEV_TYPE_NAND)
33d211a0:	e3550000 	cmp	r5, #0	; 0x0
33d211a4:	0a00004a 	beq	33d212d4 <jffs2_1pass_load+0x344>
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;
33d211a8:	e59f61ac 	ldr	r6, [pc, #428]	; 33d2135c <jffs2_1pass_load+0x3cc>
33d211ac:	e5963000 	ldr	r3, [r6]
33d211b0:	e5933020 	ldr	r3, [r3, #32]
33d211b4:	e5933008 	ldr	r3, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d211b8:	e5d32008 	ldrb	r2, [r3, #8]
33d211bc:	e3520001 	cmp	r2, #1	; 0x1
	printf("get_fl_mem: unknown device type, using raw offset!\n");
	return (void*)off;
}

static inline void *get_node_mem(u32 off)
{
33d211c0:	e5951000 	ldr	r1, [r5]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d211c4:	1a000007 	bne	33d211e8 <jffs2_1pass_load+0x258>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d211c8:	e5d33009 	ldrb	r3, [r3, #9]
33d211cc:	e59f218c 	ldr	r2, [pc, #396]	; 33d21360 <jffs2_1pass_load+0x3d0>
33d211d0:	e0833083 	add	r3, r3, r3, lsl #1
33d211d4:	e0833183 	add	r3, r3, r3, lsl #3
33d211d8:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d211dc:	e592300c 	ldr	r3, [r2, #12]
33d211e0:	e0814003 	add	r4, r1, r3
static inline void *get_node_mem(u32 off)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d211e4:	ea000008 	b	33d2120c <jffs2_1pass_load+0x27c>
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d211e8:	e3520002 	cmp	r2, #2	; 0x2
33d211ec:	e1a00001 	mov	r0, r1
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d211f0:	e1a04001 	mov	r4, r1
	if (id->type == MTD_DEV_TYPE_NOR)
		return get_node_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d211f4:	1a000002 	bne	33d21204 <jffs2_1pass_load+0x274>
33d211f8:	ebfff961 	bl	33d1f784 <get_node_mem_nand>
33d211fc:	e1a04000 	mov	r4, r0
33d21200:	ea000001 	b	33d2120c <jffs2_1pass_load+0x27c>
		return get_node_mem_nand(off);
#endif

	printf("get_node_mem: unknown device type, using raw offset!\n");
33d21204:	e59f0158 	ldr	r0, [pc, #344]	; 33d21364 <jffs2_1pass_load+0x3d4>
33d21208:	ebffd76e 	bl	33d16fc8 <printf>

	/* it's a soft link so we follow it again. */
	b2 = pL->frag.listHead;
	while (b2) {
		jNode = (struct jffs2_raw_inode *) get_node_mem(b2->offset);
		if (jNode->ino == jDirFoundIno) {
33d2120c:	e5d4200d 	ldrb	r2, [r4, #13]
33d21210:	e5d4300c 	ldrb	r3, [r4, #12]
33d21214:	e5d4100e 	ldrb	r1, [r4, #14]
33d21218:	e1833402 	orr	r3, r3, r2, lsl #8
33d2121c:	e5d4200f 	ldrb	r2, [r4, #15]
33d21220:	e1833801 	orr	r3, r3, r1, lsl #16
33d21224:	e1833c02 	orr	r3, r3, r2, lsl #24
33d21228:	e153000b 	cmp	r3, fp
static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;

	if (id->type == MTD_DEV_TYPE_NAND)
33d2122c:	e1a00004 	mov	r0, r4

	/* it's a soft link so we follow it again. */
	b2 = pL->frag.listHead;
	while (b2) {
		jNode = (struct jffs2_raw_inode *) get_node_mem(b2->offset);
		if (jNode->ino == jDirFoundIno) {
33d21230:	1a00001e 	bne	33d212b0 <jffs2_1pass_load+0x320>
			putLabeledWord("\t\t dsize = ", jNode->dsize);
			putstr("\t\t target = ");
			putnstr(src, jNode->dsize);
			putstr("\r\n");
#endif
			strncpy(tmp, (char *)src, jNode->dsize);
33d21234:	e5d43035 	ldrb	r3, [r4, #53]
33d21238:	e5d42034 	ldrb	r2, [r4, #52]
33d2123c:	e5d41036 	ldrb	r1, [r4, #54]
33d21240:	e1822403 	orr	r2, r2, r3, lsl #8
33d21244:	e5d43037 	ldrb	r3, [r4, #55]
33d21248:	e1822801 	orr	r2, r2, r1, lsl #16
33d2124c:	e1822c03 	orr	r2, r2, r3, lsl #24
33d21250:	e2841044 	add	r1, r4, #68	; 0x44
33d21254:	e28d000c 	add	r0, sp, #12	; 0xc
33d21258:	ebffe35e 	bl	33d19fd8 <strncpy>
			tmp[jNode->dsize] = '\0';
33d2125c:	e5d42035 	ldrb	r2, [r4, #53]
33d21260:	e5d43034 	ldrb	r3, [r4, #52]
33d21264:	e5d41036 	ldrb	r1, [r4, #54]
33d21268:	e1833402 	orr	r3, r3, r2, lsl #8
33d2126c:	e5d42037 	ldrb	r2, [r4, #55]
33d21270:	e1833801 	orr	r3, r3, r1, lsl #16
33d21274:	e1833c02 	orr	r3, r3, r2, lsl #24
33d21278:	e28d1f43 	add	r1, sp, #268	; 0x10c
33d2127c:	e0813003 	add	r3, r1, r3
33d21280:	e2433c01 	sub	r3, r3, #256	; 0x100
33d21284:	e3a02000 	mov	r2, #0	; 0x0
33d21288:	e5c32000 	strb	r2, [r3]
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d2128c:	e5963000 	ldr	r3, [r6]
33d21290:	e5933020 	ldr	r3, [r3, #32]
33d21294:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d21298:	e5d33008 	ldrb	r3, [r3, #8]
33d2129c:	e3530002 	cmp	r3, #2	; 0x2
33d212a0:	1a00000b 	bne	33d212d4 <jffs2_1pass_load+0x344>
33d212a4:	e1a00004 	mov	r0, r4
33d212a8:	ebfff954 	bl	33d1f800 <put_fl_mem_nand>
33d212ac:	ea000008 	b	33d212d4 <jffs2_1pass_load+0x344>
}

static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;
33d212b0:	e5963000 	ldr	r3, [r6]
33d212b4:	e5933020 	ldr	r3, [r3, #32]
33d212b8:	e5933008 	ldr	r3, [r3, #8]

	if (id->type == MTD_DEV_TYPE_NAND)
33d212bc:	e5d33008 	ldrb	r3, [r3, #8]
33d212c0:	e3530002 	cmp	r3, #2	; 0x2
			strncpy(tmp, (char *)src, jNode->dsize);
			tmp[jNode->dsize] = '\0';
			put_fl_mem(jNode);
			break;
		}
		b2 = b2->next;
33d212c4:	e5955004 	ldr	r5, [r5, #4]
static inline void put_fl_mem(void *buf)
{
#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	struct mtdids *id = current_part->dev->id;

	if (id->type == MTD_DEV_TYPE_NAND)
33d212c8:	1affffb4 	bne	33d211a0 <jffs2_1pass_load+0x210>
33d212cc:	ebfff94b 	bl	33d1f800 <put_fl_mem_nand>
33d212d0:	eaffffb2 	b	33d211a0 <jffs2_1pass_load+0x210>
		b2 = b2->next;
		put_fl_mem(jNode);
	}
	/* ok so the name of the new file to find is in tmp */
	/* if it starts with a slash it is root based else shared dirs */
	if (tmp[0] == '/')
33d212d4:	e3e030ff 	mvn	r3, #255	; 0xff
33d212d8:	e28d1f43 	add	r1, sp, #268	; 0x10c
33d212dc:	e7d12003 	ldrb	r2, [r1, r3]
		pino = 1;
	else
		pino = jDirFoundPino;
33d212e0:	e59d3000 	ldr	r3, [sp]
33d212e4:	e352002f 	cmp	r2, #47	; 0x2f
33d212e8:	03a03001 	moveq	r3, #1	; 0x1
33d212ec:	e1a02003 	mov	r2, r3
33d212f0:	e1a00009 	mov	r0, r9
33d212f4:	e28d100c 	add	r1, sp, #12	; 0xc
33d212f8:	ebfffb20 	bl	33d1ff80 <jffs2_1pass_search_inode>
33d212fc:	e1a04000 	mov	r4, r0

}

static u32
jffs2_1pass_resolve_inode(struct b_lists * pL, u32 ino)
{
33d21300:	e3540000 	cmp	r4, #0	; 0x0
33d21304:	1a000004 	bne	33d2131c <jffs2_1pass_load+0x38c>
		return 0;
	}

	/* Resolve symlinks */
	if (! (inode = jffs2_1pass_resolve_inode(pl, inode))) {
		putstr("load: Failed to resolve inode structure\r\n");
33d21308:	e59f0044 	ldr	r0, [pc, #68]	; 33d21354 <jffs2_1pass_load+0x3c4>
33d2130c:	e59f1064 	ldr	r1, [pc, #100]	; 33d21378 <jffs2_1pass_load+0x3e8>
33d21310:	ebffd72c 	bl	33d16fc8 <printf>
		return 0;
33d21314:	e1a00004 	mov	r0, r4
33d21318:	ea00000a 	b	33d21348 <jffs2_1pass_load+0x3b8>
	}

	if ((ret = jffs2_1pass_read_inode(pl, inode, dest)) < 0) {
33d2131c:	e59d2008 	ldr	r2, [sp, #8]
33d21320:	e1a00009 	mov	r0, r9
33d21324:	e1a01004 	mov	r1, r4
33d21328:	ebfff982 	bl	33d1f938 <jffs2_1pass_read_inode>
33d2132c:	e2502000 	subs	r2, r0, #0	; 0x0
		return 0;
	}

	DEBUGF ("load: loaded '%s' to 0x%lx (%ld bytes)\n", fname,
				(unsigned long) dest, ret);
	return ret;
33d21330:	a1a00002 	movge	r0, r2
	if (! (inode = jffs2_1pass_resolve_inode(pl, inode))) {
		putstr("load: Failed to resolve inode structure\r\n");
		return 0;
	}

	if ((ret = jffs2_1pass_read_inode(pl, inode, dest)) < 0) {
33d21334:	aa000003 	bge	33d21348 <jffs2_1pass_load+0x3b8>
		putstr("load: Failed to read inode\r\n");
33d21338:	e59f0014 	ldr	r0, [pc, #20]	; 33d21354 <jffs2_1pass_load+0x3c4>
33d2133c:	e59f1038 	ldr	r1, [pc, #56]	; 33d2137c <jffs2_1pass_load+0x3ec>
33d21340:	ebffd720 	bl	33d16fc8 <printf>
		return 0;
33d21344:	e3a00000 	mov	r0, #0	; 0x0
	}

	DEBUGF ("load: loaded '%s' to 0x%lx (%ld bytes)\n", fname,
				(unsigned long) dest, ret);
	return ret;
}
33d21348:	e28ddf43 	add	sp, sp, #268	; 0x10c
33d2134c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d21350:	33d25bc0 	.word	0x33d25bc0
33d21354:	33d2c2fc 	.word	0x33d2c2fc
33d21358:	33d2d74c 	.word	0x33d2d74c
33d2135c:	33d6264c 	.word	0x33d6264c
33d21360:	33d62554 	.word	0x33d62554
33d21364:	33d2d530 	.word	0x33d2d530
33d21368:	33d2d594 	.word	0x33d2d594
33d2136c:	33d2d33c 	.word	0x33d2d33c
33d21370:	33d2d568 	.word	0x33d2d568
33d21374:	33d2d76c 	.word	0x33d2d76c
33d21378:	33d2d78c 	.word	0x33d2d78c
33d2137c:	33d2d7b8 	.word	0x33d2d7b8

33d21380 <jffs2_1pass_info>:

/* Return information about the fs on this partition */
u32
jffs2_1pass_info(struct part_info * part)
{
33d21380:	e92d4070 	push	{r4, r5, r6, lr}
	struct b_jffs2_info info;
	struct b_lists *pl;
	int i;

	if (! (pl  = jffs2_get_list(part, "info")))
33d21384:	e59f1184 	ldr	r1, [pc, #388]	; 33d21510 <jffs2_1pass_info+0x190>
}

/* Return information about the fs on this partition */
u32
jffs2_1pass_info(struct part_info * part)
{
33d21388:	e24dd09c 	sub	sp, sp, #156	; 0x9c
	struct b_jffs2_info info;
	struct b_lists *pl;
	int i;

	if (! (pl  = jffs2_get_list(part, "info")))
33d2138c:	ebfffb83 	bl	33d201a0 <jffs2_get_list>
33d21390:	e3500000 	cmp	r0, #0	; 0x0
33d21394:	0a00005b 	beq	33d21508 <jffs2_1pass_info+0x188>
}


static u32
jffs2_1pass_fill_info(struct b_lists * pL, struct b_jffs2_info * piL)
{
33d21398:	e28d6048 	add	r6, sp, #72	; 0x48
33d2139c:	e3a01000 	mov	r1, #0	; 0x0
33d213a0:	e3a0c006 	mov	ip, #6	; 0x6
	struct jffs2_raw_inode ojNode;
	struct jffs2_raw_inode *jNode;
	int i;

	for (i = 0; i < JFFS2_NUM_COMPR; i++) {
		piL->compr_info[i].num_frags = 0;
33d213a4:	e0812006 	add	r2, r1, r6
33d213a8:	e3a03000 	mov	r3, #0	; 0x0
33d213ac:	e25cc001 	subs	ip, ip, #1	; 0x1
33d213b0:	e7813006 	str	r3, [r1, r6]
		piL->compr_info[i].compr_sum = 0;
		piL->compr_info[i].decompr_sum = 0;
33d213b4:	e5823008 	str	r3, [r2, #8]
	struct jffs2_raw_inode *jNode;
	int i;

	for (i = 0; i < JFFS2_NUM_COMPR; i++) {
		piL->compr_info[i].num_frags = 0;
		piL->compr_info[i].compr_sum = 0;
33d213b8:	e5823004 	str	r3, [r2, #4]
33d213bc:	e281100c 	add	r1, r1, #12	; 0xc
33d213c0:	5afffff7 	bpl	33d213a4 <jffs2_1pass_info+0x24>
		piL->compr_info[i].decompr_sum = 0;
	}

	b = pL->frag.listHead;
33d213c4:	e5905014 	ldr	r5, [r0, #20]
		if (jNode->compr < JFFS2_NUM_COMPR) {
			piL->compr_info[jNode->compr].num_frags++;
			piL->compr_info[jNode->compr].compr_sum += jNode->csize;
			piL->compr_info[jNode->compr].decompr_sum += jNode->dsize;
		}
		b = b->next;
33d213c8:	e1550003 	cmp	r5, r3
33d213cc:	0a00003e 	beq	33d214cc <jffs2_1pass_info+0x14c>
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;
33d213d0:	e59f313c 	ldr	r3, [pc, #316]	; 33d21514 <jffs2_1pass_info+0x194>
33d213d4:	e5933000 	ldr	r3, [r3]
33d213d8:	e5933020 	ldr	r3, [r3, #32]
33d213dc:	e5933008 	ldr	r3, [r3, #8]

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d213e0:	e5d3c008 	ldrb	ip, [r3, #8]
33d213e4:	e35c0001 	cmp	ip, #1	; 0x1
/*
 * Generic jffs2 raw memory and node read routines.
 *
 */
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
33d213e8:	e5954000 	ldr	r4, [r5]
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d213ec:	1a000007 	bne	33d21410 <jffs2_1pass_info+0x90>
{
	u32 addr = off;
	struct mtdids *id = current_part->dev->id;

	extern flash_info_t flash_info[];
	flash_info_t *flash = &flash_info[id->num];
33d213f0:	e5d33009 	ldrb	r3, [r3, #9]
33d213f4:	e59f211c 	ldr	r2, [pc, #284]	; 33d21518 <jffs2_1pass_info+0x198>
33d213f8:	e0833083 	add	r3, r3, r3, lsl #1
33d213fc:	e0833183 	add	r3, r3, r3, lsl #3
33d21400:	e0822103 	add	r2, r2, r3, lsl #2

	addr += flash->start[0];
33d21404:	e592300c 	ldr	r3, [r2, #12]
33d21408:	e084e003 	add	lr, r4, r3
static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
{
	struct mtdids *id = current_part->dev->id;

#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
	if (id->type == MTD_DEV_TYPE_NOR)
33d2140c:	ea00000a 	b	33d2143c <jffs2_1pass_info+0xbc>
		return get_fl_mem_nor(off);
#endif

#if defined(CONFIG_JFFS2_NAND) && (CONFIG_COMMANDS & CFG_CMD_NAND)
	if (id->type == MTD_DEV_TYPE_NAND)
33d21410:	e35c0002 	cmp	ip, #2	; 0x2
33d21414:	e1a00004 	mov	r0, r4
33d21418:	e28d2004 	add	r2, sp, #4	; 0x4
33d2141c:	e3a01044 	mov	r1, #68	; 0x44
33d21420:	1a000002 	bne	33d21430 <jffs2_1pass_info+0xb0>
33d21424:	ebfff866 	bl	33d1f5c4 <get_fl_mem_nand>
33d21428:	e1a0e000 	mov	lr, r0
33d2142c:	ea000002 	b	33d2143c <jffs2_1pass_info+0xbc>
		return get_fl_mem_nand(off, size, ext_buf);
#endif

	printf("get_fl_mem: unknown device type, using raw offset!\n");
33d21430:	e59f00e4 	ldr	r0, [pc, #228]	; 33d2151c <jffs2_1pass_info+0x19c>
33d21434:	ebffd6e3 	bl	33d16fc8 <printf>
33d21438:	e1a0e004 	mov	lr, r4

	b = pL->frag.listHead;
	while (b) {
		jNode = (struct jffs2_raw_inode *) get_fl_mem(b->offset,
			sizeof(ojNode), &ojNode);
		if (jNode->compr < JFFS2_NUM_COMPR) {
33d2143c:	e5de3038 	ldrb	r3, [lr, #56]
33d21440:	e3530006 	cmp	r3, #6	; 0x6
			piL->compr_info[jNode->compr].num_frags++;
33d21444:	e0832083 	add	r2, r3, r3, lsl #1

	b = pL->frag.listHead;
	while (b) {
		jNode = (struct jffs2_raw_inode *) get_fl_mem(b->offset,
			sizeof(ojNode), &ojNode);
		if (jNode->compr < JFFS2_NUM_COMPR) {
33d21448:	8a00001c 	bhi	33d214c0 <jffs2_1pass_info+0x140>
			piL->compr_info[jNode->compr].num_frags++;
33d2144c:	e7963102 	ldr	r3, [r6, r2, lsl #2]
33d21450:	e2833001 	add	r3, r3, #1	; 0x1
33d21454:	e7863102 	str	r3, [r6, r2, lsl #2]
			piL->compr_info[jNode->compr].compr_sum += jNode->csize;
33d21458:	e5de1038 	ldrb	r1, [lr, #56]
33d2145c:	e5de3031 	ldrb	r3, [lr, #49]
33d21460:	e5de2030 	ldrb	r2, [lr, #48]
33d21464:	e5dec032 	ldrb	ip, [lr, #50]
33d21468:	e0811081 	add	r1, r1, r1, lsl #1
33d2146c:	e5de0033 	ldrb	r0, [lr, #51]
33d21470:	e0861101 	add	r1, r6, r1, lsl #2
33d21474:	e1822403 	orr	r2, r2, r3, lsl #8
33d21478:	e182280c 	orr	r2, r2, ip, lsl #16
33d2147c:	e5913004 	ldr	r3, [r1, #4]
33d21480:	e1822c00 	orr	r2, r2, r0, lsl #24
33d21484:	e0833002 	add	r3, r3, r2
33d21488:	e5813004 	str	r3, [r1, #4]
			piL->compr_info[jNode->compr].decompr_sum += jNode->dsize;
33d2148c:	e5de1038 	ldrb	r1, [lr, #56]
33d21490:	e5de3035 	ldrb	r3, [lr, #53]
33d21494:	e5de2034 	ldrb	r2, [lr, #52]
33d21498:	e5dec036 	ldrb	ip, [lr, #54]
33d2149c:	e0811081 	add	r1, r1, r1, lsl #1
33d214a0:	e1822403 	orr	r2, r2, r3, lsl #8
33d214a4:	e0861101 	add	r1, r6, r1, lsl #2
33d214a8:	e5de0037 	ldrb	r0, [lr, #55]
33d214ac:	e5913008 	ldr	r3, [r1, #8]
33d214b0:	e182280c 	orr	r2, r2, ip, lsl #16
33d214b4:	e1822c00 	orr	r2, r2, r0, lsl #24
33d214b8:	e0833002 	add	r3, r3, r2
33d214bc:	e5813008 	str	r3, [r1, #8]
		}
		b = b->next;
33d214c0:	e5955004 	ldr	r5, [r5, #4]
33d214c4:	e3550000 	cmp	r5, #0	; 0x0
33d214c8:	eaffffbf 	b	33d213cc <jffs2_1pass_info+0x4c>

	if (! (pl  = jffs2_get_list(part, "info")))
		return 0;

	jffs2_1pass_fill_info(pl, &info);
	for (i = 0; i < JFFS2_NUM_COMPR; i++) {
33d214cc:	e3a05000 	mov	r5, #0	; 0x0
33d214d0:	e28d409c 	add	r4, sp, #156	; 0x9c
		printf ("Compression: %s\n"
33d214d4:	e59f3044 	ldr	r3, [pc, #68]	; 33d21520 <jffs2_1pass_info+0x1a0>
33d214d8:	e514c04c 	ldr	ip, [r4, #-76]
33d214dc:	e7931105 	ldr	r1, [r3, r5, lsl #2]
33d214e0:	e2442054 	sub	r2, r4, #84	; 0x54
33d214e4:	e892000c 	ldm	r2, {r2, r3}

	if (! (pl  = jffs2_get_list(part, "info")))
		return 0;

	jffs2_1pass_fill_info(pl, &info);
	for (i = 0; i < JFFS2_NUM_COMPR; i++) {
33d214e8:	e2855001 	add	r5, r5, #1	; 0x1
		printf ("Compression: %s\n"
33d214ec:	e59f0030 	ldr	r0, [pc, #48]	; 33d21524 <jffs2_1pass_info+0x1a4>
33d214f0:	e58dc000 	str	ip, [sp]
33d214f4:	ebffd6b3 	bl	33d16fc8 <printf>

	if (! (pl  = jffs2_get_list(part, "info")))
		return 0;

	jffs2_1pass_fill_info(pl, &info);
	for (i = 0; i < JFFS2_NUM_COMPR; i++) {
33d214f8:	e3550006 	cmp	r5, #6	; 0x6
33d214fc:	e284400c 	add	r4, r4, #12	; 0xc
33d21500:	dafffff3 	ble	33d214d4 <jffs2_1pass_info+0x154>
			compr_names[i],
			info.compr_info[i].num_frags,
			info.compr_info[i].compr_sum,
			info.compr_info[i].decompr_sum);
	}
	return 1;
33d21504:	e3a00001 	mov	r0, #1	; 0x1
}
33d21508:	e28dd09c 	add	sp, sp, #156	; 0x9c
33d2150c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d21510:	33d2acb0 	.word	0x33d2acb0
33d21514:	33d6264c 	.word	0x33d6264c
33d21518:	33d62554 	.word	0x33d62554
33d2151c:	33d2d5d8 	.word	0x33d2d5d8
33d21520:	33d3691c 	.word	0x33d3691c
33d21524:	33d2d7d8 	.word	0x33d2d7d8

33d21528 <rtime_decompress>:

#include <jffs2/jffs2.h>

void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
		      u32 srclen, u32 destlen)
{
33d21528:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int positions[256];
	int outpos;
	int pos;
	int i;

	outpos = pos = 0;
33d2152c:	e3a04000 	mov	r4, #0	; 0x0

#include <jffs2/jffs2.h>

void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
		      u32 srclen, u32 destlen)
{
33d21530:	e24ddb01 	sub	sp, sp, #1024	; 0x400
33d21534:	e1a07000 	mov	r7, r0
33d21538:	e1a05001 	mov	r5, r1
33d2153c:	e1a06003 	mov	r6, r3
	int positions[256];
	int outpos;
	int pos;
	int i;

	outpos = pos = 0;
33d21540:	e1a00004 	mov	r0, r4
33d21544:	e28d2b01 	add	r2, sp, #1024	; 0x400
33d21548:	e3a0e0ff 	mov	lr, #255	; 0xff

	for (i = 0; i < 256; positions[i++] = 0);
33d2154c:	e3a03000 	mov	r3, #0	; 0x0
33d21550:	e25ee001 	subs	lr, lr, #1	; 0x1
33d21554:	e5023400 	str	r3, [r2, #-1024]
33d21558:	e2822004 	add	r2, r2, #4	; 0x4
33d2155c:	5afffffa 	bpl	33d2154c <rtime_decompress+0x24>
					repeat--;
				}
			} else {
				for (i = 0; i < repeat; i++)
					*(cpage_out + outpos + i) = *(cpage_out + backoffs + i);
				outpos+=repeat;
33d21560:	e1500006 	cmp	r0, r6
33d21564:	2a000021 	bcs	33d215f0 <rtime_decompress+0xc8>
	while (outpos<destlen) {
		unsigned char value;
		int backoffs;
		int repeat;

		value = data_in[pos++];
33d21568:	e7d43007 	ldrb	r3, [r4, r7]
		cpage_out[outpos++] = value; /* first the verbatim copied byte */
33d2156c:	e7c03005 	strb	r3, [r0, r5]
	while (outpos<destlen) {
		unsigned char value;
		int backoffs;
		int repeat;

		value = data_in[pos++];
33d21570:	e2844001 	add	r4, r4, #1	; 0x1
		cpage_out[outpos++] = value; /* first the verbatim copied byte */
		repeat = data_in[pos++];
33d21574:	e7d4c007 	ldrb	ip, [r4, r7]
		backoffs = positions[value];
33d21578:	e28d2b01 	add	r2, sp, #1024	; 0x400
33d2157c:	e0823103 	add	r3, r2, r3, lsl #2
		unsigned char value;
		int backoffs;
		int repeat;

		value = data_in[pos++];
		cpage_out[outpos++] = value; /* first the verbatim copied byte */
33d21580:	e2800001 	add	r0, r0, #1	; 0x1
		repeat = data_in[pos++];
		backoffs = positions[value];

		positions[value]=outpos;
		if (repeat) {
33d21584:	e35c0000 	cmp	ip, #0	; 0x0
		int repeat;

		value = data_in[pos++];
		cpage_out[outpos++] = value; /* first the verbatim copied byte */
		repeat = data_in[pos++];
		backoffs = positions[value];
33d21588:	e5131400 	ldr	r1, [r3, #-1024]
		int backoffs;
		int repeat;

		value = data_in[pos++];
		cpage_out[outpos++] = value; /* first the verbatim copied byte */
		repeat = data_in[pos++];
33d2158c:	e2844001 	add	r4, r4, #1	; 0x1
		backoffs = positions[value];

		positions[value]=outpos;
33d21590:	e5030400 	str	r0, [r3, #-1024]
		if (repeat) {
33d21594:	0afffff1 	beq	33d21560 <rtime_decompress+0x38>
			if (backoffs + repeat >= outpos) {
33d21598:	e081300c 	add	r3, r1, ip
33d2159c:	e1530000 	cmp	r3, r0
33d215a0:	ba000007 	blt	33d215c4 <rtime_decompress+0x9c>
				while(repeat) {
					cpage_out[outpos++] = cpage_out[backoffs++];
33d215a4:	e0813005 	add	r3, r1, r5
33d215a8:	e5d33000 	ldrb	r3, [r3]
					repeat--;
33d215ac:	e25cc001 	subs	ip, ip, #1	; 0x1

		positions[value]=outpos;
		if (repeat) {
			if (backoffs + repeat >= outpos) {
				while(repeat) {
					cpage_out[outpos++] = cpage_out[backoffs++];
33d215b0:	e7c03005 	strb	r3, [r0, r5]
33d215b4:	e2811001 	add	r1, r1, #1	; 0x1
33d215b8:	e2800001 	add	r0, r0, #1	; 0x1
					repeat--;
33d215bc:	1afffff8 	bne	33d215a4 <rtime_decompress+0x7c>
33d215c0:	eaffffe6 	b	33d21560 <rtime_decompress+0x38>
				}
			} else {
				for (i = 0; i < repeat; i++)
33d215c4:	e3a0e000 	mov	lr, #0	; 0x0
33d215c8:	e15e000c 	cmp	lr, ip
33d215cc:	aa000005 	bge	33d215e8 <rtime_decompress+0xc0>
					*(cpage_out + outpos + i) = *(cpage_out + backoffs + i);
33d215d0:	e085200e 	add	r2, r5, lr
33d215d4:	e7d23001 	ldrb	r3, [r2, r1]
				while(repeat) {
					cpage_out[outpos++] = cpage_out[backoffs++];
					repeat--;
				}
			} else {
				for (i = 0; i < repeat; i++)
33d215d8:	e28ee001 	add	lr, lr, #1	; 0x1
33d215dc:	e15e000c 	cmp	lr, ip
					*(cpage_out + outpos + i) = *(cpage_out + backoffs + i);
33d215e0:	e7c23000 	strb	r3, [r2, r0]
33d215e4:	eafffff8 	b	33d215cc <rtime_decompress+0xa4>
				outpos+=repeat;
33d215e8:	e080000c 	add	r0, r0, ip
33d215ec:	eaffffdb 	b	33d21560 <rtime_decompress+0x38>
33d215f0:	e28ddb01 	add	sp, sp, #1024	; 0x400
33d215f4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

33d215f8 <rubin_do_decompress>:
#include <jffs2/compr_rubin.h>


void rubin_do_decompress(unsigned char *bits, unsigned char *in,
			 unsigned char *page_out, __u32 destlen)
{
33d215f8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	register char *curr = (char *)page_out;
	char *end = (char *)(page_out + destlen);
33d215fc:	e0829003 	add	r9, r2, r3


void rubin_do_decompress(unsigned char *bits, unsigned char *in,
			 unsigned char *page_out, __u32 destlen)
{
	register char *curr = (char *)page_out;
33d21600:	e1a05002 	mov	r5, r2
	/* init_rubin */
	q = 0;
	p = (long) (2 * UPPER_BIT_RUBIN);

	/* init_decode */
	rec_q = (in[0] << 8) | in[1];
33d21604:	e5d13001 	ldrb	r3, [r1, #1]
33d21608:	e5d12000 	ldrb	r2, [r1]
				result |= 0x80;
				p -= i0;
				q += i0;
			}
		}
		*(curr++) = result;
33d2160c:	e1550009 	cmp	r5, r9
	/* init_rubin */
	q = 0;
	p = (long) (2 * UPPER_BIT_RUBIN);

	/* init_decode */
	rec_q = (in[0] << 8) | in[1];
33d21610:	e1834402 	orr	r4, r3, r2, lsl #8
#include <jffs2/compr_rubin.h>


void rubin_do_decompress(unsigned char *bits, unsigned char *in,
			 unsigned char *page_out, __u32 destlen)
{
33d21614:	e1a0b000 	mov	fp, r0
	register unsigned long bit;
	register long i0;
	unsigned long i;

	/* init_pushpull */
	temp = *(u32 *) in;
33d21618:	e591a000 	ldr	sl, [r1]
	bit = 16;
33d2161c:	e3a06010 	mov	r6, #16	; 0x10

	/* init_rubin */
	q = 0;
33d21620:	e3a0c000 	mov	ip, #0	; 0x0
	p = (long) (2 * UPPER_BIT_RUBIN);
33d21624:	e3a0e801 	mov	lr, #65536	; 0x10000
				result |= 0x80;
				p -= i0;
				q += i0;
			}
		}
		*(curr++) = result;
33d21628:	28bd8ef0 	popcs	{r4, r5, r6, r7, r9, sl, fp, pc}
	rec_q = (in[0] << 8) | in[1];

	while (curr < end) {
		/* in byte */

		result = 0;
33d2162c:	e3a00000 	mov	r0, #0	; 0x0
		for (i = 0; i < 8; i++) {
33d21630:	e1a07000 	mov	r7, r0
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
				if (bit > 31) {
					u32 *p = (u32 *)in;
					bit = 0;
					temp = *(++p);
					in = (unsigned char *)p;
33d21634:	e31c0902 	tst	ip, #32768	; 0x8000
33d21638:	1a000002 	bne	33d21648 <rubin_do_decompress+0x50>
33d2163c:	e08e300c 	add	r3, lr, ip
33d21640:	e3530902 	cmp	r3, #32768	; 0x8000
33d21644:	8a000010 	bhi	33d2168c <rubin_do_decompress+0x94>
				q &= ~UPPER_BIT_RUBIN;
				q <<= 1;
				p <<= 1;
				rec_q &= ~UPPER_BIT_RUBIN;
				rec_q <<= 1;
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
33d21648:	e2263007 	eor	r3, r6, #7	; 0x7
		result = 0;
		for (i = 0; i < 8; i++) {
			/* decode */

			while ((q & UPPER_BIT_RUBIN) || ((p + q) <= UPPER_BIT_RUBIN)) {
				q &= ~UPPER_BIT_RUBIN;
33d2164c:	e3ccc902 	bic	ip, ip, #32768	; 0x8000
				q <<= 1;
				p <<= 1;
				rec_q &= ~UPPER_BIT_RUBIN;
				rec_q <<= 1;
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
33d21650:	e2866001 	add	r6, r6, #1	; 0x1
				if (bit > 31) {
33d21654:	e356001f 	cmp	r6, #31	; 0x1f
				q &= ~UPPER_BIT_RUBIN;
				q <<= 1;
				p <<= 1;
				rec_q &= ~UPPER_BIT_RUBIN;
				rec_q <<= 1;
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
33d21658:	e1a0333a 	lsr	r3, sl, r3
		for (i = 0; i < 8; i++) {
			/* decode */

			while ((q & UPPER_BIT_RUBIN) || ((p + q) <= UPPER_BIT_RUBIN)) {
				q &= ~UPPER_BIT_RUBIN;
				q <<= 1;
33d2165c:	e1a0c08c 	lsl	ip, ip, #1
				p <<= 1;
				rec_q &= ~UPPER_BIT_RUBIN;
				rec_q <<= 1;
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
33d21660:	e2033001 	and	r3, r3, #1	; 0x1
				if (bit > 31) {
					u32 *p = (u32 *)in;
					bit = 0;
					temp = *(++p);
33d21664:	8591a004 	ldrhi	sl, [r1, #4]

			while ((q & UPPER_BIT_RUBIN) || ((p + q) <= UPPER_BIT_RUBIN)) {
				q &= ~UPPER_BIT_RUBIN;
				q <<= 1;
				p <<= 1;
				rec_q &= ~UPPER_BIT_RUBIN;
33d21668:	e3c44902 	bic	r4, r4, #32768	; 0x8000
			/* decode */

			while ((q & UPPER_BIT_RUBIN) || ((p + q) <= UPPER_BIT_RUBIN)) {
				q &= ~UPPER_BIT_RUBIN;
				q <<= 1;
				p <<= 1;
33d2166c:	e1a0e08e 	lsl	lr, lr, #1
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
				if (bit > 31) {
					u32 *p = (u32 *)in;
					bit = 0;
					temp = *(++p);
					in = (unsigned char *)p;
33d21670:	82811004 	addhi	r1, r1, #4	; 0x4
				rec_q &= ~UPPER_BIT_RUBIN;
				rec_q <<= 1;
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
				if (bit > 31) {
					u32 *p = (u32 *)in;
					bit = 0;
33d21674:	83a06000 	movhi	r6, #0	; 0x0
					temp = *(++p);
					in = (unsigned char *)p;
33d21678:	e31c0902 	tst	ip, #32768	; 0x8000
				q &= ~UPPER_BIT_RUBIN;
				q <<= 1;
				p <<= 1;
				rec_q &= ~UPPER_BIT_RUBIN;
				rec_q <<= 1;
				rec_q |= (temp >> (bit++ ^ 7)) & 1;
33d2167c:	e1834084 	orr	r4, r3, r4, lsl #1
				if (bit > 31) {
					u32 *p = (u32 *)in;
					bit = 0;
					temp = *(++p);
					in = (unsigned char *)p;
33d21680:	e08e300c 	add	r3, lr, ip
33d21684:	1affffef 	bne	33d21648 <rubin_do_decompress+0x50>
33d21688:	eaffffec 	b	33d21640 <rubin_do_decompress+0x48>
				}
			}
			i0 =  (bits[i] * p) >> 8;
33d2168c:	e7db3007 	ldrb	r3, [fp, r7]
33d21690:	e003039e 	mul	r3, lr, r3
33d21694:	e1a03423 	lsr	r3, r3, #8

			if (i0 <= 0) i0 = 1;
33d21698:	e3530001 	cmp	r3, #1	; 0x1
33d2169c:	b3a03001 	movlt	r3, #1	; 0x1
			/* if it fails, it fails, we have our crc
			if (i0 >= p) i0 = p - 1; */

			result >>= 1;
			if (rec_q < q + i0) {
33d216a0:	e08c2003 	add	r2, ip, r3
33d216a4:	e1540002 	cmp	r4, r2

			if (i0 <= 0) i0 = 1;
			/* if it fails, it fails, we have our crc
			if (i0 >= p) i0 = p - 1; */

			result >>= 1;
33d216a8:	e1a000a0 	lsr	r0, r0, #1

	while (curr < end) {
		/* in byte */

		result = 0;
		for (i = 0; i < 8; i++) {
33d216ac:	e2877001 	add	r7, r7, #1	; 0x1
			if (i0 >= p) i0 = p - 1; */

			result >>= 1;
			if (rec_q < q + i0) {
				/* result |= 0x00; */
				p = i0;
33d216b0:	31a0e003 	movcc	lr, r3
			} else {
				result |= 0x80;
				p -= i0;
33d216b4:	2063e00e 	rsbcs	lr, r3, lr
			result >>= 1;
			if (rec_q < q + i0) {
				/* result |= 0x00; */
				p = i0;
			} else {
				result |= 0x80;
33d216b8:	23800080 	orrcs	r0, r0, #128	; 0x80
				p -= i0;
				q += i0;
33d216bc:	21a0c002 	movcs	ip, r2

	while (curr < end) {
		/* in byte */

		result = 0;
		for (i = 0; i < 8; i++) {
33d216c0:	e3570007 	cmp	r7, #7	; 0x7
33d216c4:	9affffda 	bls	33d21634 <rubin_do_decompress+0x3c>
				result |= 0x80;
				p -= i0;
				q += i0;
			}
		}
		*(curr++) = result;
33d216c8:	e4c50001 	strb	r0, [r5], #1
33d216cc:	e1550009 	cmp	r5, r9
33d216d0:	3affffd5 	bcc	33d2162c <rubin_do_decompress+0x34>
33d216d4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d216d8 <dynrubin_decompress>:
	}
}

void dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out,
		   unsigned long sourcelen, unsigned long dstlen)
{
33d216d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
33d216dc:	e24dd008 	sub	sp, sp, #8	; 0x8
33d216e0:	e1a02001 	mov	r2, r1
33d216e4:	e1a0e003 	mov	lr, r3
	unsigned char bits[8];
	int c;

	for (c=0; c<8; c++)
33d216e8:	e3a01000 	mov	r1, #0	; 0x0
33d216ec:	e1a0c00d 	mov	ip, sp
		bits[c] = (256 - data_in[c]);
33d216f0:	e7d03001 	ldrb	r3, [r0, r1]
		   unsigned long sourcelen, unsigned long dstlen)
{
	unsigned char bits[8];
	int c;

	for (c=0; c<8; c++)
33d216f4:	e2811001 	add	r1, r1, #1	; 0x1
		bits[c] = (256 - data_in[c]);
33d216f8:	e2633000 	rsb	r3, r3, #0	; 0x0
		   unsigned long sourcelen, unsigned long dstlen)
{
	unsigned char bits[8];
	int c;

	for (c=0; c<8; c++)
33d216fc:	e3510007 	cmp	r1, #7	; 0x7
		bits[c] = (256 - data_in[c]);
33d21700:	e4cc3001 	strb	r3, [ip], #1
		   unsigned long sourcelen, unsigned long dstlen)
{
	unsigned char bits[8];
	int c;

	for (c=0; c<8; c++)
33d21704:	dafffff9 	ble	33d216f0 <dynrubin_decompress+0x18>
		bits[c] = (256 - data_in[c]);

	rubin_do_decompress(bits, data_in+8, cpage_out, dstlen);
33d21708:	e2801008 	add	r1, r0, #8	; 0x8
33d2170c:	e1a0300e 	mov	r3, lr
33d21710:	e1a0000d 	mov	r0, sp
33d21714:	ebffffb7 	bl	33d215f8 <rubin_do_decompress>
33d21718:	e28dd008 	add	sp, sp, #8	; 0x8
33d2171c:	e8bd8000 	pop	{pc}

33d21720 <zlib_decompress>:
#include <jffs2/mini_inflate.h>

long zlib_decompress(unsigned char *data_in, unsigned char *cpage_out,
		      __u32 srclen, __u32 destlen)
{
    return (decompress_block(cpage_out, data_in + 2, ldr_memcpy));
33d21720:	e2803002 	add	r3, r0, #2	; 0x2
33d21724:	e59f2008 	ldr	r2, [pc, #8]	; 33d21734 <zlib_decompress+0x14>
33d21728:	e1a00001 	mov	r0, r1
33d2172c:	e1a01003 	mov	r1, r3
33d21730:	ea000138 	b	33d21c18 <decompress_block>
33d21734:	33d1a3e4 	.word	0x33d1a3e4

33d21738 <cramfs_memset>:
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
	n--;
	for (;n > 0; n--) s[n] = c;
33d21738:	e2522001 	subs	r2, r2, #1	; 0x1
33d2173c:	17801102 	strne	r1, [r0, r2, lsl #2]
33d21740:	1afffffc 	bne	33d21738 <cramfs_memset>
	s[0] = c;
33d21744:	e5801000 	str	r1, [r0]
33d21748:	e1a0f00e 	mov	pc, lr

33d2174c <pull_bits>:
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d2174c:	e92d4030 	push	{r4, r5, lr}
	unsigned long ret;
	int i;

	ret = 0;
33d21750:	e3a0e000 	mov	lr, #0	; 0x0
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21754:	e1a05001 	mov	r5, r1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21758:	e15e0001 	cmp	lr, r1
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d2175c:	e1a0c000 	mov	ip, r0
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21760:	e1a0400e 	mov	r4, lr
33d21764:	2a000010 	bcs	33d217ac <pull_bits+0x60>
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21768:	e59c1000 	ldr	r1, [ip]
33d2176c:	e5dc3004 	ldrb	r3, [ip, #4]
33d21770:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21774:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21778:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d2177c:	e20030ff 	and	r3, r0, #255	; 0xff
33d21780:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21784:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21788:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d2178c:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21790:	e08ee412 	add	lr, lr, r2, lsl r4
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21794:	e2844001 	add	r4, r4, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21798:	e5cc0004 	strb	r0, [ip, #4]
			stream->bit = 0;
			stream->data++;
33d2179c:	058c1000 	streq	r1, [ip]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d217a0:	05cc3004 	strbeq	r3, [ip, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d217a4:	e1540005 	cmp	r4, r5
33d217a8:	eaffffed 	b	33d21764 <pull_bits+0x18>
			stream->bit = 0;
			stream->data++;
		}
	}
	return ret;
}
33d217ac:	e1a0000e 	mov	r0, lr
33d217b0:	e8bd8030 	pop	{r4, r5, pc}

33d217b4 <pull_bit>:

inline int pull_bit(struct bitstream *stream)
{
33d217b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d217b8:	e5903000 	ldr	r3, [r0]
33d217bc:	e5d01004 	ldrb	r1, [r0, #4]
	if (stream->bit++ == 7) {
		stream->bit = 0;
		stream->data++;
33d217c0:	e283e001 	add	lr, r3, #1	; 0x1
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d217c4:	e5d33000 	ldrb	r3, [r3]
	}
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
33d217c8:	e1a0c000 	mov	ip, r0
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
33d217cc:	e2810001 	add	r0, r1, #1	; 0x1
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d217d0:	e1a03153 	asr	r3, r3, r1
	if (stream->bit++ == 7) {
33d217d4:	e20020ff 	and	r2, r0, #255	; 0xff
33d217d8:	e3520008 	cmp	r2, #8	; 0x8
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d217dc:	e2032001 	and	r2, r3, #1	; 0x1
	if (stream->bit++ == 7) {
33d217e0:	e5cc0004 	strb	r0, [ip, #4]
		stream->bit = 0;
33d217e4:	03a03000 	moveq	r3, #0	; 0x0
		stream->data++;
	}
	return ret;
}
33d217e8:	e1a00002 	mov	r0, r2
inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
		stream->bit = 0;
		stream->data++;
33d217ec:	058ce000 	streq	lr, [ip]

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
		stream->bit = 0;
33d217f0:	05cc3004 	strbeq	r3, [ip, #4]
		stream->data++;
	}
	return ret;
}
33d217f4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

33d217f8 <read_symbol>:
	stream->data += length;
}

/* Read in a symbol from the stream (section 3.2.2) */
static int read_symbol(struct bitstream *stream, struct huffman_set *set)
{
33d217f8:	e92d4070 	push	{r4, r5, r6, lr}
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
		if (++bits > set->bits) {
			/* error decoding (corrupted data?) */
			stream->error = CODE_NOT_FOUND;
			return -1;
33d217fc:	e5913010 	ldr	r3, [r1, #16]
33d21800:	e5932000 	ldr	r2, [r3]
}

/* Read in a symbol from the stream (section 3.2.2) */
static int read_symbol(struct bitstream *stream, struct huffman_set *set)
{
	int bits = 0;
33d21804:	e3a06000 	mov	r6, #0	; 0x0
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
		if (++bits > set->bits) {
			/* error decoding (corrupted data?) */
			stream->error = CODE_NOT_FOUND;
			return -1;
33d21808:	e3520000 	cmp	r2, #0	; 0x0
	stream->data += length;
}

/* Read in a symbol from the stream (section 3.2.2) */
static int read_symbol(struct bitstream *stream, struct huffman_set *set)
{
33d2180c:	e1a0e001 	mov	lr, r1
33d21810:	e1a04000 	mov	r4, r0
	int bits = 0;
	int code = 0;
33d21814:	e1a05006 	mov	r5, r6
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
		if (++bits > set->bits) {
			/* error decoding (corrupted data?) */
			stream->error = CODE_NOT_FOUND;
			return -1;
33d21818:	0a000004 	beq	33d21830 <read_symbol+0x38>
33d2181c:	e5913014 	ldr	r3, [r1, #20]
33d21820:	e5933000 	ldr	r3, [r3]
33d21824:	e0833002 	add	r3, r3, r2
33d21828:	e1560003 	cmp	r6, r3
33d2182c:	ba00001d 	blt	33d218a8 <read_symbol+0xb0>
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d21830:	e5d41004 	ldrb	r1, [r4, #4]
33d21834:	e5940000 	ldr	r0, [r4]
	if (stream->bit++ == 7) {
33d21838:	e281c001 	add	ip, r1, #1	; 0x1
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d2183c:	e5d03000 	ldrb	r3, [r0]
	if (stream->bit++ == 7) {
33d21840:	e20c20ff 	and	r2, ip, #255	; 0xff
33d21844:	e3520008 	cmp	r2, #8	; 0x8
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d21848:	e1a03153 	asr	r3, r3, r1
33d2184c:	e2032001 	and	r2, r3, #1	; 0x1
	if (stream->bit++ == 7) {
		stream->bit = 0;
		stream->data++;
33d21850:	e2800001 	add	r0, r0, #1	; 0x1

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
		stream->bit = 0;
33d21854:	03a03000 	moveq	r3, #0	; 0x0
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
33d21858:	e5c4c004 	strb	ip, [r4, #4]
		stream->bit = 0;
		stream->data++;
33d2185c:	05840000 	streq	r0, [r4]

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
		stream->bit = 0;
33d21860:	05c43004 	strbeq	r3, [r4, #4]
	int bits = 0;
	int code = 0;
	while (!(set->count[bits] && code < set->first[bits] +
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
		if (++bits > set->bits) {
33d21864:	e59e3000 	ldr	r3, [lr]
33d21868:	e2855001 	add	r5, r5, #1	; 0x1
{
	int bits = 0;
	int code = 0;
	while (!(set->count[bits] && code < set->first[bits] +
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
33d2186c:	e1a01086 	lsl	r1, r6, #1
		if (++bits > set->bits) {
33d21870:	e1550003 	cmp	r5, r3
	}
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
33d21874:	e0816002 	add	r6, r1, r2
	int bits = 0;
	int code = 0;
	while (!(set->count[bits] && code < set->first[bits] +
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
		if (++bits > set->bits) {
33d21878:	da000003 	ble	33d2188c <read_symbol+0x94>
			/* error decoding (corrupted data?) */
			stream->error = CODE_NOT_FOUND;
33d2187c:	e3a03002 	mov	r3, #2	; 0x2
			return -1;
33d21880:	e3e00000 	mvn	r0, #0	; 0x0
	while (!(set->count[bits] && code < set->first[bits] +
					     set->count[bits])) {
		code = (code << 1) + pull_bit(stream);
		if (++bits > set->bits) {
			/* error decoding (corrupted data?) */
			stream->error = CODE_NOT_FOUND;
33d21884:	e5843010 	str	r3, [r4, #16]
			return -1;
33d21888:	e8bd8070 	pop	{r4, r5, r6, pc}
33d2188c:	e59e3010 	ldr	r3, [lr, #16]
33d21890:	e7932105 	ldr	r2, [r3, r5, lsl #2]
33d21894:	e3520000 	cmp	r2, #0	; 0x0
33d21898:	0affffe4 	beq	33d21830 <read_symbol+0x38>
33d2189c:	e59e3014 	ldr	r3, [lr, #20]
33d218a0:	e7933105 	ldr	r3, [r3, r5, lsl #2]
33d218a4:	eaffffde 	b	33d21824 <read_symbol+0x2c>
		}
	}
	return set->symbols[set->pos[bits] + code - set->first[bits]];
33d218a8:	e28e2014 	add	r2, lr, #20	; 0x14
33d218ac:	e892000c 	ldm	r2, {r2, r3}
33d218b0:	e7933105 	ldr	r3, [r3, r5, lsl #2]
33d218b4:	e7921105 	ldr	r1, [r2, r5, lsl #2]
33d218b8:	e0833006 	add	r3, r3, r6
33d218bc:	e59e200c 	ldr	r2, [lr, #12]
33d218c0:	e0613003 	rsb	r3, r1, r3
33d218c4:	e7920103 	ldr	r0, [r2, r3, lsl #2]
}
33d218c8:	e8bd8070 	pop	{r4, r5, r6, pc}

33d218cc <decompress_huffman>:

/* decompress a stream of data encoded with the passed length and distance
 * huffman codes */
static void decompress_huffman(struct bitstream *stream, unsigned char *dest)
{
33d218cc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct huffman_set *lengths = &(stream->lengths);
33d218d0:	e2803eca 	add	r3, r0, #3232	; 0xca0
}

/* decompress a stream of data encoded with the passed length and distance
 * huffman codes */
static void decompress_huffman(struct bitstream *stream, unsigned char *dest)
{
33d218d4:	e24dd004 	sub	sp, sp, #4	; 0x4
	struct huffman_set *lengths = &(stream->lengths);
33d218d8:	e2833008 	add	r3, r3, #8	; 0x8
	struct huffman_set *distance = &(stream->distance);
33d218dc:	e280bd33 	add	fp, r0, #3264	; 0xcc0

/* decompress a stream of data encoded with the passed length and distance
 * huffman codes */
static void decompress_huffman(struct bitstream *stream, unsigned char *dest)
{
	struct huffman_set *lengths = &(stream->lengths);
33d218e0:	e58d3000 	str	r3, [sp]
}

/* decompress a stream of data encoded with the passed length and distance
 * huffman codes */
static void decompress_huffman(struct bitstream *stream, unsigned char *dest)
{
33d218e4:	e1a04000 	mov	r4, r0
33d218e8:	e1a09001 	mov	r9, r1
	struct huffman_set *lengths = &(stream->lengths);
	struct huffman_set *distance = &(stream->distance);
33d218ec:	e28bb004 	add	fp, fp, #4	; 0x4

	int symbol, length, dist, i;

	do {
		if ((symbol = read_symbol(stream, lengths)) < 0) return;
33d218f0:	e1a00004 	mov	r0, r4
33d218f4:	e59d1000 	ldr	r1, [sp]
33d218f8:	ebffffbe 	bl	33d217f8 <read_symbol>
33d218fc:	e250c000 	subs	ip, r0, #0	; 0x0
33d21900:	ba000065 	blt	33d21a9c <decompress_huffman+0x1d0>
		if (symbol < 256) {
33d21904:	e35c00ff 	cmp	ip, #255	; 0xff
			*(dest++) = symbol; /* symbol is a literal */
33d21908:	d4c9c001 	strble	ip, [r9], #1
			stream->decoded++;
33d2190c:	d594300c 	ldrle	r3, [r4, #12]
33d21910:	d2833001 	addle	r3, r3, #1	; 0x1
33d21914:	d584300c 	strle	r3, [r4, #12]

	int symbol, length, dist, i;

	do {
		if ((symbol = read_symbol(stream, lengths)) < 0) return;
		if (symbol < 256) {
33d21918:	da00005d 	ble	33d21a94 <decompress_huffman+0x1c8>
			*(dest++) = symbol; /* symbol is a literal */
			stream->decoded++;
		} else if (symbol > 256) {
33d2191c:	e35c0c01 	cmp	ip, #256	; 0x100
33d21920:	da00005b 	ble	33d21a94 <decompress_huffman+0x1c8>
			/* Determine the length of the repitition
			 * (section 3.2.5) */
			if (symbol < 265) length = symbol - 254;
33d21924:	e35c0f42 	cmp	ip, #264	; 0x108
33d21928:	d24c50fe 	suble	r5, ip, #254	; 0xfe
33d2192c:	da000025 	ble	33d219c8 <decompress_huffman+0xfc>
			else if (symbol == 285) length = 258;
33d21930:	e59f316c 	ldr	r3, [pc, #364]	; 33d21aa4 <decompress_huffman+0x1d8>
33d21934:	e15c0003 	cmp	ip, r3
33d21938:	059f5168 	ldreq	r5, [pc, #360]	; 33d21aa8 <decompress_huffman+0x1dc>
33d2193c:	0a000021 	beq	33d219c8 <decompress_huffman+0xfc>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21940:	e24cef41 	sub	lr, ip, #260	; 0x104
33d21944:	e24ee001 	sub	lr, lr, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
33d21948:	e3a06000 	mov	r6, #0	; 0x0
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d2194c:	e1a0714e 	asr	r7, lr, #2
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21950:	e1560007 	cmp	r6, r7
33d21954:	e1a05006 	mov	r5, r6
33d21958:	2a000010 	bcs	33d219a0 <decompress_huffman+0xd4>
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d2195c:	e5941000 	ldr	r1, [r4]
33d21960:	e5d43004 	ldrb	r3, [r4, #4]
33d21964:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21968:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d2196c:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21970:	e20030ff 	and	r3, r0, #255	; 0xff
33d21974:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21978:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d2197c:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21980:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21984:	e0866512 	add	r6, r6, r2, lsl r5
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21988:	e2855001 	add	r5, r5, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d2198c:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21990:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21994:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21998:	e1550007 	cmp	r5, r7
33d2199c:	eaffffed 	b	33d21958 <decompress_huffman+0x8c>
			if (symbol < 265) length = symbol - 254;
			else if (symbol == 285) length = 258;
			else {
				length = pull_bits(stream, (symbol - 261) >> 2);
				length += (4 << ((symbol - 261) >> 2)) + 3;
				length += ((symbol - 1) % 4) <<
33d219a0:	e24c1001 	sub	r1, ip, #1	; 0x1
33d219a4:	e1a03fc1 	asr	r3, r1, #31
			 * (section 3.2.5) */
			if (symbol < 265) length = symbol - 254;
			else if (symbol == 285) length = 258;
			else {
				length = pull_bits(stream, (symbol - 261) >> 2);
				length += (4 << ((symbol - 261) >> 2)) + 3;
33d219a8:	e1a0014e 	asr	r0, lr, #2
				length += ((symbol - 1) % 4) <<
33d219ac:	e0813f23 	add	r3, r1, r3, lsr #30
			 * (section 3.2.5) */
			if (symbol < 265) length = symbol - 254;
			else if (symbol == 285) length = 258;
			else {
				length = pull_bits(stream, (symbol - 261) >> 2);
				length += (4 << ((symbol - 261) >> 2)) + 3;
33d219b0:	e3a02004 	mov	r2, #4	; 0x4
33d219b4:	e0862012 	add	r2, r6, r2, lsl r0
				length += ((symbol - 1) % 4) <<
33d219b8:	e3c33003 	bic	r3, r3, #3	; 0x3
33d219bc:	e0631001 	rsb	r1, r3, r1
			 * (section 3.2.5) */
			if (symbol < 265) length = symbol - 254;
			else if (symbol == 285) length = 258;
			else {
				length = pull_bits(stream, (symbol - 261) >> 2);
				length += (4 << ((symbol - 261) >> 2)) + 3;
33d219c0:	e2825003 	add	r5, r2, #3	; 0x3
				length += ((symbol - 1) % 4) <<
33d219c4:	e0855011 	add	r5, r5, r1, lsl r0
					  ((symbol - 261) >> 2);
			}

			/* Determine how far back to go */
			if ((symbol = read_symbol(stream, distance)) < 0)
33d219c8:	e1a00004 	mov	r0, r4
33d219cc:	e1a0100b 	mov	r1, fp
33d219d0:	ebffff88 	bl	33d217f8 <read_symbol>
33d219d4:	e250c000 	subs	ip, r0, #0	; 0x0
33d219d8:	ba00002f 	blt	33d21a9c <decompress_huffman+0x1d0>
				return;
			if (symbol < 4) dist = symbol + 1;
33d219dc:	e35c0003 	cmp	ip, #3	; 0x3
33d219e0:	d28c0001 	addle	r0, ip, #1	; 0x1
33d219e4:	da00001e 	ble	33d21a64 <decompress_huffman+0x198>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d219e8:	e24ca002 	sub	sl, ip, #2	; 0x2
	unsigned long ret;
	int i;

	ret = 0;
33d219ec:	e3a06000 	mov	r6, #0	; 0x0
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d219f0:	e1a070ca 	asr	r7, sl, #1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d219f4:	e1560007 	cmp	r6, r7
33d219f8:	e1a0e006 	mov	lr, r6
33d219fc:	2a000010 	bcs	33d21a44 <decompress_huffman+0x178>
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21a00:	e5941000 	ldr	r1, [r4]
33d21a04:	e5d43004 	ldrb	r3, [r4, #4]
33d21a08:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21a0c:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21a10:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21a14:	e20030ff 	and	r3, r0, #255	; 0xff
33d21a18:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21a1c:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21a20:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21a24:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21a28:	e0866e12 	add	r6, r6, r2, lsl lr
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21a2c:	e28ee001 	add	lr, lr, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21a30:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21a34:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21a38:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21a3c:	e15e0007 	cmp	lr, r7
33d21a40:	eaffffed 	b	33d219fc <decompress_huffman+0x130>
			if ((symbol = read_symbol(stream, distance)) < 0)
				return;
			if (symbol < 4) dist = symbol + 1;
			else {
				dist = pull_bits(stream, (symbol - 2) >> 1);
				dist += (2 << ((symbol - 2) >> 1)) + 1;
33d21a44:	e1a010ca 	asr	r1, sl, #1
				dist += (symbol % 2) << ((symbol - 2) >> 1);
33d21a48:	e08c2fac 	add	r2, ip, ip, lsr #31
			if ((symbol = read_symbol(stream, distance)) < 0)
				return;
			if (symbol < 4) dist = symbol + 1;
			else {
				dist = pull_bits(stream, (symbol - 2) >> 1);
				dist += (2 << ((symbol - 2) >> 1)) + 1;
33d21a4c:	e3a03002 	mov	r3, #2	; 0x2
33d21a50:	e0863113 	add	r3, r6, r3, lsl r1
				dist += (symbol % 2) << ((symbol - 2) >> 1);
33d21a54:	e3c22001 	bic	r2, r2, #1	; 0x1
			if ((symbol = read_symbol(stream, distance)) < 0)
				return;
			if (symbol < 4) dist = symbol + 1;
			else {
				dist = pull_bits(stream, (symbol - 2) >> 1);
				dist += (2 << ((symbol - 2) >> 1)) + 1;
33d21a58:	e2830001 	add	r0, r3, #1	; 0x1
				dist += (symbol % 2) << ((symbol - 2) >> 1);
33d21a5c:	e062200c 	rsb	r2, r2, ip
33d21a60:	e0800112 	add	r0, r0, r2, lsl r1
			}
			stream->decoded += length;
33d21a64:	e594300c 	ldr	r3, [r4, #12]
33d21a68:	e0833005 	add	r3, r3, r5
			for (i = 0; i < length; i++) {
33d21a6c:	e3a02000 	mov	r2, #0	; 0x0
			else {
				dist = pull_bits(stream, (symbol - 2) >> 1);
				dist += (2 << ((symbol - 2) >> 1)) + 1;
				dist += (symbol % 2) << ((symbol - 2) >> 1);
			}
			stream->decoded += length;
33d21a70:	e584300c 	str	r3, [r4, #12]
			for (i = 0; i < length; i++) {
33d21a74:	e1520005 	cmp	r2, r5
33d21a78:	aa000005 	bge	33d21a94 <decompress_huffman+0x1c8>
				*dest = dest[-dist];
33d21a7c:	e2603000 	rsb	r3, r0, #0	; 0x0
33d21a80:	e7d93003 	ldrb	r3, [r9, r3]
				dist = pull_bits(stream, (symbol - 2) >> 1);
				dist += (2 << ((symbol - 2) >> 1)) + 1;
				dist += (symbol % 2) << ((symbol - 2) >> 1);
			}
			stream->decoded += length;
			for (i = 0; i < length; i++) {
33d21a84:	e2822001 	add	r2, r2, #1	; 0x1
				*dest = dest[-dist];
33d21a88:	e4c93001 	strb	r3, [r9], #1
				dist = pull_bits(stream, (symbol - 2) >> 1);
				dist += (2 << ((symbol - 2) >> 1)) + 1;
				dist += (symbol % 2) << ((symbol - 2) >> 1);
			}
			stream->decoded += length;
			for (i = 0; i < length; i++) {
33d21a8c:	e1520005 	cmp	r2, r5
33d21a90:	eafffff8 	b	33d21a78 <decompress_huffman+0x1ac>
				*dest = dest[-dist];
				dest++;
			}
		}
	} while (symbol != 256); /* 256 is the end of the data block */
33d21a94:	e35c0c01 	cmp	ip, #256	; 0x100
33d21a98:	1affff94 	bne	33d218f0 <decompress_huffman+0x24>
}
33d21a9c:	e28dd004 	add	sp, sp, #4	; 0x4
33d21aa0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d21aa4:	0000011d 	.word	0x0000011d
33d21aa8:	00000102 	.word	0x00000102

33d21aac <fill_code_tables>:

/* Fill the lookup tables (section 3.2.2) */
static void fill_code_tables(struct huffman_set *set)
{
33d21aac:	e92d4010 	push	{r4, lr}
	int code = 0, i, length;

	/* fill in the first code of each bit length, and the pos pointer */
	set->pos[0] = 0;
33d21ab0:	e5903018 	ldr	r3, [r0, #24]
}

/* Fill the lookup tables (section 3.2.2) */
static void fill_code_tables(struct huffman_set *set)
{
	int code = 0, i, length;
33d21ab4:	e3a04000 	mov	r4, #0	; 0x0

	/* fill in the first code of each bit length, and the pos pointer */
	set->pos[0] = 0;
33d21ab8:	e5834000 	str	r4, [r3]
	for (i = 1; i < set->bits; i++) {
33d21abc:	e5903000 	ldr	r3, [r0]
	} while (symbol != 256); /* 256 is the end of the data block */
}

/* Fill the lookup tables (section 3.2.2) */
static void fill_code_tables(struct huffman_set *set)
{
33d21ac0:	e1a0c000 	mov	ip, r0
	int code = 0, i, length;

	/* fill in the first code of each bit length, and the pos pointer */
	set->pos[0] = 0;
	for (i = 1; i < set->bits; i++) {
33d21ac4:	e3a0e001 	mov	lr, #1	; 0x1
33d21ac8:	e15e0003 	cmp	lr, r3
33d21acc:	aa000012 	bge	33d21b1c <fill_code_tables+0x70>
		code = (code + set->count[i - 1]) << 1;
33d21ad0:	e59c3010 	ldr	r3, [ip, #16]
33d21ad4:	e1a0110e 	lsl	r1, lr, #2
33d21ad8:	e0813003 	add	r3, r1, r3
33d21adc:	e5133004 	ldr	r3, [r3, #-4]
		set->first[i] = code;
33d21ae0:	e59c2014 	ldr	r2, [ip, #20]
	int code = 0, i, length;

	/* fill in the first code of each bit length, and the pos pointer */
	set->pos[0] = 0;
	for (i = 1; i < set->bits; i++) {
		code = (code + set->count[i - 1]) << 1;
33d21ae4:	e0843003 	add	r3, r4, r3
33d21ae8:	e1a04083 	lsl	r4, r3, #1
		set->first[i] = code;
33d21aec:	e782410e 	str	r4, [r2, lr, lsl #2]
		set->pos[i] = set->pos[i - 1] + set->count[i - 1];
33d21af0:	e59c0018 	ldr	r0, [ip, #24]
33d21af4:	e59c2010 	ldr	r2, [ip, #16]
33d21af8:	e0812002 	add	r2, r1, r2
33d21afc:	e0811000 	add	r1, r1, r0
33d21b00:	e5113004 	ldr	r3, [r1, #-4]
33d21b04:	e5122004 	ldr	r2, [r2, #-4]
33d21b08:	e0833002 	add	r3, r3, r2
33d21b0c:	e780310e 	str	r3, [r0, lr, lsl #2]
{
	int code = 0, i, length;

	/* fill in the first code of each bit length, and the pos pointer */
	set->pos[0] = 0;
	for (i = 1; i < set->bits; i++) {
33d21b10:	e59c3000 	ldr	r3, [ip]
33d21b14:	e28ee001 	add	lr, lr, #1	; 0x1
33d21b18:	eaffffea 	b	33d21ac8 <fill_code_tables+0x1c>
		set->first[i] = code;
		set->pos[i] = set->pos[i - 1] + set->count[i - 1];
	}

	/* Fill in the table of symbols in order of their huffman code */
	for (i = 0; i < set->num_symbols; i++) {
33d21b1c:	e59c3004 	ldr	r3, [ip, #4]
33d21b20:	e3a0e000 	mov	lr, #0	; 0x0
33d21b24:	e15e0003 	cmp	lr, r3
33d21b28:	aa00000c 	bge	33d21b60 <fill_code_tables+0xb4>
		if ((length = set->lengths[i]))
33d21b2c:	e59c3008 	ldr	r3, [ip, #8]
33d21b30:	e793010e 	ldr	r0, [r3, lr, lsl #2]
33d21b34:	e3500000 	cmp	r0, #0	; 0x0
33d21b38:	0a000005 	beq	33d21b54 <fill_code_tables+0xa8>
			set->symbols[set->pos[length]++] = i;
33d21b3c:	e59c1018 	ldr	r1, [ip, #24]
33d21b40:	e59c200c 	ldr	r2, [ip, #12]
33d21b44:	e7913100 	ldr	r3, [r1, r0, lsl #2]
33d21b48:	e782e103 	str	lr, [r2, r3, lsl #2]
33d21b4c:	e2833001 	add	r3, r3, #1	; 0x1
33d21b50:	e7813100 	str	r3, [r1, r0, lsl #2]
		set->first[i] = code;
		set->pos[i] = set->pos[i - 1] + set->count[i - 1];
	}

	/* Fill in the table of symbols in order of their huffman code */
	for (i = 0; i < set->num_symbols; i++) {
33d21b54:	e59c3004 	ldr	r3, [ip, #4]
33d21b58:	e28ee001 	add	lr, lr, #1	; 0x1
33d21b5c:	eafffff0 	b	33d21b24 <fill_code_tables+0x78>
		if ((length = set->lengths[i]))
			set->symbols[set->pos[length]++] = i;
	}

	/* reset the pos pointer */
	for (i = 1; i < set->bits; i++) set->pos[i] -= set->count[i];
33d21b60:	e59c3000 	ldr	r3, [ip]
33d21b64:	e3a0e001 	mov	lr, #1	; 0x1
33d21b68:	e15e0003 	cmp	lr, r3
33d21b6c:	a8bd8010 	popge	{r4, pc}
33d21b70:	e59c3010 	ldr	r3, [ip, #16]
33d21b74:	e59c1018 	ldr	r1, [ip, #24]
33d21b78:	e793210e 	ldr	r2, [r3, lr, lsl #2]
33d21b7c:	e791310e 	ldr	r3, [r1, lr, lsl #2]
33d21b80:	e0623003 	rsb	r3, r2, r3
33d21b84:	e781310e 	str	r3, [r1, lr, lsl #2]
33d21b88:	e59c3000 	ldr	r3, [ip]
33d21b8c:	e28ee001 	add	lr, lr, #1	; 0x1
33d21b90:	e15e0003 	cmp	lr, r3
33d21b94:	bafffff5 	blt	33d21b70 <fill_code_tables+0xc4>
33d21b98:	e8bd8010 	pop	{r4, pc}

33d21b9c <init_code_tables>:
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d21b9c:	e5902004 	ldr	r2, [r0, #4]
33d21ba0:	e5901008 	ldr	r1, [r0, #8]
	n--;
	for (;n > 0; n--) s[n] = c;
33d21ba4:	e2522001 	subs	r2, r2, #1	; 0x1
33d21ba8:	0a000003 	beq	33d21bbc <init_code_tables+0x20>
33d21bac:	e3a03000 	mov	r3, #0	; 0x0
33d21bb0:	e7813102 	str	r3, [r1, r2, lsl #2]
33d21bb4:	e2522001 	subs	r2, r2, #1	; 0x1
33d21bb8:	eafffffa 	b	33d21ba8 <init_code_tables+0xc>
	s[0] = c;
33d21bbc:	e3a03000 	mov	r3, #0	; 0x0
33d21bc0:	e5813000 	str	r3, [r1]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d21bc4:	e5902000 	ldr	r2, [r0]
33d21bc8:	e5901010 	ldr	r1, [r0, #16]
	n--;
	for (;n > 0; n--) s[n] = c;
33d21bcc:	e2522001 	subs	r2, r2, #1	; 0x1
33d21bd0:	0a000003 	beq	33d21be4 <init_code_tables+0x48>
33d21bd4:	e3a03000 	mov	r3, #0	; 0x0
33d21bd8:	e7813102 	str	r3, [r1, r2, lsl #2]
33d21bdc:	e2522001 	subs	r2, r2, #1	; 0x1
33d21be0:	eafffffa 	b	33d21bd0 <init_code_tables+0x34>
	s[0] = c;
33d21be4:	e3a03000 	mov	r3, #0	; 0x0
33d21be8:	e5813000 	str	r3, [r1]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d21bec:	e5902000 	ldr	r2, [r0]
33d21bf0:	e5900014 	ldr	r0, [r0, #20]
	n--;
	for (;n > 0; n--) s[n] = c;
33d21bf4:	e2522001 	subs	r2, r2, #1	; 0x1
33d21bf8:	0a000003 	beq	33d21c0c <init_code_tables+0x70>
33d21bfc:	e3a03000 	mov	r3, #0	; 0x0
33d21c00:	e7803102 	str	r3, [r0, r2, lsl #2]
33d21c04:	e2522001 	subs	r2, r2, #1	; 0x1
33d21c08:	eafffffa 	b	33d21bf8 <init_code_tables+0x5c>
	s[0] = c;
33d21c0c:	e3a03000 	mov	r3, #0	; 0x0
33d21c10:	e5803000 	str	r3, [r0]
33d21c14:	e1a0f00e 	mov	pc, lr

33d21c18 <decompress_block>:
/* returns the number of bytes decoded, < 0 if there was an error. Note that
 * this function assumes that the block starts on a byte boundry
 * (non-compliant, but I don't see where this would happen). section 3.2.3 */
long decompress_block(unsigned char *dest, unsigned char *source,
		      void *(*inflate_memcpy)(void *, const void *, size))
{
33d21c18:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d21c1c:	e24ddecf 	sub	sp, sp, #3312	; 0xcf0
}

/* associate a stream with a block of data and reset the stream */
static void init_stream(struct bitstream *stream, unsigned char *data,
			void *(*inflate_memcpy)(void *, const void *, size))
{
33d21c20:	e28d3010 	add	r3, sp, #16	; 0x10
	stream->distance.num_symbols = 32;
	stream->distance.lengths = stream->distance_lengths;
	stream->distance.symbols = stream->distance_symbols;
	stream->distance.count = stream->distance_count;
	stream->distance.first = stream->distance_first;
	stream->distance.pos = stream->distance_pos;
33d21c24:	e2834094 	add	r4, r3, #148	; 0x94
33d21c28:	e58d4cec 	str	r4, [sp, #3308]

	/* really sorry about all this initialization, think of a better way,
	 * let me know and it will get cleaned up */
	stream->codes.bits = 8;
	stream->codes.num_symbols = 19;
	stream->codes.lengths = stream->code_lengths;
33d21c2c:	e2834f8d 	add	r4, r3, #564	; 0x234
33d21c30:	e58d4ca4 	str	r4, [sp, #3236]
	stream->lengths.num_symbols = 288;
	stream->lengths.lengths = stream->length_lengths;
	stream->lengths.symbols = stream->length_symbols;
	stream->lengths.count = stream->length_count;
	stream->lengths.first = stream->length_first;
	stream->lengths.pos = stream->length_pos;
33d21c34:	e2834fd3 	add	r4, r3, #844	; 0x34c
33d21c38:	e58d4cd0 	str	r4, [sp, #3280]

	stream->distance.bits = 16;
	stream->distance.num_symbols = 32;
	stream->distance.lengths = stream->distance_lengths;
33d21c3c:	e28340d4 	add	r4, r3, #212	; 0xd4
33d21c40:	e58d4cdc 	str	r4, [sp, #3292]
	stream->distance.symbols = stream->distance_symbols;
33d21c44:	e2834f55 	add	r4, r3, #340	; 0x154

/* associate a stream with a block of data and reset the stream */
static void init_stream(struct bitstream *stream, unsigned char *data,
			void *(*inflate_memcpy)(void *, const void *, size))
{
	stream->error = NO_ERROR;
33d21c48:	e3a0e000 	mov	lr, #0	; 0x0
	stream->lengths.pos = stream->length_pos;

	stream->distance.bits = 16;
	stream->distance.num_symbols = 32;
	stream->distance.lengths = stream->distance_lengths;
	stream->distance.symbols = stream->distance_symbols;
33d21c4c:	e58d4ce0 	str	r4, [sp, #3296]
	stream->distance.count = stream->distance_count;
33d21c50:	e2834014 	add	r4, r3, #20	; 0x14
	 * let me know and it will get cleaned up */
	stream->codes.bits = 8;
	stream->codes.num_symbols = 19;
	stream->codes.lengths = stream->code_lengths;
	stream->codes.symbols = stream->code_symbols;
	stream->codes.count = stream->code_count;
33d21c54:	e2835f75 	add	r5, r3, #468	; 0x1d4
	stream->codes.first = stream->code_first;
33d21c58:	e2836f7d 	add	r6, r3, #500	; 0x1f4
	stream->codes.pos = stream->code_pos;
33d21c5c:	e2837f85 	add	r7, r3, #532	; 0x214

	stream->lengths.bits = 16;
	stream->lengths.num_symbols = 288;
	stream->lengths.lengths = stream->length_lengths;
33d21c60:	e283afe3 	add	sl, r3, #908	; 0x38c
	stream->lengths.symbols = stream->length_symbols;
	stream->lengths.count = stream->length_count;
33d21c64:	e2839fb3 	add	r9, r3, #716	; 0x2cc
	stream->lengths.first = stream->length_first;
33d21c68:	e283bfc3 	add	fp, r3, #780	; 0x30c
{
	stream->error = NO_ERROR;
	stream->memcpy = inflate_memcpy;
	stream->decoded = 0;
	stream->data = data;
	stream->bit = 0;	/* The first bit of the stream is the lsb of the
33d21c6c:	e5c3e004 	strb	lr, [r3, #4]

	stream->distance.bits = 16;
	stream->distance.num_symbols = 32;
	stream->distance.lengths = stream->distance_lengths;
	stream->distance.symbols = stream->distance_symbols;
	stream->distance.count = stream->distance_count;
33d21c70:	e58d4ce4 	str	r4, [sp, #3300]
	stream->distance.first = stream->distance_first;
33d21c74:	e2834054 	add	r4, r3, #84	; 0x54
	stream->bit = 0;	/* The first bit of the stream is the lsb of the
				 * first byte */

	/* really sorry about all this initialization, think of a better way,
	 * let me know and it will get cleaned up */
	stream->codes.bits = 8;
33d21c78:	e3a03008 	mov	r3, #8	; 0x8
33d21c7c:	e58d3c9c 	str	r3, [sp, #3228]
	stream->codes.num_symbols = 19;
33d21c80:	e283300b 	add	r3, r3, #11	; 0xb
33d21c84:	e58d3ca0 	str	r3, [sp, #3232]
	stream->codes.lengths = stream->code_lengths;
	stream->codes.symbols = stream->code_symbols;
33d21c88:	e28d3e29 	add	r3, sp, #656	; 0x290
	stream->codes.pos = stream->code_pos;

	stream->lengths.bits = 16;
	stream->lengths.num_symbols = 288;
	stream->lengths.lengths = stream->length_lengths;
	stream->lengths.symbols = stream->length_symbols;
33d21c8c:	e28dce82 	add	ip, sp, #2080	; 0x820
	/* really sorry about all this initialization, think of a better way,
	 * let me know and it will get cleaned up */
	stream->codes.bits = 8;
	stream->codes.num_symbols = 19;
	stream->codes.lengths = stream->code_lengths;
	stream->codes.symbols = stream->code_symbols;
33d21c90:	e58d3ca8 	str	r3, [sp, #3240]
	stream->codes.count = stream->code_count;
	stream->codes.first = stream->code_first;
	stream->codes.pos = stream->code_pos;

	stream->lengths.bits = 16;
	stream->lengths.num_symbols = 288;
33d21c94:	e3a03e12 	mov	r3, #288	; 0x120
	stream->lengths.lengths = stream->length_lengths;
	stream->lengths.symbols = stream->length_symbols;
33d21c98:	e24cc004 	sub	ip, ip, #4	; 0x4
			void *(*inflate_memcpy)(void *, const void *, size))
{
	stream->error = NO_ERROR;
	stream->memcpy = inflate_memcpy;
	stream->decoded = 0;
	stream->data = data;
33d21c9c:	e58d1010 	str	r1, [sp, #16]
	stream->codes.count = stream->code_count;
	stream->codes.first = stream->code_first;
	stream->codes.pos = stream->code_pos;

	stream->lengths.bits = 16;
	stream->lengths.num_symbols = 288;
33d21ca0:	e58d3cbc 	str	r3, [sp, #3260]
	stream->lengths.symbols = stream->length_symbols;
	stream->lengths.count = stream->length_count;
	stream->lengths.first = stream->length_first;
	stream->lengths.pos = stream->length_pos;

	stream->distance.bits = 16;
33d21ca4:	e3a01010 	mov	r1, #16	; 0x10
	stream->distance.num_symbols = 32;
33d21ca8:	e2433c01 	sub	r3, r3, #256	; 0x100
	stream->distance.lengths = stream->distance_lengths;
	stream->distance.symbols = stream->distance_symbols;
	stream->distance.count = stream->distance_count;
	stream->distance.first = stream->distance_first;
33d21cac:	e58d4ce8 	str	r4, [sp, #3304]
/* associate a stream with a block of data and reset the stream */
static void init_stream(struct bitstream *stream, unsigned char *data,
			void *(*inflate_memcpy)(void *, const void *, size))
{
	stream->error = NO_ERROR;
	stream->memcpy = inflate_memcpy;
33d21cb0:	e58d2018 	str	r2, [sp, #24]
	 * let me know and it will get cleaned up */
	stream->codes.bits = 8;
	stream->codes.num_symbols = 19;
	stream->codes.lengths = stream->code_lengths;
	stream->codes.symbols = stream->code_symbols;
	stream->codes.count = stream->code_count;
33d21cb4:	e58d5cac 	str	r5, [sp, #3244]
	stream->codes.first = stream->code_first;
33d21cb8:	e58d6cb0 	str	r6, [sp, #3248]
	stream->codes.pos = stream->code_pos;
33d21cbc:	e58d7cb4 	str	r7, [sp, #3252]

	stream->lengths.bits = 16;
	stream->lengths.num_symbols = 288;
	stream->lengths.lengths = stream->length_lengths;
33d21cc0:	e58dacc0 	str	sl, [sp, #3264]
	stream->lengths.symbols = stream->length_symbols;
33d21cc4:	e58dccc4 	str	ip, [sp, #3268]
	stream->lengths.count = stream->length_count;
33d21cc8:	e58d9cc8 	str	r9, [sp, #3272]
	stream->lengths.first = stream->length_first;
33d21ccc:	e58dbccc 	str	fp, [sp, #3276]
	stream->lengths.pos = stream->length_pos;

	stream->distance.bits = 16;
33d21cd0:	e58d1cd4 	str	r1, [sp, #3284]
	stream->distance.num_symbols = 32;
33d21cd4:	e58d3cd8 	str	r3, [sp, #3288]

/* associate a stream with a block of data and reset the stream */
static void init_stream(struct bitstream *stream, unsigned char *data,
			void *(*inflate_memcpy)(void *, const void *, size))
{
	stream->error = NO_ERROR;
33d21cd8:	e58de020 	str	lr, [sp, #32]
	stream->memcpy = inflate_memcpy;
	stream->decoded = 0;
33d21cdc:	e58de01c 	str	lr, [sp, #28]
	stream->codes.symbols = stream->code_symbols;
	stream->codes.count = stream->code_count;
	stream->codes.first = stream->code_first;
	stream->codes.pos = stream->code_pos;

	stream->lengths.bits = 16;
33d21ce0:	e58d1cb8 	str	r1, [sp, #3256]
/* returns the number of bytes decoded, < 0 if there was an error. Note that
 * this function assumes that the block starts on a byte boundry
 * (non-compliant, but I don't see where this would happen). section 3.2.3 */
long decompress_block(unsigned char *dest, unsigned char *source,
		      void *(*inflate_memcpy)(void *, const void *, size))
{
33d21ce4:	e58d000c 	str	r0, [sp, #12]
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d21ce8:	e59dc010 	ldr	ip, [sp, #16]
	}
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
33d21cec:	e28d4010 	add	r4, sp, #16	; 0x10
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d21cf0:	e5d41004 	ldrb	r1, [r4, #4]
33d21cf4:	e5dc3000 	ldrb	r3, [ip]
	if (stream->bit++ == 7) {
33d21cf8:	e2810001 	add	r0, r1, #1	; 0x1
33d21cfc:	e20020ff 	and	r2, r0, #255	; 0xff
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d21d00:	e1a03153 	asr	r3, r3, r1
	if (stream->bit++ == 7) {
33d21d04:	e3520008 	cmp	r2, #8	; 0x8
	return ret;
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
33d21d08:	e2033001 	and	r3, r3, #1	; 0x1
33d21d0c:	e58d3008 	str	r3, [sp, #8]
	if (stream->bit++ == 7) {
		stream->bit = 0;
		stream->data++;
33d21d10:	028c2001 	addeq	r2, ip, #1	; 0x1

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
		stream->bit = 0;
33d21d14:	03a03000 	moveq	r3, #0	; 0x0
}

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
33d21d18:	e5c40004 	strb	r0, [r4, #4]
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d21d1c:	e3a0c000 	mov	ip, #0	; 0x0

inline int pull_bit(struct bitstream *stream)
{
	int ret = ((*(stream->data) >> stream->bit) & 1);
	if (stream->bit++ == 7) {
		stream->bit = 0;
33d21d20:	05c43004 	strbeq	r3, [r4, #4]
		stream->data++;
33d21d24:	058d2010 	streq	r2, [sp, #16]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21d28:	e1a0e00c 	mov	lr, ip
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21d2c:	e5941000 	ldr	r1, [r4]
33d21d30:	e5d43004 	ldrb	r3, [r4, #4]
33d21d34:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21d38:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21d3c:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21d40:	e20030ff 	and	r3, r0, #255	; 0xff
33d21d44:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21d48:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21d4c:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21d50:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21d54:	e08cce12 	add	ip, ip, r2, lsl lr
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21d58:	e28ee001 	add	lr, lr, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21d5c:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21d60:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21d64:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21d68:	e35e0002 	cmp	lr, #2	; 0x2
33d21d6c:	3affffee 	bcc	33d21d2c <decompress_block+0x114>

	init_stream(&stream, source, inflate_memcpy);
	do {
		bfinal = pull_bit(&stream);
		btype = pull_bits(&stream, 2);
		if (btype == NO_COMP) decompress_none(&stream, dest + stream.decoded);
33d21d70:	e35c0000 	cmp	ip, #0	; 0x0
33d21d74:	1a000027 	bne	33d21e18 <decompress_block+0x200>
}

/* discard bits up to the next whole byte */
static void discard_bits(struct bitstream *stream)
{
	if (stream->bit != 0) {
33d21d78:	e5d43004 	ldrb	r3, [r4, #4]
	}
}

/* No decompression, the data is all literals (section 3.2.4) */
static void decompress_none(struct bitstream *stream, unsigned char *dest)
{
33d21d7c:	e59d200c 	ldr	r2, [sp, #12]
}

/* discard bits up to the next whole byte */
static void discard_bits(struct bitstream *stream)
{
	if (stream->bit != 0) {
33d21d80:	e3530000 	cmp	r3, #0	; 0x0
	}
}

/* No decompression, the data is all literals (section 3.2.4) */
static void decompress_none(struct bitstream *stream, unsigned char *dest)
{
33d21d84:	e59d301c 	ldr	r3, [sp, #28]
33d21d88:	e0820003 	add	r0, r2, r3
/* discard bits up to the next whole byte */
static void discard_bits(struct bitstream *stream)
{
	if (stream->bit != 0) {
		stream->bit = 0;
		stream->data++;
33d21d8c:	159d3010 	ldrne	r3, [sp, #16]
33d21d90:	12833001 	addne	r3, r3, #1	; 0x1
33d21d94:	158d3010 	strne	r3, [sp, #16]

/* discard bits up to the next whole byte */
static void discard_bits(struct bitstream *stream)
{
	if (stream->bit != 0) {
		stream->bit = 0;
33d21d98:	15c4c004 	strbne	ip, [r4, #4]
static void decompress_none(struct bitstream *stream, unsigned char *dest)
{
	unsigned int length;

	discard_bits(stream);
	length = *(stream->data++);
33d21d9c:	e59d3010 	ldr	r3, [sp, #16]
33d21da0:	e4d35001 	ldrb	r5, [r3], #1
33d21da4:	e58d3010 	str	r3, [sp, #16]
	length += *(stream->data++) << 8;
33d21da8:	e4d32001 	ldrb	r2, [r3], #1
33d21dac:	e58d3010 	str	r3, [sp, #16]
33d21db0:	e0855402 	add	r5, r5, r2, lsl #8
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d21db4:	e1a0100c 	mov	r1, ip
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21db8:	e5d43004 	ldrb	r3, [r4, #4]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21dbc:	e2833001 	add	r3, r3, #1	; 0x1
33d21dc0:	e20320ff 	and	r2, r3, #255	; 0xff
33d21dc4:	e5c43004 	strb	r3, [r4, #4]
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21dc8:	e5943000 	ldr	r3, [r4]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21dcc:	e3520008 	cmp	r2, #8	; 0x8
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21dd0:	e2811001 	add	r1, r1, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
			stream->data++;
33d21dd4:	e2832001 	add	r2, r3, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21dd8:	03a03000 	moveq	r3, #0	; 0x0
33d21ddc:	05c43004 	strbeq	r3, [r4, #4]
			stream->data++;
33d21de0:	05842000 	streq	r2, [r4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21de4:	e3510010 	cmp	r1, #16	; 0x10
33d21de8:	3afffff2 	bcc	33d21db8 <decompress_block+0x1a0>
	discard_bits(stream);
	length = *(stream->data++);
	length += *(stream->data++) << 8;
	pull_bits(stream, 16);	/* throw away the inverse of the size */

	stream->decoded += length;
33d21dec:	e594300c 	ldr	r3, [r4, #12]
33d21df0:	e0833005 	add	r3, r3, r5
33d21df4:	e584300c 	str	r3, [r4, #12]
	stream->memcpy(dest, stream->data, length);
33d21df8:	e5941000 	ldr	r1, [r4]
33d21dfc:	e1a02005 	mov	r2, r5
33d21e00:	e1a0e00f 	mov	lr, pc
33d21e04:	e594f008 	ldr	pc, [r4, #8]
	stream->data += length;
33d21e08:	e5943000 	ldr	r3, [r4]
33d21e0c:	e0833005 	add	r3, r3, r5
33d21e10:	e5843000 	str	r3, [r4]
33d21e14:	ea0001ae 	b	33d224d4 <decompress_block+0x8bc>
	init_stream(&stream, source, inflate_memcpy);
	do {
		bfinal = pull_bit(&stream);
		btype = pull_bits(&stream, 2);
		if (btype == NO_COMP) decompress_none(&stream, dest + stream.decoded);
		else if (btype == DYNAMIC_COMP)
33d21e18:	e35c0002 	cmp	ip, #2	; 0x2
33d21e1c:	1a00014d 	bne	33d22358 <decompress_block+0x740>
	cramfs_memset(set->first, 0, set->bits);
}

/* read in the huffman codes for dynamic decoding (section 3.2.7) */
static void decompress_dynamic(struct bitstream *stream, unsigned char *dest)
{
33d21e20:	e59d301c 	ldr	r3, [sp, #28]
33d21e24:	e59d100c 	ldr	r1, [sp, #12]
33d21e28:	e0813003 	add	r3, r1, r3
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d21e2c:	e3a0e000 	mov	lr, #0	; 0x0
	 * code (the pos element points to the first place in the symbol table
	 * where that bit length occurs). I also hate the initization of these
	 * structs, if someone knows how to compact these, lemme know. */

	struct huffman_set *codes = &(stream->codes);
	struct huffman_set *lengths = &(stream->lengths);
33d21e30:	e28dbecb 	add	fp, sp, #3248	; 0xcb0
	struct huffman_set *distance = &(stream->distance);
33d21e34:	e28d9ecd 	add	r9, sp, #3280	; 0xcd0
	cramfs_memset(set->first, 0, set->bits);
}

/* read in the huffman codes for dynamic decoding (section 3.2.7) */
static void decompress_dynamic(struct bitstream *stream, unsigned char *dest)
{
33d21e38:	e58d3004 	str	r3, [sp, #4]
	 * code (the pos element points to the first place in the symbol table
	 * where that bit length occurs). I also hate the initization of these
	 * structs, if someone knows how to compact these, lemme know. */

	struct huffman_set *codes = &(stream->codes);
	struct huffman_set *lengths = &(stream->lengths);
33d21e3c:	e28bb008 	add	fp, fp, #8	; 0x8
	struct huffman_set *distance = &(stream->distance);
33d21e40:	e2899004 	add	r9, r9, #4	; 0x4
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21e44:	e1a0c00e 	mov	ip, lr
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21e48:	e5941000 	ldr	r1, [r4]
33d21e4c:	e5d43004 	ldrb	r3, [r4, #4]
33d21e50:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21e54:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21e58:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21e5c:	e20030ff 	and	r3, r0, #255	; 0xff
33d21e60:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21e64:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21e68:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21e6c:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21e70:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21e74:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21e78:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21e7c:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21e80:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21e84:	e35c0005 	cmp	ip, #5	; 0x5
33d21e88:	3affffee 	bcc	33d21e48 <decompress_block+0x230>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21e8c:	e28e7c01 	add	r7, lr, #256	; 0x100
	unsigned long ret;
	int i;

	ret = 0;
33d21e90:	e3a0e000 	mov	lr, #0	; 0x0
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21e94:	e2877001 	add	r7, r7, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21e98:	e1a0c00e 	mov	ip, lr
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21e9c:	e5941000 	ldr	r1, [r4]
33d21ea0:	e5d43004 	ldrb	r3, [r4, #4]
33d21ea4:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21ea8:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21eac:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21eb0:	e20030ff 	and	r3, r0, #255	; 0xff
33d21eb4:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21eb8:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21ebc:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21ec0:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21ec4:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21ec8:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21ecc:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21ed0:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21ed4:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21ed8:	e35c0005 	cmp	ip, #5	; 0x5
33d21edc:	3affffee 	bcc	33d21e9c <decompress_block+0x284>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21ee0:	e28ee001 	add	lr, lr, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
33d21ee4:	e3a05000 	mov	r5, #0	; 0x0
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21ee8:	e58de000 	str	lr, [sp]
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21eec:	e1a0c005 	mov	ip, r5
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21ef0:	e5941000 	ldr	r1, [r4]
33d21ef4:	e5d43004 	ldrb	r3, [r4, #4]
33d21ef8:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21efc:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f00:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21f04:	e20030ff 	and	r3, r0, #255	; 0xff
33d21f08:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f0c:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21f10:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21f14:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f18:	e0855c12 	add	r5, r5, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21f1c:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21f20:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21f24:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21f28:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21f2c:	e35c0004 	cmp	ip, #4	; 0x4
33d21f30:	3affffee 	bcc	33d21ef0 <decompress_block+0x2d8>
	int hclen = pull_bits(stream, 4) + 4;
	int length, curr_code, symbol, i, last_code;

	last_code = 0;

	init_code_tables(codes);
33d21f34:	e28d0ec9 	add	r0, sp, #3216	; 0xc90
33d21f38:	e280000c 	add	r0, r0, #12	; 0xc
33d21f3c:	ebffff16 	bl	33d21b9c <init_code_tables>
	init_code_tables(lengths);
33d21f40:	e1a0000b 	mov	r0, fp
33d21f44:	ebffff14 	bl	33d21b9c <init_code_tables>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d21f48:	e285a004 	add	sl, r5, #4	; 0x4
	int hlit = pull_bits(stream, 5) + 257;
	int hdist = pull_bits(stream, 5) + 1;
	int hclen = pull_bits(stream, 4) + 4;
	int length, curr_code, symbol, i, last_code;

	last_code = 0;
33d21f4c:	e3a06000 	mov	r6, #0	; 0x0

	init_code_tables(codes);
	init_code_tables(lengths);
	init_code_tables(distance);
33d21f50:	e1a00009 	mov	r0, r9
33d21f54:	ebffff10 	bl	33d21b9c <init_code_tables>

	/* fill in the count of each bit length' as well as the lengths
	 * table */
	for (i = 0; i < hclen; i++) {
33d21f58:	e1a05006 	mov	r5, r6
33d21f5c:	e156000a 	cmp	r6, sl
33d21f60:	aa00001e 	bge	33d21fe0 <decompress_block+0x3c8>
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d21f64:	e3a0e000 	mov	lr, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d21f68:	e1a0c00e 	mov	ip, lr
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f6c:	e5941000 	ldr	r1, [r4]
33d21f70:	e5d43004 	ldrb	r3, [r4, #4]
33d21f74:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21f78:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f7c:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21f80:	e20030ff 	and	r3, r0, #255	; 0xff
33d21f84:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f88:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21f8c:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d21f90:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d21f94:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21f98:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d21f9c:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d21fa0:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d21fa4:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d21fa8:	e35c0003 	cmp	ip, #3	; 0x3
33d21fac:	3affffee 	bcc	33d21f6c <decompress_block+0x354>

	/* fill in the count of each bit length' as well as the lengths
	 * table */
	for (i = 0; i < hclen; i++) {
		length = pull_bits(stream, 3);
		codes->lengths[huffman_order[i]] = length;
33d21fb0:	e59f354c 	ldr	r3, [pc, #1356]	; 33d22504 <decompress_block+0x8ec>
33d21fb4:	e7d32005 	ldrb	r2, [r3, r5]
33d21fb8:	e59d3ca4 	ldr	r3, [sp, #3236]
33d21fbc:	e783e102 	str	lr, [r3, r2, lsl #2]
		if (length) codes->count[length]++;
33d21fc0:	e35e0000 	cmp	lr, #0	; 0x0
33d21fc4:	159d2cac 	ldrne	r2, [sp, #3244]
33d21fc8:	1792310e 	ldrne	r3, [r2, lr, lsl #2]
	init_code_tables(lengths);
	init_code_tables(distance);

	/* fill in the count of each bit length' as well as the lengths
	 * table */
	for (i = 0; i < hclen; i++) {
33d21fcc:	e2855001 	add	r5, r5, #1	; 0x1
		length = pull_bits(stream, 3);
		codes->lengths[huffman_order[i]] = length;
		if (length) codes->count[length]++;
33d21fd0:	12833001 	addne	r3, r3, #1	; 0x1
33d21fd4:	1782310e 	strne	r3, [r2, lr, lsl #2]
	init_code_tables(lengths);
	init_code_tables(distance);

	/* fill in the count of each bit length' as well as the lengths
	 * table */
	for (i = 0; i < hclen; i++) {
33d21fd8:	e155000a 	cmp	r5, sl
33d21fdc:	eaffffdf 	b	33d21f60 <decompress_block+0x348>
		length = pull_bits(stream, 3);
		codes->lengths[huffman_order[i]] = length;
		if (length) codes->count[length]++;

	}
	fill_code_tables(codes);
33d21fe0:	e28d0ec9 	add	r0, sp, #3216	; 0xc90
33d21fe4:	e280000c 	add	r0, r0, #12	; 0xc

	/* Do the same for the length codes, being carefull of wrap through
	 * to the distance table */
	curr_code = 0;
33d21fe8:	e3a05000 	mov	r5, #0	; 0x0
		length = pull_bits(stream, 3);
		codes->lengths[huffman_order[i]] = length;
		if (length) codes->count[length]++;

	}
	fill_code_tables(codes);
33d21fec:	ebfffeae 	bl	33d21aac <fill_code_tables>
		} else if (symbol == 17) { /* repeat a bit length 0 */
			curr_code += 3 + pull_bits(stream, 3);
			last_code = 0;
		} else { /* same, but more times */
			curr_code += 11 + pull_bits(stream, 7);
			last_code = 0;
33d21ff0:	e1550007 	cmp	r5, r7
33d21ff4:	aa000067 	bge	33d22198 <decompress_block+0x580>

	/* Do the same for the length codes, being carefull of wrap through
	 * to the distance table */
	curr_code = 0;
	while (curr_code < hlit) {
		if ((symbol = read_symbol(stream, codes)) < 0) return;
33d21ff8:	e28d1ec9 	add	r1, sp, #3216	; 0xc90
33d21ffc:	e1a00004 	mov	r0, r4
33d22000:	e281100c 	add	r1, r1, #12	; 0xc
33d22004:	ebfffdfb 	bl	33d217f8 <read_symbol>
33d22008:	e3500000 	cmp	r0, #0	; 0x0
33d2200c:	ba000130 	blt	33d224d4 <decompress_block+0x8bc>
		if (symbol == 0) {
			curr_code++;
33d22010:	02855001 	addeq	r5, r5, #1	; 0x1
			last_code = 0;
33d22014:	01a06000 	moveq	r6, r0
	/* Do the same for the length codes, being carefull of wrap through
	 * to the distance table */
	curr_code = 0;
	while (curr_code < hlit) {
		if ((symbol = read_symbol(stream, codes)) < 0) return;
		if (symbol == 0) {
33d22018:	0afffff4 	beq	33d21ff0 <decompress_block+0x3d8>
			curr_code++;
			last_code = 0;
		} else if (symbol < 16) { /* Literal length */
33d2201c:	e350000f 	cmp	r0, #15	; 0xf
33d22020:	ca000008 	bgt	33d22048 <decompress_block+0x430>
			lengths->lengths[curr_code] =  last_code = symbol;
33d22024:	e59b3008 	ldr	r3, [fp, #8]
33d22028:	e7830105 	str	r0, [r3, r5, lsl #2]
			lengths->count[symbol]++;
33d2202c:	e59b2010 	ldr	r2, [fp, #16]
33d22030:	e7923100 	ldr	r3, [r2, r0, lsl #2]
		if ((symbol = read_symbol(stream, codes)) < 0) return;
		if (symbol == 0) {
			curr_code++;
			last_code = 0;
		} else if (symbol < 16) { /* Literal length */
			lengths->lengths[curr_code] =  last_code = symbol;
33d22034:	e1a06000 	mov	r6, r0
			lengths->count[symbol]++;
33d22038:	e2833001 	add	r3, r3, #1	; 0x1
			curr_code++;
33d2203c:	e2855001 	add	r5, r5, #1	; 0x1
		if (symbol == 0) {
			curr_code++;
			last_code = 0;
		} else if (symbol < 16) { /* Literal length */
			lengths->lengths[curr_code] =  last_code = symbol;
			lengths->count[symbol]++;
33d22040:	e7823100 	str	r3, [r2, r0, lsl #2]
			curr_code++;
33d22044:	eaffffe9 	b	33d21ff0 <decompress_block+0x3d8>
		} else if (symbol == 16) { /* repeat the last symbol 3 - 6
33d22048:	e3500010 	cmp	r0, #16	; 0x10
33d2204c:	1a000022 	bne	33d220dc <decompress_block+0x4c4>
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d22050:	e3a0c000 	mov	ip, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d22054:	e1a0e00c 	mov	lr, ip
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22058:	e5941000 	ldr	r1, [r4]
33d2205c:	e5d43004 	ldrb	r3, [r4, #4]
33d22060:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22064:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22068:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d2206c:	e20030ff 	and	r3, r0, #255	; 0xff
33d22070:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22074:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22078:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d2207c:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22080:	e08cce12 	add	ip, ip, r2, lsl lr
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22084:	e28ee001 	add	lr, lr, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22088:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d2208c:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22090:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22094:	e35e0002 	cmp	lr, #2	; 0x2
33d22098:	3affffee 	bcc	33d22058 <decompress_block+0x440>
			lengths->count[symbol]++;
			curr_code++;
		} else if (symbol == 16) { /* repeat the last symbol 3 - 6
					    * times */
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++)
33d2209c:	e29c1003 	adds	r1, ip, #3	; 0x3
33d220a0:	0affffd2 	beq	33d21ff0 <decompress_block+0x3d8>
				if (curr_code < hlit) {
33d220a4:	e1550007 	cmp	r5, r7
					lengths->lengths[curr_code] =
33d220a8:	b59b3008 	ldrlt	r3, [fp, #8]
						last_code;
					lengths->count[last_code]++;
				} else { /* wrap to the distance table */
					distance->lengths[curr_code - hlit] =
33d220ac:	a5993008 	ldrge	r3, [r9, #8]
33d220b0:	e0672005 	rsb	r2, r7, r5
		} else if (symbol == 16) { /* repeat the last symbol 3 - 6
					    * times */
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++)
				if (curr_code < hlit) {
					lengths->lengths[curr_code] =
33d220b4:	b7836105 	strlt	r6, [r3, r5, lsl #2]
						last_code;
					lengths->count[last_code]++;
				} else { /* wrap to the distance table */
					distance->lengths[curr_code - hlit] =
33d220b8:	a7836102 	strge	r6, [r3, r2, lsl #2]
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++)
				if (curr_code < hlit) {
					lengths->lengths[curr_code] =
						last_code;
					lengths->count[last_code]++;
33d220bc:	b59b2010 	ldrlt	r2, [fp, #16]
				} else { /* wrap to the distance table */
					distance->lengths[curr_code - hlit] =
						last_code;
					distance->count[last_code]++;
33d220c0:	a5992010 	ldrge	r2, [r9, #16]
33d220c4:	e7923106 	ldr	r3, [r2, r6, lsl #2]
			lengths->count[symbol]++;
			curr_code++;
		} else if (symbol == 16) { /* repeat the last symbol 3 - 6
					    * times */
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++)
33d220c8:	e2511001 	subs	r1, r1, #1	; 0x1
						last_code;
					lengths->count[last_code]++;
				} else { /* wrap to the distance table */
					distance->lengths[curr_code - hlit] =
						last_code;
					distance->count[last_code]++;
33d220cc:	e2833001 	add	r3, r3, #1	; 0x1
			lengths->count[symbol]++;
			curr_code++;
		} else if (symbol == 16) { /* repeat the last symbol 3 - 6
					    * times */
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++)
33d220d0:	e2855001 	add	r5, r5, #1	; 0x1
						last_code;
					lengths->count[last_code]++;
				} else { /* wrap to the distance table */
					distance->lengths[curr_code - hlit] =
						last_code;
					distance->count[last_code]++;
33d220d4:	e7823106 	str	r3, [r2, r6, lsl #2]
33d220d8:	eafffff0 	b	33d220a0 <decompress_block+0x488>
				}
		} else if (symbol == 17) { /* repeat a bit length 0 */
33d220dc:	e3500011 	cmp	r0, #17	; 0x11
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d220e0:	13a0e000 	movne	lr, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d220e4:	11a0c00e 	movne	ip, lr
				} else { /* wrap to the distance table */
					distance->lengths[curr_code - hlit] =
						last_code;
					distance->count[last_code]++;
				}
		} else if (symbol == 17) { /* repeat a bit length 0 */
33d220e8:	1a000015 	bne	33d22144 <decompress_block+0x52c>
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d220ec:	e3a0e000 	mov	lr, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d220f0:	e1a0c00e 	mov	ip, lr
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d220f4:	e5941000 	ldr	r1, [r4]
33d220f8:	e5d43004 	ldrb	r3, [r4, #4]
33d220fc:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22100:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22104:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22108:	e20030ff 	and	r3, r0, #255	; 0xff
33d2210c:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22110:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22114:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d22118:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d2211c:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22120:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22124:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d22128:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d2212c:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22130:	e35c0003 	cmp	ip, #3	; 0x3
33d22134:	3affffee 	bcc	33d220f4 <decompress_block+0x4dc>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d22138:	e085300e 	add	r3, r5, lr
33d2213c:	e2835003 	add	r5, r3, #3	; 0x3
33d22140:	ea000012 	b	33d22190 <decompress_block+0x578>
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22144:	e5941000 	ldr	r1, [r4]
33d22148:	e5d43004 	ldrb	r3, [r4, #4]
33d2214c:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22150:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22154:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22158:	e20030ff 	and	r3, r0, #255	; 0xff
33d2215c:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22160:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22164:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d22168:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d2216c:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22170:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22174:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d22178:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d2217c:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22180:	e35c0007 	cmp	ip, #7	; 0x7
33d22184:	3affffee 	bcc	33d22144 <decompress_block+0x52c>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d22188:	e085300e 	add	r3, r5, lr
33d2218c:	e283500b 	add	r5, r3, #11	; 0xb
		} else if (symbol == 17) { /* repeat a bit length 0 */
			curr_code += 3 + pull_bits(stream, 3);
			last_code = 0;
		} else { /* same, but more times */
			curr_code += 11 + pull_bits(stream, 7);
			last_code = 0;
33d22190:	e3a06000 	mov	r6, #0	; 0x0
33d22194:	eaffff95 	b	33d21ff0 <decompress_block+0x3d8>
		}
	}
	fill_code_tables(lengths);
33d22198:	e1a0000b 	mov	r0, fp
33d2219c:	ebfffe42 	bl	33d21aac <fill_code_tables>
		} else if (symbol == 17) {
			curr_code += 3 + pull_bits(stream, 3);
			last_code = 0;
		} else {
			curr_code += 11 + pull_bits(stream, 7);
			last_code = 0;
33d221a0:	e59d2000 	ldr	r2, [sp]
	}
	fill_code_tables(lengths);

	/* Fill the distance table, don't need to worry about wrapthrough
	 * here */
	curr_code -= hlit;
33d221a4:	e0675005 	rsb	r5, r7, r5
		} else if (symbol == 17) {
			curr_code += 3 + pull_bits(stream, 3);
			last_code = 0;
		} else {
			curr_code += 11 + pull_bits(stream, 7);
			last_code = 0;
33d221a8:	e1550002 	cmp	r5, r2
33d221ac:	aa000064 	bge	33d22344 <decompress_block+0x72c>

	/* Fill the distance table, don't need to worry about wrapthrough
	 * here */
	curr_code -= hlit;
	while (curr_code < hdist) {
		if ((symbol = read_symbol(stream, codes)) < 0) return;
33d221b0:	e28d1ec9 	add	r1, sp, #3216	; 0xc90
33d221b4:	e1a00004 	mov	r0, r4
33d221b8:	e281100c 	add	r1, r1, #12	; 0xc
33d221bc:	ebfffd8d 	bl	33d217f8 <read_symbol>
33d221c0:	e3500000 	cmp	r0, #0	; 0x0
33d221c4:	ba0000c2 	blt	33d224d4 <decompress_block+0x8bc>
		if (symbol == 0) {
			curr_code++;
33d221c8:	02855001 	addeq	r5, r5, #1	; 0x1
			last_code = 0;
33d221cc:	01a06000 	moveq	r6, r0
	/* Fill the distance table, don't need to worry about wrapthrough
	 * here */
	curr_code -= hlit;
	while (curr_code < hdist) {
		if ((symbol = read_symbol(stream, codes)) < 0) return;
		if (symbol == 0) {
33d221d0:	0a000058 	beq	33d22338 <decompress_block+0x720>
			curr_code++;
			last_code = 0;
		} else if (symbol < 16) {
33d221d4:	e350000f 	cmp	r0, #15	; 0xf
33d221d8:	ca000008 	bgt	33d22200 <decompress_block+0x5e8>
			distance->lengths[curr_code] = last_code = symbol;
33d221dc:	e5993008 	ldr	r3, [r9, #8]
33d221e0:	e7830105 	str	r0, [r3, r5, lsl #2]
			distance->count[symbol]++;
33d221e4:	e5992010 	ldr	r2, [r9, #16]
33d221e8:	e7923100 	ldr	r3, [r2, r0, lsl #2]
		if ((symbol = read_symbol(stream, codes)) < 0) return;
		if (symbol == 0) {
			curr_code++;
			last_code = 0;
		} else if (symbol < 16) {
			distance->lengths[curr_code] = last_code = symbol;
33d221ec:	e1a06000 	mov	r6, r0
			distance->count[symbol]++;
33d221f0:	e2833001 	add	r3, r3, #1	; 0x1
			curr_code++;
33d221f4:	e2855001 	add	r5, r5, #1	; 0x1
		if (symbol == 0) {
			curr_code++;
			last_code = 0;
		} else if (symbol < 16) {
			distance->lengths[curr_code] = last_code = symbol;
			distance->count[symbol]++;
33d221f8:	e7823100 	str	r3, [r2, r0, lsl #2]
			curr_code++;
33d221fc:	ea00004d 	b	33d22338 <decompress_block+0x720>
		} else if (symbol == 16) {
33d22200:	e3500010 	cmp	r0, #16	; 0x10
33d22204:	1a00001d 	bne	33d22280 <decompress_block+0x668>
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d22208:	e3a0c000 	mov	ip, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d2220c:	e1a0e00c 	mov	lr, ip
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22210:	e5941000 	ldr	r1, [r4]
33d22214:	e5d43004 	ldrb	r3, [r4, #4]
33d22218:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d2221c:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22220:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22224:	e20030ff 	and	r3, r0, #255	; 0xff
33d22228:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d2222c:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22230:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d22234:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22238:	e08cce12 	add	ip, ip, r2, lsl lr
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d2223c:	e28ee001 	add	lr, lr, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22240:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d22244:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22248:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d2224c:	e35e0002 	cmp	lr, #2	; 0x2
33d22250:	3affffee 	bcc	33d22210 <decompress_block+0x5f8>
			distance->lengths[curr_code] = last_code = symbol;
			distance->count[symbol]++;
			curr_code++;
		} else if (symbol == 16) {
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++) {
33d22254:	e29c1003 	adds	r1, ip, #3	; 0x3
33d22258:	0a000036 	beq	33d22338 <decompress_block+0x720>
				distance->lengths[curr_code] =
33d2225c:	e5993008 	ldr	r3, [r9, #8]
33d22260:	e7836105 	str	r6, [r3, r5, lsl #2]
					last_code;
				distance->count[last_code]++;
33d22264:	e5992010 	ldr	r2, [r9, #16]
33d22268:	e7923106 	ldr	r3, [r2, r6, lsl #2]
			distance->lengths[curr_code] = last_code = symbol;
			distance->count[symbol]++;
			curr_code++;
		} else if (symbol == 16) {
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++) {
33d2226c:	e2511001 	subs	r1, r1, #1	; 0x1
				distance->lengths[curr_code] =
					last_code;
				distance->count[last_code]++;
33d22270:	e2833001 	add	r3, r3, #1	; 0x1
			distance->lengths[curr_code] = last_code = symbol;
			distance->count[symbol]++;
			curr_code++;
		} else if (symbol == 16) {
			length = 3 + pull_bits(stream, 2);
			for (;length; length--, curr_code++) {
33d22274:	e2855001 	add	r5, r5, #1	; 0x1
				distance->lengths[curr_code] =
					last_code;
				distance->count[last_code]++;
33d22278:	e7823106 	str	r3, [r2, r6, lsl #2]
33d2227c:	eafffff5 	b	33d22258 <decompress_block+0x640>
			}
		} else if (symbol == 17) {
33d22280:	e3500011 	cmp	r0, #17	; 0x11
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d22284:	13a0e000 	movne	lr, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d22288:	11a0c00e 	movne	ip, lr
			for (;length; length--, curr_code++) {
				distance->lengths[curr_code] =
					last_code;
				distance->count[last_code]++;
			}
		} else if (symbol == 17) {
33d2228c:	1a000015 	bne	33d222e8 <decompress_block+0x6d0>
			       const unsigned int bits)
{
	unsigned long ret;
	int i;

	ret = 0;
33d22290:	e3a0e000 	mov	lr, #0	; 0x0
	for (i = 0; i < bits; i++) {
33d22294:	e1a0c00e 	mov	ip, lr
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22298:	e5941000 	ldr	r1, [r4]
33d2229c:	e5d43004 	ldrb	r3, [r4, #4]
33d222a0:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d222a4:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d222a8:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d222ac:	e20030ff 	and	r3, r0, #255	; 0xff
33d222b0:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d222b4:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d222b8:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d222bc:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d222c0:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d222c4:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d222c8:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d222cc:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d222d0:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d222d4:	e35c0003 	cmp	ip, #3	; 0x3
33d222d8:	3affffee 	bcc	33d22298 <decompress_block+0x680>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d222dc:	e085300e 	add	r3, r5, lr
33d222e0:	e2835003 	add	r5, r3, #3	; 0x3
33d222e4:	ea000012 	b	33d22334 <decompress_block+0x71c>
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d222e8:	e5941000 	ldr	r1, [r4]
33d222ec:	e5d43004 	ldrb	r3, [r4, #4]
33d222f0:	e5d12000 	ldrb	r2, [r1]

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d222f4:	e2830001 	add	r0, r3, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d222f8:	e1a02352 	asr	r2, r2, r3

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d222fc:	e20030ff 	and	r3, r0, #255	; 0xff
33d22300:	e3530008 	cmp	r3, #8	; 0x8
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22304:	e2022001 	and	r2, r2, #1	; 0x1

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22308:	02433008 	subeq	r3, r3, #8	; 0x8
			stream->data++;
33d2230c:	e2811001 	add	r1, r1, #1	; 0x1
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
		ret += ((*(stream->data) >> stream->bit) & 1) << i;
33d22310:	e08eec12 	add	lr, lr, r2, lsl ip
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22314:	e28cc001 	add	ip, ip, #1	; 0x1
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
33d22318:	e5c40004 	strb	r0, [r4, #4]
			stream->bit = 0;
			stream->data++;
33d2231c:	05841000 	streq	r1, [r4]
		ret += ((*(stream->data) >> stream->bit) & 1) << i;

		/* if, before incrementing, we are on bit 7,
		 * go to the lsb of the next byte */
		if (stream->bit++ == 7) {
			stream->bit = 0;
33d22320:	05c43004 	strbeq	r3, [r4, #4]
{
	unsigned long ret;
	int i;

	ret = 0;
	for (i = 0; i < bits; i++) {
33d22324:	e35c0007 	cmp	ip, #7	; 0x7
33d22328:	3affffee 	bcc	33d222e8 <decompress_block+0x6d0>
/* pull 'bits' bits out of the stream. The last bit pulled it returned as the
 * msb. (section 3.1.1)
 */
inline unsigned long pull_bits(struct bitstream *stream,
			       const unsigned int bits)
{
33d2232c:	e085300e 	add	r3, r5, lr
33d22330:	e283500b 	add	r5, r3, #11	; 0xb
		} else if (symbol == 17) {
			curr_code += 3 + pull_bits(stream, 3);
			last_code = 0;
		} else {
			curr_code += 11 + pull_bits(stream, 7);
			last_code = 0;
33d22334:	e3a06000 	mov	r6, #0	; 0x0
33d22338:	e59d3000 	ldr	r3, [sp]
33d2233c:	e1550003 	cmp	r5, r3
33d22340:	eaffff99 	b	33d221ac <decompress_block+0x594>
		}
	}
	fill_code_tables(distance);
33d22344:	e1a00009 	mov	r0, r9
33d22348:	ebfffdd7 	bl	33d21aac <fill_code_tables>

	decompress_huffman(stream, dest);
33d2234c:	e59d1004 	ldr	r1, [sp, #4]
33d22350:	e1a00004 	mov	r0, r4
33d22354:	ea00005d 	b	33d224d0 <decompress_block+0x8b8>
		bfinal = pull_bit(&stream);
		btype = pull_bits(&stream, 2);
		if (btype == NO_COMP) decompress_none(&stream, dest + stream.decoded);
		else if (btype == DYNAMIC_COMP)
			decompress_dynamic(&stream, dest + stream.decoded);
		else if (btype == FIXED_COMP) decompress_fixed(&stream, dest + stream.decoded);
33d22358:	e35c0001 	cmp	ip, #1	; 0x1
		else stream.error = COMP_UNKNOWN;
33d2235c:	13a03001 	movne	r3, #1	; 0x1
33d22360:	158d3020 	strne	r3, [sp, #32]
		bfinal = pull_bit(&stream);
		btype = pull_bits(&stream, 2);
		if (btype == NO_COMP) decompress_none(&stream, dest + stream.decoded);
		else if (btype == DYNAMIC_COMP)
			decompress_dynamic(&stream, dest + stream.decoded);
		else if (btype == FIXED_COMP) decompress_fixed(&stream, dest + stream.decoded);
33d22364:	1a00005a 	bne	33d224d4 <decompress_block+0x8bc>
}

/* fill in the length and distance huffman codes for fixed encoding
 * (section 3.2.6) */
static void decompress_fixed(struct bitstream *stream, unsigned char *dest)
{
33d22368:	e59d301c 	ldr	r3, [sp, #28]
33d2236c:	e59de00c 	ldr	lr, [sp, #12]
	/* let gcc fill in the initial values */
	struct huffman_set *lengths = &(stream->lengths);
33d22370:	e28d0ecb 	add	r0, sp, #3248	; 0xcb0
	struct huffman_set *distance = &(stream->distance);
33d22374:	e28d5ecd 	add	r5, sp, #3280	; 0xcd0
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d22378:	e59d2cc8 	ldr	r2, [sp, #3272]
}

/* fill in the length and distance huffman codes for fixed encoding
 * (section 3.2.6) */
static void decompress_fixed(struct bitstream *stream, unsigned char *dest)
{
33d2237c:	e08e6003 	add	r6, lr, r3
	/* let gcc fill in the initial values */
	struct huffman_set *lengths = &(stream->lengths);
33d22380:	e2800008 	add	r0, r0, #8	; 0x8
	struct huffman_set *distance = &(stream->distance);
33d22384:	e2855004 	add	r5, r5, #4	; 0x4
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
	n--;
33d22388:	e3a0300f 	mov	r3, #15	; 0xf
	for (;n > 0; n--) s[n] = c;
33d2238c:	e3a01000 	mov	r1, #0	; 0x0
33d22390:	e7821103 	str	r1, [r2, r3, lsl #2]
33d22394:	e2533001 	subs	r3, r3, #1	; 0x1
33d22398:	1afffffb 	bne	33d2238c <decompress_block+0x774>
	s[0] = c;
33d2239c:	e5821000 	str	r1, [r2]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d223a0:	e5902014 	ldr	r2, [r0, #20]
	n--;
33d223a4:	e3a0300f 	mov	r3, #15	; 0xf
	for (;n > 0; n--) s[n] = c;
33d223a8:	e3a01000 	mov	r1, #0	; 0x0
33d223ac:	e7821103 	str	r1, [r2, r3, lsl #2]
33d223b0:	e2533001 	subs	r3, r3, #1	; 0x1
33d223b4:	1afffffb 	bne	33d223a8 <decompress_block+0x790>
	s[0] = c;
33d223b8:	e5821000 	str	r1, [r2]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d223bc:	e5902008 	ldr	r2, [r0, #8]
	n--;
33d223c0:	e3a0308f 	mov	r3, #143	; 0x8f
	for (;n > 0; n--) s[n] = c;
33d223c4:	e3a01008 	mov	r1, #8	; 0x8
33d223c8:	e7821103 	str	r1, [r2, r3, lsl #2]
33d223cc:	e2533001 	subs	r3, r3, #1	; 0x1
33d223d0:	1afffffb 	bne	33d223c4 <decompress_block+0x7ac>
	s[0] = c;
33d223d4:	e5821000 	str	r1, [r2]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d223d8:	e5903008 	ldr	r3, [r0, #8]
	n--;
33d223dc:	e3a0206f 	mov	r2, #111	; 0x6f
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d223e0:	e2833d09 	add	r3, r3, #576	; 0x240
	n--;
	for (;n > 0; n--) s[n] = c;
33d223e4:	e3a01009 	mov	r1, #9	; 0x9
33d223e8:	e7831102 	str	r1, [r3, r2, lsl #2]
33d223ec:	e2522001 	subs	r2, r2, #1	; 0x1
33d223f0:	1afffffb 	bne	33d223e4 <decompress_block+0x7cc>
	s[0] = c;
33d223f4:	e5831000 	str	r1, [r3]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d223f8:	e5903008 	ldr	r3, [r0, #8]
	n--;
33d223fc:	e3a02017 	mov	r2, #23	; 0x17
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d22400:	e2833b01 	add	r3, r3, #1024	; 0x400
	n--;
	for (;n > 0; n--) s[n] = c;
33d22404:	e3a01007 	mov	r1, #7	; 0x7
33d22408:	e7831102 	str	r1, [r3, r2, lsl #2]
33d2240c:	e2522001 	subs	r2, r2, #1	; 0x1
33d22410:	1afffffb 	bne	33d22404 <decompress_block+0x7ec>
	s[0] = c;
33d22414:	e5831000 	str	r1, [r3]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d22418:	e5903008 	ldr	r3, [r0, #8]
	n--;
33d2241c:	e1a02001 	mov	r2, r1
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d22420:	e2833e46 	add	r3, r3, #1120	; 0x460
	n--;
	for (;n > 0; n--) s[n] = c;
33d22424:	e3a01008 	mov	r1, #8	; 0x8
33d22428:	e7831102 	str	r1, [r3, r2, lsl #2]
33d2242c:	e2522001 	subs	r2, r2, #1	; 0x1
33d22430:	1afffffb 	bne	33d22424 <decompress_block+0x80c>
	s[0] = c;
33d22434:	e5831000 	str	r1, [r3]
	cramfs_memset(lengths->first, 0, 16);
	cramfs_memset(lengths->lengths, 8, 144);
	cramfs_memset(lengths->lengths + 144, 9, 112);
	cramfs_memset(lengths->lengths + 256, 7, 24);
	cramfs_memset(lengths->lengths + 280, 8, 8);
	lengths->count[7] = 24;
33d22438:	e5902010 	ldr	r2, [r0, #16]
33d2243c:	e3a03018 	mov	r3, #24	; 0x18
33d22440:	e582301c 	str	r3, [r2, #28]
	lengths->count[8] = 152;
33d22444:	e5902010 	ldr	r2, [r0, #16]
33d22448:	e2833080 	add	r3, r3, #128	; 0x80
33d2244c:	e5823020 	str	r3, [r2, #32]
	lengths->count[9] = 112;
33d22450:	e5902010 	ldr	r2, [r0, #16]
33d22454:	e2433028 	sub	r3, r3, #40	; 0x28
33d22458:	e5823024 	str	r3, [r2, #36]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d2245c:	e5952010 	ldr	r2, [r5, #16]
	n--;
33d22460:	e2433061 	sub	r3, r3, #97	; 0x61
	for (;n > 0; n--) s[n] = c;
33d22464:	e3a01000 	mov	r1, #0	; 0x0
33d22468:	e7821103 	str	r1, [r2, r3, lsl #2]
33d2246c:	e2533001 	subs	r3, r3, #1	; 0x1
33d22470:	1afffffb 	bne	33d22464 <decompress_block+0x84c>
	s[0] = c;
33d22474:	e5821000 	str	r1, [r2]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d22478:	e5952014 	ldr	r2, [r5, #20]
	n--;
33d2247c:	e3a0300f 	mov	r3, #15	; 0xf
	for (;n > 0; n--) s[n] = c;
33d22480:	e3a01000 	mov	r1, #0	; 0x0
33d22484:	e7821103 	str	r1, [r2, r3, lsl #2]
33d22488:	e2533001 	subs	r3, r3, #1	; 0x1
33d2248c:	1afffffb 	bne	33d22480 <decompress_block+0x868>
	s[0] = c;
33d22490:	e5821000 	str	r1, [r2]
/* The order that the code lengths in section 3.2.7 are in */
static unsigned char huffman_order[] = {16, 17, 18,  0,  8,  7,  9,  6, 10,  5,
					11,  4, 12,  3, 13,  2, 14,  1, 15};

inline void cramfs_memset(int *s, const int c, size n)
{
33d22494:	e5952008 	ldr	r2, [r5, #8]
	n--;
33d22498:	e3a0301f 	mov	r3, #31	; 0x1f
	for (;n > 0; n--) s[n] = c;
33d2249c:	e3a01005 	mov	r1, #5	; 0x5
33d224a0:	e7821103 	str	r1, [r2, r3, lsl #2]
33d224a4:	e2533001 	subs	r3, r3, #1	; 0x1
33d224a8:	1afffffb 	bne	33d2249c <decompress_block+0x884>
	s[0] = c;
33d224ac:	e5821000 	str	r1, [r2]
	lengths->count[9] = 112;

	cramfs_memset(distance->count, 0, 16);
	cramfs_memset(distance->first, 0, 16);
	cramfs_memset(distance->lengths, 5, 32);
	distance->count[5] = 32;
33d224b0:	e5952010 	ldr	r2, [r5, #16]
33d224b4:	e3a03020 	mov	r3, #32	; 0x20
33d224b8:	e5823014 	str	r3, [r2, #20]


	fill_code_tables(lengths);
33d224bc:	ebfffd7a 	bl	33d21aac <fill_code_tables>
	fill_code_tables(distance);
33d224c0:	e1a00005 	mov	r0, r5
33d224c4:	ebfffd78 	bl	33d21aac <fill_code_tables>


	decompress_huffman(stream, dest);
33d224c8:	e1a00004 	mov	r0, r4
33d224cc:	e1a01006 	mov	r1, r6
33d224d0:	ebfffcfd 	bl	33d218cc <decompress_huffman>
		if (btype == NO_COMP) decompress_none(&stream, dest + stream.decoded);
		else if (btype == DYNAMIC_COMP)
			decompress_dynamic(&stream, dest + stream.decoded);
		else if (btype == FIXED_COMP) decompress_fixed(&stream, dest + stream.decoded);
		else stream.error = COMP_UNKNOWN;
	} while (!bfinal && !stream.error);
33d224d4:	e59d1008 	ldr	r1, [sp, #8]
33d224d8:	e3510000 	cmp	r1, #0	; 0x0
33d224dc:	1a000002 	bne	33d224ec <decompress_block+0x8d4>
33d224e0:	e59d3020 	ldr	r3, [sp, #32]
33d224e4:	e3530000 	cmp	r3, #0	; 0x0
33d224e8:	0afffdfe 	beq	33d21ce8 <decompress_block+0xd0>
	putLabeledWord("stream.error = ",stream.error);
	putLabeledWord("stream.decoded = ",stream.decoded);
	putLabeledWord("dest = ",dest);
	putstr("decompress_block end\r\n");
#endif
	return stream.error ? -stream.error : stream.decoded;
33d224ec:	e59d0020 	ldr	r0, [sp, #32]
33d224f0:	e3500000 	cmp	r0, #0	; 0x0
33d224f4:	059d001c 	ldreq	r0, [sp, #28]
33d224f8:	12600000 	rsbne	r0, r0, #0	; 0x0
}
33d224fc:	e28ddecf 	add	sp, sp, #3312	; 0xcf0
33d22500:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d22504:	33d36944 	.word	0x33d36944

33d22508 <GregorianDay>:

/*
 * This only works for the Gregorian calendar - i.e. after 1752 (in the UK)
 */
void GregorianDay(struct rtc_time * tm)
{
33d22508:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int leapsToDate;
	int lastYear;
	int day;
	int MonthOffset[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };
33d2250c:	e59f30e0 	ldr	r3, [pc, #224]	; 33d225f4 <GregorianDay+0xec>
33d22510:	e1a0e003 	mov	lr, r3

/*
 * This only works for the Gregorian calendar - i.e. after 1752 (in the UK)
 */
void GregorianDay(struct rtc_time * tm)
{
33d22514:	e24dd030 	sub	sp, sp, #48	; 0x30
33d22518:	e1a07000 	mov	r7, r0
	int leapsToDate;
	int lastYear;
	int day;
	int MonthOffset[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };
33d2251c:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
33d22520:	e1a0c00d 	mov	ip, sp
33d22524:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
33d22528:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
33d2252c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}

	lastYear=tm->tm_year-1;
33d22530:	e5976014 	ldr	r6, [r7, #20]
void GregorianDay(struct rtc_time * tm)
{
	int leapsToDate;
	int lastYear;
	int day;
	int MonthOffset[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };
33d22534:	e89e000f 	ldm	lr, {r0, r1, r2, r3}

	lastYear=tm->tm_year-1;
33d22538:	e2465001 	sub	r5, r6, #1	; 0x1
void GregorianDay(struct rtc_time * tm)
{
	int leapsToDate;
	int lastYear;
	int day;
	int MonthOffset[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };
33d2253c:	e88c000f 	stm	ip, {r0, r1, r2, r3}
	lastYear=tm->tm_year-1;

	/*
	 * Number of leap corrections to apply up to end of last year
	 */
	leapsToDate = lastYear/4 - lastYear/100 + lastYear/400;
33d22540:	e3a01064 	mov	r1, #100	; 0x64
33d22544:	e1a00005 	mov	r0, r5
33d22548:	ebfff044 	bl	33d1e660 <__divsi3>
33d2254c:	e1a04fc5 	asr	r4, r5, #31
33d22550:	e0854f24 	add	r4, r5, r4, lsr #30
33d22554:	e1a04144 	asr	r4, r4, #2
33d22558:	e0604004 	rsb	r4, r0, r4
33d2255c:	e3a01e19 	mov	r1, #400	; 0x190
33d22560:	e1a00005 	mov	r0, r5
33d22564:	ebfff03d 	bl	33d1e660 <__divsi3>
	 * This year is a leap year if it is divisible by 4 except when it is
	 * divisible by 100 unless it is divisible by 400
	 *
	 * e.g. 1904 was a leap year, 1900 was not, 1996 is, and 2000 will be
	 */
	if((tm->tm_year%4==0) &&
33d22568:	e3160003 	tst	r6, #3	; 0x3
	lastYear=tm->tm_year-1;

	/*
	 * Number of leap corrections to apply up to end of last year
	 */
	leapsToDate = lastYear/4 - lastYear/100 + lastYear/400;
33d2256c:	e0844000 	add	r4, r4, r0
	 * This year is a leap year if it is divisible by 4 except when it is
	 * divisible by 100 unless it is divisible by 400
	 *
	 * e.g. 1904 was a leap year, 1900 was not, 1996 is, and 2000 will be
	 */
	if((tm->tm_year%4==0) &&
33d22570:	e3a01064 	mov	r1, #100	; 0x64
33d22574:	e1a00006 	mov	r0, r6
33d22578:	1a00000b 	bne	33d225ac <GregorianDay+0xa4>
33d2257c:	ebfff087 	bl	33d1e7a0 <__modsi3>
33d22580:	e3500000 	cmp	r0, #0	; 0x0
33d22584:	e3a01e19 	mov	r1, #400	; 0x190
33d22588:	e1a00006 	mov	r0, r6
33d2258c:	1a000002 	bne	33d2259c <GregorianDay+0x94>
33d22590:	ebfff082 	bl	33d1e7a0 <__modsi3>
33d22594:	e3500000 	cmp	r0, #0	; 0x0
33d22598:	1a000003 	bne	33d225ac <GregorianDay+0xa4>
33d2259c:	e5973010 	ldr	r3, [r7, #16]
33d225a0:	e3530002 	cmp	r3, #2	; 0x2
	   ((tm->tm_year%100!=0) || (tm->tm_year%400==0)) &&
	   (tm->tm_mon>2)) {
		/*
		 * We are past Feb. 29 in a leap year
		 */
		day=1;
33d225a4:	e3a01001 	mov	r1, #1	; 0x1
	 * This year is a leap year if it is divisible by 4 except when it is
	 * divisible by 100 unless it is divisible by 400
	 *
	 * e.g. 1904 was a leap year, 1900 was not, 1996 is, and 2000 will be
	 */
	if((tm->tm_year%4==0) &&
33d225a8:	ca000000 	bgt	33d225b0 <GregorianDay+0xa8>
		/*
		 * We are past Feb. 29 in a leap year
		 */
		day=1;
	} else {
		day=0;
33d225ac:	e3a01000 	mov	r1, #0	; 0x0
	}

	day += lastYear*365 + leapsToDate + MonthOffset[tm->tm_mon-1] + tm->tm_mday;
33d225b0:	e5973010 	ldr	r3, [r7, #16]
33d225b4:	e28d2030 	add	r2, sp, #48	; 0x30
33d225b8:	e0850185 	add	r0, r5, r5, lsl #3
33d225bc:	e0823103 	add	r3, r2, r3, lsl #2
33d225c0:	e0850180 	add	r0, r5, r0, lsl #3
33d225c4:	e5133034 	ldr	r3, [r3, #-52]
33d225c8:	e0800100 	add	r0, r0, r0, lsl #2
33d225cc:	e597200c 	ldr	r2, [r7, #12]
33d225d0:	e0800004 	add	r0, r0, r4
33d225d4:	e0800003 	add	r0, r0, r3
33d225d8:	e0800002 	add	r0, r0, r2

	tm->tm_wday=day%7;
33d225dc:	e0810000 	add	r0, r1, r0
33d225e0:	e3a01007 	mov	r1, #7	; 0x7
33d225e4:	ebfff06d 	bl	33d1e7a0 <__modsi3>
33d225e8:	e5870018 	str	r0, [r7, #24]
33d225ec:	e28dd030 	add	sp, sp, #48	; 0x30
33d225f0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d225f4:	33d250b0 	.word	0x33d250b0

33d225f8 <to_tm>:
}

void to_tm(int tim, struct rtc_time * tm)
{
33d225f8:	e92d4070 	push	{r4, r5, r6, lr}
33d225fc:	e1a06001 	mov	r6, r1
	register int    i;
	register long   hms, day;

	day = tim / SECDAY;
33d22600:	e59f1108 	ldr	r1, [pc, #264]	; 33d22710 <to_tm+0x118>

	tm->tm_wday=day%7;
}

void to_tm(int tim, struct rtc_time * tm)
{
33d22604:	e1a04000 	mov	r4, r0
	register int    i;
	register long   hms, day;

	day = tim / SECDAY;
33d22608:	ebfff014 	bl	33d1e660 <__divsi3>
	hms = tim % SECDAY;
33d2260c:	e59f10fc 	ldr	r1, [pc, #252]	; 33d22710 <to_tm+0x118>
void to_tm(int tim, struct rtc_time * tm)
{
	register int    i;
	register long   hms, day;

	day = tim / SECDAY;
33d22610:	e1a05000 	mov	r5, r0
	hms = tim % SECDAY;
33d22614:	e1a00004 	mov	r0, r4
33d22618:	ebfff060 	bl	33d1e7a0 <__modsi3>

	/* Hours, minutes, seconds are easy */
	tm->tm_hour = hms / 3600;
33d2261c:	e3a01ee1 	mov	r1, #3600	; 0xe10
{
	register int    i;
	register long   hms, day;

	day = tim / SECDAY;
	hms = tim % SECDAY;
33d22620:	e1a04000 	mov	r4, r0

	/* Hours, minutes, seconds are easy */
	tm->tm_hour = hms / 3600;
33d22624:	ebfff00d 	bl	33d1e660 <__divsi3>
	tm->tm_min = (hms % 3600) / 60;
33d22628:	e3a01ee1 	mov	r1, #3600	; 0xe10

	day = tim / SECDAY;
	hms = tim % SECDAY;

	/* Hours, minutes, seconds are easy */
	tm->tm_hour = hms / 3600;
33d2262c:	e5860008 	str	r0, [r6, #8]
	tm->tm_min = (hms % 3600) / 60;
33d22630:	e1a00004 	mov	r0, r4
33d22634:	ebfff059 	bl	33d1e7a0 <__modsi3>
33d22638:	e3a0103c 	mov	r1, #60	; 0x3c
33d2263c:	e1a04000 	mov	r4, r0
33d22640:	ebfff006 	bl	33d1e660 <__divsi3>
	tm->tm_sec = (hms % 3600) % 60;
33d22644:	e3a0103c 	mov	r1, #60	; 0x3c
	day = tim / SECDAY;
	hms = tim % SECDAY;

	/* Hours, minutes, seconds are easy */
	tm->tm_hour = hms / 3600;
	tm->tm_min = (hms % 3600) / 60;
33d22648:	e5860004 	str	r0, [r6, #4]
	tm->tm_sec = (hms % 3600) % 60;
33d2264c:	e1a00004 	mov	r0, r4
33d22650:	ebfff052 	bl	33d1e7a0 <__modsi3>

	/* Number of years in days */
	for (i = STARTOFTIME; day >= days_in_year(i); i++) {
33d22654:	e59fc0b8 	ldr	ip, [pc, #184]	; 33d22714 <to_tm+0x11c>
	hms = tim % SECDAY;

	/* Hours, minutes, seconds are easy */
	tm->tm_hour = hms / 3600;
	tm->tm_min = (hms % 3600) / 60;
	tm->tm_sec = (hms % 3600) % 60;
33d22658:	e5860000 	str	r0, [r6]

	/* Number of years in days */
	for (i = STARTOFTIME; day >= days_in_year(i); i++) {
33d2265c:	ea000005 	b	33d22678 <to_tm+0x80>
		day -= days_in_year(i);
33d22660:	e2455f5b 	sub	r5, r5, #364	; 0x16c
33d22664:	e2455002 	sub	r5, r5, #2	; 0x2
33d22668:	ea000001 	b	33d22674 <to_tm+0x7c>
33d2266c:	e2455f5b 	sub	r5, r5, #364	; 0x16c
33d22670:	e2455001 	sub	r5, r5, #1	; 0x1
	tm->tm_hour = hms / 3600;
	tm->tm_min = (hms % 3600) / 60;
	tm->tm_sec = (hms % 3600) % 60;

	/* Number of years in days */
	for (i = STARTOFTIME; day >= days_in_year(i); i++) {
33d22674:	e28cc001 	add	ip, ip, #1	; 0x1
33d22678:	e21c2003 	ands	r2, ip, #3	; 0x3
33d2267c:	1a000003 	bne	33d22690 <to_tm+0x98>
33d22680:	e59f3090 	ldr	r3, [pc, #144]	; 33d22718 <to_tm+0x120>
33d22684:	e1550003 	cmp	r5, r3
33d22688:	cafffff4 	bgt	33d22660 <to_tm+0x68>
33d2268c:	ea000001 	b	33d22698 <to_tm+0xa0>
33d22690:	e3550f5b 	cmp	r5, #364	; 0x16c
33d22694:	cafffff4 	bgt	33d2266c <to_tm+0x74>
		day -= days_in_year(i);
	}
	tm->tm_year = i;

	/* Number of months in days left */
	if (leapyear(tm->tm_year)) {
33d22698:	e3520000 	cmp	r2, #0	; 0x0
		days_in_month(FEBRUARY) = 29;
33d2269c:	059f3078 	ldreq	r3, [pc, #120]	; 33d2271c <to_tm+0x124>
33d226a0:	0282201d 	addeq	r2, r2, #29	; 0x1d

	/* Number of years in days */
	for (i = STARTOFTIME; day >= days_in_year(i); i++) {
		day -= days_in_year(i);
	}
	tm->tm_year = i;
33d226a4:	e586c014 	str	ip, [r6, #20]

	/* Number of months in days left */
	if (leapyear(tm->tm_year)) {
		days_in_month(FEBRUARY) = 29;
33d226a8:	05832004 	streq	r2, [r3, #4]
	}
	for (i = 1; day >= days_in_month(i); i++) {
33d226ac:	e59f2068 	ldr	r2, [pc, #104]	; 33d2271c <to_tm+0x124>
33d226b0:	e5923000 	ldr	r3, [r2]
33d226b4:	e1550003 	cmp	r5, r3
33d226b8:	e3a0c001 	mov	ip, #1	; 0x1
33d226bc:	e3a03004 	mov	r3, #4	; 0x4
33d226c0:	ba000009 	blt	33d226ec <to_tm+0xf4>
33d226c4:	e1a01002 	mov	r1, r2
		day -= days_in_month(i);
33d226c8:	e0833002 	add	r3, r3, r2
33d226cc:	e5133004 	ldr	r3, [r3, #-4]

	/* Number of months in days left */
	if (leapyear(tm->tm_year)) {
		days_in_month(FEBRUARY) = 29;
	}
	for (i = 1; day >= days_in_month(i); i++) {
33d226d0:	e5b12004 	ldr	r2, [r1, #4]!
		day -= days_in_month(i);
33d226d4:	e0635005 	rsb	r5, r3, r5

	/* Number of months in days left */
	if (leapyear(tm->tm_year)) {
		days_in_month(FEBRUARY) = 29;
	}
	for (i = 1; day >= days_in_month(i); i++) {
33d226d8:	e1550002 	cmp	r5, r2
33d226dc:	e28cc001 	add	ip, ip, #1	; 0x1
33d226e0:	e59f2034 	ldr	r2, [pc, #52]	; 33d2271c <to_tm+0x124>
33d226e4:	e1a0310c 	lsl	r3, ip, #2
33d226e8:	aafffff6 	bge	33d226c8 <to_tm+0xd0>
		day -= days_in_month(i);
	}
	days_in_month(FEBRUARY) = 28;
33d226ec:	e59f3028 	ldr	r3, [pc, #40]	; 33d2271c <to_tm+0x124>
	tm->tm_mon = i;

	/* Days are what is left over (+1) from all that. */
	tm->tm_mday = day + 1;
33d226f0:	e2851001 	add	r1, r5, #1	; 0x1
		days_in_month(FEBRUARY) = 29;
	}
	for (i = 1; day >= days_in_month(i); i++) {
		day -= days_in_month(i);
	}
	days_in_month(FEBRUARY) = 28;
33d226f4:	e3a0201c 	mov	r2, #28	; 0x1c
	tm->tm_mday = day + 1;

	/*
	 * Determine the day of week
	 */
	GregorianDay(tm);
33d226f8:	e1a00006 	mov	r0, r6
		days_in_month(FEBRUARY) = 29;
	}
	for (i = 1; day >= days_in_month(i); i++) {
		day -= days_in_month(i);
	}
	days_in_month(FEBRUARY) = 28;
33d226fc:	e5832004 	str	r2, [r3, #4]
	tm->tm_mon = i;
33d22700:	e586c010 	str	ip, [r6, #16]

	/* Days are what is left over (+1) from all that. */
	tm->tm_mday = day + 1;
33d22704:	e586100c 	str	r1, [r6, #12]

	/*
	 * Determine the day of week
	 */
	GregorianDay(tm);
33d22708:	e8bd4070 	pop	{r4, r5, r6, lr}
33d2270c:	eaffff7d 	b	33d22508 <GregorianDay>
33d22710:	00015180 	.word	0x00015180
33d22714:	000007b2 	.word	0x000007b2
33d22718:	0000016d 	.word	0x0000016d
33d2271c:	33d36958 	.word	0x33d36958

33d22720 <mktime>:
 */
unsigned long
mktime (unsigned int year, unsigned int mon,
	unsigned int day, unsigned int hour,
	unsigned int min, unsigned int sec)
{
33d22720:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
33d22724:	e2416002 	sub	r6, r1, #2	; 0x2
33d22728:	e3560000 	cmp	r6, #0	; 0x0
 */
unsigned long
mktime (unsigned int year, unsigned int mon,
	unsigned int day, unsigned int hour,
	unsigned int min, unsigned int sec)
{
33d2272c:	e1a05000 	mov	r5, r0
	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
		mon += 12;		/* Puts Feb last since it has leap day */
		year -= 1;
33d22730:	d2405001 	suble	r5, r0, #1	; 0x1
	}

	return (((
33d22734:	e3a01064 	mov	r1, #100	; 0x64
33d22738:	e1a00005 	mov	r0, r5
mktime (unsigned int year, unsigned int mon,
	unsigned int day, unsigned int hour,
	unsigned int min, unsigned int sec)
{
	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
		mon += 12;		/* Puts Feb last since it has leap day */
33d2273c:	d286600c 	addle	r6, r6, #12	; 0xc
 */
unsigned long
mktime (unsigned int year, unsigned int mon,
	unsigned int day, unsigned int hour,
	unsigned int min, unsigned int sec)
{
33d22740:	e1a07002 	mov	r7, r2
33d22744:	e1a0a003 	mov	sl, r3
	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
		mon += 12;		/* Puts Feb last since it has leap day */
		year -= 1;
	}

	return (((
33d22748:	ebff7b24 	bl	33d013e0 <__udivsi3>
33d2274c:	e1a04125 	lsr	r4, r5, #2
33d22750:	e0604004 	rsb	r4, r0, r4
33d22754:	e3a01e19 	mov	r1, #400	; 0x190
33d22758:	e1a00005 	mov	r0, r5
33d2275c:	ebff7b1f 	bl	33d013e0 <__udivsi3>
33d22760:	e0863086 	add	r3, r6, r6, lsl #1
33d22764:	e0663183 	rsb	r3, r6, r3, lsl #3
33d22768:	e0844000 	add	r4, r4, r0
33d2276c:	e3a0100c 	mov	r1, #12	; 0xc
33d22770:	e0660203 	rsb	r0, r6, r3, lsl #4
33d22774:	ebff7b19 	bl	33d013e0 <__udivsi3>
33d22778:	e0853185 	add	r3, r5, r5, lsl #3
33d2277c:	e0844000 	add	r4, r4, r0
33d22780:	e0853183 	add	r3, r5, r3, lsl #3
33d22784:	e0844007 	add	r4, r4, r7
33d22788:	e0833103 	add	r3, r3, r3, lsl #2
33d2278c:	e0844003 	add	r4, r4, r3
33d22790:	e0844084 	add	r4, r4, r4, lsl #1
33d22794:	e08a4184 	add	r4, sl, r4, lsl #3
33d22798:	e59d2018 	ldr	r2, [sp, #24]
33d2279c:	e0644204 	rsb	r4, r4, r4, lsl #4
33d227a0:	e0822104 	add	r2, r2, r4, lsl #2
33d227a4:	e59d301c 	ldr	r3, [sp, #28]
33d227a8:	e0622202 	rsb	r2, r2, r2, lsl #4
		(unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
			year*365 - 719499
	    )*24 + hour /* now have hours */
	  )*60 + min /* now have minutes */
	)*60 + sec; /* finally seconds */
}
33d227ac:	e59f0008 	ldr	r0, [pc, #8]	; 33d227bc <mktime+0x9c>
	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
		mon += 12;		/* Puts Feb last since it has leap day */
		year -= 1;
	}

	return (((
33d227b0:	e0833102 	add	r3, r3, r2, lsl #2
		(unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
			year*365 - 719499
	    )*24 + hour /* now have hours */
	  )*60 + min /* now have minutes */
	)*60 + sec; /* finally seconds */
}
33d227b4:	e0830000 	add	r0, r3, r0
33d227b8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d227bc:	86b1bf80 	.word	0x86b1bf80

33d227c0 <bcd2bin>:
			rtc->RTCCON &= ~0x01; break;
	}
}

static unsigned bcd2bin (uchar n)
{
33d227c0:	e1a03000 	mov	r3, r0
33d227c4:	e20000ff 	and	r0, r0, #255	; 0xff
	return ((((n >> 4) & 0x0F) * 10) + (n & 0x0F));
33d227c8:	e1a00220 	lsr	r0, r0, #4
33d227cc:	e203300f 	and	r3, r3, #15	; 0xf
33d227d0:	e0800100 	add	r0, r0, r0, lsl #2
}
33d227d4:	e0830080 	add	r0, r3, r0, lsl #1
33d227d8:	e1a0f00e 	mov	pc, lr

33d227dc <bin2bcd>:

static unsigned char bin2bcd (unsigned int n)
{
33d227dc:	e92d4030 	push	{r4, r5, lr}
	return (((n / 10) << 4) | (n % 10));
33d227e0:	e3a0100a 	mov	r1, #10	; 0xa
{
	return ((((n >> 4) & 0x0F) * 10) + (n & 0x0F));
}

static unsigned char bin2bcd (unsigned int n)
{
33d227e4:	e1a05000 	mov	r5, r0
	return (((n / 10) << 4) | (n % 10));
33d227e8:	ebff7afc 	bl	33d013e0 <__udivsi3>
33d227ec:	e3a0100a 	mov	r1, #10	; 0xa
33d227f0:	e1a04200 	lsl	r4, r0, #4
33d227f4:	e1a00005 	mov	r0, r5
33d227f8:	ebfff028 	bl	33d1e8a0 <__umodsi3>
33d227fc:	e1844000 	orr	r4, r4, r0
33d22800:	e20440ff 	and	r4, r4, #255	; 0xff
}
33d22804:	e1a00004 	mov	r0, r4
33d22808:	e8bd8030 	pop	{r4, r5, pc}

33d2280c <rtc_get>:

/* ------------------------------------------------------------------------- */

void rtc_get (struct rtc_time *tmp)
{
33d2280c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
{
    return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
}
static inline S3C24X0_RTC * const S3C24X0_GetBase_RTC(void)
{
    return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
33d22810:	e3a01457 	mov	r1, #1459617792	; 0x57000000
static inline void SetRTC_Access(RTC_ACCESS a)
{
	S3C24X0_RTC * const rtc = S3C24X0_GetBase_RTC();
	switch (a) {
		case RTC_ENABLE:
			rtc->RTCCON |= 0x01; break;
33d22814:	e5d13040 	ldrb	r3, [r1, #64]
33d22818:	e3833001 	orr	r3, r3, #1	; 0x1
33d2281c:	e5c13040 	strb	r3, [r1, #64]
}

/* ------------------------------------------------------------------------- */

void rtc_get (struct rtc_time *tmp)
{
33d22820:	e1a05000 	mov	r5, r0
	/* enable access to RTC registers */
	SetRTC_Access(RTC_ENABLE);

	/* read RTC registers */
	do {
		sec	= rtc->BCDSEC;
33d22824:	e5d10070 	ldrb	r0, [r1, #112]
		min	= rtc->BCDMIN;
33d22828:	e5d14074 	ldrb	r4, [r1, #116]
		hour	= rtc->BCDHOUR;
33d2282c:	e5d16078 	ldrb	r6, [r1, #120]
		mday	= rtc->BCDDATE;
33d22830:	e5d1a07c 	ldrb	sl, [r1, #124]
		wday	= rtc->BCDDAY;
33d22834:	e5d1b080 	ldrb	fp, [r1, #128]
		mon	= rtc->BCDMON;
33d22838:	e5d19084 	ldrb	r9, [r1, #132]
		year	= rtc->BCDYEAR;
33d2283c:	e5d12088 	ldrb	r2, [r1, #136]
	} while (sec != rtc->BCDSEC);
33d22840:	e5d13070 	ldrb	r3, [r1, #112]
33d22844:	e1530000 	cmp	r3, r0
		min	= rtc->BCDMIN;
		hour	= rtc->BCDHOUR;
		mday	= rtc->BCDDATE;
		wday	= rtc->BCDDAY;
		mon	= rtc->BCDMON;
		year	= rtc->BCDYEAR;
33d22848:	e20270ff 	and	r7, r2, #255	; 0xff
	} while (sec != rtc->BCDSEC);
33d2284c:	1afffff4 	bne	33d22824 <rtc_get+0x18>
33d22850:	e3a02457 	mov	r2, #1459617792	; 0x57000000

	/* read ALARM registers */
	a_sec	= rtc->ALMSEC;
33d22854:	e5d13054 	ldrb	r3, [r1, #84]
	a_min	= rtc->ALMMIN;
33d22858:	e5d13058 	ldrb	r3, [r1, #88]
	a_hour	= rtc->ALMHOUR;
33d2285c:	e5d1305c 	ldrb	r3, [r1, #92]
	a_date	= rtc->ALMDATE;
33d22860:	e5d13060 	ldrb	r3, [r1, #96]
	a_mon	= rtc->ALMMON;
33d22864:	e5d13064 	ldrb	r3, [r1, #100]
	a_year	= rtc->ALMYEAR;
33d22868:	e5d13068 	ldrb	r3, [r1, #104]
	a_armed	= rtc->RTCALM;
33d2286c:	e5d13050 	ldrb	r3, [r1, #80]
	switch (a) {
		case RTC_ENABLE:
			rtc->RTCCON |= 0x01; break;

		case RTC_DISABLE:
			rtc->RTCCON &= ~0x01; break;
33d22870:	e5d23040 	ldrb	r3, [r2, #64]
33d22874:	e3c33001 	bic	r3, r3, #1	; 0x1
33d22878:	e5c23040 	strb	r3, [r2, #64]
		a_armed,
		a_year, a_mon, a_date,
		a_hour, a_min, a_sec);
#endif

	tmp->tm_sec  = bcd2bin(sec  & 0x7F);
33d2287c:	e200007f 	and	r0, r0, #127	; 0x7f
33d22880:	ebffffce 	bl	33d227c0 <bcd2bin>
33d22884:	e5850000 	str	r0, [r5]
	tmp->tm_min  = bcd2bin(min  & 0x7F);
33d22888:	e204007f 	and	r0, r4, #127	; 0x7f
33d2288c:	ebffffcb 	bl	33d227c0 <bcd2bin>
33d22890:	e5850004 	str	r0, [r5, #4]
	tmp->tm_hour = bcd2bin(hour & 0x3F);
33d22894:	e206003f 	and	r0, r6, #63	; 0x3f
33d22898:	ebffffc8 	bl	33d227c0 <bcd2bin>
33d2289c:	e5850008 	str	r0, [r5, #8]
	tmp->tm_mday = bcd2bin(mday & 0x3F);
33d228a0:	e20a003f 	and	r0, sl, #63	; 0x3f
33d228a4:	ebffffc5 	bl	33d227c0 <bcd2bin>
33d228a8:	e585000c 	str	r0, [r5, #12]
	tmp->tm_mon  = bcd2bin(mon & 0x1F);
33d228ac:	e209001f 	and	r0, r9, #31	; 0x1f
33d228b0:	ebffffc2 	bl	33d227c0 <bcd2bin>
33d228b4:	e5850010 	str	r0, [r5, #16]
	tmp->tm_year = bcd2bin(year);
33d228b8:	e1a00007 	mov	r0, r7
33d228bc:	ebffffbf 	bl	33d227c0 <bcd2bin>
33d228c0:	e1a04000 	mov	r4, r0
33d228c4:	e5850014 	str	r0, [r5, #20]
	tmp->tm_wday = bcd2bin(wday & 0x07);
33d228c8:	e20b0007 	and	r0, fp, #7	; 0x7
33d228cc:	ebffffbb 	bl	33d227c0 <bcd2bin>
	if(tmp->tm_year<70)
33d228d0:	e3540045 	cmp	r4, #69	; 0x45
		tmp->tm_year+=2000;
	else
		tmp->tm_year+=1900;
33d228d4:	c2843e76 	addgt	r3, r4, #1888	; 0x760
	tmp->tm_mday = bcd2bin(mday & 0x3F);
	tmp->tm_mon  = bcd2bin(mon & 0x1F);
	tmp->tm_year = bcd2bin(year);
	tmp->tm_wday = bcd2bin(wday & 0x07);
	if(tmp->tm_year<70)
		tmp->tm_year+=2000;
33d228d8:	d2843e7d 	addle	r3, r4, #2000	; 0x7d0
	else
		tmp->tm_year+=1900;
33d228dc:	c283300c 	addgt	r3, r3, #12	; 0xc
33d228e0:	e5853014 	str	r3, [r5, #20]
	tmp->tm_yday = 0;
33d228e4:	e3a03000 	mov	r3, #0	; 0x0
	tmp->tm_min  = bcd2bin(min  & 0x7F);
	tmp->tm_hour = bcd2bin(hour & 0x3F);
	tmp->tm_mday = bcd2bin(mday & 0x3F);
	tmp->tm_mon  = bcd2bin(mon & 0x1F);
	tmp->tm_year = bcd2bin(year);
	tmp->tm_wday = bcd2bin(wday & 0x07);
33d228e8:	e5850018 	str	r0, [r5, #24]
	if(tmp->tm_year<70)
		tmp->tm_year+=2000;
	else
		tmp->tm_year+=1900;
	tmp->tm_yday = 0;
	tmp->tm_isdst= 0;
33d228ec:	e5853020 	str	r3, [r5, #32]
	tmp->tm_wday = bcd2bin(wday & 0x07);
	if(tmp->tm_year<70)
		tmp->tm_year+=2000;
	else
		tmp->tm_year+=1900;
	tmp->tm_yday = 0;
33d228f0:	e585301c 	str	r3, [r5, #28]
	tmp->tm_isdst= 0;
33d228f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d228f8 <rtc_set>:
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
}

void rtc_set (struct rtc_time *tmp)
{
33d228f8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
#ifdef RTC_DEBUG
	printf ( "Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
	year	= bin2bcd(tmp->tm_year % 100);
33d228fc:	e3a01064 	mov	r1, #100	; 0x64
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
}

void rtc_set (struct rtc_time *tmp)
{
33d22900:	e1a04000 	mov	r4, r0
#ifdef RTC_DEBUG
	printf ( "Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
	year	= bin2bcd(tmp->tm_year % 100);
33d22904:	e5900014 	ldr	r0, [r0, #20]
33d22908:	ebffefa4 	bl	33d1e7a0 <__modsi3>
33d2290c:	ebffffb2 	bl	33d227dc <bin2bcd>
33d22910:	e1a03000 	mov	r3, r0
	mon	= bin2bcd(tmp->tm_mon);
33d22914:	e5940010 	ldr	r0, [r4, #16]
#ifdef RTC_DEBUG
	printf ( "Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
	year	= bin2bcd(tmp->tm_year % 100);
33d22918:	e203b0ff 	and	fp, r3, #255	; 0xff
	mon	= bin2bcd(tmp->tm_mon);
33d2291c:	ebffffae 	bl	33d227dc <bin2bcd>
33d22920:	e1a09000 	mov	r9, r0
	wday	= bin2bcd(tmp->tm_wday);
33d22924:	e5940018 	ldr	r0, [r4, #24]
33d22928:	ebffffab 	bl	33d227dc <bin2bcd>
33d2292c:	e1a0a000 	mov	sl, r0
	mday	= bin2bcd(tmp->tm_mday);
33d22930:	e594000c 	ldr	r0, [r4, #12]
33d22934:	ebffffa8 	bl	33d227dc <bin2bcd>
33d22938:	e1a07000 	mov	r7, r0
	hour	= bin2bcd(tmp->tm_hour);
33d2293c:	e5940008 	ldr	r0, [r4, #8]
33d22940:	ebffffa5 	bl	33d227dc <bin2bcd>
33d22944:	e1a06000 	mov	r6, r0
	min	= bin2bcd(tmp->tm_min);
33d22948:	e5940004 	ldr	r0, [r4, #4]
33d2294c:	ebffffa2 	bl	33d227dc <bin2bcd>
33d22950:	e1a05000 	mov	r5, r0
	sec	= bin2bcd(tmp->tm_sec);
33d22954:	e5940000 	ldr	r0, [r4]
33d22958:	ebffff9f 	bl	33d227dc <bin2bcd>
33d2295c:	e3a02457 	mov	r2, #1459617792	; 0x57000000
static inline void SetRTC_Access(RTC_ACCESS a)
{
	S3C24X0_RTC * const rtc = S3C24X0_GetBase_RTC();
	switch (a) {
		case RTC_ENABLE:
			rtc->RTCCON |= 0x01; break;
33d22960:	e5d23040 	ldrb	r3, [r2, #64]
	printf ( "Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
	year	= bin2bcd(tmp->tm_year % 100);
	mon	= bin2bcd(tmp->tm_mon);
33d22964:	e20990ff 	and	r9, r9, #255	; 0xff
static inline void SetRTC_Access(RTC_ACCESS a)
{
	S3C24X0_RTC * const rtc = S3C24X0_GetBase_RTC();
	switch (a) {
		case RTC_ENABLE:
			rtc->RTCCON |= 0x01; break;
33d22968:	e3833001 	orr	r3, r3, #1	; 0x1
		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
#endif
	year	= bin2bcd(tmp->tm_year % 100);
	mon	= bin2bcd(tmp->tm_mon);
	wday	= bin2bcd(tmp->tm_wday);
33d2296c:	e20aa0ff 	and	sl, sl, #255	; 0xff
	mday	= bin2bcd(tmp->tm_mday);
33d22970:	e20770ff 	and	r7, r7, #255	; 0xff
	hour	= bin2bcd(tmp->tm_hour);
33d22974:	e20660ff 	and	r6, r6, #255	; 0xff
	min	= bin2bcd(tmp->tm_min);
33d22978:	e20550ff 	and	r5, r5, #255	; 0xff
	sec	= bin2bcd(tmp->tm_sec);
33d2297c:	e20000ff 	and	r0, r0, #255	; 0xff
static inline void SetRTC_Access(RTC_ACCESS a)
{
	S3C24X0_RTC * const rtc = S3C24X0_GetBase_RTC();
	switch (a) {
		case RTC_ENABLE:
			rtc->RTCCON |= 0x01; break;
33d22980:	e5c23040 	strb	r3, [r2, #64]

	/* enable access to RTC registers */
	SetRTC_Access(RTC_ENABLE);

	/* write RTC registers */
	rtc->BCDSEC	= sec;
33d22984:	e5c20070 	strb	r0, [r2, #112]
	rtc->BCDMIN	= min;
33d22988:	e5c25074 	strb	r5, [r2, #116]
	rtc->BCDHOUR	= hour;
33d2298c:	e5c26078 	strb	r6, [r2, #120]
	rtc->BCDDATE	= mday;
33d22990:	e5c2707c 	strb	r7, [r2, #124]
	rtc->BCDDAY	= wday;
33d22994:	e5c2a080 	strb	sl, [r2, #128]
	rtc->BCDMON	= mon;
33d22998:	e5c29084 	strb	r9, [r2, #132]
	rtc->BCDYEAR	= year;
33d2299c:	e5c2b088 	strb	fp, [r2, #136]
	switch (a) {
		case RTC_ENABLE:
			rtc->RTCCON |= 0x01; break;

		case RTC_DISABLE:
			rtc->RTCCON &= ~0x01; break;
33d229a0:	e5d23040 	ldrb	r3, [r2, #64]
33d229a4:	e3c33001 	bic	r3, r3, #1	; 0x1
33d229a8:	e5c23040 	strb	r3, [r2, #64]
	rtc->BCDMON	= mon;
	rtc->BCDYEAR	= year;

	/* disable access to RTC registers */
	SetRTC_Access(RTC_DISABLE);
}
33d229ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

33d229b0 <rtc_reset>:
33d229b0:	e3a03457 	mov	r3, #1459617792	; 0x57000000

void rtc_reset (void)
{
	S3C24X0_RTC * const rtc = S3C24X0_GetBase_RTC();

	rtc->RTCCON = (rtc->RTCCON & ~0x06) | 0x08;
33d229b4:	e5d32040 	ldrb	r2, [r3, #64]
33d229b8:	e3c22006 	bic	r2, r2, #6	; 0x6
33d229bc:	e3822008 	orr	r2, r2, #8	; 0x8
33d229c0:	e5c32040 	strb	r2, [r3, #64]
	rtc->RTCCON &= ~(0x08|0x01);
33d229c4:	e5d32040 	ldrb	r2, [r3, #64]
33d229c8:	e3c22009 	bic	r2, r2, #9	; 0x9
33d229cc:	e5c32040 	strb	r2, [r3, #64]
33d229d0:	e1a0f00e 	mov	pc, lr

33d229d4 <nand_block_bad_scrub>:

/*****************************************************************************/
static int nand_block_bad_scrub(struct mtd_info *mtd, loff_t ofs, int getchip)
{
    return 0;
}
33d229d4:	e3a00000 	mov	r0, #0	; 0x0
33d229d8:	e1a0f00e 	mov	pc, lr

33d229dc <nand_erase_opts>:
 *
 * This code is ported from flash_eraseall.c from Linux mtd utils by
 * Arcom Control System Ltd.
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
33d229dc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    struct jffs2_unknown_node cleanmarker;
    int clmpos = 0;
33d229e0:	e3a02000 	mov	r2, #0	; 0x0
 *
 * This code is ported from flash_eraseall.c from Linux mtd utils by
 * Arcom Control System Ltd.
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
33d229e4:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    struct jffs2_unknown_node cleanmarker;
    int clmpos = 0;
33d229e8:	e58d2018 	str	r2, [sp, #24]
    ulong erase_length;
    int isNAND;
    int bbtest = 1;
    int result;
    int percent_complete = -1;
    int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
33d229ec:	e58d2008 	str	r2, [sp, #8]
 *
 * This code is ported from flash_eraseall.c from Linux mtd utils by
 * Arcom Control System Ltd.
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
33d229f0:	e1a05000 	mov	r5, r0
33d229f4:	e1a07001 	mov	r7, r1
    int result;
    int percent_complete = -1;
    int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
    const char *mtd_device = meminfo->name;

    memset(&erase, 0, sizeof(erase));
33d229f8:	e28d0020 	add	r0, sp, #32	; 0x20
33d229fc:	e1a01002 	mov	r1, r2
33d22a00:	e2822030 	add	r2, r2, #48	; 0x30
    int isNAND;
    int bbtest = 1;
    int result;
    int percent_complete = -1;
    int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
    const char *mtd_device = meminfo->name;
33d22a04:	e5959024 	ldr	r9, [r5, #36]

    memset(&erase, 0, sizeof(erase));
33d22a08:	ebffde61 	bl	33d1a394 <memset>
    erase.mtd = meminfo;
    erase.len  = meminfo->erasesize;
    erase.addr = opts->offset;
    erase_length = opts->length;

    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
33d22a0c:	e5d53000 	ldrb	r3, [r5]

    if (opts->jffs2) {
33d22a10:	e597200c 	ldr	r2, [r7, #12]
    const char *mtd_device = meminfo->name;

    memset(&erase, 0, sizeof(erase));

    erase.mtd = meminfo;
    erase.len  = meminfo->erasesize;
33d22a14:	e595100c 	ldr	r1, [r5, #12]
    erase.addr = opts->offset;
33d22a18:	e5970004 	ldr	r0, [r7, #4]
    erase_length = opts->length;

    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
33d22a1c:	e3530004 	cmp	r3, #4	; 0x4
33d22a20:	13a03000 	movne	r3, #0	; 0x0
33d22a24:	03a03001 	moveq	r3, #1	; 0x1
33d22a28:	e58d3010 	str	r3, [sp, #16]

    if (opts->jffs2) {
33d22a2c:	e3520000 	cmp	r2, #0	; 0x0
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
    struct jffs2_unknown_node cleanmarker;
    int clmpos = 0;
    int clmlen = 8;
33d22a30:	e3a03008 	mov	r3, #8	; 0x8
    erase_info_t erase;
    ulong erase_length;
    int isNAND;
    int bbtest = 1;
    int result;
    int percent_complete = -1;
33d22a34:	e3e02000 	mvn	r2, #0	; 0x0
    const char *mtd_device = meminfo->name;

    memset(&erase, 0, sizeof(erase));

    erase.mtd = meminfo;
    erase.len  = meminfo->erasesize;
33d22a38:	e58d1028 	str	r1, [sp, #40]
    erase.addr = opts->offset;
33d22a3c:	e58d0024 	str	r0, [sp, #36]
    int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
    const char *mtd_device = meminfo->name;

    memset(&erase, 0, sizeof(erase));

    erase.mtd = meminfo;
33d22a40:	e58d5020 	str	r5, [sp, #32]
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
    struct jffs2_unknown_node cleanmarker;
    int clmpos = 0;
    int clmlen = 8;
33d22a44:	e58d3014 	str	r3, [sp, #20]
    erase_info_t erase;
    ulong erase_length;
    int isNAND;
    int bbtest = 1;
    int result;
    int percent_complete = -1;
33d22a48:	e58d200c 	str	r2, [sp, #12]
    memset(&erase, 0, sizeof(erase));

    erase.mtd = meminfo;
    erase.len  = meminfo->erasesize;
    erase.addr = opts->offset;
    erase_length = opts->length;
33d22a4c:	e597b000 	ldr	fp, [r7]

    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;

    if (opts->jffs2) {
33d22a50:	0a000038 	beq	33d22b38 <nand_erase_opts+0x15c>
        cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
        cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
        if (isNAND) {
33d22a54:	e59d3010 	ldr	r3, [sp, #16]
33d22a58:	e3530000 	cmp	r3, #0	; 0x0
    erase_length = opts->length;

    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;

    if (opts->jffs2) {
        cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
33d22a5c:	e59f32d8 	ldr	r3, [pc, #728]	; 33d22d3c <nand_erase_opts+0x360>
33d22a60:	e1cd35b0 	strh	r3, [sp, #80]
        cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
33d22a64:	e59f32d4 	ldr	r3, [pc, #724]	; 33d22d40 <nand_erase_opts+0x364>
33d22a68:	e1cd35b2 	strh	r3, [sp, #82]
                }
            }

            cleanmarker.totlen = cpu_to_je32(8);
        } else {
            cleanmarker.totlen =
33d22a6c:	03a0300c 	moveq	r3, #12	; 0xc
    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;

    if (opts->jffs2) {
        cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
        cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
        if (isNAND) {
33d22a70:	0a00002a 	beq	33d22b20 <nand_erase_opts+0x144>
            struct nand_oobinfo *oobinfo = &meminfo->oobinfo;

            /* check for autoplacement */
            if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
33d22a74:	e595302c 	ldr	r3, [r5, #44]
33d22a78:	e3530002 	cmp	r3, #2	; 0x2

    if (opts->jffs2) {
        cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
        cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
        if (isNAND) {
            struct nand_oobinfo *oobinfo = &meminfo->oobinfo;
33d22a7c:	e285202c 	add	r2, r5, #44	; 0x2c

            /* check for autoplacement */
            if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
33d22a80:	1a00000d 	bne	33d22abc <nand_erase_opts+0xe0>
                /* get the position of the free bytes */
                if (!oobinfo->oobfree[0][1]) {
33d22a84:	e592300c 	ldr	r3, [r2, #12]
33d22a88:	e3530000 	cmp	r3, #0	; 0x0
33d22a8c:	1a000003 	bne	33d22aa0 <nand_erase_opts+0xc4>
                    printf(" Eeep. Autoplacement selected "
33d22a90:	e59f02ac 	ldr	r0, [pc, #684]	; 33d22d44 <nand_erase_opts+0x368>
33d22a94:	ebffd14b 	bl	33d16fc8 <printf>
                           "and no empty space in oob\n");
                    return -1;
33d22a98:	e59d000c 	ldr	r0, [sp, #12]
33d22a9c:	ea0000a4 	b	33d22d34 <nand_erase_opts+0x358>
                }
                clmpos = oobinfo->oobfree[0][0];
                clmlen = oobinfo->oobfree[0][1];
33d22aa0:	e58d3014 	str	r3, [sp, #20]
                if (!oobinfo->oobfree[0][1]) {
                    printf(" Eeep. Autoplacement selected "
                           "and no empty space in oob\n");
                    return -1;
                }
                clmpos = oobinfo->oobfree[0][0];
33d22aa4:	e5922008 	ldr	r2, [r2, #8]
                clmlen = oobinfo->oobfree[0][1];
                if (clmlen > 8)
33d22aa8:	e3530008 	cmp	r3, #8	; 0x8
                if (!oobinfo->oobfree[0][1]) {
                    printf(" Eeep. Autoplacement selected "
                           "and no empty space in oob\n");
                    return -1;
                }
                clmpos = oobinfo->oobfree[0][0];
33d22aac:	e58d2018 	str	r2, [sp, #24]
                clmlen = oobinfo->oobfree[0][1];
                if (clmlen > 8)
                    clmlen = 8;
33d22ab0:	c3a02008 	movgt	r2, #8	; 0x8
                           "and no empty space in oob\n");
                    return -1;
                }
                clmpos = oobinfo->oobfree[0][0];
                clmlen = oobinfo->oobfree[0][1];
                if (clmlen > 8)
33d22ab4:	ca000010 	bgt	33d22afc <nand_erase_opts+0x120>
33d22ab8:	ea000010 	b	33d22b00 <nand_erase_opts+0x124>
                    clmlen = 8;
            } else {
                /* legacy mode */
                switch (meminfo->oobsize) {
33d22abc:	e5953014 	ldr	r3, [r5, #20]
33d22ac0:	e3530010 	cmp	r3, #16	; 0x10
                case 8:
                    clmpos = 6;
                    clmlen = 2;
                    break;
                case 16:
                    clmpos = 8;
33d22ac4:	059d3014 	ldreq	r3, [sp, #20]
33d22ac8:	058d3018 	streq	r3, [sp, #24]
                clmlen = oobinfo->oobfree[0][1];
                if (clmlen > 8)
                    clmlen = 8;
            } else {
                /* legacy mode */
                switch (meminfo->oobsize) {
33d22acc:	0a00000b 	beq	33d22b00 <nand_erase_opts+0x124>
33d22ad0:	8a000002 	bhi	33d22ae0 <nand_erase_opts+0x104>
33d22ad4:	e3530008 	cmp	r3, #8	; 0x8
33d22ad8:	0a000004 	beq	33d22af0 <nand_erase_opts+0x114>
33d22adc:	ea000007 	b	33d22b00 <nand_erase_opts+0x124>
33d22ae0:	e3530040 	cmp	r3, #64	; 0x40
                case 16:
                    clmpos = 8;
                    clmlen = 8;
                    break;
                case 64:
                    clmpos = 16;
33d22ae4:	03a02010 	moveq	r2, #16	; 0x10
33d22ae8:	058d2018 	streq	r2, [sp, #24]
33d22aec:	ea000003 	b	33d22b00 <nand_erase_opts+0x124>
                    clmlen = 8;
            } else {
                /* legacy mode */
                switch (meminfo->oobsize) {
                case 8:
                    clmpos = 6;
33d22af0:	e3a03006 	mov	r3, #6	; 0x6
33d22af4:	e58d3018 	str	r3, [sp, #24]
                    clmlen = 2;
33d22af8:	e3a02002 	mov	r2, #2	; 0x2
33d22afc:	e58d2014 	str	r2, [sp, #20]
                    clmlen = 8;
                    break;
                }
            }

            cleanmarker.totlen = cpu_to_je32(8);
33d22b00:	e3a03008 	mov	r3, #8	; 0x8
33d22b04:	ea000005 	b	33d22b20 <nand_erase_opts+0x144>
                           "                         \n",
                           erase.addr);
                continue;

            } else if (ret < 0) {
                printf("\n%s: MTD get bad block failed: %d\n",
33d22b08:	e1a02000 	mov	r2, r0
33d22b0c:	e1a01009 	mov	r1, r9
33d22b10:	e59f0230 	ldr	r0, [pc, #560]	; 33d22d48 <nand_erase_opts+0x36c>
33d22b14:	ebffd12b 	bl	33d16fc8 <printf>
                       mtd_device,
                       ret);
                return -1;
33d22b18:	e3e00000 	mvn	r0, #0	; 0x0
33d22b1c:	ea000084 	b	33d22d34 <nand_erase_opts+0x358>
            cleanmarker.totlen = cpu_to_je32(8);
        } else {
            cleanmarker.totlen =
                cpu_to_je32(sizeof(struct jffs2_unknown_node));
        }
        cleanmarker.hdr_crc =  cpu_to_je32(
33d22b20:	e3a00000 	mov	r0, #0	; 0x0
33d22b24:	e28d1050 	add	r1, sp, #80	; 0x50
33d22b28:	e3a02008 	mov	r2, #8	; 0x8
                }
            }

            cleanmarker.totlen = cpu_to_je32(8);
        } else {
            cleanmarker.totlen =
33d22b2c:	e58d3054 	str	r3, [sp, #84]
                cpu_to_je32(sizeof(struct jffs2_unknown_node));
        }
        cleanmarker.hdr_crc =  cpu_to_je32(
33d22b30:	ebffdcb7 	bl	33d19e14 <crc32_no_comp>
33d22b34:	e58d0058 	str	r0, [sp, #88]

    /* scrub option allows to erase badblock. To prevent internal
     * check from erase() method, set block check method to dummy
     * and disable bad block table while erasing.
     */
    if (opts->scrub) {
33d22b38:	e5973010 	ldr	r3, [r7, #16]
33d22b3c:	e3530000 	cmp	r3, #0	; 0x0
33d22b40:	0a000009 	beq	33d22b6c <nand_erase_opts+0x190>
        struct nand_chip *priv_nand = meminfo->priv;
33d22b44:	e595413c 	ldr	r4, [r5, #316]

        nand_block_bad_old = priv_nand->block_bad;
33d22b48:	e5943028 	ldr	r3, [r4, #40]
        priv_nand->block_bad = nand_block_bad_scrub;
        /* we don't need the bad block table anymore...
         * after scrub, there are no bad blocks left!
         */
        if (priv_nand->bbt) {
33d22b4c:	e59400a4 	ldr	r0, [r4, #164]
     * and disable bad block table while erasing.
     */
    if (opts->scrub) {
        struct nand_chip *priv_nand = meminfo->priv;

        nand_block_bad_old = priv_nand->block_bad;
33d22b50:	e58d3008 	str	r3, [sp, #8]
        priv_nand->block_bad = nand_block_bad_scrub;
33d22b54:	e59f31f0 	ldr	r3, [pc, #496]	; 33d22d4c <nand_erase_opts+0x370>
        /* we don't need the bad block table anymore...
         * after scrub, there are no bad blocks left!
         */
        if (priv_nand->bbt) {
33d22b58:	e3500000 	cmp	r0, #0	; 0x0
     */
    if (opts->scrub) {
        struct nand_chip *priv_nand = meminfo->priv;

        nand_block_bad_old = priv_nand->block_bad;
        priv_nand->block_bad = nand_block_bad_scrub;
33d22b5c:	e5843028 	str	r3, [r4, #40]
        /* we don't need the bad block table anymore...
         * after scrub, there are no bad blocks left!
         */
        if (priv_nand->bbt) {
            kfree(priv_nand->bbt);
33d22b60:	1bffd23b 	blne	33d17454 <free>
        }
        priv_nand->bbt = NULL;
33d22b64:	e3a03000 	mov	r3, #0	; 0x0
33d22b68:	e58430a4 	str	r3, [r4, #164]
    }

    for (;
33d22b6c:	e5973004 	ldr	r3, [r7, #4]
33d22b70:	e59d1024 	ldr	r1, [sp, #36]
33d22b74:	e083300b 	add	r3, r3, fp
33d22b78:	e1510003 	cmp	r1, r3
33d22b7c:	2a00005f 	bcs	33d22d00 <nand_erase_opts+0x324>
         erase.addr < opts->offset + erase_length;
         erase.addr += meminfo->erasesize) {

        WATCHDOG_RESET ();

        if (!opts->scrub && bbtest) {
33d22b80:	e5973010 	ldr	r3, [r7, #16]
33d22b84:	e3530000 	cmp	r3, #0	; 0x0
33d22b88:	03a03001 	moveq	r3, #1	; 0x1
33d22b8c:	13a03000 	movne	r3, #0	; 0x0
33d22b90:	e3530000 	cmp	r3, #0	; 0x0
33d22b94:	0a00000b 	beq	33d22bc8 <nand_erase_opts+0x1ec>
            int ret = meminfo->block_isbad(meminfo, erase.addr);
33d22b98:	e3a02000 	mov	r2, #0	; 0x0
33d22b9c:	e1a00005 	mov	r0, r5
33d22ba0:	e1a0e00f 	mov	lr, pc
33d22ba4:	e595f134 	ldr	pc, [r5, #308]
            if (ret > 0) {
33d22ba8:	e3500000 	cmp	r0, #0	; 0x0
33d22bac:	da000004 	ble	33d22bc4 <nand_erase_opts+0x1e8>
                if (!opts->quiet)
33d22bb0:	e5973008 	ldr	r3, [r7, #8]
33d22bb4:	e3530000 	cmp	r3, #0	; 0x0
                    printf("\rSkipping bad block at  "
33d22bb8:	059f0190 	ldreq	r0, [pc, #400]	; 33d22d50 <nand_erase_opts+0x374>
        WATCHDOG_RESET ();

        if (!opts->scrub && bbtest) {
            int ret = meminfo->block_isbad(meminfo, erase.addr);
            if (ret > 0) {
                if (!opts->quiet)
33d22bbc:	0a000044 	beq	33d22cd4 <nand_erase_opts+0x2f8>
33d22bc0:	ea000045 	b	33d22cdc <nand_erase_opts+0x300>
                           "0x%08x                   "
                           "                         \n",
                           erase.addr);
                continue;

            } else if (ret < 0) {
33d22bc4:	baffffcf 	blt	33d22b08 <nand_erase_opts+0x12c>
                       ret);
                return -1;
            }
        }

        result = meminfo->erase(meminfo, &erase);
33d22bc8:	e1a00005 	mov	r0, r5
33d22bcc:	e28d1020 	add	r1, sp, #32	; 0x20
33d22bd0:	e1a0e00f 	mov	lr, pc
33d22bd4:	e595f100 	ldr	pc, [r5, #256]
        if (result != 0) {
33d22bd8:	e2506000 	subs	r6, r0, #0	; 0x0
            printf("\n%s: MTD Erase failure: %d\n",
33d22bdc:	11a02006 	movne	r2, r6
33d22be0:	159f016c 	ldrne	r0, [pc, #364]	; 33d22d54 <nand_erase_opts+0x378>
                return -1;
            }
        }

        result = meminfo->erase(meminfo, &erase);
        if (result != 0) {
33d22be4:	1a000015 	bne	33d22c40 <nand_erase_opts+0x264>
                   mtd_device, result);
            continue;
        }

        /* format for JFFS2 ? */
        if (opts->jffs2) {
33d22be8:	e597300c 	ldr	r3, [r7, #12]
33d22bec:	e3530000 	cmp	r3, #0	; 0x0
33d22bf0:	0a000018 	beq	33d22c58 <nand_erase_opts+0x27c>

            /* write cleanmarker */
            if (isNAND) {
33d22bf4:	e59d2010 	ldr	r2, [sp, #16]
33d22bf8:	e3520000 	cmp	r2, #0	; 0x0
33d22bfc:	0a000012 	beq	33d22c4c <nand_erase_opts+0x270>
                size_t written;
                result = meminfo->write_oob(meminfo,
33d22c00:	e59d3018 	ldr	r3, [sp, #24]
33d22c04:	e59d1024 	ldr	r1, [sp, #36]
33d22c08:	e0811003 	add	r1, r1, r3
33d22c0c:	e28d301c 	add	r3, sp, #28	; 0x1c
33d22c10:	e58d3000 	str	r3, [sp]
33d22c14:	e28d3050 	add	r3, sp, #80	; 0x50
33d22c18:	e58d3004 	str	r3, [sp, #4]
33d22c1c:	e3a02000 	mov	r2, #0	; 0x0
33d22c20:	e1a00005 	mov	r0, r5
33d22c24:	e59d3014 	ldr	r3, [sp, #20]
33d22c28:	e1a0e00f 	mov	lr, pc
33d22c2c:	e595f120 	ldr	pc, [r5, #288]
                                erase.addr + clmpos,
                                clmlen,
                                &written,
                                (unsigned char *)
                                &cleanmarker);
                if (result != 0) {
33d22c30:	e2506000 	subs	r6, r0, #0	; 0x0
33d22c34:	0a000007 	beq	33d22c58 <nand_erase_opts+0x27c>
                    printf("\n%s: MTD writeoob failure: %d\n",
33d22c38:	e59f0118 	ldr	r0, [pc, #280]	; 33d22d58 <nand_erase_opts+0x37c>
33d22c3c:	e1a02006 	mov	r2, r6
33d22c40:	e1a01009 	mov	r1, r9
33d22c44:	ebffd0df 	bl	33d16fc8 <printf>
                           mtd_device, result);
                    continue;
33d22c48:	ea000023 	b	33d22cdc <nand_erase_opts+0x300>
                }
            } else {
                printf("\n%s: this erase routine only supports"
33d22c4c:	e59f0108 	ldr	r0, [pc, #264]	; 33d22d5c <nand_erase_opts+0x380>
33d22c50:	e1a01009 	mov	r1, r9
33d22c54:	ebffd0db 	bl	33d16fc8 <printf>
                       " NAND devices!\n",
                       mtd_device);
            }
        }

        if (!opts->quiet) {
33d22c58:	e5973008 	ldr	r3, [r7, #8]
33d22c5c:	e3530000 	cmp	r3, #0	; 0x0
33d22c60:	1a00001d 	bne	33d22cdc <nand_erase_opts+0x300>
            int percent = (int)
33d22c64:	e59da024 	ldr	sl, [sp, #36]
33d22c68:	e595300c 	ldr	r3, [r5, #12]
33d22c6c:	e5972004 	ldr	r2, [r7, #4]
33d22c70:	e08a3003 	add	r3, sl, r3
33d22c74:	e0623003 	rsb	r3, r2, r3
33d22c78:	e3a02064 	mov	r2, #100	; 0x64
33d22c7c:	e0810293 	umull	r0, r1, r3, r2
33d22c80:	e1a0200b 	mov	r2, fp
33d22c84:	e3a03000 	mov	r3, #0	; 0x0
33d22c88:	eb000567 	bl	33d2422c <__udivdi3>

            /* output progress message only at whole percent
             * steps to reduce the number of messages printed
             * on (slow) serial consoles
             */
            if (percent != percent_complete) {
33d22c8c:	e59d200c 	ldr	r2, [sp, #12]
33d22c90:	e1520000 	cmp	r2, r0
                       mtd_device);
            }
        }

        if (!opts->quiet) {
            int percent = (int)
33d22c94:	e1a04001 	mov	r4, r1
33d22c98:	e1a03000 	mov	r3, r0

            /* output progress message only at whole percent
             * steps to reduce the number of messages printed
             * on (slow) serial consoles
             */
            if (percent != percent_complete) {
33d22c9c:	0a00000e 	beq	33d22cdc <nand_erase_opts+0x300>
                percent_complete = percent;

                printf("\rErasing at 0x%x -- %3d%% complete.",
33d22ca0:	e1a02003 	mov	r2, r3
33d22ca4:	e1a0100a 	mov	r1, sl
33d22ca8:	e59f00b0 	ldr	r0, [pc, #176]	; 33d22d60 <nand_erase_opts+0x384>
            /* output progress message only at whole percent
             * steps to reduce the number of messages printed
             * on (slow) serial consoles
             */
            if (percent != percent_complete) {
                percent_complete = percent;
33d22cac:	e58d300c 	str	r3, [sp, #12]

                printf("\rErasing at 0x%x -- %3d%% complete.",
33d22cb0:	ebffd0c4 	bl	33d16fc8 <printf>
                       erase.addr, percent);

                if (opts->jffs2 && result == 0)
33d22cb4:	e597300c 	ldr	r3, [r7, #12]
33d22cb8:	e2533000 	subs	r3, r3, #0	; 0x0
33d22cbc:	13a03001 	movne	r3, #1	; 0x1
33d22cc0:	e3560000 	cmp	r6, #0	; 0x0
33d22cc4:	13a03000 	movne	r3, #0	; 0x0
33d22cc8:	e3530000 	cmp	r3, #0	; 0x0
33d22ccc:	0a000002 	beq	33d22cdc <nand_erase_opts+0x300>
                    printf(" Cleanmarker written at 0x%x.",
33d22cd0:	e59f008c 	ldr	r0, [pc, #140]	; 33d22d64 <nand_erase_opts+0x388>
33d22cd4:	e59d1024 	ldr	r1, [sp, #36]
33d22cd8:	ebffd0ba 	bl	33d16fc8 <printf>
            kfree(priv_nand->bbt);
        }
        priv_nand->bbt = NULL;
    }

    for (;
33d22cdc:	e595100c 	ldr	r1, [r5, #12]
33d22ce0:	e5972004 	ldr	r2, [r7, #4]
33d22ce4:	e59d3024 	ldr	r3, [sp, #36]
33d22ce8:	e082200b 	add	r2, r2, fp
33d22cec:	e0833001 	add	r3, r3, r1
33d22cf0:	e1a01003 	mov	r1, r3
33d22cf4:	e1530002 	cmp	r3, r2
33d22cf8:	e58d3024 	str	r3, [sp, #36]
33d22cfc:	eaffff9e 	b	33d22b7c <nand_erase_opts+0x1a0>
                    printf(" Cleanmarker written at 0x%x.",
                           erase.addr);
            }
        }
    }
    if (!opts->quiet)
33d22d00:	e5973008 	ldr	r3, [r7, #8]
33d22d04:	e3530000 	cmp	r3, #0	; 0x0
        printf("\n");
33d22d08:	059f0058 	ldreq	r0, [pc, #88]	; 33d22d68 <nand_erase_opts+0x38c>
33d22d0c:	0bffd0ad 	bleq	33d16fc8 <printf>

    if (nand_block_bad_old) {
33d22d10:	e59d3008 	ldr	r3, [sp, #8]
33d22d14:	e3530000 	cmp	r3, #0	; 0x0
        struct nand_chip *priv_nand = meminfo->priv;
33d22d18:	1595313c 	ldrne	r3, [r5, #316]

        priv_nand->block_bad = nand_block_bad_old;
33d22d1c:	159d2008 	ldrne	r2, [sp, #8]
        priv_nand->scan_bbt(meminfo);
33d22d20:	11a00005 	movne	r0, r5
        printf("\n");

    if (nand_block_bad_old) {
        struct nand_chip *priv_nand = meminfo->priv;

        priv_nand->block_bad = nand_block_bad_old;
33d22d24:	15832028 	strne	r2, [r3, #40]
        priv_nand->scan_bbt(meminfo);
33d22d28:	11a0e00f 	movne	lr, pc
33d22d2c:	1593f050 	ldrne	pc, [r3, #80]
    }

    return 0;
33d22d30:	e3a00000 	mov	r0, #0	; 0x0
}
33d22d34:	e28dd05c 	add	sp, sp, #92	; 0x5c
33d22d38:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d22d3c:	00001985 	.word	0x00001985
33d22d40:	00002003 	.word	0x00002003
33d22d44:	33d2d824 	.word	0x33d2d824
33d22d48:	33d2d860 	.word	0x33d2d860
33d22d4c:	33d229d4 	.word	0x33d229d4
33d22d50:	33d2d884 	.word	0x33d2d884
33d22d54:	33d2d8d0 	.word	0x33d2d8d0
33d22d58:	33d2d8ec 	.word	0x33d2d8ec
33d22d5c:	33d2d90c 	.word	0x33d2d90c
33d22d60:	33d2d944 	.word	0x33d2d944
33d22d64:	33d2d968 	.word	0x33d2d968
33d22d68:	33d2bd80 	.word	0x33d2bd80

33d22d6c <nand_write_opts>:
 *
 * This code is ported from nandwrite.c from Linux mtd utils by
 * Steven J. Hill and Thomas Gleixner.
 */
int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
{
33d22d6c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d22d70:	e1a07001 	mov	r7, r1
    u_char *buffer = opts->buffer;
    size_t written;
    int result;
    int skipfirstblk = opts->skipfirstblk;

    if (opts->pad && opts->writeoob) {
33d22d74:	e5913024 	ldr	r3, [r1, #36]
 *
 * This code is ported from nandwrite.c from Linux mtd utils by
 * Steven J. Hill and Thomas Gleixner.
 */
int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
{
33d22d78:	e24dd0f4 	sub	sp, sp, #244	; 0xf4
    int imglen = 0;
    int pagelen;
    int baderaseblock;
    int blockstart = -1;
33d22d7c:	e3e01000 	mvn	r1, #0	; 0x0
 * This code is ported from nandwrite.c from Linux mtd utils by
 * Steven J. Hill and Thomas Gleixner.
 */
int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
{
    int imglen = 0;
33d22d80:	e3a0b000 	mov	fp, #0	; 0x0
    int pagelen;
    int baderaseblock;
    int blockstart = -1;
33d22d84:	e58d1020 	str	r1, [sp, #32]
    loff_t offs;
    int readlen;
    int oobinfochanged = 0;
33d22d88:	e58db01c 	str	fp, [sp, #28]
    int percent_complete = -1;
33d22d8c:	e58d1018 	str	r1, [sp, #24]
    struct nand_oobinfo old_oobinfo;
    ulong mtdoffset = opts->offset;
    ulong erasesize_blockalign;
    u_char *buffer = opts->buffer;
33d22d90:	e5972000 	ldr	r2, [r7]
    loff_t offs;
    int readlen;
    int oobinfochanged = 0;
    int percent_complete = -1;
    struct nand_oobinfo old_oobinfo;
    ulong mtdoffset = opts->offset;
33d22d94:	e5979008 	ldr	r9, [r7, #8]
    ulong erasesize_blockalign;
    u_char *buffer = opts->buffer;
33d22d98:	e58d2010 	str	r2, [sp, #16]
    size_t written;
    int result;
    int skipfirstblk = opts->skipfirstblk;

    if (opts->pad && opts->writeoob) {
33d22d9c:	e3530000 	cmp	r3, #0	; 0x0
    ulong mtdoffset = opts->offset;
    ulong erasesize_blockalign;
    u_char *buffer = opts->buffer;
    size_t written;
    int result;
    int skipfirstblk = opts->skipfirstblk;
33d22da0:	e597302c 	ldr	r3, [r7, #44]
 *
 * This code is ported from nandwrite.c from Linux mtd utils by
 * Steven J. Hill and Thomas Gleixner.
 */
int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
{
33d22da4:	e1a0a000 	mov	sl, r0
    ulong mtdoffset = opts->offset;
    ulong erasesize_blockalign;
    u_char *buffer = opts->buffer;
    size_t written;
    int result;
    int skipfirstblk = opts->skipfirstblk;
33d22da8:	e58d300c 	str	r3, [sp, #12]

    if (opts->pad && opts->writeoob) {
33d22dac:	0a000006 	beq	33d22dcc <nand_write_opts+0x60>
33d22db0:	e5973020 	ldr	r3, [r7, #32]
33d22db4:	e153000b 	cmp	r3, fp
33d22db8:	0a000003 	beq	33d22dcc <nand_write_opts+0x60>
        printf("Can't pad when oob data is present.\n");
33d22dbc:	e59f0488 	ldr	r0, [pc, #1160]	; 33d2324c <nand_write_opts+0x4e0>
33d22dc0:	ebffd080 	bl	33d16fc8 <printf>
        return -1;
33d22dc4:	e59d0018 	ldr	r0, [sp, #24]
33d22dc8:	ea00011d 	b	33d23244 <nand_write_opts+0x4d8>
    }

    /* set erasesize to specified number of blocks - to match
     * jffs2 (virtual) block size */
    if (opts->blockalign == 0) {
33d22dcc:	e5973028 	ldr	r3, [r7, #40]
33d22dd0:	e59a000c 	ldr	r0, [sl, #12]
33d22dd4:	e3530000 	cmp	r3, #0	; 0x0
        erasesize_blockalign = meminfo->erasesize;
    } else {
        erasesize_blockalign = meminfo->erasesize * opts->blockalign;
33d22dd8:	10000093 	mulne	r0, r3, r0
33d22ddc:	e58d0014 	str	r0, [sp, #20]
    }

    /* make sure device page sizes are valid */
    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
33d22de0:	e59a2014 	ldr	r2, [sl, #20]
33d22de4:	e3520010 	cmp	r2, #16	; 0x10
33d22de8:	1a000003 	bne	33d22dfc <nand_write_opts+0x90>
33d22dec:	e59a3010 	ldr	r3, [sl, #16]
33d22df0:	e3530c02 	cmp	r3, #512	; 0x200
33d22df4:	0a00000c 	beq	33d22e2c <nand_write_opts+0xc0>
33d22df8:	ea000004 	b	33d22e10 <nand_write_opts+0xa4>
33d22dfc:	e3520008 	cmp	r2, #8	; 0x8
33d22e00:	1a000002 	bne	33d22e10 <nand_write_opts+0xa4>
33d22e04:	e59a3010 	ldr	r3, [sl, #16]
33d22e08:	e3530c01 	cmp	r3, #256	; 0x100
33d22e0c:	ea000003 	b	33d22e20 <nand_write_opts+0xb4>
33d22e10:	e3520040 	cmp	r2, #64	; 0x40
33d22e14:	1a000002 	bne	33d22e24 <nand_write_opts+0xb8>
33d22e18:	e59a3010 	ldr	r3, [sl, #16]
33d22e1c:	e3530b02 	cmp	r3, #2048	; 0x800
33d22e20:	0a000001 	beq	33d22e2c <nand_write_opts+0xc0>
        && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
        && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
        printf("Unknown flash (not normal NAND)\n");
33d22e24:	e59f0424 	ldr	r0, [pc, #1060]	; 33d23250 <nand_write_opts+0x4e4>
33d22e28:	ea000103 	b	33d2323c <nand_write_opts+0x4d0>
        return -1;
    }

    /* read the current oob info */
    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
33d22e2c:	e28a402c 	add	r4, sl, #44	; 0x2c
33d22e30:	e28d002c 	add	r0, sp, #44	; 0x2c
33d22e34:	e1a01004 	mov	r1, r4
33d22e38:	e3a020c8 	mov	r2, #200	; 0xc8
33d22e3c:	ebffdd68 	bl	33d1a3e4 <memcpy>

    /* write without ecc? */
    if (opts->noecc) {
33d22e40:	e597301c 	ldr	r3, [r7, #28]
33d22e44:	e3530000 	cmp	r3, #0	; 0x0
33d22e48:	0a000005 	beq	33d22e64 <nand_write_opts+0xf8>
        memcpy(&meminfo->oobinfo, &none_oobinfo,
33d22e4c:	e1a00004 	mov	r0, r4
33d22e50:	e59f13fc 	ldr	r1, [pc, #1020]	; 33d23254 <nand_write_opts+0x4e8>
33d22e54:	e3a020c8 	mov	r2, #200	; 0xc8
               sizeof(meminfo->oobinfo));
        oobinfochanged = 1;
33d22e58:	e3a05001 	mov	r5, #1	; 0x1
    /* read the current oob info */
    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));

    /* write without ecc? */
    if (opts->noecc) {
        memcpy(&meminfo->oobinfo, &none_oobinfo,
33d22e5c:	ebffdd60 	bl	33d1a3e4 <memcpy>
               sizeof(meminfo->oobinfo));
        oobinfochanged = 1;
33d22e60:	e58d501c 	str	r5, [sp, #28]
    }

    /* autoplace ECC? */
    if (opts->autoplace && (old_oobinfo.useecc != MTD_NANDECC_AUTOPLACE)) {
33d22e64:	e5973010 	ldr	r3, [r7, #16]
33d22e68:	e3530000 	cmp	r3, #0	; 0x0
33d22e6c:	0a000008 	beq	33d22e94 <nand_write_opts+0x128>
33d22e70:	e59d302c 	ldr	r3, [sp, #44]
33d22e74:	e3530002 	cmp	r3, #2	; 0x2
33d22e78:	0a000005 	beq	33d22e94 <nand_write_opts+0x128>

        memcpy(&meminfo->oobinfo, &autoplace_oobinfo,
33d22e7c:	e1a00004 	mov	r0, r4
33d22e80:	e59f13d0 	ldr	r1, [pc, #976]	; 33d23258 <nand_write_opts+0x4ec>
33d22e84:	e3a020c8 	mov	r2, #200	; 0xc8
33d22e88:	ebffdd55 	bl	33d1a3e4 <memcpy>
               sizeof(meminfo->oobinfo));
        oobinfochanged = 1;
33d22e8c:	e3a0e001 	mov	lr, #1	; 0x1
33d22e90:	e58de01c 	str	lr, [sp, #28]
    }

    /* force OOB layout for jffs2 or yaffs? */
    if (opts->forcejffs2 || opts->forceyaffs) {
33d22e94:	e5973014 	ldr	r3, [r7, #20]
33d22e98:	e3530000 	cmp	r3, #0	; 0x0
        struct nand_oobinfo *oobsel =
33d22e9c:	159f13b8 	ldrne	r1, [pc, #952]	; 33d2325c <nand_write_opts+0x4f0>
               sizeof(meminfo->oobinfo));
        oobinfochanged = 1;
    }

    /* force OOB layout for jffs2 or yaffs? */
    if (opts->forcejffs2 || opts->forceyaffs) {
33d22ea0:	1a000003 	bne	33d22eb4 <nand_write_opts+0x148>
33d22ea4:	e5973018 	ldr	r3, [r7, #24]
33d22ea8:	e3530000 	cmp	r3, #0	; 0x0
33d22eac:	0a00000f 	beq	33d22ef0 <nand_write_opts+0x184>
        struct nand_oobinfo *oobsel =
33d22eb0:	e59f13a8 	ldr	r1, [pc, #936]	; 33d23260 <nand_write_opts+0x4f4>
            opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;

        if (meminfo->oobsize == 8) {
33d22eb4:	e59a3014 	ldr	r3, [sl, #20]
33d22eb8:	e3530008 	cmp	r3, #8	; 0x8
33d22ebc:	1a000006 	bne	33d22edc <nand_write_opts+0x170>
            if (opts->forceyaffs) {
33d22ec0:	e5973018 	ldr	r3, [r7, #24]
33d22ec4:	e3530000 	cmp	r3, #0	; 0x0
                printf("YAFSS cannot operate on "
33d22ec8:	159f0394 	ldrne	r0, [pc, #916]	; 33d23264 <nand_write_opts+0x4f8>
    if (opts->forcejffs2 || opts->forceyaffs) {
        struct nand_oobinfo *oobsel =
            opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;

        if (meminfo->oobsize == 8) {
            if (opts->forceyaffs) {
33d22ecc:	1a0000cf 	bne	33d23210 <nand_write_opts+0x4a4>
                printf("YAFSS cannot operate on "
                       "256 Byte page size\n");
                goto restoreoob;
            }
            /* Adjust number of ecc bytes */
            jffs2_oobinfo.eccbytes = 3;
33d22ed0:	e59f3384 	ldr	r3, [pc, #900]	; 33d2325c <nand_write_opts+0x4f0>
33d22ed4:	e3a02003 	mov	r2, #3	; 0x3
33d22ed8:	e5832004 	str	r2, [r3, #4]
        }

        memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
33d22edc:	e1a00004 	mov	r0, r4
33d22ee0:	e3a020c8 	mov	r2, #200	; 0xc8
33d22ee4:	ebffdd3e 	bl	33d1a3e4 <memcpy>
        oobinfochanged = 1;
33d22ee8:	e3a01001 	mov	r1, #1	; 0x1
33d22eec:	e58d101c 	str	r1, [sp, #28]
    }

    /* get image length */
    imglen = opts->length;
    pagelen = meminfo->oobblock
33d22ef0:	e5973020 	ldr	r3, [r7, #32]
33d22ef4:	e3530000 	cmp	r3, #0	; 0x0
33d22ef8:	159a3014 	ldrne	r3, [sl, #20]
33d22efc:	e59a5010 	ldr	r5, [sl, #16]
33d22f00:	e1a04005 	mov	r4, r5
33d22f04:	10854003 	addne	r4, r5, r3
        + ((opts->writeoob != 0) ? meminfo->oobsize : 0);

    /* check, if file is pagealigned */
    if ((!opts->pad) && ((imglen % pagelen) != 0)) {
33d22f08:	e5973024 	ldr	r3, [r7, #36]
33d22f0c:	e3530000 	cmp	r3, #0	; 0x0
        memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
        oobinfochanged = 1;
    }

    /* get image length */
    imglen = opts->length;
33d22f10:	e597b004 	ldr	fp, [r7, #4]
    pagelen = meminfo->oobblock
        + ((opts->writeoob != 0) ? meminfo->oobsize : 0);

    /* check, if file is pagealigned */
    if ((!opts->pad) && ((imglen % pagelen) != 0)) {
33d22f14:	1a000005 	bne	33d22f30 <nand_write_opts+0x1c4>
33d22f18:	e1a0000b 	mov	r0, fp
33d22f1c:	e1a01004 	mov	r1, r4
33d22f20:	ebffee1e 	bl	33d1e7a0 <__modsi3>
33d22f24:	e3500000 	cmp	r0, #0	; 0x0
        printf("Input block length is not page aligned\n");
33d22f28:	159f0338 	ldrne	r0, [pc, #824]	; 33d23268 <nand_write_opts+0x4fc>
    imglen = opts->length;
    pagelen = meminfo->oobblock
        + ((opts->writeoob != 0) ? meminfo->oobsize : 0);

    /* check, if file is pagealigned */
    if ((!opts->pad) && ((imglen % pagelen) != 0)) {
33d22f2c:	1a0000b7 	bne	33d23210 <nand_write_opts+0x4a4>
        printf("Input block length is not page aligned\n");
        goto restoreoob;
    }

    /* check, if length fits into device */
    if (((imglen / pagelen) * meminfo->oobblock)
33d22f30:	e1a0000b 	mov	r0, fp
33d22f34:	e1a01004 	mov	r1, r4
33d22f38:	ebffedc8 	bl	33d1e660 <__divsi3>
33d22f3c:	e0020095 	mul	r2, r5, r0
33d22f40:	e59ac008 	ldr	ip, [sl, #8]
33d22f44:	e5973008 	ldr	r3, [r7, #8]
33d22f48:	e063300c 	rsb	r3, r3, ip
33d22f4c:	e1520003 	cmp	r2, r3
33d22f50:	9a000010 	bls	33d22f98 <nand_write_opts+0x22c>
         > (meminfo->size - opts->offset)) {
        printf("Image %d bytes, NAND page %d bytes, "
33d22f54:	e59f0310 	ldr	r0, [pc, #784]	; 33d2326c <nand_write_opts+0x500>
33d22f58:	e1a02004 	mov	r2, r4
33d22f5c:	e1a03005 	mov	r3, r5
33d22f60:	e1a0100b 	mov	r1, fp
33d22f64:	e58dc000 	str	ip, [sp]
33d22f68:	ebffd016 	bl	33d16fc8 <printf>
               "OOB area %u bytes, device size %u bytes\n",
               imglen, pagelen, meminfo->oobblock, meminfo->size);
        printf("Input block does not fit into device\n");
33d22f6c:	e59f02fc 	ldr	r0, [pc, #764]	; 33d23270 <nand_write_opts+0x504>
33d22f70:	ea0000a6 	b	33d23210 <nand_write_opts+0x4a4>
            if (!opts->nocheckbadblk) {
                do {
                    int ret = meminfo->block_isbad(meminfo, offs);

                    if (ret < 0) {
                        printf("Bad block check failed\n");
33d22f74:	e59f02f8 	ldr	r0, [pc, #760]	; 33d23274 <nand_write_opts+0x508>
33d22f78:	ea0000a4 	b	33d23210 <nand_write_opts+0x4a4>
                            &written,
                            (unsigned char *)
                            &oob_buf);

            if (result != 0) {
                printf("\nMTD writeoob failure: %d\n",
33d22f7c:	e1a01000 	mov	r1, r0
33d22f80:	e59f02f0 	ldr	r0, [pc, #752]	; 33d23278 <nand_write_opts+0x50c>
33d22f84:	ea000001 	b	33d22f90 <nand_write_opts+0x224>
                    meminfo->oobblock,
                    &written,
                    (unsigned char *) &data_buf);

        if (result != 0) {
            printf("writing NAND page at offset 0x%lx failed\n",
33d22f88:	e59f02ec 	ldr	r0, [pc, #748]	; 33d2327c <nand_write_opts+0x510>
33d22f8c:	e1a01009 	mov	r1, r9
33d22f90:	ebffd00c 	bl	33d16fc8 <printf>
                   mtdoffset);
            goto restoreoob;
33d22f94:	ea00009e 	b	33d23214 <nand_write_opts+0x4a8>
               imglen, pagelen, meminfo->oobblock, meminfo->size);
        printf("Input block does not fit into device\n");
        goto restoreoob;
    }

    if (!opts->quiet)
33d22f98:	e597300c 	ldr	r3, [r7, #12]
33d22f9c:	e3530000 	cmp	r3, #0	; 0x0
33d22fa0:	1a000094 	bne	33d231f8 <nand_write_opts+0x48c>
        printf("\n");
33d22fa4:	e59f02d4 	ldr	r0, [pc, #724]	; 33d23280 <nand_write_opts+0x514>
33d22fa8:	ebffd006 	bl	33d16fc8 <printf>
33d22fac:	ea000091 	b	33d231f8 <nand_write_opts+0x48c>
                       mtdoffset, percent);
                percent_complete = percent;
            }
        }

        mtdoffset += meminfo->oobblock;
33d22fb0:	e59a3008 	ldr	r3, [sl, #8]
33d22fb4:	e1590003 	cmp	r9, r3
33d22fb8:	2a000090 	bcs	33d23200 <nand_write_opts+0x494>
                        mtdoffset = blockstart
                            + erasesize_blockalign;
                    }
                    offs +=  erasesize_blockalign
                        / opts->blockalign;
                } while (offs < blockstart + erasesize_blockalign);
33d22fbc:	e59d2014 	ldr	r2, [sp, #20]
33d22fc0:	e1e02002 	mvn	r2, r2
33d22fc4:	e58d2008 	str	r2, [sp, #8]
33d22fc8:	e2822001 	add	r2, r2, #1	; 0x1
33d22fcc:	e59d4020 	ldr	r4, [sp, #32]
33d22fd0:	e0093002 	and	r3, r9, r2
33d22fd4:	e1540003 	cmp	r4, r3
33d22fd8:	0a000031 	beq	33d230a4 <nand_write_opts+0x338>
            offs = blockstart;
            baderaseblock = 0;

            /* check all the blocks in an erase block for
             * bad blocks */
            if (!opts->nocheckbadblk) {
33d22fdc:	e5973030 	ldr	r3, [r7, #48]
         * written to is also checked. Thus avoiding errors if
         * the block(s) after the skipped block(s) is also bad
         * (number of blocks depending on the blockalign
         */
        while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
            blockstart = mtdoffset & (~erasesize_blockalign+1);
33d22fe0:	e0092002 	and	r2, r9, r2
            offs = blockstart;
            baderaseblock = 0;
33d22fe4:	e3a0e000 	mov	lr, #0	; 0x0

            /* check all the blocks in an erase block for
             * bad blocks */
            if (!opts->nocheckbadblk) {
33d22fe8:	e3530000 	cmp	r3, #0	; 0x0
         * written to is also checked. Thus avoiding errors if
         * the block(s) after the skipped block(s) is also bad
         * (number of blocks depending on the blockalign
         */
        while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
            blockstart = mtdoffset & (~erasesize_blockalign+1);
33d22fec:	e58d2020 	str	r2, [sp, #32]
            offs = blockstart;
33d22ff0:	e1a05002 	mov	r5, r2
33d22ff4:	e1a06fc5 	asr	r6, r5, #31
            baderaseblock = 0;
33d22ff8:	e58de024 	str	lr, [sp, #36]

            /* check all the blocks in an erase block for
             * bad blocks */
            if (!opts->nocheckbadblk) {
33d22ffc:	1a000025 	bne	33d23098 <nand_write_opts+0x32c>
                do {
                    int ret = meminfo->block_isbad(meminfo, offs);
33d23000:	e1a02006 	mov	r2, r6
33d23004:	e1a01005 	mov	r1, r5
33d23008:	e1a0000a 	mov	r0, sl
33d2300c:	e1a0e00f 	mov	lr, pc
33d23010:	e59af134 	ldr	pc, [sl, #308]

                    if (ret < 0) {
33d23014:	e250c000 	subs	ip, r0, #0	; 0x0
33d23018:	baffffd5 	blt	33d22f74 <nand_write_opts+0x208>
                        printf("Bad block check failed\n");
                        goto restoreoob;
                    }
                    if (ret == 1) {
33d2301c:	e35c0001 	cmp	ip, #1	; 0x1
33d23020:	1a000008 	bne	33d23048 <nand_write_opts+0x2dc>
                        baderaseblock = 1;
                        if (!opts->quiet)
33d23024:	e597300c 	ldr	r3, [r7, #12]
33d23028:	e3530000 	cmp	r3, #0	; 0x0
                            printf("\rBad block at 0x%lx "
33d2302c:	e59f0250 	ldr	r0, [pc, #592]	; 33d23284 <nand_write_opts+0x518>
33d23030:	e1a01005 	mov	r1, r5
33d23034:	e59d2020 	ldr	r2, [sp, #32]
                    if (ret < 0) {
                        printf("Bad block check failed\n");
                        goto restoreoob;
                    }
                    if (ret == 1) {
                        baderaseblock = 1;
33d23038:	e58dc024 	str	ip, [sp, #36]
                        if (!opts->quiet)
33d2303c:	1a000004 	bne	33d23054 <nand_write_opts+0x2e8>
                            printf("\rBad block at 0x%lx "
33d23040:	ebffcfe0 	bl	33d16fc8 <printf>
33d23044:	ea000002 	b	33d23054 <nand_write_opts+0x2e8>
                                   "0x%x will be skipped\n",
                                   (long) offs,
                                   blockstart);
                    }

                    if (baderaseblock) {
33d23048:	e59d1024 	ldr	r1, [sp, #36]
33d2304c:	e3510000 	cmp	r1, #0	; 0x0
33d23050:	0a000002 	beq	33d23060 <nand_write_opts+0x2f4>
                        mtdoffset = blockstart
33d23054:	e59d2020 	ldr	r2, [sp, #32]
33d23058:	e59d3014 	ldr	r3, [sp, #20]
33d2305c:	e0829003 	add	r9, r2, r3
                            + erasesize_blockalign;
                    }
                    offs +=  erasesize_blockalign
33d23060:	e59d0014 	ldr	r0, [sp, #20]
33d23064:	e5971028 	ldr	r1, [r7, #40]
33d23068:	ebff78dc 	bl	33d013e0 <__udivsi3>
                        / opts->blockalign;
                } while (offs < blockstart + erasesize_blockalign);
33d2306c:	e59d4020 	ldr	r4, [sp, #32]
33d23070:	e59de014 	ldr	lr, [sp, #20]

                    if (baderaseblock) {
                        mtdoffset = blockstart
                            + erasesize_blockalign;
                    }
                    offs +=  erasesize_blockalign
33d23074:	e0955000 	adds	r5, r5, r0
                        / opts->blockalign;
                } while (offs < blockstart + erasesize_blockalign);
33d23078:	e084300e 	add	r3, r4, lr

                    if (baderaseblock) {
                        mtdoffset = blockstart
                            + erasesize_blockalign;
                    }
                    offs +=  erasesize_blockalign
33d2307c:	e2a66000 	adc	r6, r6, #0	; 0x0
                        / opts->blockalign;
                } while (offs < blockstart + erasesize_blockalign);
33d23080:	e3a04000 	mov	r4, #0	; 0x0
33d23084:	e1540006 	cmp	r4, r6
33d23088:	caffffdc 	bgt	33d23000 <nand_write_opts+0x294>
33d2308c:	1a000001 	bne	33d23098 <nand_write_opts+0x32c>
33d23090:	e1530005 	cmp	r3, r5
33d23094:	8affffd9 	bhi	33d23000 <nand_write_opts+0x294>
33d23098:	e59d1008 	ldr	r1, [sp, #8]
33d2309c:	e2812001 	add	r2, r1, #1	; 0x1
33d230a0:	eaffffc9 	b	33d22fcc <nand_write_opts+0x260>
            }
        }

        /* skip the first good block when wirte yaffs image, by www.embedsky.net */
        if (skipfirstblk) {
33d230a4:	e59d500c 	ldr	r5, [sp, #12]
33d230a8:	e3550000 	cmp	r5, #0	; 0x0
            mtdoffset += erasesize_blockalign;
33d230ac:	159de014 	ldrne	lr, [sp, #20]
            skipfirstblk = 0;
33d230b0:	13a01000 	movne	r1, #0	; 0x0
            }
        }

        /* skip the first good block when wirte yaffs image, by www.embedsky.net */
        if (skipfirstblk) {
            mtdoffset += erasesize_blockalign;
33d230b4:	1089900e 	addne	r9, r9, lr
            skipfirstblk = 0;
33d230b8:	158d100c 	strne	r1, [sp, #12]
                } while (offs < blockstart + erasesize_blockalign);
            }
        }

        /* skip the first good block when wirte yaffs image, by www.embedsky.net */
        if (skipfirstblk) {
33d230bc:	1a00004d 	bne	33d231f8 <nand_write_opts+0x48c>
            mtdoffset += erasesize_blockalign;
            skipfirstblk = 0;
            continue;
        }

        readlen = meminfo->oobblock;
33d230c0:	e59a5010 	ldr	r5, [sl, #16]
        if (opts->pad && (imglen < readlen)) {
33d230c4:	e5973024 	ldr	r3, [r7, #36]
33d230c8:	e3530000 	cmp	r3, #0	; 0x0
33d230cc:	115b0005 	cmpne	fp, r5
33d230d0:	aa000005 	bge	33d230ec <nand_write_opts+0x380>
            readlen = imglen;
            memset(data_buf + readlen, 0xff,
33d230d4:	e59f01ac 	ldr	r0, [pc, #428]	; 33d23288 <nand_write_opts+0x51c>
33d230d8:	e06b2005 	rsb	r2, fp, r5
33d230dc:	e08b0000 	add	r0, fp, r0
33d230e0:	e3a010ff 	mov	r1, #255	; 0xff
            continue;
        }

        readlen = meminfo->oobblock;
        if (opts->pad && (imglen < readlen)) {
            readlen = imglen;
33d230e4:	e1a0500b 	mov	r5, fp
            memset(data_buf + readlen, 0xff,
33d230e8:	ebffdca9 	bl	33d1a394 <memset>
                   meminfo->oobblock - readlen);
        }

        /* read page data from input memory buffer */
        memcpy(data_buf, buffer, readlen);
33d230ec:	e59f6194 	ldr	r6, [pc, #404]	; 33d23288 <nand_write_opts+0x51c>
33d230f0:	e1a02005 	mov	r2, r5
33d230f4:	e59d1010 	ldr	r1, [sp, #16]
33d230f8:	e1a00006 	mov	r0, r6
33d230fc:	ebffdcb8 	bl	33d1a3e4 <memcpy>
        buffer += readlen;

        if (opts->writeoob) {
33d23100:	e5973020 	ldr	r3, [r7, #32]
                   meminfo->oobblock - readlen);
        }

        /* read page data from input memory buffer */
        memcpy(data_buf, buffer, readlen);
        buffer += readlen;
33d23104:	e59d2010 	ldr	r2, [sp, #16]

        if (opts->writeoob) {
33d23108:	e3530000 	cmp	r3, #0	; 0x0
                   meminfo->oobblock - readlen);
        }

        /* read page data from input memory buffer */
        memcpy(data_buf, buffer, readlen);
        buffer += readlen;
33d2310c:	e0822005 	add	r2, r2, r5
33d23110:	e58d2010 	str	r2, [sp, #16]

        if (opts->writeoob) {
33d23114:	0a000015 	beq	33d23170 <nand_write_opts+0x404>
            /* read OOB data from input memory block, exit
             * on failure */
            memcpy(oob_buf, buffer, meminfo->oobsize);
33d23118:	e59f416c 	ldr	r4, [pc, #364]	; 33d2328c <nand_write_opts+0x520>
33d2311c:	e1a01002 	mov	r1, r2
33d23120:	e1a00004 	mov	r0, r4
33d23124:	e59a2014 	ldr	r2, [sl, #20]
33d23128:	ebffdcad 	bl	33d1a3e4 <memcpy>
            buffer += meminfo->oobsize;
33d2312c:	e59ac014 	ldr	ip, [sl, #20]

            /* write OOB data first, as ecc will be placed
             * in there*/
            result = meminfo->write_oob(meminfo,
33d23130:	e58d4004 	str	r4, [sp, #4]

        if (opts->writeoob) {
            /* read OOB data from input memory block, exit
             * on failure */
            memcpy(oob_buf, buffer, meminfo->oobsize);
            buffer += meminfo->oobsize;
33d23134:	e59d4010 	ldr	r4, [sp, #16]

            /* write OOB data first, as ecc will be placed
             * in there*/
            result = meminfo->write_oob(meminfo,
33d23138:	e28d3028 	add	r3, sp, #40	; 0x28

        if (opts->writeoob) {
            /* read OOB data from input memory block, exit
             * on failure */
            memcpy(oob_buf, buffer, meminfo->oobsize);
            buffer += meminfo->oobsize;
33d2313c:	e084400c 	add	r4, r4, ip

            /* write OOB data first, as ecc will be placed
             * in there*/
            result = meminfo->write_oob(meminfo,
33d23140:	e58d3000 	str	r3, [sp]
33d23144:	e1a0000a 	mov	r0, sl
33d23148:	e1a0300c 	mov	r3, ip
33d2314c:	e1a01009 	mov	r1, r9
33d23150:	e3a02000 	mov	r2, #0	; 0x0

        if (opts->writeoob) {
            /* read OOB data from input memory block, exit
             * on failure */
            memcpy(oob_buf, buffer, meminfo->oobsize);
            buffer += meminfo->oobsize;
33d23154:	e58d4010 	str	r4, [sp, #16]

            /* write OOB data first, as ecc will be placed
             * in there*/
            result = meminfo->write_oob(meminfo,
33d23158:	e1a0e00f 	mov	lr, pc
33d2315c:	e59af120 	ldr	pc, [sl, #288]
                            meminfo->oobsize,
                            &written,
                            (unsigned char *)
                            &oob_buf);

            if (result != 0) {
33d23160:	e3500000 	cmp	r0, #0	; 0x0
33d23164:	1affff84 	bne	33d22f7c <nand_write_opts+0x210>
                printf("\nMTD writeoob failure: %d\n",
                       result);
                goto restoreoob;
            }
            imglen -= meminfo->oobsize;
33d23168:	e59a3014 	ldr	r3, [sl, #20]
33d2316c:	e063b00b 	rsb	fp, r3, fp
        }

        /* write out the page data */
        result = meminfo->write(meminfo,
33d23170:	e28d2028 	add	r2, sp, #40	; 0x28
33d23174:	e59a3010 	ldr	r3, [sl, #16]
33d23178:	e1a0000a 	mov	r0, sl
33d2317c:	e88d0044 	stm	sp, {r2, r6}
33d23180:	e1a01009 	mov	r1, r9
33d23184:	e3a02000 	mov	r2, #0	; 0x0
33d23188:	e1a0e00f 	mov	lr, pc
33d2318c:	e59af110 	ldr	pc, [sl, #272]
                    mtdoffset,
                    meminfo->oobblock,
                    &written,
                    (unsigned char *) &data_buf);

        if (result != 0) {
33d23190:	e3500000 	cmp	r0, #0	; 0x0
33d23194:	1affff7b 	bne	33d22f88 <nand_write_opts+0x21c>
                   mtdoffset);
            goto restoreoob;
        }
        imglen -= readlen;

        if (!opts->quiet) {
33d23198:	e597300c 	ldr	r3, [r7, #12]
33d2319c:	e3530000 	cmp	r3, #0	; 0x0
        if (result != 0) {
            printf("writing NAND page at offset 0x%lx failed\n",
                   mtdoffset);
            goto restoreoob;
        }
        imglen -= readlen;
33d231a0:	e065b00b 	rsb	fp, r5, fp

        if (!opts->quiet) {
33d231a4:	1a000011 	bne	33d231f0 <nand_write_opts+0x484>
            int percent = (int)
33d231a8:	e5972004 	ldr	r2, [r7, #4]
33d231ac:	e2833064 	add	r3, r3, #100	; 0x64
33d231b0:	e06b1002 	rsb	r1, fp, r2
33d231b4:	e0854391 	umull	r4, r5, r1, r3
33d231b8:	e3a03000 	mov	r3, #0	; 0x0
33d231bc:	e1a01005 	mov	r1, r5
33d231c0:	e1a00004 	mov	r0, r4
33d231c4:	eb000418 	bl	33d2422c <__udivdi3>
                 / opts->length);
            /* output progress message only at whole percent
             * steps to reduce the number of messages printed
             * on (slow) serial consoles
             */
            if (percent != percent_complete) {
33d231c8:	e59de018 	ldr	lr, [sp, #24]
33d231cc:	e15e0000 	cmp	lr, r0
            goto restoreoob;
        }
        imglen -= readlen;

        if (!opts->quiet) {
            int percent = (int)
33d231d0:	e1a05001 	mov	r5, r1
33d231d4:	e1a04000 	mov	r4, r0
                 / opts->length);
            /* output progress message only at whole percent
             * steps to reduce the number of messages printed
             * on (slow) serial consoles
             */
            if (percent != percent_complete) {
33d231d8:	0a000004 	beq	33d231f0 <nand_write_opts+0x484>
                printf("\rWriting data at 0x%x "
33d231dc:	e59f00ac 	ldr	r0, [pc, #172]	; 33d23290 <nand_write_opts+0x524>
33d231e0:	e1a01009 	mov	r1, r9
33d231e4:	e1a02004 	mov	r2, r4
33d231e8:	ebffcf76 	bl	33d16fc8 <printf>
                       "-- %3d%% complete.",
                       mtdoffset, percent);
                percent_complete = percent;
33d231ec:	e58d4018 	str	r4, [sp, #24]
            }
        }

        mtdoffset += meminfo->oobblock;
33d231f0:	e59a3010 	ldr	r3, [sl, #16]
33d231f4:	e0899003 	add	r9, r9, r3
33d231f8:	e35b0000 	cmp	fp, #0	; 0x0
33d231fc:	1affff6b 	bne	33d22fb0 <nand_write_opts+0x244>
    }

    if (!opts->quiet)
33d23200:	e597300c 	ldr	r3, [r7, #12]
33d23204:	e3530000 	cmp	r3, #0	; 0x0
33d23208:	1a000001 	bne	33d23214 <nand_write_opts+0x4a8>
        printf("\n");
33d2320c:	e59f006c 	ldr	r0, [pc, #108]	; 33d23280 <nand_write_opts+0x514>
33d23210:	ebffcf6c 	bl	33d16fc8 <printf>

restoreoob:
    if (oobinfochanged) {
33d23214:	e59d101c 	ldr	r1, [sp, #28]
33d23218:	e3510000 	cmp	r1, #0	; 0x0
        memcpy(&meminfo->oobinfo, &old_oobinfo,
33d2321c:	128a002c 	addne	r0, sl, #44	; 0x2c
33d23220:	128d102c 	addne	r1, sp, #44	; 0x2c
33d23224:	13a020c8 	movne	r2, #200	; 0xc8
33d23228:	1bffdc6d 	blne	33d1a3e4 <memcpy>
               sizeof(meminfo->oobinfo));
    }

    if (imglen > 0) {
33d2322c:	e35b0000 	cmp	fp, #0	; 0x0
        printf("Data did not fit into device, due to bad blocks\n");
        return -1;
    }

    /* return happy */
    return 0;
33d23230:	d3a00000 	movle	r0, #0	; 0x0
    if (oobinfochanged) {
        memcpy(&meminfo->oobinfo, &old_oobinfo,
               sizeof(meminfo->oobinfo));
    }

    if (imglen > 0) {
33d23234:	da000002 	ble	33d23244 <nand_write_opts+0x4d8>
        printf("Data did not fit into device, due to bad blocks\n");
33d23238:	e59f0054 	ldr	r0, [pc, #84]	; 33d23294 <nand_write_opts+0x528>
33d2323c:	ebffcf61 	bl	33d16fc8 <printf>
        return -1;
33d23240:	e3e00000 	mvn	r0, #0	; 0x0
    }

    /* return happy */
    return 0;
}
33d23244:	e28dd0f4 	add	sp, sp, #244	; 0xf4
33d23248:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d2324c:	33d2d988 	.word	0x33d2d988
33d23250:	33d2d9b0 	.word	0x33d2d9b0
33d23254:	33d62650 	.word	0x33d62650
33d23258:	33d36b18 	.word	0x33d36b18
33d2325c:	33d36a50 	.word	0x33d36a50
33d23260:	33d36988 	.word	0x33d36988
33d23264:	33d2d9d4 	.word	0x33d2d9d4
33d23268:	33d2da00 	.word	0x33d2da00
33d2326c:	33d2da28 	.word	0x33d2da28
33d23270:	33d2da78 	.word	0x33d2da78
33d23274:	33d2daa0 	.word	0x33d2daa0
33d23278:	33d2dab8 	.word	0x33d2dab8
33d2327c:	33d2dad4 	.word	0x33d2dad4
33d23280:	33d2bd80 	.word	0x33d2bd80
33d23284:	33d2db00 	.word	0x33d2db00
33d23288:	33d62718 	.word	0x33d62718
33d2328c:	33d62f18 	.word	0x33d62f18
33d23290:	33d2db40 	.word	0x33d2db40
33d23294:	33d2db6c 	.word	0x33d2db6c

33d23298 <nand_read_opts>:
 * @param opts      read options (@see struct nand_read_options)
 * @return      0 in case of success
 *
 */
int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
{
33d23298:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
33d2329c:	e1a0b001 	mov	fp, r1
33d232a0:	e24dd0ec 	sub	sp, sp, #236	; 0xec
    int imglen = opts->length;
    int pagelen;
    int baderaseblock;
    int blockstart = -1;
33d232a4:	e3e01000 	mvn	r1, #0	; 0x0
    int result;
    struct nand_oobinfo old_oobinfo;
    int oobinfochanged = 0;

    /* make sure device page sizes are valid */
    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
33d232a8:	e5902014 	ldr	r2, [r0, #20]
int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
{
    int imglen = opts->length;
    int pagelen;
    int baderaseblock;
    int blockstart = -1;
33d232ac:	e58d1014 	str	r1, [sp, #20]
 * @return      0 in case of success
 *
 */
int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
{
    int imglen = opts->length;
33d232b0:	e59b9004 	ldr	r9, [fp, #4]
    int pagelen;
    int baderaseblock;
    int blockstart = -1;
    int percent_complete = -1;
33d232b4:	e58d1018 	str	r1, [sp, #24]
    loff_t offs;
    size_t readlen;
    ulong mtdoffset = opts->offset;
    u_char *buffer = opts->buffer;
33d232b8:	e59b3000 	ldr	r3, [fp]
    int result;
    struct nand_oobinfo old_oobinfo;
    int oobinfochanged = 0;
33d232bc:	e3a04000 	mov	r4, #0	; 0x0

    /* make sure device page sizes are valid */
    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
33d232c0:	e3520010 	cmp	r2, #16	; 0x10
    int baderaseblock;
    int blockstart = -1;
    int percent_complete = -1;
    loff_t offs;
    size_t readlen;
    ulong mtdoffset = opts->offset;
33d232c4:	e59ba008 	ldr	sl, [fp, #8]
 * @param opts      read options (@see struct nand_read_options)
 * @return      0 in case of success
 *
 */
int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
{
33d232c8:	e1a07000 	mov	r7, r0
    int blockstart = -1;
    int percent_complete = -1;
    loff_t offs;
    size_t readlen;
    ulong mtdoffset = opts->offset;
    u_char *buffer = opts->buffer;
33d232cc:	e58d3010 	str	r3, [sp, #16]
    int result;
    struct nand_oobinfo old_oobinfo;
    int oobinfochanged = 0;
33d232d0:	e58d400c 	str	r4, [sp, #12]

    /* make sure device page sizes are valid */
    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
33d232d4:	1a000003 	bne	33d232e8 <nand_read_opts+0x50>
33d232d8:	e5903010 	ldr	r3, [r0, #16]
33d232dc:	e3530c02 	cmp	r3, #512	; 0x200
33d232e0:	0a00000c 	beq	33d23318 <nand_read_opts+0x80>
33d232e4:	ea000004 	b	33d232fc <nand_read_opts+0x64>
33d232e8:	e3520008 	cmp	r2, #8	; 0x8
33d232ec:	1a000002 	bne	33d232fc <nand_read_opts+0x64>
33d232f0:	e5903010 	ldr	r3, [r0, #16]
33d232f4:	e3530c01 	cmp	r3, #256	; 0x100
33d232f8:	ea000003 	b	33d2330c <nand_read_opts+0x74>
33d232fc:	e3520040 	cmp	r2, #64	; 0x40
33d23300:	1a000002 	bne	33d23310 <nand_read_opts+0x78>
33d23304:	e5973010 	ldr	r3, [r7, #16]
33d23308:	e3530b02 	cmp	r3, #2048	; 0x800
33d2330c:	0a000001 	beq	33d23318 <nand_read_opts+0x80>
        && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
        && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
        printf("Unknown flash (not normal NAND)\n");
33d23310:	e59f0328 	ldr	r0, [pc, #808]	; 33d23640 <nand_read_opts+0x3a8>
33d23314:	ea0000c5 	b	33d23630 <nand_read_opts+0x398>
        return -1;
    }

    pagelen = meminfo->oobblock
33d23318:	e59b3010 	ldr	r3, [fp, #16]
33d2331c:	e5974010 	ldr	r4, [r7, #16]
33d23320:	e3530000 	cmp	r3, #0	; 0x0
33d23324:	e1a05004 	mov	r5, r4
33d23328:	10845002 	addne	r5, r4, r2
        + ((opts->readoob != 0) ? meminfo->oobsize : 0);

    /* check, if length is not larger than device */
    if (((imglen / pagelen) * meminfo->oobblock)
33d2332c:	e1a00009 	mov	r0, r9
33d23330:	e1a01005 	mov	r1, r5
33d23334:	ebffecc9 	bl	33d1e660 <__divsi3>
33d23338:	e0020094 	mul	r2, r4, r0
33d2333c:	e597c008 	ldr	ip, [r7, #8]
33d23340:	e06a300c 	rsb	r3, sl, ip
33d23344:	e1520003 	cmp	r2, r3
33d23348:	9a000010 	bls	33d23390 <nand_read_opts+0xf8>
         > (meminfo->size - opts->offset)) {
        printf("Image %d bytes, NAND page %d bytes, "
33d2334c:	e59f02f0 	ldr	r0, [pc, #752]	; 33d23644 <nand_read_opts+0x3ac>
33d23350:	e1a01009 	mov	r1, r9
33d23354:	e1a02005 	mov	r2, r5
33d23358:	e1a03004 	mov	r3, r4
33d2335c:	e58dc000 	str	ip, [sp]
33d23360:	ebffcf18 	bl	33d16fc8 <printf>
               "OOB area %u bytes, device size %u bytes\n",
               imglen, pagelen, meminfo->oobblock, meminfo->size);
        printf("Input block is larger than device\n");
33d23364:	e59f02dc 	ldr	r0, [pc, #732]	; 33d23648 <nand_read_opts+0x3b0>
33d23368:	ea0000b0 	b	33d23630 <nand_read_opts+0x398>
            if (!opts->nocheckbadblk) {
                do {
                    int ret = meminfo->block_isbad(meminfo, offs);

                    if (ret < 0) {
                        printf("Bad block check failed\n");
33d2336c:	e59f02d8 	ldr	r0, [pc, #728]	; 33d2364c <nand_read_opts+0x3b4>
33d23370:	ea0000a3 	b	33d23604 <nand_read_opts+0x36c>
                       meminfo->oobblock,
                       &readlen,
                       (unsigned char *) &data_buf);

        if (result != 0) {
            printf("reading NAND page at offset 0x%lx failed\n",
33d23374:	e59f02d4 	ldr	r0, [pc, #724]	; 33d23650 <nand_read_opts+0x3b8>
33d23378:	e1a0100a 	mov	r1, sl
33d2337c:	ea000001 	b	33d23388 <nand_read_opts+0xf0>
                           &readlen,
                           (unsigned char *)
                           &oob_buf);

            if (result != 0) {
                printf("\nMTD readoob failure: %d\n",
33d23380:	e1a01000 	mov	r1, r0
33d23384:	e59f02c8 	ldr	r0, [pc, #712]	; 33d23654 <nand_read_opts+0x3bc>
33d23388:	ebffcf0e 	bl	33d16fc8 <printf>
                       result);
                goto restoreoob;
33d2338c:	ea00009d 	b	33d23608 <nand_read_opts+0x370>
               imglen, pagelen, meminfo->oobblock, meminfo->size);
        printf("Input block is larger than device\n");
        return -1;
    }

    if (!opts->quiet)
33d23390:	e59b300c 	ldr	r3, [fp, #12]
33d23394:	e3530000 	cmp	r3, #0	; 0x0
        printf("\n");
33d23398:	059f02b8 	ldreq	r0, [pc, #696]	; 33d23658 <nand_read_opts+0x3c0>
33d2339c:	0bffcf09 	bleq	33d16fc8 <printf>

    /* read the current oob info */
    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
33d233a0:	e287502c 	add	r5, r7, #44	; 0x2c
33d233a4:	e28d0024 	add	r0, sp, #36	; 0x24
33d233a8:	e1a01005 	mov	r1, r5
33d233ac:	e3a020c8 	mov	r2, #200	; 0xc8
33d233b0:	e58d5008 	str	r5, [sp, #8]
33d233b4:	ebffdc0a 	bl	33d1a3e4 <memcpy>

    /* write without ecc? */
    if (opts->noecc) {
33d233b8:	e59b3014 	ldr	r3, [fp, #20]
33d233bc:	e3530000 	cmp	r3, #0	; 0x0
33d233c0:	0a000005 	beq	33d233dc <nand_read_opts+0x144>
        memcpy(&meminfo->oobinfo, &none_oobinfo,
33d233c4:	e59f1290 	ldr	r1, [pc, #656]	; 33d2365c <nand_read_opts+0x3c4>
33d233c8:	e59d0008 	ldr	r0, [sp, #8]
33d233cc:	e3a020c8 	mov	r2, #200	; 0xc8
33d233d0:	ebffdc03 	bl	33d1a3e4 <memcpy>
               sizeof(meminfo->oobinfo));
        oobinfochanged = 1;
33d233d4:	e3a01001 	mov	r1, #1	; 0x1
33d233d8:	e58d100c 	str	r1, [sp, #12]
                       mtdoffset, percent);
                percent_complete = percent;
            }
        }

        mtdoffset += meminfo->oobblock;
33d233dc:	e3590000 	cmp	r9, #0	; 0x0
33d233e0:	ea000082 	b	33d235f0 <nand_read_opts+0x358>
33d233e4:	e5973008 	ldr	r3, [r7, #8]
33d233e8:	e15a0003 	cmp	sl, r3
33d233ec:	2a000080 	bcs	33d235f4 <nand_read_opts+0x35c>
                        mtdoffset = blockstart
                            + meminfo->erasesize;
                    }
                    offs +=  meminfo->erasesize;

                } while (offs < blockstart + meminfo->erasesize);
33d233f0:	e597200c 	ldr	r2, [r7, #12]
33d233f4:	e1e02002 	mvn	r2, r2
33d233f8:	e2823001 	add	r3, r2, #1	; 0x1
33d233fc:	e59d4018 	ldr	r4, [sp, #24]
33d23400:	e00a3003 	and	r3, sl, r3
33d23404:	e1540003 	cmp	r4, r3
33d23408:	0a00002d 	beq	33d234c4 <nand_read_opts+0x22c>
            offs = blockstart;
            baderaseblock = 0;

            /* check all the blocks in an erase block for
             * bad blocks */
            if (!opts->nocheckbadblk) {
33d2340c:	e59b3018 	ldr	r3, [fp, #24]
         * written to is also checked. Thus avoiding errors if
         * the block(s) after the skipped block(s) is also bad
         * (number of blocks depending on the blockalign
         */
        while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
            blockstart = mtdoffset & (~meminfo->erasesize+1);
33d23410:	e2822001 	add	r2, r2, #1	; 0x1
33d23414:	e00a2002 	and	r2, sl, r2
            offs = blockstart;
            baderaseblock = 0;
33d23418:	e3a01000 	mov	r1, #0	; 0x0

            /* check all the blocks in an erase block for
             * bad blocks */
            if (!opts->nocheckbadblk) {
33d2341c:	e3530000 	cmp	r3, #0	; 0x0
         * written to is also checked. Thus avoiding errors if
         * the block(s) after the skipped block(s) is also bad
         * (number of blocks depending on the blockalign
         */
        while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
            blockstart = mtdoffset & (~meminfo->erasesize+1);
33d23420:	e58d2018 	str	r2, [sp, #24]
            offs = blockstart;
33d23424:	e1a05002 	mov	r5, r2
33d23428:	e1a06fc5 	asr	r6, r5, #31
            baderaseblock = 0;
33d2342c:	e58d101c 	str	r1, [sp, #28]

            /* check all the blocks in an erase block for
             * bad blocks */
            if (!opts->nocheckbadblk) {
33d23430:	1affffee 	bne	33d233f0 <nand_read_opts+0x158>
                do {
                    int ret = meminfo->block_isbad(meminfo, offs);
33d23434:	e1a02006 	mov	r2, r6
33d23438:	e1a01005 	mov	r1, r5
33d2343c:	e1a00007 	mov	r0, r7
33d23440:	e1a0e00f 	mov	lr, pc
33d23444:	e597f134 	ldr	pc, [r7, #308]

                    if (ret < 0) {
33d23448:	e250c000 	subs	ip, r0, #0	; 0x0
33d2344c:	baffffc6 	blt	33d2336c <nand_read_opts+0xd4>
                        printf("Bad block check failed\n");
                        goto restoreoob;
                    }
                    if (ret == 1) {
33d23450:	e35c0001 	cmp	ip, #1	; 0x1
33d23454:	1a000008 	bne	33d2347c <nand_read_opts+0x1e4>
                        baderaseblock = 1;
                        if (!opts->quiet)
33d23458:	e59b300c 	ldr	r3, [fp, #12]
33d2345c:	e3530000 	cmp	r3, #0	; 0x0
                            printf("\rBad block at 0x%lx "
33d23460:	e59f01f8 	ldr	r0, [pc, #504]	; 33d23660 <nand_read_opts+0x3c8>
33d23464:	e1a01005 	mov	r1, r5
33d23468:	e59d2018 	ldr	r2, [sp, #24]
                    if (ret < 0) {
                        printf("Bad block check failed\n");
                        goto restoreoob;
                    }
                    if (ret == 1) {
                        baderaseblock = 1;
33d2346c:	e58dc01c 	str	ip, [sp, #28]
                        if (!opts->quiet)
33d23470:	1a000004 	bne	33d23488 <nand_read_opts+0x1f0>
                            printf("\rBad block at 0x%lx "
33d23474:	ebffced3 	bl	33d16fc8 <printf>
33d23478:	ea000002 	b	33d23488 <nand_read_opts+0x1f0>
                                   "0x%x will be skipped\n",
                                   (long) offs,
                                   blockstart);
                    }

                    if (baderaseblock) {
33d2347c:	e59d201c 	ldr	r2, [sp, #28]
33d23480:	e3520000 	cmp	r2, #0	; 0x0
33d23484:	0a000002 	beq	33d23494 <nand_read_opts+0x1fc>
                        mtdoffset = blockstart
33d23488:	e597300c 	ldr	r3, [r7, #12]
33d2348c:	e59d4018 	ldr	r4, [sp, #24]
33d23490:	e084a003 	add	sl, r4, r3
                            + meminfo->erasesize;
                    }
                    offs +=  meminfo->erasesize;
33d23494:	e597200c 	ldr	r2, [r7, #12]

                } while (offs < blockstart + meminfo->erasesize);
33d23498:	e59d1018 	ldr	r1, [sp, #24]

                    if (baderaseblock) {
                        mtdoffset = blockstart
                            + meminfo->erasesize;
                    }
                    offs +=  meminfo->erasesize;
33d2349c:	e0955002 	adds	r5, r5, r2

                } while (offs < blockstart + meminfo->erasesize);
33d234a0:	e0813002 	add	r3, r1, r2
33d234a4:	e3a04000 	mov	r4, #0	; 0x0

                    if (baderaseblock) {
                        mtdoffset = blockstart
                            + meminfo->erasesize;
                    }
                    offs +=  meminfo->erasesize;
33d234a8:	e2a66000 	adc	r6, r6, #0	; 0x0

                } while (offs < blockstart + meminfo->erasesize);
33d234ac:	e1540006 	cmp	r4, r6
33d234b0:	caffffdf 	bgt	33d23434 <nand_read_opts+0x19c>
33d234b4:	1affffcd 	bne	33d233f0 <nand_read_opts+0x158>
33d234b8:	e1530005 	cmp	r3, r5
33d234bc:	8affffdc 	bhi	33d23434 <nand_read_opts+0x19c>
33d234c0:	eaffffca 	b	33d233f0 <nand_read_opts+0x158>
            }
        }


        /* read page data to memory buffer */
        result = meminfo->read(meminfo,
33d234c4:	e59f6198 	ldr	r6, [pc, #408]	; 33d23664 <nand_read_opts+0x3cc>
33d234c8:	e28d1020 	add	r1, sp, #32	; 0x20
33d234cc:	e1a0400a 	mov	r4, sl
33d234d0:	e3a05000 	mov	r5, #0	; 0x0
33d234d4:	e5973010 	ldr	r3, [r7, #16]
33d234d8:	e1a00007 	mov	r0, r7
33d234dc:	e88d0042 	stm	sp, {r1, r6}
33d234e0:	e1a02005 	mov	r2, r5
33d234e4:	e1a01004 	mov	r1, r4
33d234e8:	e1a0e00f 	mov	lr, pc
33d234ec:	e597f10c 	ldr	pc, [r7, #268]
                       mtdoffset,
                       meminfo->oobblock,
                       &readlen,
                       (unsigned char *) &data_buf);

        if (result != 0) {
33d234f0:	e3500000 	cmp	r0, #0	; 0x0
33d234f4:	1affff9e 	bne	33d23374 <nand_read_opts+0xdc>
            printf("reading NAND page at offset 0x%lx failed\n",
                   mtdoffset);
            goto restoreoob;
        }

        if (imglen < readlen) {
33d234f8:	e59d3020 	ldr	r3, [sp, #32]
33d234fc:	e1590003 	cmp	r9, r3
            readlen = imglen;
33d23500:	358d9020 	strcc	r9, [sp, #32]
        }

        memcpy(buffer, data_buf, readlen);
33d23504:	e1a01006 	mov	r1, r6
33d23508:	e59d2020 	ldr	r2, [sp, #32]
33d2350c:	e59d0010 	ldr	r0, [sp, #16]
33d23510:	ebffdbb3 	bl	33d1a3e4 <memcpy>
        buffer += readlen;
        imglen -= readlen;

        if (opts->readoob) {
33d23514:	e59b3010 	ldr	r3, [fp, #16]
        if (imglen < readlen) {
            readlen = imglen;
        }

        memcpy(buffer, data_buf, readlen);
        buffer += readlen;
33d23518:	e59d2020 	ldr	r2, [sp, #32]
        imglen -= readlen;

        if (opts->readoob) {
33d2351c:	e3530000 	cmp	r3, #0	; 0x0
        if (imglen < readlen) {
            readlen = imglen;
        }

        memcpy(buffer, data_buf, readlen);
        buffer += readlen;
33d23520:	e59d3010 	ldr	r3, [sp, #16]
33d23524:	e0833002 	add	r3, r3, r2
        imglen -= readlen;
33d23528:	e0629009 	rsb	r9, r2, r9
        if (imglen < readlen) {
            readlen = imglen;
        }

        memcpy(buffer, data_buf, readlen);
        buffer += readlen;
33d2352c:	e58d3010 	str	r3, [sp, #16]
        imglen -= readlen;

        if (opts->readoob) {
33d23530:	0a000016 	beq	33d23590 <nand_read_opts+0x2f8>
            result = meminfo->read_oob(meminfo,
33d23534:	e59f612c 	ldr	r6, [pc, #300]	; 33d23668 <nand_read_opts+0x3d0>
33d23538:	e28d1020 	add	r1, sp, #32	; 0x20
33d2353c:	e5973014 	ldr	r3, [r7, #20]
33d23540:	e1a00007 	mov	r0, r7
33d23544:	e88d0042 	stm	sp, {r1, r6}
33d23548:	e1a02005 	mov	r2, r5
33d2354c:	e1a01004 	mov	r1, r4
33d23550:	e1a0e00f 	mov	lr, pc
33d23554:	e597f11c 	ldr	pc, [r7, #284]
                           meminfo->oobsize,
                           &readlen,
                           (unsigned char *)
                           &oob_buf);

            if (result != 0) {
33d23558:	e3500000 	cmp	r0, #0	; 0x0
33d2355c:	1affff87 	bne	33d23380 <nand_read_opts+0xe8>
                       result);
                goto restoreoob;
            }


            if (imglen < readlen) {
33d23560:	e59d3020 	ldr	r3, [sp, #32]
33d23564:	e1590003 	cmp	r9, r3
                readlen = imglen;
33d23568:	358d9020 	strcc	r9, [sp, #32]
            }

            memcpy(buffer, oob_buf, readlen);
33d2356c:	e1a01006 	mov	r1, r6
33d23570:	e59d2020 	ldr	r2, [sp, #32]
33d23574:	e59d0010 	ldr	r0, [sp, #16]
33d23578:	ebffdb99 	bl	33d1a3e4 <memcpy>

            buffer += readlen;
33d2357c:	e59d3020 	ldr	r3, [sp, #32]
33d23580:	e59d2010 	ldr	r2, [sp, #16]
33d23584:	e0822003 	add	r2, r2, r3
33d23588:	e58d2010 	str	r2, [sp, #16]
            imglen -= readlen;
33d2358c:	e0639009 	rsb	r9, r3, r9
        }

        if (!opts->quiet) {
33d23590:	e59b300c 	ldr	r3, [fp, #12]
33d23594:	e3530000 	cmp	r3, #0	; 0x0
33d23598:	1a000011 	bne	33d235e4 <nand_read_opts+0x34c>
            int percent = (int)
33d2359c:	e59b2004 	ldr	r2, [fp, #4]
33d235a0:	e2833064 	add	r3, r3, #100	; 0x64
33d235a4:	e0691002 	rsb	r1, r9, r2
33d235a8:	e0854391 	umull	r4, r5, r1, r3
33d235ac:	e3a03000 	mov	r3, #0	; 0x0
33d235b0:	e1a01005 	mov	r1, r5
33d235b4:	e1a00004 	mov	r0, r4
33d235b8:	eb00031b 	bl	33d2422c <__udivdi3>
33d235bc:	e1a05001 	mov	r5, r1
33d235c0:	e1a04000 	mov	r4, r0
                 / opts->length);
            /* output progress message only at whole percent
             * steps to reduce the number of messages printed
             * on (slow) serial consoles
             */
            if (percent != percent_complete) {
33d235c4:	e59d1014 	ldr	r1, [sp, #20]
33d235c8:	e1510004 	cmp	r1, r4
33d235cc:	0a000004 	beq	33d235e4 <nand_read_opts+0x34c>
            if (!opts->quiet)
                printf("\rReading data from 0x%x "
33d235d0:	e59f0094 	ldr	r0, [pc, #148]	; 33d2366c <nand_read_opts+0x3d4>
33d235d4:	e1a0100a 	mov	r1, sl
33d235d8:	e1a02004 	mov	r2, r4
33d235dc:	ebffce79 	bl	33d16fc8 <printf>
                       "-- %3d%% complete.",
                       mtdoffset, percent);
                percent_complete = percent;
33d235e0:	e58d4014 	str	r4, [sp, #20]
            }
        }

        mtdoffset += meminfo->oobblock;
33d235e4:	e5973010 	ldr	r3, [r7, #16]
33d235e8:	e3590000 	cmp	r9, #0	; 0x0
33d235ec:	e08aa003 	add	sl, sl, r3
33d235f0:	1affff7b 	bne	33d233e4 <nand_read_opts+0x14c>
    }

    if (!opts->quiet)
33d235f4:	e59b300c 	ldr	r3, [fp, #12]
33d235f8:	e3530000 	cmp	r3, #0	; 0x0
33d235fc:	1a000001 	bne	33d23608 <nand_read_opts+0x370>
        printf("\n");
33d23600:	e59f0050 	ldr	r0, [pc, #80]	; 33d23658 <nand_read_opts+0x3c0>
33d23604:	ebffce6f 	bl	33d16fc8 <printf>

restoreoob:
    if (oobinfochanged) {
33d23608:	e59d200c 	ldr	r2, [sp, #12]
33d2360c:	e3520000 	cmp	r2, #0	; 0x0
        memcpy(&meminfo->oobinfo, &old_oobinfo,
33d23610:	159d0008 	ldrne	r0, [sp, #8]
33d23614:	128d1024 	addne	r1, sp, #36	; 0x24
33d23618:	13a020c8 	movne	r2, #200	; 0xc8
33d2361c:	1bffdb70 	blne	33d1a3e4 <memcpy>
               sizeof(meminfo->oobinfo));
    }

    if (imglen > 0) {
33d23620:	e3590000 	cmp	r9, #0	; 0x0
        printf("Could not read entire image due to bad blocks\n");
        return -1;
    }

    /* return happy */
    return 0;
33d23624:	d3a00000 	movle	r0, #0	; 0x0
    if (oobinfochanged) {
        memcpy(&meminfo->oobinfo, &old_oobinfo,
               sizeof(meminfo->oobinfo));
    }

    if (imglen > 0) {
33d23628:	da000002 	ble	33d23638 <nand_read_opts+0x3a0>
        printf("Could not read entire image due to bad blocks\n");
33d2362c:	e59f003c 	ldr	r0, [pc, #60]	; 33d23670 <nand_read_opts+0x3d8>
33d23630:	ebffce64 	bl	33d16fc8 <printf>
        return -1;
33d23634:	e3e00000 	mvn	r0, #0	; 0x0
    }

    /* return happy */
    return 0;
}
33d23638:	e28dd0ec 	add	sp, sp, #236	; 0xec
33d2363c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
33d23640:	33d2d9b0 	.word	0x33d2d9b0
33d23644:	33d2da28 	.word	0x33d2da28
33d23648:	33d2dba0 	.word	0x33d2dba0
33d2364c:	33d2daa0 	.word	0x33d2daa0
33d23650:	33d2dbc4 	.word	0x33d2dbc4
33d23654:	33d2dbf0 	.word	0x33d2dbf0
33d23658:	33d2bd80 	.word	0x33d2bd80
33d2365c:	33d62650 	.word	0x33d62650
33d23660:	33d2db00 	.word	0x33d2db00
33d23664:	33d62718 	.word	0x33d62718
33d23668:	33d62f18 	.word	0x33d62f18
33d2366c:	33d2dc0c 	.word	0x33d2dc0c
33d23670:	33d2dc38 	.word	0x33d2dc38

33d23674 <nand_lock>:
 *   current active lock/unlock state of all pages. nand_lock() / nand_unlock()
 *   calls will fail. It is only posible to leave lock-tight state by
 *   an hardware signal (low pulse on _WP pin) or by power down.
 */
int nand_lock(nand_info_t *meminfo, int tight)
{
33d23674:	e92d4070 	push	{r4, r5, r6, lr}
33d23678:	e1a06001 	mov	r6, r1
    int ret = 0;
    int status;
    struct nand_chip *this = meminfo->priv;
33d2367c:	e590413c 	ldr	r4, [r0, #316]

    /* select the NAND device */
    this->select_chip(meminfo, 0);
33d23680:	e3a01000 	mov	r1, #0	; 0x0
 *   current active lock/unlock state of all pages. nand_lock() / nand_unlock()
 *   calls will fail. It is only posible to leave lock-tight state by
 *   an hardware signal (low pulse on _WP pin) or by power down.
 */
int nand_lock(nand_info_t *meminfo, int tight)
{
33d23684:	e1a05000 	mov	r5, r0
    int ret = 0;
    int status;
    struct nand_chip *this = meminfo->priv;

    /* select the NAND device */
    this->select_chip(meminfo, 0);
33d23688:	e1a0e00f 	mov	lr, pc
33d2368c:	e594f024 	ldr	pc, [r4, #36]

    this->cmdfunc(meminfo,
33d23690:	e3560000 	cmp	r6, #0	; 0x0
33d23694:	e3e02000 	mvn	r2, #0	; 0x0
33d23698:	e1a03002 	mov	r3, r2
33d2369c:	03a0102a 	moveq	r1, #42	; 0x2a
33d236a0:	13a0102c 	movne	r1, #44	; 0x2c
33d236a4:	e1a00005 	mov	r0, r5
33d236a8:	e1a0e00f 	mov	lr, pc
33d236ac:	e594f038 	ldr	pc, [r4, #56]
              (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
              -1, -1);

    /* call wait ready function */
    status = this->waitfunc(meminfo, this, FL_WRITING);
33d236b0:	e1a01004 	mov	r1, r4
33d236b4:	e3a02002 	mov	r2, #2	; 0x2
33d236b8:	e1a00005 	mov	r0, r5
33d236bc:	e1a0e00f 	mov	lr, pc
33d236c0:	e594f03c 	ldr	pc, [r4, #60]
    if (status & 0x01) {
        ret = -1;
    }

    /* de-select the NAND device */
    this->select_chip(meminfo, -1);
33d236c4:	e3e01000 	mvn	r1, #0	; 0x0

    /* call wait ready function */
    status = this->waitfunc(meminfo, this, FL_WRITING);

    /* see if device thinks it succeeded */
    if (status & 0x01) {
33d236c8:	e3100001 	tst	r0, #1	; 0x1
        ret = -1;
    }

    /* de-select the NAND device */
    this->select_chip(meminfo, -1);
33d236cc:	e1a00005 	mov	r0, r5
    /* call wait ready function */
    status = this->waitfunc(meminfo, this, FL_WRITING);

    /* see if device thinks it succeeded */
    if (status & 0x01) {
        ret = -1;
33d236d0:	03a06000 	moveq	r6, #0	; 0x0
33d236d4:	13e06000 	mvnne	r6, #0	; 0x0
    }

    /* de-select the NAND device */
    this->select_chip(meminfo, -1);
33d236d8:	e1a0e00f 	mov	lr, pc
33d236dc:	e594f024 	ldr	pc, [r4, #36]
    return ret;
}
33d236e0:	e1a00006 	mov	r0, r6
33d236e4:	e8bd8070 	pop	{r4, r5, r6, pc}

33d236e8 <nand_get_lock_status>:
 *            NAND_LOCK_STATUS_LOCK:  page locked
 *            NAND_LOCK_STATUS_UNLOCK: page unlocked
 *
 */
int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
{
33d236e8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    int ret = 0;
    int chipnr;
    int page;
    struct nand_chip *this = meminfo->priv;
33d236ec:	e590413c 	ldr	r4, [r0, #316]

    /* select the NAND device */
    chipnr = (int)(offset >> this->chip_shift);
33d236f0:	e5943074 	ldr	r3, [r4, #116]
 *            NAND_LOCK_STATUS_LOCK:  page locked
 *            NAND_LOCK_STATUS_UNLOCK: page unlocked
 *
 */
int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
{
33d236f4:	e1a06000 	mov	r6, r0
33d236f8:	e1a05001 	mov	r5, r1
    int page;
    struct nand_chip *this = meminfo->priv;

    /* select the NAND device */
    chipnr = (int)(offset >> this->chip_shift);
    this->select_chip(meminfo, chipnr);
33d236fc:	e1a01331 	lsr	r1, r1, r3
33d23700:	e1a0e00f 	mov	lr, pc
33d23704:	e594f024 	ldr	pc, [r4, #36]


    if ((offset & (meminfo->oobblock - 1)) != 0) {
33d23708:	e5963010 	ldr	r3, [r6, #16]
        goto out;
    }

    /* check the Lock Status */
    page = (int)(offset >> this->page_shift);
    this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
33d2370c:	e3e02000 	mvn	r2, #0	; 0x0
    /* select the NAND device */
    chipnr = (int)(offset >> this->chip_shift);
    this->select_chip(meminfo, chipnr);


    if ((offset & (meminfo->oobblock - 1)) != 0) {
33d23710:	e0833002 	add	r3, r3, r2
33d23714:	e1150003 	tst	r5, r3
        goto out;
    }

    /* check the Lock Status */
    page = (int)(offset >> this->page_shift);
    this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
33d23718:	e3a0107a 	mov	r1, #122	; 0x7a
33d2371c:	e1a00006 	mov	r0, r6

    if ((offset & (meminfo->oobblock - 1)) != 0) {
        printf ("nand_get_lock_status: "
            "Start address must be beginning of "
            "nand page!\n");
        ret = -1;
33d23720:	e1a07002 	mov	r7, r2
    /* select the NAND device */
    chipnr = (int)(offset >> this->chip_shift);
    this->select_chip(meminfo, chipnr);


    if ((offset & (meminfo->oobblock - 1)) != 0) {
33d23724:	0a000002 	beq	33d23734 <nand_get_lock_status+0x4c>
        printf ("nand_get_lock_status: "
33d23728:	e59f0040 	ldr	r0, [pc, #64]	; 33d23770 <nand_get_lock_status+0x88>
33d2372c:	ebffce25 	bl	33d16fc8 <printf>
            "Start address must be beginning of "
            "nand page!\n");
        ret = -1;
        goto out;
33d23730:	ea000008 	b	33d23758 <nand_get_lock_status+0x70>
    }

    /* check the Lock Status */
    page = (int)(offset >> this->page_shift);
33d23734:	e594c068 	ldr	ip, [r4, #104]
    this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
33d23738:	e5943098 	ldr	r3, [r4, #152]
33d2373c:	e0033c35 	and	r3, r3, r5, lsr ip
33d23740:	e1a0e00f 	mov	lr, pc
33d23744:	e594f038 	ldr	pc, [r4, #56]

    ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
33d23748:	e1a00006 	mov	r0, r6
33d2374c:	e1a0e00f 	mov	lr, pc
33d23750:	e594f008 	ldr	pc, [r4, #8]
33d23754:	e2007007 	and	r7, r0, #7	; 0x7
                      | NAND_LOCK_STATUS_LOCK
                      | NAND_LOCK_STATUS_UNLOCK);

 out:
    /* de-select the NAND device */
    this->select_chip(meminfo, -1);
33d23758:	e1a00006 	mov	r0, r6
33d2375c:	e3e01000 	mvn	r1, #0	; 0x0
33d23760:	e1a0e00f 	mov	lr, pc
33d23764:	e594f024 	ldr	pc, [r4, #36]
    return ret;
}
33d23768:	e1a00007 	mov	r0, r7
33d2376c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
33d23770:	33d2dc68 	.word	0x33d2dc68

33d23774 <nand_unlock>:
 *          page size nand->oobblock)
 *
 * @return      0 on success, -1 in case of error
 */
int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
{
33d23774:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
    int ret = 0;
    int chipnr;
    int status;
    int page;
    struct nand_chip *this = meminfo->priv;
33d23778:	e590513c 	ldr	r5, [r0, #316]
 *          page size nand->oobblock)
 *
 * @return      0 on success, -1 in case of error
 */
int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
{
33d2377c:	e1a06000 	mov	r6, r0
    int ret = 0;
    int chipnr;
    int status;
    int page;
    struct nand_chip *this = meminfo->priv;
    printf ("nand_unlock: start: %08x, length: %d!\n",
33d23780:	e59f010c 	ldr	r0, [pc, #268]	; 33d23894 <nand_unlock+0x120>
 *          page size nand->oobblock)
 *
 * @return      0 on success, -1 in case of error
 */
int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
{
33d23784:	e1a07002 	mov	r7, r2
33d23788:	e1a04001 	mov	r4, r1
    int ret = 0;
    int chipnr;
    int status;
    int page;
    struct nand_chip *this = meminfo->priv;
    printf ("nand_unlock: start: %08x, length: %d!\n",
33d2378c:	ebffce0d 	bl	33d16fc8 <printf>
        (int)start, (int)length);

    /* select the NAND device */
    chipnr = (int)(start >> this->chip_shift);
33d23790:	e5951074 	ldr	r1, [r5, #116]
    this->select_chip(meminfo, chipnr);
33d23794:	e1a00006 	mov	r0, r6
33d23798:	e1a01134 	lsr	r1, r4, r1
33d2379c:	e1a0e00f 	mov	lr, pc
33d237a0:	e595f024 	ldr	pc, [r5, #36]

    /* check the WP bit */
    this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
33d237a4:	e3e02000 	mvn	r2, #0	; 0x0
33d237a8:	e1a00006 	mov	r0, r6
33d237ac:	e1a03002 	mov	r3, r2
33d237b0:	e3a01070 	mov	r1, #112	; 0x70
33d237b4:	e1a0e00f 	mov	lr, pc
33d237b8:	e595f038 	ldr	pc, [r5, #56]
    if ((this->read_byte(meminfo) & 0x80) == 0) {
33d237bc:	e1a00006 	mov	r0, r6
33d237c0:	e1a0e00f 	mov	lr, pc
33d237c4:	e595f008 	ldr	pc, [r5, #8]
33d237c8:	e3100080 	tst	r0, #128	; 0x80
        printf ("nand_unlock: Device is write protected!\n");
        ret = -1;
33d237cc:	e3e0a000 	mvn	sl, #0	; 0x0
    this->select_chip(meminfo, chipnr);

    /* check the WP bit */
    this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
    if ((this->read_byte(meminfo) & 0x80) == 0) {
        printf ("nand_unlock: Device is write protected!\n");
33d237d0:	e59f00c0 	ldr	r0, [pc, #192]	; 33d23898 <nand_unlock+0x124>
    chipnr = (int)(start >> this->chip_shift);
    this->select_chip(meminfo, chipnr);

    /* check the WP bit */
    this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
    if ((this->read_byte(meminfo) & 0x80) == 0) {
33d237d4:	0a00000d 	beq	33d23810 <nand_unlock+0x9c>
        printf ("nand_unlock: Device is write protected!\n");
        ret = -1;
        goto out;
    }

    if ((start & (meminfo->oobblock - 1)) != 0) {
33d237d8:	e5963010 	ldr	r3, [r6, #16]
33d237dc:	e2433001 	sub	r3, r3, #1	; 0x1
33d237e0:	e1140003 	tst	r4, r3
        printf ("nand_unlock: Start address must be beginning of "
33d237e4:	e59f00b0 	ldr	r0, [pc, #176]	; 33d2389c <nand_unlock+0x128>
            "nand page!\n");
        ret = -1;
33d237e8:	e3e0a000 	mvn	sl, #0	; 0x0
        printf ("nand_unlock: Device is write protected!\n");
        ret = -1;
        goto out;
    }

    if ((start & (meminfo->oobblock - 1)) != 0) {
33d237ec:	1a000007 	bne	33d23810 <nand_unlock+0x9c>
            "nand page!\n");
        ret = -1;
        goto out;
    }

    if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
33d237f0:	e3570000 	cmp	r7, #0	; 0x0
        printf ("nand_unlock: Length must be a multiple of nand page "
33d237f4:	e59f00a4 	ldr	r0, [pc, #164]	; 33d238a0 <nand_unlock+0x12c>
            "size!\n");
        ret = -1;
33d237f8:	e3e0a000 	mvn	sl, #0	; 0x0
            "nand page!\n");
        ret = -1;
        goto out;
    }

    if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
33d237fc:	0a000003 	beq	33d23810 <nand_unlock+0x9c>
33d23800:	e1170003 	tst	r7, r3
        goto out;
    }

    /* submit address of first page to unlock */
    page = (int)(start >> this->page_shift);
    this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
33d23804:	e3a01023 	mov	r1, #35	; 0x23
33d23808:	e1a0200a 	mov	r2, sl
            "nand page!\n");
        ret = -1;
        goto out;
    }

    if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
33d2380c:	0a000001 	beq	33d23818 <nand_unlock+0xa4>
        printf ("nand_unlock: Length must be a multiple of nand page "
33d23810:	ebffcdec 	bl	33d16fc8 <printf>
            "size!\n");
        ret = -1;
        goto out;
33d23814:	ea000018 	b	33d2387c <nand_unlock+0x108>
    }

    /* submit address of first page to unlock */
    page = (int)(start >> this->page_shift);
33d23818:	e595c068 	ldr	ip, [r5, #104]
    this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
33d2381c:	e5953098 	ldr	r3, [r5, #152]
        ret = -1;
        goto out;
    }

    /* submit address of first page to unlock */
    page = (int)(start >> this->page_shift);
33d23820:	e1a04c34 	lsr	r4, r4, ip
    this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
33d23824:	e0043003 	and	r3, r4, r3
33d23828:	e1a00006 	mov	r0, r6
33d2382c:	e1a0e00f 	mov	lr, pc
33d23830:	e595f038 	ldr	pc, [r5, #56]

    /* submit ADDRESS of LAST page to unlock */
    page += (int)(length >> this->page_shift) - 1;
33d23834:	e5952068 	ldr	r2, [r5, #104]
    this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
33d23838:	e5953098 	ldr	r3, [r5, #152]
    /* submit address of first page to unlock */
    page = (int)(start >> this->page_shift);
    this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);

    /* submit ADDRESS of LAST page to unlock */
    page += (int)(length >> this->page_shift) - 1;
33d2383c:	e0842237 	add	r2, r4, r7, lsr r2
33d23840:	e2424001 	sub	r4, r2, #1	; 0x1
    this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
33d23844:	e0043003 	and	r3, r4, r3
33d23848:	e1a00006 	mov	r0, r6
33d2384c:	e3a01024 	mov	r1, #36	; 0x24
33d23850:	e3e02000 	mvn	r2, #0	; 0x0
33d23854:	e1a0e00f 	mov	lr, pc
33d23858:	e595f038 	ldr	pc, [r5, #56]

    /* call wait ready function */
    status = this->waitfunc(meminfo, this, FL_WRITING);
33d2385c:	e1a00006 	mov	r0, r6
33d23860:	e1a01005 	mov	r1, r5
33d23864:	e3a02002 	mov	r2, #2	; 0x2
33d23868:	e1a0e00f 	mov	lr, pc
33d2386c:	e595f03c 	ldr	pc, [r5, #60]
    /* see if device thinks it succeeded */
    if (status & 0x01) {
33d23870:	e3100001 	tst	r0, #1	; 0x1
        /* there was an error */
        ret = -1;
33d23874:	03a0a000 	moveq	sl, #0	; 0x0
33d23878:	13e0a000 	mvnne	sl, #0	; 0x0
        goto out;
    }

 out:
    /* de-select the NAND device */
    this->select_chip(meminfo, -1);
33d2387c:	e1a00006 	mov	r0, r6
33d23880:	e3e01000 	mvn	r1, #0	; 0x0
33d23884:	e1a0e00f 	mov	lr, pc
33d23888:	e595f024 	ldr	pc, [r5, #36]
    return ret;
}
33d2388c:	e1a0000a 	mov	r0, sl
33d23890:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
33d23894:	33d2dcb0 	.word	0x33d2dcb0
33d23898:	33d2dcd8 	.word	0x33d2dcd8
33d2389c:	33d2dd04 	.word	0x33d2dd04
33d238a0:	33d2dd40 	.word	0x33d2dd40

33d238a4 <__subdf3>:
33d238a4:	e2222102 	eor	r2, r2, #-2147483648	; 0x80000000

33d238a8 <__adddf3>:
33d238a8:	e1310003 	teq	r1, r3
33d238ac:	0020c002 	eoreq	ip, r0, r2
33d238b0:	033c0102 	teqeq	ip, #-2147483648	; 0x80000000
33d238b4:	0a00009e 	beq	33d23b34 <__adddf3+0x28c>
33d238b8:	e191c080 	orrs	ip, r1, r0, lsl #1
33d238bc:	01a01003 	moveq	r1, r3
33d238c0:	01a00002 	moveq	r0, r2
33d238c4:	1193c082 	orrsne	ip, r3, r2, lsl #1
33d238c8:	01a0f00e 	moveq	pc, lr
33d238cc:	e92d4030 	push	{r4, r5, lr}
33d238d0:	e3a0c47f 	mov	ip, #2130706432	; 0x7f000000
33d238d4:	e38cc60f 	orr	ip, ip, #15728640	; 0xf00000
33d238d8:	e000400c 	and	r4, r0, ip
33d238dc:	e002500c 	and	r5, r2, ip
33d238e0:	e134000c 	teq	r4, ip
33d238e4:	1135000c 	teqne	r5, ip
33d238e8:	0a00009c 	beq	33d23b60 <__adddf3+0x2b8>
33d238ec:	e0555004 	subs	r5, r5, r4
33d238f0:	b2655000 	rsblt	r5, r5, #0	; 0x0
33d238f4:	da000006 	ble	33d23914 <__adddf3+0x6c>
33d238f8:	e0844005 	add	r4, r4, r5
33d238fc:	e0213003 	eor	r3, r1, r3
33d23900:	e0202002 	eor	r2, r0, r2
33d23904:	e0231001 	eor	r1, r3, r1
33d23908:	e0220000 	eor	r0, r2, r0
33d2390c:	e0213003 	eor	r3, r1, r3
33d23910:	e0202002 	eor	r2, r0, r2
33d23914:	e3550636 	cmp	r5, #56623104	; 0x3600000
33d23918:	88bd8030 	pophi	{r4, r5, pc}
33d2391c:	e3100102 	tst	r0, #-2147483648	; 0x80000000
33d23920:	e1c0008c 	bic	r0, r0, ip, lsl #1
33d23924:	e3800601 	orr	r0, r0, #1048576	; 0x100000
33d23928:	0a000001 	beq	33d23934 <__adddf3+0x8c>
33d2392c:	e2711000 	rsbs	r1, r1, #0	; 0x0
33d23930:	e2e00000 	rsc	r0, r0, #0	; 0x0
33d23934:	e3120102 	tst	r2, #-2147483648	; 0x80000000
33d23938:	e1c2208c 	bic	r2, r2, ip, lsl #1
33d2393c:	e3822601 	orr	r2, r2, #1048576	; 0x100000
33d23940:	0a000001 	beq	33d2394c <__adddf3+0xa4>
33d23944:	e2733000 	rsbs	r3, r3, #0	; 0x0
33d23948:	e2e22000 	rsc	r2, r2, #0	; 0x0
33d2394c:	e1340005 	teq	r4, r5
33d23950:	0a000071 	beq	33d23b1c <__adddf3+0x274>
33d23954:	e3a0c000 	mov	ip, #0	; 0x0
33d23958:	e1b05a25 	lsrs	r5, r5, #20
33d2395c:	0a000013 	beq	33d239b0 <__adddf3+0x108>
33d23960:	e3340601 	teq	r4, #1048576	; 0x100000
33d23964:	0a000004 	beq	33d2397c <__adddf3+0xd4>
33d23968:	e1b01081 	lsls	r1, r1, #1
33d2396c:	e0ac0080 	adc	r0, ip, r0, lsl #1
33d23970:	e2444601 	sub	r4, r4, #1048576	; 0x100000
33d23974:	e2555001 	subs	r5, r5, #1	; 0x1
33d23978:	0a00000c 	beq	33d239b0 <__adddf3+0x108>
33d2397c:	e275e020 	rsbs	lr, r5, #32	; 0x20
33d23980:	ba000004 	blt	33d23998 <__adddf3+0xf0>
33d23984:	e1a0ce13 	lsl	ip, r3, lr
33d23988:	e1a03533 	lsr	r3, r3, r5
33d2398c:	e1833e12 	orr	r3, r3, r2, lsl lr
33d23990:	e1a02552 	asr	r2, r2, r5
33d23994:	ea000005 	b	33d239b0 <__adddf3+0x108>
33d23998:	e2455020 	sub	r5, r5, #32	; 0x20
33d2399c:	e28ee020 	add	lr, lr, #32	; 0x20
33d239a0:	e3530001 	cmp	r3, #1	; 0x1
33d239a4:	e0acce12 	adc	ip, ip, r2, lsl lr
33d239a8:	e1a03552 	asr	r3, r2, r5
33d239ac:	e1a02042 	asr	r2, r2, #32
33d239b0:	e0911003 	adds	r1, r1, r3
33d239b4:	e0a00002 	adc	r0, r0, r2
33d239b8:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
33d239bc:	5a000002 	bpl	33d239cc <__adddf3+0x124>
33d239c0:	e27cc000 	rsbs	ip, ip, #0	; 0x0
33d239c4:	e2f11000 	rscs	r1, r1, #0	; 0x0
33d239c8:	e2e00000 	rsc	r0, r0, #0	; 0x0
33d239cc:	e3500601 	cmp	r0, #1048576	; 0x100000
33d239d0:	3a000019 	bcc	33d23a3c <__adddf3+0x194>
33d239d4:	e3500602 	cmp	r0, #2097152	; 0x200000
33d239d8:	3a00000b 	bcc	33d23a0c <__adddf3+0x164>
33d239dc:	e3500501 	cmp	r0, #4194304	; 0x400000
33d239e0:	3a000004 	bcc	33d239f8 <__adddf3+0x150>
33d239e4:	e1b000a0 	lsrs	r0, r0, #1
33d239e8:	e1b01061 	rrxs	r1, r1
33d239ec:	e1b0c06c 	rrxs	ip, ip
33d239f0:	238cc001 	orrcs	ip, ip, #1	; 0x1
33d239f4:	e2844601 	add	r4, r4, #1048576	; 0x100000
33d239f8:	e1b000a0 	lsrs	r0, r0, #1
33d239fc:	e1b01061 	rrxs	r1, r1
33d23a00:	e1b0c06c 	rrxs	ip, ip
33d23a04:	238cc001 	orrcs	ip, ip, #1	; 0x1
33d23a08:	e2844601 	add	r4, r4, #1048576	; 0x100000
33d23a0c:	e0911fac 	adds	r1, r1, ip, lsr #31
33d23a10:	e2a00000 	adc	r0, r0, #0	; 0x0
33d23a14:	e33c0102 	teq	ip, #-2147483648	; 0x80000000
33d23a18:	03c11001 	biceq	r1, r1, #1	; 0x1
33d23a1c:	e3100602 	tst	r0, #2097152	; 0x200000
33d23a20:	12844601 	addne	r4, r4, #1048576	; 0x100000
33d23a24:	e294c601 	adds	ip, r4, #1048576	; 0x100000
33d23a28:	4a000048 	bmi	33d23b50 <__adddf3+0x2a8>
33d23a2c:	e3c00603 	bic	r0, r0, #3145728	; 0x300000
33d23a30:	e1800004 	orr	r0, r0, r4
33d23a34:	e1800005 	orr	r0, r0, r5
33d23a38:	e8bd8030 	pop	{r4, r5, pc}
33d23a3c:	e3300000 	teq	r0, #0	; 0x0
33d23a40:	13e0300a 	mvnne	r3, #10	; 0xa
33d23a44:	03a03015 	moveq	r3, #21	; 0x15
33d23a48:	01a00001 	moveq	r0, r1
33d23a4c:	03a01000 	moveq	r1, #0	; 0x0
33d23a50:	e1a02000 	mov	r2, r0
33d23a54:	e1b0c820 	lsrs	ip, r0, #16
33d23a58:	01a02802 	lsleq	r2, r2, #16
33d23a5c:	02833010 	addeq	r3, r3, #16	; 0x10
33d23a60:	e31204ff 	tst	r2, #-16777216	; 0xff000000
33d23a64:	01a02402 	lsleq	r2, r2, #8
33d23a68:	02833008 	addeq	r3, r3, #8	; 0x8
33d23a6c:	e312020f 	tst	r2, #-268435456	; 0xf0000000
33d23a70:	01a02202 	lsleq	r2, r2, #4
33d23a74:	02833004 	addeq	r3, r3, #4	; 0x4
33d23a78:	e3120103 	tst	r2, #-1073741824	; 0xc0000000
33d23a7c:	01a02102 	lsleq	r2, r2, #2
33d23a80:	02833002 	addeq	r3, r3, #2	; 0x2
33d23a84:	e3120102 	tst	r2, #-2147483648	; 0x80000000
33d23a88:	02833001 	addeq	r3, r3, #1	; 0x1
33d23a8c:	e2532020 	subs	r2, r3, #32	; 0x20
33d23a90:	aa000007 	bge	33d23ab4 <__adddf3+0x20c>
33d23a94:	e292200c 	adds	r2, r2, #12	; 0xc
33d23a98:	da000004 	ble	33d23ab0 <__adddf3+0x208>
33d23a9c:	e282c014 	add	ip, r2, #20	; 0x14
33d23aa0:	e262200c 	rsb	r2, r2, #12	; 0xc
33d23aa4:	e1a01c10 	lsl	r1, r0, ip
33d23aa8:	e1a00230 	lsr	r0, r0, r2
33d23aac:	ea000004 	b	33d23ac4 <__adddf3+0x21c>
33d23ab0:	e2822014 	add	r2, r2, #20	; 0x14
33d23ab4:	d262c020 	rsble	ip, r2, #32	; 0x20
33d23ab8:	e1a00210 	lsl	r0, r0, r2
33d23abc:	d1800c31 	orrle	r0, r0, r1, lsr ip
33d23ac0:	d1a01211 	lslle	r1, r1, r2
33d23ac4:	e0544a03 	subs	r4, r4, r3, lsl #20
33d23ac8:	caffffd7 	bgt	33d23a2c <__adddf3+0x184>
33d23acc:	e1e04a44 	mvn	r4, r4, asr #20
33d23ad0:	e254401e 	subs	r4, r4, #30	; 0x1e
33d23ad4:	aa00000d 	bge	33d23b10 <__adddf3+0x268>
33d23ad8:	e294400c 	adds	r4, r4, #12	; 0xc
33d23adc:	ca000005 	bgt	33d23af8 <__adddf3+0x250>
33d23ae0:	e2844014 	add	r4, r4, #20	; 0x14
33d23ae4:	e2642020 	rsb	r2, r4, #32	; 0x20
33d23ae8:	e1a01431 	lsr	r1, r1, r4
33d23aec:	e1811210 	orr	r1, r1, r0, lsl r2
33d23af0:	e1850430 	orr	r0, r5, r0, lsr r4
33d23af4:	e8bd8030 	pop	{r4, r5, pc}
33d23af8:	e264400c 	rsb	r4, r4, #12	; 0xc
33d23afc:	e2642020 	rsb	r2, r4, #32	; 0x20
33d23b00:	e1a01231 	lsr	r1, r1, r2
33d23b04:	e1811410 	orr	r1, r1, r0, lsl r4
33d23b08:	e1a00005 	mov	r0, r5
33d23b0c:	e8bd8030 	pop	{r4, r5, pc}
33d23b10:	e1a01430 	lsr	r1, r0, r4
33d23b14:	e1a00005 	mov	r0, r5
33d23b18:	e8bd8030 	pop	{r4, r5, pc}
33d23b1c:	e3340000 	teq	r4, #0	; 0x0
33d23b20:	02200601 	eoreq	r0, r0, #1048576	; 0x100000
33d23b24:	02844601 	addeq	r4, r4, #1048576	; 0x100000
33d23b28:	e2222601 	eor	r2, r2, #1048576	; 0x100000
33d23b2c:	12455601 	subne	r5, r5, #1048576	; 0x100000
33d23b30:	eaffff87 	b	33d23954 <__adddf3+0xac>
33d23b34:	e24cc601 	sub	ip, ip, #1048576	; 0x100000
33d23b38:	e000200c 	and	r2, r0, ip
33d23b3c:	e132000c 	teq	r2, ip
33d23b40:	038c0702 	orreq	r0, ip, #524288	; 0x80000
33d23b44:	13a00000 	movne	r0, #0	; 0x0
33d23b48:	e3a01000 	mov	r1, #0	; 0x0
33d23b4c:	e1a0f00e 	mov	pc, lr
33d23b50:	e385047f 	orr	r0, r5, #2130706432	; 0x7f000000
33d23b54:	e380060f 	orr	r0, r0, #15728640	; 0xf00000
33d23b58:	e3a01000 	mov	r1, #0	; 0x0
33d23b5c:	e8bd8030 	pop	{r4, r5, pc}
33d23b60:	e134000c 	teq	r4, ip
33d23b64:	11a00002 	movne	r0, r2
33d23b68:	11a01003 	movne	r1, r3
33d23b6c:	0135000c 	teqeq	r5, ip
33d23b70:	18bd8030 	popne	{r4, r5, pc}
33d23b74:	e1914600 	orrs	r4, r1, r0, lsl #12
33d23b78:	01934602 	orrseq	r4, r3, r2, lsl #12
33d23b7c:	01300002 	teqeq	r0, r2
33d23b80:	13850702 	orrne	r0, r5, #524288	; 0x80000
33d23b84:	13a01000 	movne	r1, #0	; 0x0
33d23b88:	e8bd8030 	pop	{r4, r5, pc}

33d23b8c <__floatunsidf>:
33d23b8c:	e3300000 	teq	r0, #0	; 0x0
33d23b90:	03a01000 	moveq	r1, #0	; 0x0
33d23b94:	01a0f00e 	moveq	pc, lr
33d23b98:	e92d4030 	push	{r4, r5, lr}
33d23b9c:	e3a04101 	mov	r4, #1073741824	; 0x40000000
33d23ba0:	e2844633 	add	r4, r4, #53477376	; 0x3300000
33d23ba4:	e3a05000 	mov	r5, #0	; 0x0
33d23ba8:	e1a01000 	mov	r1, r0
33d23bac:	e3a00000 	mov	r0, #0	; 0x0
33d23bb0:	eaffffa1 	b	33d23a3c <__adddf3+0x194>

33d23bb4 <__floatsidf>:
33d23bb4:	e3300000 	teq	r0, #0	; 0x0
33d23bb8:	03a01000 	moveq	r1, #0	; 0x0
33d23bbc:	01a0f00e 	moveq	pc, lr
33d23bc0:	e92d4030 	push	{r4, r5, lr}
33d23bc4:	e3a04101 	mov	r4, #1073741824	; 0x40000000
33d23bc8:	e2844633 	add	r4, r4, #53477376	; 0x3300000
33d23bcc:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
33d23bd0:	42600000 	rsbmi	r0, r0, #0	; 0x0
33d23bd4:	e1a01000 	mov	r1, r0
33d23bd8:	e3a00000 	mov	r0, #0	; 0x0
33d23bdc:	eaffff96 	b	33d23a3c <__adddf3+0x194>

33d23be0 <__extendsfdf2>:
33d23be0:	e1b02080 	lsls	r2, r0, #1
33d23be4:	0a000007 	beq	33d23c08 <__extendsfdf2+0x28>
33d23be8:	e1a001c2 	asr	r0, r2, #3
33d23bec:	e1a00060 	rrx	r0, r0
33d23bf0:	e1a01e02 	lsl	r1, r2, #28
33d23bf4:	e21224ff 	ands	r2, r2, #-16777216	; 0xff000000
33d23bf8:	0a000005 	beq	33d23c14 <__extendsfdf2+0x34>
33d23bfc:	e33204ff 	teq	r2, #-16777216	; 0xff000000
33d23c00:	1220030e 	eorne	r0, r0, #939524096	; 0x38000000
33d23c04:	e1a0f00e 	mov	pc, lr
33d23c08:	e1a00000 	nop			(mov r0,r0)
33d23c0c:	e3a01000 	mov	r1, #0	; 0x0
33d23c10:	e1a0f00e 	mov	pc, lr
33d23c14:	e92d4030 	push	{r4, r5, lr}
33d23c18:	e3a0430e 	mov	r4, #939524096	; 0x38000000
33d23c1c:	e2844601 	add	r4, r4, #1048576	; 0x100000
33d23c20:	e2005102 	and	r5, r0, #-2147483648	; 0x80000000
33d23c24:	e3c00102 	bic	r0, r0, #-2147483648	; 0x80000000
33d23c28:	eaffff83 	b	33d23a3c <__adddf3+0x194>

33d23c2c <__muldf3>:
33d23c2c:	e92d4070 	push	{r4, r5, r6, lr}
33d23c30:	e3a0c47f 	mov	ip, #2130706432	; 0x7f000000
33d23c34:	e38cc60f 	orr	ip, ip, #15728640	; 0xf00000
33d23c38:	e000400c 	and	r4, r0, ip
33d23c3c:	e002500c 	and	r5, r2, ip
33d23c40:	e134000c 	teq	r4, ip
33d23c44:	1135000c 	teqne	r5, ip
33d23c48:	0a0000a8 	beq	33d23ef0 <__muldf3+0x2c4>
33d23c4c:	e1916080 	orrs	r6, r1, r0, lsl #1
33d23c50:	11936082 	orrsne	r6, r3, r2, lsl #1
33d23c54:	0a00005e 	beq	33d23dd4 <__muldf3+0x1a8>
33d23c58:	e1b040a4 	lsrs	r4, r4, #1
33d23c5c:	13350000 	teqne	r5, #0	; 0x0
33d23c60:	0a00008e 	beq	33d23ea0 <__muldf3+0x274>
33d23c64:	e08440c5 	add	r4, r4, r5, asr #1
33d23c68:	e1300002 	teq	r0, r2
33d23c6c:	43844902 	orrmi	r4, r4, #32768	; 0x8000
33d23c70:	e1c0008c 	bic	r0, r0, ip, lsl #1
33d23c74:	e1c2208c 	bic	r2, r2, ip, lsl #1
33d23c78:	e3800601 	orr	r0, r0, #1048576	; 0x100000
33d23c7c:	e3822601 	orr	r2, r2, #1048576	; 0x100000
33d23c80:	e92d0f80 	push	{r7, r8, r9, sl, fp}
33d23c84:	e1a07821 	lsr	r7, r1, #16
33d23c88:	e1a08823 	lsr	r8, r3, #16
33d23c8c:	e1a09820 	lsr	r9, r0, #16
33d23c90:	e1a0a822 	lsr	sl, r2, #16
33d23c94:	e1c11807 	bic	r1, r1, r7, lsl #16
33d23c98:	e1c33808 	bic	r3, r3, r8, lsl #16
33d23c9c:	e1c00809 	bic	r0, r0, r9, lsl #16
33d23ca0:	e1c2280a 	bic	r2, r2, sl, lsl #16
33d23ca4:	e00c0391 	mul	ip, r1, r3
33d23ca8:	e00b0891 	mul	fp, r1, r8
33d23cac:	e3a0e000 	mov	lr, #0	; 0x0
33d23cb0:	e09cc80b 	adds	ip, ip, fp, lsl #16
33d23cb4:	e0aee82b 	adc	lr, lr, fp, lsr #16
33d23cb8:	e00b0397 	mul	fp, r7, r3
33d23cbc:	e09cc80b 	adds	ip, ip, fp, lsl #16
33d23cc0:	e0aee82b 	adc	lr, lr, fp, lsr #16
33d23cc4:	e00b0a91 	mul	fp, r1, sl
33d23cc8:	e3a05000 	mov	r5, #0	; 0x0
33d23ccc:	e09ee80b 	adds	lr, lr, fp, lsl #16
33d23cd0:	e0a5582b 	adc	r5, r5, fp, lsr #16
33d23cd4:	e00b0297 	mul	fp, r7, r2
33d23cd8:	e09ee80b 	adds	lr, lr, fp, lsl #16
33d23cdc:	e0a5582b 	adc	r5, r5, fp, lsr #16
33d23ce0:	e00b0890 	mul	fp, r0, r8
33d23ce4:	e09ee80b 	adds	lr, lr, fp, lsl #16
33d23ce8:	e0a5582b 	adc	r5, r5, fp, lsr #16
33d23cec:	e00b0399 	mul	fp, r9, r3
33d23cf0:	e09ee80b 	adds	lr, lr, fp, lsl #16
33d23cf4:	e0a5582b 	adc	r5, r5, fp, lsr #16
33d23cf8:	e00b0a90 	mul	fp, r0, sl
33d23cfc:	e0060a99 	mul	r6, r9, sl
33d23d00:	e095580b 	adds	r5, r5, fp, lsl #16
33d23d04:	e0a6682b 	adc	r6, r6, fp, lsr #16
33d23d08:	e00b0299 	mul	fp, r9, r2
33d23d0c:	e095580b 	adds	r5, r5, fp, lsl #16
33d23d10:	e0a6682b 	adc	r6, r6, fp, lsr #16
33d23d14:	e00b0291 	mul	fp, r1, r2
33d23d18:	e09ee00b 	adds	lr, lr, fp
33d23d1c:	e00b0a97 	mul	fp, r7, sl
33d23d20:	e0b5500b 	adcs	r5, r5, fp
33d23d24:	e00b0390 	mul	fp, r0, r3
33d23d28:	e2a66000 	adc	r6, r6, #0	; 0x0
33d23d2c:	e09ee00b 	adds	lr, lr, fp
33d23d30:	e00b0899 	mul	fp, r9, r8
33d23d34:	e0b5500b 	adcs	r5, r5, fp
33d23d38:	e00b0897 	mul	fp, r7, r8
33d23d3c:	e2a66000 	adc	r6, r6, #0	; 0x0
33d23d40:	e09ee00b 	adds	lr, lr, fp
33d23d44:	e00b0290 	mul	fp, r0, r2
33d23d48:	e0b5500b 	adcs	r5, r5, fp
33d23d4c:	e2a66000 	adc	r6, r6, #0	; 0x0
33d23d50:	e8bd0f80 	pop	{r7, r8, r9, sl, fp}
33d23d54:	e33c0000 	teq	ip, #0	; 0x0
33d23d58:	138ee001 	orrne	lr, lr, #1	; 0x1
33d23d5c:	e1a00804 	lsl	r0, r4, #16
33d23d60:	e3c44902 	bic	r4, r4, #32768	; 0x8000
33d23d64:	e3160c02 	tst	r6, #512	; 0x200
33d23d68:	0a000004 	beq	33d23d80 <__muldf3+0x154>
33d23d6c:	e2844702 	add	r4, r4, #524288	; 0x80000
33d23d70:	e1b060a6 	lsrs	r6, r6, #1
33d23d74:	e1b05065 	rrxs	r5, r5
33d23d78:	e1b0e06e 	rrxs	lr, lr
33d23d7c:	238ee001 	orrcs	lr, lr, #1	; 0x1
33d23d80:	e1800606 	orr	r0, r0, r6, lsl #12
33d23d84:	e1800a25 	orr	r0, r0, r5, lsr #20
33d23d88:	e1a01605 	lsl	r1, r5, #12
33d23d8c:	e1811a2e 	orr	r1, r1, lr, lsr #20
33d23d90:	e244473e 	sub	r4, r4, #16252928	; 0xf80000
33d23d94:	e254441f 	subs	r4, r4, #520093696	; 0x1f000000
33d23d98:	da000011 	ble	33d23de4 <__muldf3+0x1b8>
33d23d9c:	e1b0e60e 	lsls	lr, lr, #12
33d23da0:	5a000005 	bpl	33d23dbc <__muldf3+0x190>
33d23da4:	e2911001 	adds	r1, r1, #1	; 0x1
33d23da8:	e2a00000 	adc	r0, r0, #0	; 0x0
33d23dac:	e33e0102 	teq	lr, #-2147483648	; 0x80000000
33d23db0:	03c11001 	biceq	r1, r1, #1	; 0x1
33d23db4:	e3100602 	tst	r0, #2097152	; 0x200000
33d23db8:	12844702 	addne	r4, r4, #524288	; 0x80000
33d23dbc:	e294c702 	adds	ip, r4, #524288	; 0x80000
33d23dc0:	e31c0101 	tst	ip, #1073741824	; 0x40000000
33d23dc4:	1a000055 	bne	33d23f20 <__muldf3+0x2f4>
33d23dc8:	e3c00603 	bic	r0, r0, #3145728	; 0x300000
33d23dcc:	e1800084 	orr	r0, r0, r4, lsl #1
33d23dd0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d23dd4:	e0200002 	eor	r0, r0, r2
33d23dd8:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
33d23ddc:	e3a01000 	mov	r1, #0	; 0x0
33d23de0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d23de4:	e374076a 	cmn	r4, #27787264	; 0x1a80000
33d23de8:	d3a01000 	movle	r1, #0	; 0x0
33d23dec:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
33d23df0:	d8bd8070 	pople	{r4, r5, r6, pc}
33d23df4:	e1e049c4 	mvn	r4, r4, asr #19
33d23df8:	e254401e 	subs	r4, r4, #30	; 0x1e
33d23dfc:	aa00001b 	bge	33d23e70 <__muldf3+0x244>
33d23e00:	e294400c 	adds	r4, r4, #12	; 0xc
33d23e04:	ca00000d 	bgt	33d23e40 <__muldf3+0x214>
33d23e08:	e2844014 	add	r4, r4, #20	; 0x14
33d23e0c:	e2645020 	rsb	r5, r4, #32	; 0x20
33d23e10:	e1a03511 	lsl	r3, r1, r5
33d23e14:	e1a01431 	lsr	r1, r1, r4
33d23e18:	e1811510 	orr	r1, r1, r0, lsl r5
33d23e1c:	e1b00080 	lsls	r0, r0, #1
33d23e20:	e1a00430 	lsr	r0, r0, r4
33d23e24:	e1a00060 	rrx	r0, r0
33d23e28:	e0911fa3 	adds	r1, r1, r3, lsr #31
33d23e2c:	e2a00000 	adc	r0, r0, #0	; 0x0
33d23e30:	e33e0000 	teq	lr, #0	; 0x0
33d23e34:	03330102 	teqeq	r3, #-2147483648	; 0x80000000
33d23e38:	03c11001 	biceq	r1, r1, #1	; 0x1
33d23e3c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d23e40:	e264400c 	rsb	r4, r4, #12	; 0xc
33d23e44:	e2645020 	rsb	r5, r4, #32	; 0x20
33d23e48:	e1a03411 	lsl	r3, r1, r4
33d23e4c:	e1a01531 	lsr	r1, r1, r5
33d23e50:	e1811410 	orr	r1, r1, r0, lsl r4
33d23e54:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
33d23e58:	e0911fa3 	adds	r1, r1, r3, lsr #31
33d23e5c:	e2a00000 	adc	r0, r0, #0	; 0x0
33d23e60:	e33e0000 	teq	lr, #0	; 0x0
33d23e64:	03330102 	teqeq	r3, #-2147483648	; 0x80000000
33d23e68:	03c11001 	biceq	r1, r1, #1	; 0x1
33d23e6c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d23e70:	e2645020 	rsb	r5, r4, #32	; 0x20
33d23e74:	e1a06511 	lsl	r6, r1, r5
33d23e78:	e1a03431 	lsr	r3, r1, r4
33d23e7c:	e1833510 	orr	r3, r3, r0, lsl r5
33d23e80:	e1a01430 	lsr	r1, r0, r4
33d23e84:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
33d23e88:	e1c11430 	bic	r1, r1, r0, lsr r4
33d23e8c:	e0811fa3 	add	r1, r1, r3, lsr #31
33d23e90:	e196600e 	orrs	r6, r6, lr
33d23e94:	03330102 	teqeq	r3, #-2147483648	; 0x80000000
33d23e98:	03c11001 	biceq	r1, r1, #1	; 0x1
33d23e9c:	e8bd8070 	pop	{r4, r5, r6, pc}
33d23ea0:	e3a0e000 	mov	lr, #0	; 0x0
33d23ea4:	e3340000 	teq	r4, #0	; 0x0
33d23ea8:	1a000008 	bne	33d23ed0 <__muldf3+0x2a4>
33d23eac:	e2006102 	and	r6, r0, #-2147483648	; 0x80000000
33d23eb0:	e1b01081 	lsls	r1, r1, #1
33d23eb4:	e0ae0080 	adc	r0, lr, r0, lsl #1
33d23eb8:	e3100601 	tst	r0, #1048576	; 0x100000
33d23ebc:	02444702 	subeq	r4, r4, #524288	; 0x80000
33d23ec0:	0afffffa 	beq	33d23eb0 <__muldf3+0x284>
33d23ec4:	e1800006 	orr	r0, r0, r6
33d23ec8:	e3350000 	teq	r5, #0	; 0x0
33d23ecc:	1affff64 	bne	33d23c64 <__muldf3+0x38>
33d23ed0:	e2026102 	and	r6, r2, #-2147483648	; 0x80000000
33d23ed4:	e1b03083 	lsls	r3, r3, #1
33d23ed8:	e0ae2082 	adc	r2, lr, r2, lsl #1
33d23edc:	e3120601 	tst	r2, #1048576	; 0x100000
33d23ee0:	02455601 	subeq	r5, r5, #1048576	; 0x100000
33d23ee4:	0afffffa 	beq	33d23ed4 <__muldf3+0x2a8>
33d23ee8:	e1822006 	orr	r2, r2, r6
33d23eec:	eaffff5c 	b	33d23c64 <__muldf3+0x38>
33d23ef0:	e1916080 	orrs	r6, r1, r0, lsl #1
33d23ef4:	11936082 	orrsne	r6, r3, r2, lsl #1
33d23ef8:	0a00000d 	beq	33d23f34 <__muldf3+0x308>
33d23efc:	e134000c 	teq	r4, ip
33d23f00:	1a000001 	bne	33d23f0c <__muldf3+0x2e0>
33d23f04:	e1916600 	orrs	r6, r1, r0, lsl #12
33d23f08:	1a000009 	bne	33d23f34 <__muldf3+0x308>
33d23f0c:	e135000c 	teq	r5, ip
33d23f10:	1a000001 	bne	33d23f1c <__muldf3+0x2f0>
33d23f14:	e1936602 	orrs	r6, r3, r2, lsl #12
33d23f18:	1a000005 	bne	33d23f34 <__muldf3+0x308>
33d23f1c:	e0200002 	eor	r0, r0, r2
33d23f20:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
33d23f24:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
33d23f28:	e380060f 	orr	r0, r0, #15728640	; 0xf00000
33d23f2c:	e3a01000 	mov	r1, #0	; 0x0
33d23f30:	e8bd8070 	pop	{r4, r5, r6, pc}
33d23f34:	e3a0047f 	mov	r0, #2130706432	; 0x7f000000
33d23f38:	e380073e 	orr	r0, r0, #16252928	; 0xf80000
33d23f3c:	e8bd8070 	pop	{r4, r5, r6, pc}

33d23f40 <__divdf3>:
33d23f40:	e92d4070 	push	{r4, r5, r6, lr}
33d23f44:	e3a0c47f 	mov	ip, #2130706432	; 0x7f000000
33d23f48:	e38cc60f 	orr	ip, ip, #15728640	; 0xf00000
33d23f4c:	e000400c 	and	r4, r0, ip
33d23f50:	e002500c 	and	r5, r2, ip
33d23f54:	e134000c 	teq	r4, ip
33d23f58:	1135000c 	teqne	r5, ip
33d23f5c:	11916080 	orrsne	r6, r1, r0, lsl #1
33d23f60:	11936082 	orrsne	r6, r3, r2, lsl #1
33d23f64:	0a00007e 	beq	33d24164 <__divdf3+0x224>
33d23f68:	e1b040a4 	lsrs	r4, r4, #1
33d23f6c:	13350000 	teqne	r5, #0	; 0x0
33d23f70:	0a000067 	beq	33d24114 <__divdf3+0x1d4>
33d23f74:	e04440c5 	sub	r4, r4, r5, asr #1
33d23f78:	e020e002 	eor	lr, r0, r2
33d23f7c:	e3a05201 	mov	r5, #268435456	; 0x10000000
33d23f80:	e1a02602 	lsl	r2, r2, #12
33d23f84:	e1852222 	orr	r2, r5, r2, lsr #4
33d23f88:	e1822c23 	orr	r2, r2, r3, lsr #24
33d23f8c:	e1b03403 	lsls	r3, r3, #8
33d23f90:	e1a00600 	lsl	r0, r0, #12
33d23f94:	01320005 	teqeq	r2, r5
33d23f98:	0a00004d 	beq	33d240d4 <__divdf3+0x194>
33d23f9c:	e1855220 	orr	r5, r5, r0, lsr #4
33d23fa0:	e1855c21 	orr	r5, r5, r1, lsr #24
33d23fa4:	e1a06401 	lsl	r6, r1, #8
33d23fa8:	e20e0102 	and	r0, lr, #-2147483648	; 0x80000000
33d23fac:	e1550002 	cmp	r5, r2
33d23fb0:	01560003 	cmpeq	r6, r3
33d23fb4:	2a000002 	bcs	33d23fc4 <__divdf3+0x84>
33d23fb8:	e2444702 	sub	r4, r4, #524288	; 0x80000
33d23fbc:	e1b020a2 	lsrs	r2, r2, #1
33d23fc0:	e1a03063 	rrx	r3, r3
33d23fc4:	e284441f 	add	r4, r4, #520093696	; 0x1f000000
33d23fc8:	e284473e 	add	r4, r4, #16252928	; 0xf80000
33d23fcc:	e374076a 	cmn	r4, #27787264	; 0x1a80000
33d23fd0:	daffff80 	ble	33d23dd8 <__muldf3+0x1ac>
33d23fd4:	e15400ac 	cmp	r4, ip, lsr #1
33d23fd8:	aaffffd0 	bge	33d23f20 <__muldf3+0x2f4>
33d23fdc:	e0566003 	subs	r6, r6, r3
33d23fe0:	e0c55002 	sbc	r5, r5, r2
33d23fe4:	e1b020a2 	lsrs	r2, r2, #1
33d23fe8:	e1a03063 	rrx	r3, r3
33d23fec:	e3a01601 	mov	r1, #1048576	; 0x100000
33d23ff0:	e3a0c702 	mov	ip, #524288	; 0x80000
33d23ff4:	e056e003 	subs	lr, r6, r3
33d23ff8:	e0d5e002 	sbcs	lr, r5, r2
33d23ffc:	20466003 	subcs	r6, r6, r3
33d24000:	21a0500e 	movcs	r5, lr
33d24004:	2181100c 	orrcs	r1, r1, ip
33d24008:	e1b020a2 	lsrs	r2, r2, #1
33d2400c:	e1a03063 	rrx	r3, r3
33d24010:	e056e003 	subs	lr, r6, r3
33d24014:	e0d5e002 	sbcs	lr, r5, r2
33d24018:	20466003 	subcs	r6, r6, r3
33d2401c:	21a0500e 	movcs	r5, lr
33d24020:	218110ac 	orrcs	r1, r1, ip, lsr #1
33d24024:	e1b020a2 	lsrs	r2, r2, #1
33d24028:	e1a03063 	rrx	r3, r3
33d2402c:	e056e003 	subs	lr, r6, r3
33d24030:	e0d5e002 	sbcs	lr, r5, r2
33d24034:	20466003 	subcs	r6, r6, r3
33d24038:	21a0500e 	movcs	r5, lr
33d2403c:	2181112c 	orrcs	r1, r1, ip, lsr #2
33d24040:	e1b020a2 	lsrs	r2, r2, #1
33d24044:	e1a03063 	rrx	r3, r3
33d24048:	e056e003 	subs	lr, r6, r3
33d2404c:	e0d5e002 	sbcs	lr, r5, r2
33d24050:	20466003 	subcs	r6, r6, r3
33d24054:	21a0500e 	movcs	r5, lr
33d24058:	218111ac 	orrcs	r1, r1, ip, lsr #3
33d2405c:	e195e006 	orrs	lr, r5, r6
33d24060:	0a00000d 	beq	33d2409c <__divdf3+0x15c>
33d24064:	e1a05205 	lsl	r5, r5, #4
33d24068:	e1855e26 	orr	r5, r5, r6, lsr #28
33d2406c:	e1a06206 	lsl	r6, r6, #4
33d24070:	e1a02182 	lsl	r2, r2, #3
33d24074:	e1822ea3 	orr	r2, r2, r3, lsr #29
33d24078:	e1a03183 	lsl	r3, r3, #3
33d2407c:	e1b0c22c 	lsrs	ip, ip, #4
33d24080:	1affffdb 	bne	33d23ff4 <__divdf3+0xb4>
33d24084:	e3100601 	tst	r0, #1048576	; 0x100000
33d24088:	1a000006 	bne	33d240a8 <__divdf3+0x168>
33d2408c:	e1800001 	orr	r0, r0, r1
33d24090:	e3a01000 	mov	r1, #0	; 0x0
33d24094:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
33d24098:	eaffffd5 	b	33d23ff4 <__divdf3+0xb4>
33d2409c:	e3100601 	tst	r0, #1048576	; 0x100000
33d240a0:	01800001 	orreq	r0, r0, r1
33d240a4:	03a01000 	moveq	r1, #0	; 0x0
33d240a8:	e3540000 	cmp	r4, #0	; 0x0
33d240ac:	da000016 	ble	33d2410c <__divdf3+0x1cc>
33d240b0:	e055c002 	subs	ip, r5, r2
33d240b4:	0056c003 	subseq	ip, r6, r3
33d240b8:	e2b11000 	adcs	r1, r1, #0	; 0x0
33d240bc:	e2a00000 	adc	r0, r0, #0	; 0x0
33d240c0:	e33c0000 	teq	ip, #0	; 0x0
33d240c4:	03c11001 	biceq	r1, r1, #1	; 0x1
33d240c8:	e3c00601 	bic	r0, r0, #1048576	; 0x100000
33d240cc:	e1800084 	orr	r0, r0, r4, lsl #1
33d240d0:	e8bd8070 	pop	{r4, r5, r6, pc}
33d240d4:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
33d240d8:	e18e0620 	orr	r0, lr, r0, lsr #12
33d240dc:	e284441f 	add	r4, r4, #520093696	; 0x1f000000
33d240e0:	e284473e 	add	r4, r4, #16252928	; 0xf80000
33d240e4:	e15400ac 	cmp	r4, ip, lsr #1
33d240e8:	aaffff8c 	bge	33d23f20 <__muldf3+0x2f4>
33d240ec:	e3540000 	cmp	r4, #0	; 0x0
33d240f0:	c1800084 	orrgt	r0, r0, r4, lsl #1
33d240f4:	c8bd8070 	popgt	{r4, r5, r6, pc}
33d240f8:	e374076a 	cmn	r4, #27787264	; 0x1a80000
33d240fc:	daffff35 	ble	33d23dd8 <__muldf3+0x1ac>
33d24100:	e3800601 	orr	r0, r0, #1048576	; 0x100000
33d24104:	e3a0e000 	mov	lr, #0	; 0x0
33d24108:	eaffff39 	b	33d23df4 <__muldf3+0x1c8>
33d2410c:	e185e006 	orr	lr, r5, r6
33d24110:	eaffff37 	b	33d23df4 <__muldf3+0x1c8>
33d24114:	e3a0e000 	mov	lr, #0	; 0x0
33d24118:	e3340000 	teq	r4, #0	; 0x0
33d2411c:	1a000008 	bne	33d24144 <__divdf3+0x204>
33d24120:	e2006102 	and	r6, r0, #-2147483648	; 0x80000000
33d24124:	e1b01081 	lsls	r1, r1, #1
33d24128:	e0ae0080 	adc	r0, lr, r0, lsl #1
33d2412c:	e3100601 	tst	r0, #1048576	; 0x100000
33d24130:	02444702 	subeq	r4, r4, #524288	; 0x80000
33d24134:	0afffffa 	beq	33d24124 <__divdf3+0x1e4>
33d24138:	e1800006 	orr	r0, r0, r6
33d2413c:	e3350000 	teq	r5, #0	; 0x0
33d24140:	1affff8b 	bne	33d23f74 <__divdf3+0x34>
33d24144:	e2026102 	and	r6, r2, #-2147483648	; 0x80000000
33d24148:	e1b03083 	lsls	r3, r3, #1
33d2414c:	e0ae2082 	adc	r2, lr, r2, lsl #1
33d24150:	e3120601 	tst	r2, #1048576	; 0x100000
33d24154:	02455601 	subeq	r5, r5, #1048576	; 0x100000
33d24158:	0afffffa 	beq	33d24148 <__divdf3+0x208>
33d2415c:	e1822006 	orr	r2, r2, r6
33d24160:	eaffff83 	b	33d23f74 <__divdf3+0x34>
33d24164:	e134000c 	teq	r4, ip
33d24168:	0135000c 	teqeq	r5, ip
33d2416c:	0affff70 	beq	33d23f34 <__muldf3+0x308>
33d24170:	e134000c 	teq	r4, ip
33d24174:	1a000002 	bne	33d24184 <__divdf3+0x244>
33d24178:	e1914600 	orrs	r4, r1, r0, lsl #12
33d2417c:	1affff6c 	bne	33d23f34 <__muldf3+0x308>
33d24180:	eaffff65 	b	33d23f1c <__muldf3+0x2f0>
33d24184:	e135000c 	teq	r5, ip
33d24188:	1a000002 	bne	33d24198 <__divdf3+0x258>
33d2418c:	e1935602 	orrs	r5, r3, r2, lsl #12
33d24190:	1affff67 	bne	33d23f34 <__muldf3+0x308>
33d24194:	eaffff0e 	b	33d23dd4 <__muldf3+0x1a8>
33d24198:	e1914080 	orrs	r4, r1, r0, lsl #1
33d2419c:	1affff5e 	bne	33d23f1c <__muldf3+0x2f0>
33d241a0:	e1935082 	orrs	r5, r3, r2, lsl #1
33d241a4:	1affff0a 	bne	33d23dd4 <__muldf3+0x1a8>
33d241a8:	eaffff61 	b	33d23f34 <__muldf3+0x308>

33d241ac <__fixdfsi>:
33d241ac:	e191c080 	orrs	ip, r1, r0, lsl #1
33d241b0:	0a000014 	beq	33d24208 <__fixdfsi+0x5c>
33d241b4:	e1a03063 	rrx	r3, r3
33d241b8:	e3a0c47f 	mov	ip, #2130706432	; 0x7f000000
33d241bc:	e38cc60f 	orr	ip, ip, #15728640	; 0xf00000
33d241c0:	e000200c 	and	r2, r0, ip
33d241c4:	e132000c 	teq	r2, ip
33d241c8:	0a000010 	beq	33d24210 <__fixdfsi+0x64>
33d241cc:	e3ccc101 	bic	ip, ip, #1073741824	; 0x40000000
33d241d0:	e152000c 	cmp	r2, ip
33d241d4:	3a00000b 	bcc	33d24208 <__fixdfsi+0x5c>
33d241d8:	e28cc61f 	add	ip, ip, #32505856	; 0x1f00000
33d241dc:	e152000c 	cmp	r2, ip
33d241e0:	2a00000c 	bcs	33d24218 <__fixdfsi+0x6c>
33d241e4:	e062200c 	rsb	r2, r2, ip
33d241e8:	e1a0c580 	lsl	ip, r0, #11
33d241ec:	e38cc102 	orr	ip, ip, #-2147483648	; 0x80000000
33d241f0:	e18ccaa1 	orr	ip, ip, r1, lsr #21
33d241f4:	e1a02a22 	lsr	r2, r2, #20
33d241f8:	e3130102 	tst	r3, #-2147483648	; 0x80000000
33d241fc:	e1a0023c 	lsr	r0, ip, r2
33d24200:	12600000 	rsbne	r0, r0, #0	; 0x0
33d24204:	e1a0f00e 	mov	pc, lr
33d24208:	e3a00000 	mov	r0, #0	; 0x0
33d2420c:	e1a0f00e 	mov	pc, lr
33d24210:	e1911600 	orrs	r1, r1, r0, lsl #12
33d24214:	1a000002 	bne	33d24224 <__fixdfsi+0x78>
33d24218:	e2130102 	ands	r0, r3, #-2147483648	; 0x80000000
33d2421c:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
33d24220:	e1a0f00e 	mov	pc, lr
33d24224:	e3a00000 	mov	r0, #0	; 0x0
33d24228:	e1a0f00e 	mov	pc, lr

33d2422c <__udivdi3>:
33d2422c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
33d24230:	e59fa530 	ldr	sl, [pc, #1328]	; 33d24768 <__udivdi3+0x53c>
33d24234:	e2534000 	subs	r4, r3, #0	; 0x0
33d24238:	e08fa00a 	add	sl, pc, sl
33d2423c:	e1a08001 	mov	r8, r1
33d24240:	e1a06002 	mov	r6, r2
33d24244:	e24dd008 	sub	sp, sp, #8	; 0x8
33d24248:	e58d0004 	str	r0, [sp, #4]
33d2424c:	1a000046 	bne	33d2436c <__udivdi3+0x140>
33d24250:	e1520001 	cmp	r2, r1
33d24254:	9a00005b 	bls	33d243c8 <__udivdi3+0x19c>
33d24258:	e3520801 	cmp	r2, #65536	; 0x10000
33d2425c:	e1a00002 	mov	r0, r2
33d24260:	3a00012f 	bcc	33d24724 <__udivdi3+0x4f8>
33d24264:	e3520401 	cmp	r2, #16777216	; 0x1000000
33d24268:	23a0c018 	movcs	ip, #24	; 0x18
33d2426c:	33a0c010 	movcc	ip, #16	; 0x10
33d24270:	e59f24f4 	ldr	r2, [pc, #1268]	; 33d2476c <__udivdi3+0x540>
33d24274:	e79a1002 	ldr	r1, [sl, r2]
33d24278:	e1a00c30 	lsr	r0, r0, ip
33d2427c:	e7d13000 	ldrb	r3, [r1, r0]
33d24280:	e083300c 	add	r3, r3, ip
33d24284:	e2732020 	rsbs	r2, r3, #32	; 0x20
33d24288:	0a000006 	beq	33d242a8 <__udivdi3+0x7c>
33d2428c:	e59d0004 	ldr	r0, [sp, #4]
33d24290:	e2623020 	rsb	r3, r2, #32	; 0x20
33d24294:	e1a03330 	lsr	r3, r0, r3
33d24298:	e1a00210 	lsl	r0, r0, r2
33d2429c:	e58d0004 	str	r0, [sp, #4]
33d242a0:	e1838218 	orr	r8, r3, r8, lsl r2
33d242a4:	e1a06216 	lsl	r6, r6, r2
33d242a8:	e1a09826 	lsr	r9, r6, #16
33d242ac:	e1a01009 	mov	r1, r9
33d242b0:	e1a00008 	mov	r0, r8
33d242b4:	ebffe979 	bl	33d1e8a0 <__umodsi3>
33d242b8:	e1a01009 	mov	r1, r9
33d242bc:	e1a04000 	mov	r4, r0
33d242c0:	e1a00008 	mov	r0, r8
33d242c4:	ebff7445 	bl	33d013e0 <__udivsi3>
33d242c8:	e1a07806 	lsl	r7, r6, #16
33d242cc:	e1a07827 	lsr	r7, r7, #16
33d242d0:	e0020097 	mul	r2, r7, r0
33d242d4:	e59d1004 	ldr	r1, [sp, #4]
33d242d8:	e1a03821 	lsr	r3, r1, #16
33d242dc:	e1834804 	orr	r4, r3, r4, lsl #16
33d242e0:	e1540002 	cmp	r4, r2
33d242e4:	e1a08000 	mov	r8, r0
33d242e8:	2a000005 	bcs	33d24304 <__udivdi3+0xd8>
33d242ec:	e0944006 	adds	r4, r4, r6
33d242f0:	e2408001 	sub	r8, r0, #1	; 0x1
33d242f4:	2a000002 	bcs	33d24304 <__udivdi3+0xd8>
33d242f8:	e1540002 	cmp	r4, r2
33d242fc:	32488001 	subcc	r8, r8, #1	; 0x1
33d24300:	30844006 	addcc	r4, r4, r6
33d24304:	e0624004 	rsb	r4, r2, r4
33d24308:	e1a01009 	mov	r1, r9
33d2430c:	e1a00004 	mov	r0, r4
33d24310:	ebffe962 	bl	33d1e8a0 <__umodsi3>
33d24314:	e1a01009 	mov	r1, r9
33d24318:	e1a05000 	mov	r5, r0
33d2431c:	e1a00004 	mov	r0, r4
33d24320:	ebff742e 	bl	33d013e0 <__udivsi3>
33d24324:	e0020097 	mul	r2, r7, r0
33d24328:	e59d1004 	ldr	r1, [sp, #4]
33d2432c:	e1a03801 	lsl	r3, r1, #16
33d24330:	e1a03823 	lsr	r3, r3, #16
33d24334:	e1835805 	orr	r5, r3, r5, lsl #16
33d24338:	e1550002 	cmp	r5, r2
33d2433c:	2a000004 	bcs	33d24354 <__udivdi3+0x128>
33d24340:	e0955006 	adds	r5, r5, r6
33d24344:	e2400001 	sub	r0, r0, #1	; 0x1
33d24348:	2a000001 	bcs	33d24354 <__udivdi3+0x128>
33d2434c:	e1550002 	cmp	r5, r2
33d24350:	32400001 	subcc	r0, r0, #1	; 0x1
33d24354:	e180c808 	orr	ip, r0, r8, lsl #16
33d24358:	e3a0b000 	mov	fp, #0	; 0x0
33d2435c:	e1a0000c 	mov	r0, ip
33d24360:	e1a0100b 	mov	r1, fp
33d24364:	e28dd008 	add	sp, sp, #8	; 0x8
33d24368:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
33d2436c:	e1540001 	cmp	r4, r1
33d24370:	83a0b000 	movhi	fp, #0	; 0x0
33d24374:	81a0c00b 	movhi	ip, fp
33d24378:	8afffff7 	bhi	33d2435c <__udivdi3+0x130>
33d2437c:	e3540801 	cmp	r4, #65536	; 0x10000
33d24380:	3a000090 	bcc	33d245c8 <__udivdi3+0x39c>
33d24384:	e3540401 	cmp	r4, #16777216	; 0x1000000
33d24388:	23a0c018 	movcs	ip, #24	; 0x18
33d2438c:	33a0c010 	movcc	ip, #16	; 0x10
33d24390:	e1a00c34 	lsr	r0, r4, ip
33d24394:	e59f23d0 	ldr	r2, [pc, #976]	; 33d2476c <__udivdi3+0x540>
33d24398:	e79a1002 	ldr	r1, [sl, r2]
33d2439c:	e7d13000 	ldrb	r3, [r1, r0]
33d243a0:	e083300c 	add	r3, r3, ip
33d243a4:	e2732020 	rsbs	r2, r3, #32	; 0x20
33d243a8:	1a000090 	bne	33d245f0 <__udivdi3+0x3c4>
33d243ac:	e59d3004 	ldr	r3, [sp, #4]
33d243b0:	e1580004 	cmp	r8, r4
33d243b4:	91530006 	cmpls	r3, r6
33d243b8:	23a0c001 	movcs	ip, #1	; 0x1
33d243bc:	31a0c002 	movcc	ip, r2
33d243c0:	e3a0b000 	mov	fp, #0	; 0x0
33d243c4:	eaffffe4 	b	33d2435c <__udivdi3+0x130>
33d243c8:	e3520000 	cmp	r2, #0	; 0x0
33d243cc:	0a00003a 	beq	33d244bc <__udivdi3+0x290>
33d243d0:	e3560801 	cmp	r6, #65536	; 0x10000
33d243d4:	2a00003e 	bcs	33d244d4 <__udivdi3+0x2a8>
33d243d8:	e35600ff 	cmp	r6, #255	; 0xff
33d243dc:	83a0c008 	movhi	ip, #8	; 0x8
33d243e0:	93a0c000 	movls	ip, #0	; 0x0
33d243e4:	e1a00c36 	lsr	r0, r6, ip
33d243e8:	e59f237c 	ldr	r2, [pc, #892]	; 33d2476c <__udivdi3+0x540>
33d243ec:	e79a1002 	ldr	r1, [sl, r2]
33d243f0:	e7d13000 	ldrb	r3, [r1, r0]
33d243f4:	e083300c 	add	r3, r3, ip
33d243f8:	e2732020 	rsbs	r2, r3, #32	; 0x20
33d243fc:	1a00003e 	bne	33d244fc <__udivdi3+0x2d0>
33d24400:	e1a09806 	lsl	r9, r6, #16
33d24404:	e0668008 	rsb	r8, r6, r8
33d24408:	e1a09829 	lsr	r9, r9, #16
33d2440c:	e3a0b001 	mov	fp, #1	; 0x1
33d24410:	e1a07826 	lsr	r7, r6, #16
33d24414:	e1a01007 	mov	r1, r7
33d24418:	e1a00008 	mov	r0, r8
33d2441c:	ebffe91f 	bl	33d1e8a0 <__umodsi3>
33d24420:	e1a01007 	mov	r1, r7
33d24424:	e1a04000 	mov	r4, r0
33d24428:	e1a00008 	mov	r0, r8
33d2442c:	ebff73eb 	bl	33d013e0 <__udivsi3>
33d24430:	e0020099 	mul	r2, r9, r0
33d24434:	e1a08000 	mov	r8, r0
33d24438:	e59d0004 	ldr	r0, [sp, #4]
33d2443c:	e1a03820 	lsr	r3, r0, #16
33d24440:	e1834804 	orr	r4, r3, r4, lsl #16
33d24444:	e1540002 	cmp	r4, r2
33d24448:	2a000005 	bcs	33d24464 <__udivdi3+0x238>
33d2444c:	e0944006 	adds	r4, r4, r6
33d24450:	e2488001 	sub	r8, r8, #1	; 0x1
33d24454:	2a000002 	bcs	33d24464 <__udivdi3+0x238>
33d24458:	e1540002 	cmp	r4, r2
33d2445c:	32488001 	subcc	r8, r8, #1	; 0x1
33d24460:	30844006 	addcc	r4, r4, r6
33d24464:	e0624004 	rsb	r4, r2, r4
33d24468:	e1a01007 	mov	r1, r7
33d2446c:	e1a00004 	mov	r0, r4
33d24470:	ebffe90a 	bl	33d1e8a0 <__umodsi3>
33d24474:	e1a01007 	mov	r1, r7
33d24478:	e1a05000 	mov	r5, r0
33d2447c:	e1a00004 	mov	r0, r4
33d24480:	ebff73d6 	bl	33d013e0 <__udivsi3>
33d24484:	e0020099 	mul	r2, r9, r0
33d24488:	e59d1004 	ldr	r1, [sp, #4]
33d2448c:	e1a03801 	lsl	r3, r1, #16
33d24490:	e1a03823 	lsr	r3, r3, #16
33d24494:	e1835805 	orr	r5, r3, r5, lsl #16
33d24498:	e1550002 	cmp	r5, r2
33d2449c:	2a000004 	bcs	33d244b4 <__udivdi3+0x288>
33d244a0:	e0955006 	adds	r5, r5, r6
33d244a4:	e2400001 	sub	r0, r0, #1	; 0x1
33d244a8:	2a000001 	bcs	33d244b4 <__udivdi3+0x288>
33d244ac:	e1550002 	cmp	r5, r2
33d244b0:	32400001 	subcc	r0, r0, #1	; 0x1
33d244b4:	e180c808 	orr	ip, r0, r8, lsl #16
33d244b8:	eaffffa7 	b	33d2435c <__udivdi3+0x130>
33d244bc:	e1a01002 	mov	r1, r2
33d244c0:	e3a00001 	mov	r0, #1	; 0x1
33d244c4:	ebff73c5 	bl	33d013e0 <__udivsi3>
33d244c8:	e1a06000 	mov	r6, r0
33d244cc:	e3560801 	cmp	r6, #65536	; 0x10000
33d244d0:	3affffc0 	bcc	33d243d8 <__udivdi3+0x1ac>
33d244d4:	e59f2290 	ldr	r2, [pc, #656]	; 33d2476c <__udivdi3+0x540>
33d244d8:	e3560401 	cmp	r6, #16777216	; 0x1000000
33d244dc:	23a0c018 	movcs	ip, #24	; 0x18
33d244e0:	33a0c010 	movcc	ip, #16	; 0x10
33d244e4:	e79a1002 	ldr	r1, [sl, r2]
33d244e8:	e1a00c36 	lsr	r0, r6, ip
33d244ec:	e7d13000 	ldrb	r3, [r1, r0]
33d244f0:	e083300c 	add	r3, r3, ip
33d244f4:	e2732020 	rsbs	r2, r3, #32	; 0x20
33d244f8:	0affffc0 	beq	33d24400 <__udivdi3+0x1d4>
33d244fc:	e59d0004 	ldr	r0, [sp, #4]
33d24500:	e2621020 	rsb	r1, r2, #32	; 0x20
33d24504:	e1a03130 	lsr	r3, r0, r1
33d24508:	e1a06216 	lsl	r6, r6, r2
33d2450c:	e1a05138 	lsr	r5, r8, r1
33d24510:	e1838218 	orr	r8, r3, r8, lsl r2
33d24514:	e59d3004 	ldr	r3, [sp, #4]
33d24518:	e1a07826 	lsr	r7, r6, #16
33d2451c:	e1a03213 	lsl	r3, r3, r2
33d24520:	e1a01007 	mov	r1, r7
33d24524:	e1a00005 	mov	r0, r5
33d24528:	e58d3004 	str	r3, [sp, #4]
33d2452c:	ebffe8db 	bl	33d1e8a0 <__umodsi3>
33d24530:	e1a01007 	mov	r1, r7
33d24534:	e1a04000 	mov	r4, r0
33d24538:	e1a00005 	mov	r0, r5
33d2453c:	ebff73a7 	bl	33d013e0 <__udivsi3>
33d24540:	e1a09806 	lsl	r9, r6, #16
33d24544:	e1a09829 	lsr	r9, r9, #16
33d24548:	e0020099 	mul	r2, r9, r0
33d2454c:	e1a03828 	lsr	r3, r8, #16
33d24550:	e1834804 	orr	r4, r3, r4, lsl #16
33d24554:	e1540002 	cmp	r4, r2
33d24558:	e1a0b000 	mov	fp, r0
33d2455c:	2a000002 	bcs	33d2456c <__udivdi3+0x340>
33d24560:	e0944006 	adds	r4, r4, r6
33d24564:	e240b001 	sub	fp, r0, #1	; 0x1
33d24568:	3a000071 	bcc	33d24734 <__udivdi3+0x508>
33d2456c:	e0624004 	rsb	r4, r2, r4
33d24570:	e1a01007 	mov	r1, r7
33d24574:	e1a00004 	mov	r0, r4
33d24578:	ebffe8c8 	bl	33d1e8a0 <__umodsi3>
33d2457c:	e1a01007 	mov	r1, r7
33d24580:	e1a05000 	mov	r5, r0
33d24584:	e1a00004 	mov	r0, r4
33d24588:	ebff7394 	bl	33d013e0 <__udivsi3>
33d2458c:	e0020099 	mul	r2, r9, r0
33d24590:	e1a03808 	lsl	r3, r8, #16
33d24594:	e1a03823 	lsr	r3, r3, #16
33d24598:	e1835805 	orr	r5, r3, r5, lsl #16
33d2459c:	e1550002 	cmp	r5, r2
33d245a0:	2a000005 	bcs	33d245bc <__udivdi3+0x390>
33d245a4:	e0955006 	adds	r5, r5, r6
33d245a8:	e2400001 	sub	r0, r0, #1	; 0x1
33d245ac:	2a000002 	bcs	33d245bc <__udivdi3+0x390>
33d245b0:	e1550002 	cmp	r5, r2
33d245b4:	32400001 	subcc	r0, r0, #1	; 0x1
33d245b8:	30855006 	addcc	r5, r5, r6
33d245bc:	e180b80b 	orr	fp, r0, fp, lsl #16
33d245c0:	e0628005 	rsb	r8, r2, r5
33d245c4:	eaffff92 	b	33d24414 <__udivdi3+0x1e8>
33d245c8:	e59f219c 	ldr	r2, [pc, #412]	; 33d2476c <__udivdi3+0x540>
33d245cc:	e35400ff 	cmp	r4, #255	; 0xff
33d245d0:	83a0c008 	movhi	ip, #8	; 0x8
33d245d4:	93a0c000 	movls	ip, #0	; 0x0
33d245d8:	e79a1002 	ldr	r1, [sl, r2]
33d245dc:	e1a00c34 	lsr	r0, r4, ip
33d245e0:	e7d13000 	ldrb	r3, [r1, r0]
33d245e4:	e083300c 	add	r3, r3, ip
33d245e8:	e2732020 	rsbs	r2, r3, #32	; 0x20
33d245ec:	0affff6e 	beq	33d243ac <__udivdi3+0x180>
33d245f0:	e2621020 	rsb	r1, r2, #32	; 0x20
33d245f4:	e59d0004 	ldr	r0, [sp, #4]
33d245f8:	e1a03136 	lsr	r3, r6, r1
33d245fc:	e1834214 	orr	r4, r3, r4, lsl r2
33d24600:	e1a03130 	lsr	r3, r0, r1
33d24604:	e1a05138 	lsr	r5, r8, r1
33d24608:	e1838218 	orr	r8, r3, r8, lsl r2
33d2460c:	e59d3004 	ldr	r3, [sp, #4]
33d24610:	e1a0b824 	lsr	fp, r4, #16
33d24614:	e1a03213 	lsl	r3, r3, r2
33d24618:	e1a0100b 	mov	r1, fp
33d2461c:	e1a00005 	mov	r0, r5
33d24620:	e58d3004 	str	r3, [sp, #4]
33d24624:	e1a06216 	lsl	r6, r6, r2
33d24628:	ebffe89c 	bl	33d1e8a0 <__umodsi3>
33d2462c:	e1a0100b 	mov	r1, fp
33d24630:	e1a07000 	mov	r7, r0
33d24634:	e1a00005 	mov	r0, r5
33d24638:	ebff7368 	bl	33d013e0 <__udivsi3>
33d2463c:	e1a09804 	lsl	r9, r4, #16
33d24640:	e1a09829 	lsr	r9, r9, #16
33d24644:	e1a02000 	mov	r2, r0
33d24648:	e0020299 	mul	r2, r9, r2
33d2464c:	e1a03828 	lsr	r3, r8, #16
33d24650:	e1837807 	orr	r7, r3, r7, lsl #16
33d24654:	e1570002 	cmp	r7, r2
33d24658:	e58d0000 	str	r0, [sp]
33d2465c:	2a000003 	bcs	33d24670 <__udivdi3+0x444>
33d24660:	e2400001 	sub	r0, r0, #1	; 0x1
33d24664:	e0977004 	adds	r7, r7, r4
33d24668:	e58d0000 	str	r0, [sp]
33d2466c:	3a000038 	bcc	33d24754 <__udivdi3+0x528>
33d24670:	e0627007 	rsb	r7, r2, r7
33d24674:	e1a0100b 	mov	r1, fp
33d24678:	e1a00007 	mov	r0, r7
33d2467c:	ebffe887 	bl	33d1e8a0 <__umodsi3>
33d24680:	e1a0100b 	mov	r1, fp
33d24684:	e1a05000 	mov	r5, r0
33d24688:	e1a00007 	mov	r0, r7
33d2468c:	ebff7353 	bl	33d013e0 <__udivsi3>
33d24690:	e0020099 	mul	r2, r9, r0
33d24694:	e1a03808 	lsl	r3, r8, #16
33d24698:	e1a03823 	lsr	r3, r3, #16
33d2469c:	e1835805 	orr	r5, r3, r5, lsl #16
33d246a0:	e1550002 	cmp	r5, r2
33d246a4:	2a000002 	bcs	33d246b4 <__udivdi3+0x488>
33d246a8:	e0955004 	adds	r5, r5, r4
33d246ac:	e2400001 	sub	r0, r0, #1	; 0x1
33d246b0:	3a000023 	bcc	33d24744 <__udivdi3+0x518>
33d246b4:	e59d1000 	ldr	r1, [sp]
33d246b8:	e0625005 	rsb	r5, r2, r5
33d246bc:	e180c801 	orr	ip, r0, r1, lsl #16
33d246c0:	e1a0082c 	lsr	r0, ip, #16
33d246c4:	e1a03826 	lsr	r3, r6, #16
33d246c8:	e1cc1800 	bic	r1, ip, r0, lsl #16
33d246cc:	e1c62803 	bic	r2, r6, r3, lsl #16
33d246d0:	e00e0291 	mul	lr, r1, r2
33d246d4:	e0020290 	mul	r2, r0, r2
33d246d8:	e0010193 	mul	r1, r3, r1
33d246dc:	e0030390 	mul	r3, r0, r3
33d246e0:	e0921001 	adds	r1, r2, r1
33d246e4:	22833801 	addcs	r3, r3, #65536	; 0x10000
33d246e8:	e09ee801 	adds	lr, lr, r1, lsl #16
33d246ec:	e0a33821 	adc	r3, r3, r1, lsr #16
33d246f0:	e1530005 	cmp	r3, r5
33d246f4:	8a000007 	bhi	33d24718 <__udivdi3+0x4ec>
33d246f8:	e59d2004 	ldr	r2, [sp, #4]
33d246fc:	13a03000 	movne	r3, #0	; 0x0
33d24700:	03a03001 	moveq	r3, #1	; 0x1
33d24704:	e15e0002 	cmp	lr, r2
33d24708:	93a03000 	movls	r3, #0	; 0x0
33d2470c:	82033001 	andhi	r3, r3, #1	; 0x1
33d24710:	e3530000 	cmp	r3, #0	; 0x0
33d24714:	0affff0f 	beq	33d24358 <__udivdi3+0x12c>
33d24718:	e24cc001 	sub	ip, ip, #1	; 0x1
33d2471c:	e3a0b000 	mov	fp, #0	; 0x0
33d24720:	eaffff0d 	b	33d2435c <__udivdi3+0x130>
33d24724:	e35200ff 	cmp	r2, #255	; 0xff
33d24728:	83a0c008 	movhi	ip, #8	; 0x8
33d2472c:	93a0c000 	movls	ip, #0	; 0x0
33d24730:	eafffece 	b	33d24270 <__udivdi3+0x44>
33d24734:	e1540002 	cmp	r4, r2
33d24738:	324bb001 	subcc	fp, fp, #1	; 0x1
33d2473c:	30844006 	addcc	r4, r4, r6
33d24740:	eaffff89 	b	33d2456c <__udivdi3+0x340>
33d24744:	e1550002 	cmp	r5, r2
33d24748:	30855004 	addcc	r5, r5, r4
33d2474c:	32400001 	subcc	r0, r0, #1	; 0x1
33d24750:	eaffffd7 	b	33d246b4 <__udivdi3+0x488>
33d24754:	e1570002 	cmp	r7, r2
33d24758:	32400001 	subcc	r0, r0, #1	; 0x1
33d2475c:	30877004 	addcc	r7, r7, r4
33d24760:	358d0000 	strcc	r0, [sp]
33d24764:	eaffffc1 	b	33d24670 <__udivdi3+0x444>
33d24768:	000129ac 	.word	0x000129ac
33d2476c:	00000000 	.word	0x00000000
